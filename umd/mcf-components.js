(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react-dom'), require('react'), require('moment'), require('prop-types')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react-dom', 'react', 'moment', 'prop-types'], factory) :
  (factory((global.components = {}),global.ReactDOM,global.React,global.moment,global.PropTypes));
}(this, (function (exports,ReactDOM,React$1,moment,PropTypes) { 'use strict';

  var ReactDOM__default = 'default' in ReactDOM ? ReactDOM['default'] : ReactDOM;
  var React$1__default = 'default' in React$1 ? React$1['default'] : React$1;
  moment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;
  PropTypes = PropTypes && PropTypes.hasOwnProperty('default') ? PropTypes['default'] : PropTypes;

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  var Td = function Td(_ref) {
    var dataSource = _ref.dataSource,
        _ref$labelKey = _ref.labelKey,
        labelKey = _ref$labelKey === void 0 ? 'label' : _ref$labelKey,
        _ref$valueKey = _ref.valueKey,
        valueKey = _ref$valueKey === void 0 ? 'value' : _ref$valueKey;
    return [React$1__default.createElement("th", {
      key: 'td' + dataSource[labelKey]
    }, typeof dataSource[labelKey] === 'function' ? dataSource[labelKey]() : dataSource[labelKey]), React$1__default.createElement("td", {
      key: 'td1' + dataSource[valueKey]
    }, typeof dataSource[valueKey] === 'function' ? dataSource[valueKey]() : dataSource[valueKey])];
  };

  Td.propTypes = {
    labelKey: PropTypes.string,
    valueKey: PropTypes.string
  };

  var DetailTable =
  /*#__PURE__*/
  function (_React$Component) {
    _inherits(DetailTable, _React$Component);

    function DetailTable() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, DetailTable);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(DetailTable)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "showDom", function (dataSource) {
        var Data = [];

        if (_this.props.mode === 'object' && Array.isArray(dataSource)) {
          throw Error('使用对象模式，数据必须为object');
        }

        if (!Array.isArray(dataSource) && _this.props.mode !== 'object') {
          throw Error('数据为对象时，mode需要为object');
        }

        if (_this.props.mode && _this.props.mode === 'object') {
          for (var a in dataSource) {
            Data.push({
              label: a,
              value: dataSource[a]
            });
          }
        } else {
          Data = _toConsumableArray(dataSource);
        }

        var columnNumber = _this.props.columnNumber === undefined ? 1 : _this.props.columnNumber;

        if (columnNumber <= 0) {
          throw Error('列数必须大于0');
        }

        var array = [];
        var trLength = Math.ceil(Data.length / columnNumber);
        var remainder = Data.length % columnNumber; // 数据不足进行补充

        if (remainder > 0) {
          for (var b = 0; b < remainder; b++) {
            Data.push({
              name: '',
              value: ''
            });
          }
        }

        for (var i = 0; i < trLength; i++) {
          array.push(Data.slice(columnNumber * i, columnNumber * i + columnNumber));
        }

        return array.map(function (d, k) {
          return React$1__default.createElement("tr", {
            key: k
          }, d.map(function (c, v) {
            return React$1__default.createElement(Td, {
              key: v,
              dataSource: c,
              labelKey: _this.props.labelKey,
              valueKey: _this.props.valueKey
            });
          }));
        });
      });

      return _this;
    }

    _createClass(DetailTable, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            dataSource = _this$props.dataSource,
            title = _this$props.title,
            tableClass = _this$props.tableClass;
        return React$1__default.createElement("div", {
          className: tableClass
        }, React$1__default.createElement("div", {
          className: "ant-table-title"
        }, title), React$1__default.createElement("div", {
          className: "ant-table-content"
        }, React$1__default.createElement("div", {
          className: "ant-table-body"
        }, React$1__default.createElement("table", {
          style: {
            width: '100%'
          }
        }, React$1__default.createElement("tbody", {
          className: "ant-table-tbody"
        }, this.showDom(dataSource))))));
      }
    }]);

    return DetailTable;
  }(React$1__default.Component);

  DetailTable.propTypes = {
    mode: PropTypes.oneOf(['object', 'array']),
    columnNumber: PropTypes.number,
    dataSource: PropTypes.array,
    tableClass: PropTypes.string,
    title: PropTypes.string
  };
  DetailTable.defaultProps = {
    columnNumber: 2,
    tableClass: "ant-table ant-table-bordered ant-table-detail"
  };

  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  function getCjsExportFromNamespace (n) {
  	return n && n.default || n;
  }

  var _global = createCommonjsModule(function (module) {
  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math
    ? window : typeof self != 'undefined' && self.Math == Math ? self
    // eslint-disable-next-line no-new-func
    : Function('return this')();
  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
  });

  var _core = createCommonjsModule(function (module) {
  var core = module.exports = { version: '2.5.7' };
  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
  });
  var _core_1 = _core.version;

  var _aFunction = function (it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
  };

  // optional / simple context binding

  var _ctx = function (fn, that, length) {
    _aFunction(fn);
    if (that === undefined) return fn;
    switch (length) {
      case 1: return function (a) {
        return fn.call(that, a);
      };
      case 2: return function (a, b) {
        return fn.call(that, a, b);
      };
      case 3: return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
    }
    return function (/* ...args */) {
      return fn.apply(that, arguments);
    };
  };

  var _isObject = function (it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };

  var _anObject = function (it) {
    if (!_isObject(it)) throw TypeError(it + ' is not an object!');
    return it;
  };

  var _fails = function (exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };

  // Thank's IE8 for his funny defineProperty
  var _descriptors = !_fails(function () {
    return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
  });

  var document$1 = _global.document;
  // typeof document.createElement is 'object' in old IE
  var is = _isObject(document$1) && _isObject(document$1.createElement);
  var _domCreate = function (it) {
    return is ? document$1.createElement(it) : {};
  };

  var _ie8DomDefine = !_descriptors && !_fails(function () {
    return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
  });

  // 7.1.1 ToPrimitive(input [, PreferredType])

  // instead of the ES6 spec version, we didn't implement @@toPrimitive case
  // and the second argument - flag - preferred type is a string
  var _toPrimitive = function (it, S) {
    if (!_isObject(it)) return it;
    var fn, val;
    if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
    if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
    if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
    throw TypeError("Can't convert object to primitive value");
  };

  var dP = Object.defineProperty;

  var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
    _anObject(O);
    P = _toPrimitive(P, true);
    _anObject(Attributes);
    if (_ie8DomDefine) try {
      return dP(O, P, Attributes);
    } catch (e) { /* empty */ }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };

  var _objectDp = {
  	f: f
  };

  var _propertyDesc = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };

  var _hide = _descriptors ? function (object, key, value) {
    return _objectDp.f(object, key, _propertyDesc(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var hasOwnProperty = {}.hasOwnProperty;
  var _has = function (it, key) {
    return hasOwnProperty.call(it, key);
  };

  var PROTOTYPE = 'prototype';

  var $export = function (type, name, source) {
    var IS_FORCED = type & $export.F;
    var IS_GLOBAL = type & $export.G;
    var IS_STATIC = type & $export.S;
    var IS_PROTO = type & $export.P;
    var IS_BIND = type & $export.B;
    var IS_WRAP = type & $export.W;
    var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
    var expProto = exports[PROTOTYPE];
    var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] : (_global[name] || {})[PROTOTYPE];
    var key, own, out;
    if (IS_GLOBAL) source = name;
    for (key in source) {
      // contains in native
      own = !IS_FORCED && target && target[key] !== undefined;
      if (own && _has(exports, key)) continue;
      // export native or passed
      out = own ? target[key] : source[key];
      // prevent global pollution for namespaces
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
      // bind timers to global for call from export context
      : IS_BIND && own ? _ctx(out, _global)
      // wrap global constructors for prevent change them in library
      : IS_WRAP && target[key] == out ? (function (C) {
        var F = function (a, b, c) {
          if (this instanceof C) {
            switch (arguments.length) {
              case 0: return new C();
              case 1: return new C(a);
              case 2: return new C(a, b);
            } return new C(a, b, c);
          } return C.apply(this, arguments);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      // make static versions for prototype methods
      })(out) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
      // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
      if (IS_PROTO) {
        (exports.virtual || (exports.virtual = {}))[key] = out;
        // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
        if (type & $export.R && expProto && !expProto[key]) _hide(expProto, key, out);
      }
    }
  };
  // type bitmap
  $export.F = 1;   // forced
  $export.G = 2;   // global
  $export.S = 4;   // static
  $export.P = 8;   // proto
  $export.B = 16;  // bind
  $export.W = 32;  // wrap
  $export.U = 64;  // safe
  $export.R = 128; // real proto method for `library`
  var _export = $export;

  // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
  _export(_export.S + _export.F * !_descriptors, 'Object', { defineProperty: _objectDp.f });

  var $Object = _core.Object;
  var defineProperty = function defineProperty(it, key, desc) {
    return $Object.defineProperty(it, key, desc);
  };

  var defineProperty$1 = createCommonjsModule(function (module) {
  module.exports = { "default": defineProperty, __esModule: true };
  });

  unwrapExports(defineProperty$1);

  var defineProperty$3 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _defineProperty2 = _interopRequireDefault(defineProperty$1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = function (obj, key, value) {
    if (key in obj) {
      (0, _defineProperty2.default)(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };
  });

  var _defineProperty$1 = unwrapExports(defineProperty$3);

  var toString = {}.toString;

  var _cof = function (it) {
    return toString.call(it).slice(8, -1);
  };

  // fallback for non-array-like ES3 and non-enumerable old V8 strings

  // eslint-disable-next-line no-prototype-builtins
  var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
    return _cof(it) == 'String' ? it.split('') : Object(it);
  };

  // 7.2.1 RequireObjectCoercible(argument)
  var _defined = function (it) {
    if (it == undefined) throw TypeError("Can't call method on  " + it);
    return it;
  };

  // to indexed object, toObject with fallback for non-array-like ES3 strings


  var _toIobject = function (it) {
    return _iobject(_defined(it));
  };

  // 7.1.4 ToInteger
  var ceil = Math.ceil;
  var floor = Math.floor;
  var _toInteger = function (it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };

  // 7.1.15 ToLength

  var min = Math.min;
  var _toLength = function (it) {
    return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
  };

  var max = Math.max;
  var min$1 = Math.min;
  var _toAbsoluteIndex = function (index, length) {
    index = _toInteger(index);
    return index < 0 ? max(index + length, 0) : min$1(index, length);
  };

  // false -> Array#indexOf
  // true  -> Array#includes



  var _arrayIncludes = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = _toIobject($this);
      var length = _toLength(O.length);
      var index = _toAbsoluteIndex(fromIndex, length);
      var value;
      // Array#includes uses SameValueZero equality algorithm
      // eslint-disable-next-line no-self-compare
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        // eslint-disable-next-line no-self-compare
        if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
      } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      } return !IS_INCLUDES && -1;
    };
  };

  var _library = true;

  var _shared = createCommonjsModule(function (module) {
  var SHARED = '__core-js_shared__';
  var store = _global[SHARED] || (_global[SHARED] = {});

  (module.exports = function (key, value) {
    return store[key] || (store[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: _core.version,
    mode: _library ? 'pure' : 'global',
    copyright: '© 2018 Denis Pushkarev (zloirock.ru)'
  });
  });

  var id$1 = 0;
  var px = Math.random();
  var _uid = function (key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id$1 + px).toString(36));
  };

  var shared = _shared('keys');

  var _sharedKey = function (key) {
    return shared[key] || (shared[key] = _uid(key));
  };

  var arrayIndexOf = _arrayIncludes(false);
  var IE_PROTO = _sharedKey('IE_PROTO');

  var _objectKeysInternal = function (object, names) {
    var O = _toIobject(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key);
    // Don't enum bug & hidden keys
    while (names.length > i) if (_has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
    return result;
  };

  // IE 8- don't enum bug keys
  var _enumBugKeys = (
    'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
  ).split(',');

  // 19.1.2.14 / 15.2.3.14 Object.keys(O)



  var _objectKeys = Object.keys || function keys(O) {
    return _objectKeysInternal(O, _enumBugKeys);
  };

  var f$1 = Object.getOwnPropertySymbols;

  var _objectGops = {
  	f: f$1
  };

  var f$2 = {}.propertyIsEnumerable;

  var _objectPie = {
  	f: f$2
  };

  // 7.1.13 ToObject(argument)

  var _toObject = function (it) {
    return Object(_defined(it));
  };

  // 19.1.2.1 Object.assign(target, source, ...)





  var $assign = Object.assign;

  // should work with symbols and should have deterministic property order (V8 bug)
  var _objectAssign = !$assign || _fails(function () {
    var A = {};
    var B = {};
    // eslint-disable-next-line no-undef
    var S = Symbol();
    var K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function (k) { B[k] = k; });
    return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
  }) ? function assign(target, source) { // eslint-disable-line no-unused-vars
    var T = _toObject(target);
    var aLen = arguments.length;
    var index = 1;
    var getSymbols = _objectGops.f;
    var isEnum = _objectPie.f;
    while (aLen > index) {
      var S = _iobject(arguments[index++]);
      var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);
      var length = keys.length;
      var j = 0;
      var key;
      while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
    } return T;
  } : $assign;

  // 19.1.3.1 Object.assign(target, source)


  _export(_export.S + _export.F, 'Object', { assign: _objectAssign });

  var assign = _core.Object.assign;

  var assign$1 = createCommonjsModule(function (module) {
  module.exports = { "default": assign, __esModule: true };
  });

  unwrapExports(assign$1);

  var _extends$1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _assign2 = _interopRequireDefault(assign$1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = _assign2.default || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  });

  var _extends$2 = unwrapExports(_extends$1);

  // true  -> String#at
  // false -> String#codePointAt
  var _stringAt = function (TO_STRING) {
    return function (that, pos) {
      var s = String(_defined(that));
      var i = _toInteger(pos);
      var l = s.length;
      var a, b;
      if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
        ? TO_STRING ? s.charAt(i) : a
        : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };

  var _redefine = _hide;

  var _iterators = {};

  var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
    _anObject(O);
    var keys = _objectKeys(Properties);
    var length = keys.length;
    var i = 0;
    var P;
    while (length > i) _objectDp.f(O, P = keys[i++], Properties[P]);
    return O;
  };

  var document$2 = _global.document;
  var _html = document$2 && document$2.documentElement;

  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])



  var IE_PROTO$1 = _sharedKey('IE_PROTO');
  var Empty = function () { /* empty */ };
  var PROTOTYPE$1 = 'prototype';

  // Create object with fake `null` prototype: use iframe Object with cleared prototype
  var createDict = function () {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = _domCreate('iframe');
    var i = _enumBugKeys.length;
    var lt = '<';
    var gt = '>';
    var iframeDocument;
    iframe.style.display = 'none';
    _html.appendChild(iframe);
    iframe.src = 'javascript:'; // eslint-disable-line no-script-url
    // createDict = iframe.contentWindow.Object;
    // html.removeChild(iframe);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
    iframeDocument.close();
    createDict = iframeDocument.F;
    while (i--) delete createDict[PROTOTYPE$1][_enumBugKeys[i]];
    return createDict();
  };

  var _objectCreate = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
      Empty[PROTOTYPE$1] = _anObject(O);
      result = new Empty();
      Empty[PROTOTYPE$1] = null;
      // add "__proto__" for Object.getPrototypeOf polyfill
      result[IE_PROTO$1] = O;
    } else result = createDict();
    return Properties === undefined ? result : _objectDps(result, Properties);
  };

  var _wks = createCommonjsModule(function (module) {
  var store = _shared('wks');

  var Symbol = _global.Symbol;
  var USE_SYMBOL = typeof Symbol == 'function';

  var $exports = module.exports = function (name) {
    return store[name] || (store[name] =
      USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));
  };

  $exports.store = store;
  });

  var def = _objectDp.f;

  var TAG = _wks('toStringTag');

  var _setToStringTag = function (it, tag, stat) {
    if (it && !_has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
  };

  var IteratorPrototype = {};

  // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
  _hide(IteratorPrototype, _wks('iterator'), function () { return this; });

  var _iterCreate = function (Constructor, NAME, next) {
    Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc(1, next) });
    _setToStringTag(Constructor, NAME + ' Iterator');
  };

  // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)


  var IE_PROTO$2 = _sharedKey('IE_PROTO');
  var ObjectProto = Object.prototype;

  var _objectGpo = Object.getPrototypeOf || function (O) {
    O = _toObject(O);
    if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];
    if (typeof O.constructor == 'function' && O instanceof O.constructor) {
      return O.constructor.prototype;
    } return O instanceof Object ? ObjectProto : null;
  };

  var ITERATOR = _wks('iterator');
  var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
  var FF_ITERATOR = '@@iterator';
  var KEYS = 'keys';
  var VALUES = 'values';

  var returnThis = function () { return this; };

  var _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    _iterCreate(Constructor, NAME, next);
    var getMethod = function (kind) {
      if (!BUGGY && kind in proto) return proto[kind];
      switch (kind) {
        case KEYS: return function keys() { return new Constructor(this, kind); };
        case VALUES: return function values() { return new Constructor(this, kind); };
      } return function entries() { return new Constructor(this, kind); };
    };
    var TAG = NAME + ' Iterator';
    var DEF_VALUES = DEFAULT == VALUES;
    var VALUES_BUG = false;
    var proto = Base.prototype;
    var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
    var $default = $native || getMethod(DEFAULT);
    var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
    var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
    var methods, key, IteratorPrototype;
    // Fix native
    if ($anyNative) {
      IteratorPrototype = _objectGpo($anyNative.call(new Base()));
      if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
        // Set @@toStringTag to native iterators
        _setToStringTag(IteratorPrototype, TAG, true);
        // fix for some old engines
        if (!_library && typeof IteratorPrototype[ITERATOR] != 'function') _hide(IteratorPrototype, ITERATOR, returnThis);
      }
    }
    // fix Array#{values, @@iterator}.name in V8 / FF
    if (DEF_VALUES && $native && $native.name !== VALUES) {
      VALUES_BUG = true;
      $default = function values() { return $native.call(this); };
    }
    // Define iterator
    if ((!_library || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      _hide(proto, ITERATOR, $default);
    }
    // Plug for library
    _iterators[NAME] = $default;
    _iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: $entries
      };
      if (FORCED) for (key in methods) {
        if (!(key in proto)) _redefine(proto, key, methods[key]);
      } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };

  var $at = _stringAt(true);

  // 21.1.3.27 String.prototype[@@iterator]()
  _iterDefine(String, 'String', function (iterated) {
    this._t = String(iterated); // target
    this._i = 0;                // next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
  }, function () {
    var O = this._t;
    var index = this._i;
    var point;
    if (index >= O.length) return { value: undefined, done: true };
    point = $at(O, index);
    this._i += point.length;
    return { value: point, done: false };
  });

  var _iterStep = function (done, value) {
    return { value: value, done: !!done };
  };

  // 22.1.3.4 Array.prototype.entries()
  // 22.1.3.13 Array.prototype.keys()
  // 22.1.3.29 Array.prototype.values()
  // 22.1.3.30 Array.prototype[@@iterator]()
  var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {
    this._t = _toIobject(iterated); // target
    this._i = 0;                   // next index
    this._k = kind;                // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
  }, function () {
    var O = this._t;
    var kind = this._k;
    var index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return _iterStep(1);
    }
    if (kind == 'keys') return _iterStep(0, index);
    if (kind == 'values') return _iterStep(0, O[index]);
    return _iterStep(0, [index, O[index]]);
  }, 'values');

  // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
  _iterators.Arguments = _iterators.Array;

  var TO_STRING_TAG = _wks('toStringTag');

  var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
    'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
    'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
    'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
    'TextTrackList,TouchList').split(',');

  for (var i = 0; i < DOMIterables.length; i++) {
    var NAME = DOMIterables[i];
    var Collection = _global[NAME];
    var proto = Collection && Collection.prototype;
    if (proto && !proto[TO_STRING_TAG]) _hide(proto, TO_STRING_TAG, NAME);
    _iterators[NAME] = _iterators.Array;
  }

  var f$3 = _wks;

  var _wksExt = {
  	f: f$3
  };

  var iterator = _wksExt.f('iterator');

  var iterator$1 = createCommonjsModule(function (module) {
  module.exports = { "default": iterator, __esModule: true };
  });

  unwrapExports(iterator$1);

  var _meta = createCommonjsModule(function (module) {
  var META = _uid('meta');


  var setDesc = _objectDp.f;
  var id = 0;
  var isExtensible = Object.isExtensible || function () {
    return true;
  };
  var FREEZE = !_fails(function () {
    return isExtensible(Object.preventExtensions({}));
  });
  var setMeta = function (it) {
    setDesc(it, META, { value: {
      i: 'O' + ++id, // object ID
      w: {}          // weak collections IDs
    } });
  };
  var fastKey = function (it, create) {
    // return primitive with prefix
    if (!_isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!_has(it, META)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return 'F';
      // not necessary to add metadata
      if (!create) return 'E';
      // add missing metadata
      setMeta(it);
    // return object ID
    } return it[META].i;
  };
  var getWeak = function (it, create) {
    if (!_has(it, META)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return true;
      // not necessary to add metadata
      if (!create) return false;
      // add missing metadata
      setMeta(it);
    // return hash weak collections IDs
    } return it[META].w;
  };
  // add metadata on freeze-family methods calling
  var onFreeze = function (it) {
    if (FREEZE && meta.NEED && isExtensible(it) && !_has(it, META)) setMeta(it);
    return it;
  };
  var meta = module.exports = {
    KEY: META,
    NEED: false,
    fastKey: fastKey,
    getWeak: getWeak,
    onFreeze: onFreeze
  };
  });
  var _meta_1 = _meta.KEY;
  var _meta_2 = _meta.NEED;
  var _meta_3 = _meta.fastKey;
  var _meta_4 = _meta.getWeak;
  var _meta_5 = _meta.onFreeze;

  var defineProperty$4 = _objectDp.f;
  var _wksDefine = function (name) {
    var $Symbol = _core.Symbol || (_core.Symbol = {});
    if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty$4($Symbol, name, { value: _wksExt.f(name) });
  };

  // all enumerable object keys, includes symbols



  var _enumKeys = function (it) {
    var result = _objectKeys(it);
    var getSymbols = _objectGops.f;
    if (getSymbols) {
      var symbols = getSymbols(it);
      var isEnum = _objectPie.f;
      var i = 0;
      var key;
      while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
    } return result;
  };

  // 7.2.2 IsArray(argument)

  var _isArray = Array.isArray || function isArray(arg) {
    return _cof(arg) == 'Array';
  };

  // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)

  var hiddenKeys = _enumBugKeys.concat('length', 'prototype');

  var f$4 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return _objectKeysInternal(O, hiddenKeys);
  };

  var _objectGopn = {
  	f: f$4
  };

  // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window

  var gOPN = _objectGopn.f;
  var toString$1 = {}.toString;

  var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
    ? Object.getOwnPropertyNames(window) : [];

  var getWindowNames = function (it) {
    try {
      return gOPN(it);
    } catch (e) {
      return windowNames.slice();
    }
  };

  var f$5 = function getOwnPropertyNames(it) {
    return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(_toIobject(it));
  };

  var _objectGopnExt = {
  	f: f$5
  };

  var gOPD = Object.getOwnPropertyDescriptor;

  var f$6 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {
    O = _toIobject(O);
    P = _toPrimitive(P, true);
    if (_ie8DomDefine) try {
      return gOPD(O, P);
    } catch (e) { /* empty */ }
    if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);
  };

  var _objectGopd = {
  	f: f$6
  };

  // ECMAScript 6 symbols shim





  var META = _meta.KEY;



















  var gOPD$1 = _objectGopd.f;
  var dP$1 = _objectDp.f;
  var gOPN$1 = _objectGopnExt.f;
  var $Symbol = _global.Symbol;
  var $JSON = _global.JSON;
  var _stringify = $JSON && $JSON.stringify;
  var PROTOTYPE$2 = 'prototype';
  var HIDDEN = _wks('_hidden');
  var TO_PRIMITIVE = _wks('toPrimitive');
  var isEnum = {}.propertyIsEnumerable;
  var SymbolRegistry = _shared('symbol-registry');
  var AllSymbols = _shared('symbols');
  var OPSymbols = _shared('op-symbols');
  var ObjectProto$1 = Object[PROTOTYPE$2];
  var USE_NATIVE = typeof $Symbol == 'function';
  var QObject = _global.QObject;
  // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
  var setter = !QObject || !QObject[PROTOTYPE$2] || !QObject[PROTOTYPE$2].findChild;

  // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
  var setSymbolDesc = _descriptors && _fails(function () {
    return _objectCreate(dP$1({}, 'a', {
      get: function () { return dP$1(this, 'a', { value: 7 }).a; }
    })).a != 7;
  }) ? function (it, key, D) {
    var protoDesc = gOPD$1(ObjectProto$1, key);
    if (protoDesc) delete ObjectProto$1[key];
    dP$1(it, key, D);
    if (protoDesc && it !== ObjectProto$1) dP$1(ObjectProto$1, key, protoDesc);
  } : dP$1;

  var wrap = function (tag) {
    var sym = AllSymbols[tag] = _objectCreate($Symbol[PROTOTYPE$2]);
    sym._k = tag;
    return sym;
  };

  var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
    return typeof it == 'symbol';
  } : function (it) {
    return it instanceof $Symbol;
  };

  var $defineProperty = function defineProperty(it, key, D) {
    if (it === ObjectProto$1) $defineProperty(OPSymbols, key, D);
    _anObject(it);
    key = _toPrimitive(key, true);
    _anObject(D);
    if (_has(AllSymbols, key)) {
      if (!D.enumerable) {
        if (!_has(it, HIDDEN)) dP$1(it, HIDDEN, _propertyDesc(1, {}));
        it[HIDDEN][key] = true;
      } else {
        if (_has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
        D = _objectCreate(D, { enumerable: _propertyDesc(0, false) });
      } return setSymbolDesc(it, key, D);
    } return dP$1(it, key, D);
  };
  var $defineProperties = function defineProperties(it, P) {
    _anObject(it);
    var keys = _enumKeys(P = _toIobject(P));
    var i = 0;
    var l = keys.length;
    var key;
    while (l > i) $defineProperty(it, key = keys[i++], P[key]);
    return it;
  };
  var $create = function create(it, P) {
    return P === undefined ? _objectCreate(it) : $defineProperties(_objectCreate(it), P);
  };
  var $propertyIsEnumerable = function propertyIsEnumerable(key) {
    var E = isEnum.call(this, key = _toPrimitive(key, true));
    if (this === ObjectProto$1 && _has(AllSymbols, key) && !_has(OPSymbols, key)) return false;
    return E || !_has(this, key) || !_has(AllSymbols, key) || _has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
  };
  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
    it = _toIobject(it);
    key = _toPrimitive(key, true);
    if (it === ObjectProto$1 && _has(AllSymbols, key) && !_has(OPSymbols, key)) return;
    var D = gOPD$1(it, key);
    if (D && _has(AllSymbols, key) && !(_has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
    return D;
  };
  var $getOwnPropertyNames = function getOwnPropertyNames(it) {
    var names = gOPN$1(_toIobject(it));
    var result = [];
    var i = 0;
    var key;
    while (names.length > i) {
      if (!_has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
    } return result;
  };
  var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
    var IS_OP = it === ObjectProto$1;
    var names = gOPN$1(IS_OP ? OPSymbols : _toIobject(it));
    var result = [];
    var i = 0;
    var key;
    while (names.length > i) {
      if (_has(AllSymbols, key = names[i++]) && (IS_OP ? _has(ObjectProto$1, key) : true)) result.push(AllSymbols[key]);
    } return result;
  };

  // 19.4.1.1 Symbol([description])
  if (!USE_NATIVE) {
    $Symbol = function Symbol() {
      if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
      var tag = _uid(arguments.length > 0 ? arguments[0] : undefined);
      var $set = function (value) {
        if (this === ObjectProto$1) $set.call(OPSymbols, value);
        if (_has(this, HIDDEN) && _has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
        setSymbolDesc(this, tag, _propertyDesc(1, value));
      };
      if (_descriptors && setter) setSymbolDesc(ObjectProto$1, tag, { configurable: true, set: $set });
      return wrap(tag);
    };
    _redefine($Symbol[PROTOTYPE$2], 'toString', function toString() {
      return this._k;
    });

    _objectGopd.f = $getOwnPropertyDescriptor;
    _objectDp.f = $defineProperty;
    _objectGopn.f = _objectGopnExt.f = $getOwnPropertyNames;
    _objectPie.f = $propertyIsEnumerable;
    _objectGops.f = $getOwnPropertySymbols;

    if (_descriptors && !_library) {
      _redefine(ObjectProto$1, 'propertyIsEnumerable', $propertyIsEnumerable, true);
    }

    _wksExt.f = function (name) {
      return wrap(_wks(name));
    };
  }

  _export(_export.G + _export.W + _export.F * !USE_NATIVE, { Symbol: $Symbol });

  for (var es6Symbols = (
    // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
    'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
  ).split(','), j = 0; es6Symbols.length > j;)_wks(es6Symbols[j++]);

  for (var wellKnownSymbols = _objectKeys(_wks.store), k = 0; wellKnownSymbols.length > k;) _wksDefine(wellKnownSymbols[k++]);

  _export(_export.S + _export.F * !USE_NATIVE, 'Symbol', {
    // 19.4.2.1 Symbol.for(key)
    'for': function (key) {
      return _has(SymbolRegistry, key += '')
        ? SymbolRegistry[key]
        : SymbolRegistry[key] = $Symbol(key);
    },
    // 19.4.2.5 Symbol.keyFor(sym)
    keyFor: function keyFor(sym) {
      if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
      for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
    },
    useSetter: function () { setter = true; },
    useSimple: function () { setter = false; }
  });

  _export(_export.S + _export.F * !USE_NATIVE, 'Object', {
    // 19.1.2.2 Object.create(O [, Properties])
    create: $create,
    // 19.1.2.4 Object.defineProperty(O, P, Attributes)
    defineProperty: $defineProperty,
    // 19.1.2.3 Object.defineProperties(O, Properties)
    defineProperties: $defineProperties,
    // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    // 19.1.2.7 Object.getOwnPropertyNames(O)
    getOwnPropertyNames: $getOwnPropertyNames,
    // 19.1.2.8 Object.getOwnPropertySymbols(O)
    getOwnPropertySymbols: $getOwnPropertySymbols
  });

  // 24.3.2 JSON.stringify(value [, replacer [, space]])
  $JSON && _export(_export.S + _export.F * (!USE_NATIVE || _fails(function () {
    var S = $Symbol();
    // MS Edge converts symbol values to JSON as {}
    // WebKit converts symbol values to JSON as null
    // V8 throws on boxed symbols
    return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
  })), 'JSON', {
    stringify: function stringify(it) {
      var args = [it];
      var i = 1;
      var replacer, $replacer;
      while (arguments.length > i) args.push(arguments[i++]);
      $replacer = replacer = args[1];
      if (!_isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
      if (!_isArray(replacer)) replacer = function (key, value) {
        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
        if (!isSymbol(value)) return value;
      };
      args[1] = replacer;
      return _stringify.apply($JSON, args);
    }
  });

  // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
  $Symbol[PROTOTYPE$2][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE$2], TO_PRIMITIVE, $Symbol[PROTOTYPE$2].valueOf);
  // 19.4.3.5 Symbol.prototype[@@toStringTag]
  _setToStringTag($Symbol, 'Symbol');
  // 20.2.1.9 Math[@@toStringTag]
  _setToStringTag(Math, 'Math', true);
  // 24.3.3 JSON[@@toStringTag]
  _setToStringTag(_global.JSON, 'JSON', true);



  var es6_object_toString = /*#__PURE__*/Object.freeze({

  });

  _wksDefine('asyncIterator');

  _wksDefine('observable');

  getCjsExportFromNamespace(es6_object_toString);

  var symbol = _core.Symbol;

  var symbol$1 = createCommonjsModule(function (module) {
  module.exports = { "default": symbol, __esModule: true };
  });

  unwrapExports(symbol$1);

  var _typeof_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _iterator2 = _interopRequireDefault(iterator$1);



  var _symbol2 = _interopRequireDefault(symbol$1);

  var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
    return typeof obj === "undefined" ? "undefined" : _typeof(obj);
  } : function (obj) {
    return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
  };
  });

  var _typeof$1 = unwrapExports(_typeof_1);

  var classCallCheck = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;

  exports.default = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  });

  var _classCallCheck$1 = unwrapExports(classCallCheck);

  var createClass = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _defineProperty2 = _interopRequireDefault(defineProperty$1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        (0, _defineProperty2.default)(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  });

  var _createClass$1 = unwrapExports(createClass);

  var possibleConstructorReturn = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _typeof3 = _interopRequireDefault(_typeof_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
  };
  });

  var _possibleConstructorReturn$1 = unwrapExports(possibleConstructorReturn);

  // Works with __proto__ only. Old v8 can't work with null proto objects.
  /* eslint-disable no-proto */


  var check = function (O, proto) {
    _anObject(O);
    if (!_isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
  };
  var _setProto = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
      function (test, buggy, set) {
        try {
          set = _ctx(Function.call, _objectGopd.f(Object.prototype, '__proto__').set, 2);
          set(test, []);
          buggy = !(test instanceof Array);
        } catch (e) { buggy = true; }
        return function setPrototypeOf(O, proto) {
          check(O, proto);
          if (buggy) O.__proto__ = proto;
          else set(O, proto);
          return O;
        };
      }({}, false) : undefined),
    check: check
  };

  // 19.1.3.19 Object.setPrototypeOf(O, proto)

  _export(_export.S, 'Object', { setPrototypeOf: _setProto.set });

  var setPrototypeOf = _core.Object.setPrototypeOf;

  var setPrototypeOf$1 = createCommonjsModule(function (module) {
  module.exports = { "default": setPrototypeOf, __esModule: true };
  });

  unwrapExports(setPrototypeOf$1);

  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
  _export(_export.S, 'Object', { create: _objectCreate });

  var $Object$1 = _core.Object;
  var create = function create(P, D) {
    return $Object$1.create(P, D);
  };

  var create$1 = createCommonjsModule(function (module) {
  module.exports = { "default": create, __esModule: true };
  });

  unwrapExports(create$1);

  var inherits = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _setPrototypeOf2 = _interopRequireDefault(setPrototypeOf$1);



  var _create2 = _interopRequireDefault(create$1);



  var _typeof3 = _interopRequireDefault(_typeof_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
    }

    subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
  };
  });

  var _inherits$1 = unwrapExports(inherits);

  var classnames = createCommonjsModule(function (module) {
  /*!
    Copyright (c) 2017 Jed Watson.
    Licensed under the MIT License (MIT), see
    http://jedwatson.github.io/classnames
  */
  /* global define */

  (function () {

  	var hasOwn = {}.hasOwnProperty;

  	function classNames () {
  		var classes = [];

  		for (var i = 0; i < arguments.length; i++) {
  			var arg = arguments[i];
  			if (!arg) continue;

  			var argType = typeof arg;

  			if (argType === 'string' || argType === 'number') {
  				classes.push(arg);
  			} else if (Array.isArray(arg) && arg.length) {
  				var inner = classNames.apply(null, arg);
  				if (inner) {
  					classes.push(inner);
  				}
  			} else if (argType === 'object') {
  				for (var key in arg) {
  					if (hasOwn.call(arg, key) && arg[key]) {
  						classes.push(key);
  					}
  				}
  			}
  		}

  		return classes.join(' ');
  	}

  	if (module.exports) {
  		classNames.default = classNames;
  		module.exports = classNames;
  	} else {
  		window.classNames = classNames;
  	}
  }());
  });

  /**
   * Delegate to handle a media query being matched and unmatched.
   *
   * @param {object} options
   * @param {function} options.match callback for when the media query is matched
   * @param {function} [options.unmatch] callback for when the media query is unmatched
   * @param {function} [options.setup] one-time callback triggered the first time a query is matched
   * @param {boolean} [options.deferSetup=false] should the setup callback be run immediately, rather than first time query is matched?
   * @constructor
   */
  function QueryHandler(options) {
      this.options = options;
      !options.deferSetup && this.setup();
  }

  QueryHandler.prototype = {

      constructor : QueryHandler,

      /**
       * coordinates setup of the handler
       *
       * @function
       */
      setup : function() {
          if(this.options.setup) {
              this.options.setup();
          }
          this.initialised = true;
      },

      /**
       * coordinates setup and triggering of the handler
       *
       * @function
       */
      on : function() {
          !this.initialised && this.setup();
          this.options.match && this.options.match();
      },

      /**
       * coordinates the unmatch event for the handler
       *
       * @function
       */
      off : function() {
          this.options.unmatch && this.options.unmatch();
      },

      /**
       * called when a handler is to be destroyed.
       * delegates to the destroy or unmatch callbacks, depending on availability.
       *
       * @function
       */
      destroy : function() {
          this.options.destroy ? this.options.destroy() : this.off();
      },

      /**
       * determines equality by reference.
       * if object is supplied compare options, if function, compare match callback
       *
       * @function
       * @param {object || function} [target] the target for comparison
       */
      equals : function(target) {
          return this.options === target || this.options.match === target;
      }

  };

  var QueryHandler_1 = QueryHandler;

  /**
   * Helper function for iterating over a collection
   *
   * @param collection
   * @param fn
   */
  function each(collection, fn) {
      var i      = 0,
          length = collection.length,
          cont;

      for(i; i < length; i++) {
          cont = fn(collection[i], i);
          if(cont === false) {
              break; //allow early exit
          }
      }
  }

  /**
   * Helper function for determining whether target object is an array
   *
   * @param target the object under test
   * @return {Boolean} true if array, false otherwise
   */
  function isArray(target) {
      return Object.prototype.toString.apply(target) === '[object Array]';
  }

  /**
   * Helper function for determining whether target object is a function
   *
   * @param target the object under test
   * @return {Boolean} true if function, false otherwise
   */
  function isFunction(target) {
      return typeof target === 'function';
  }

  var Util = {
      isFunction : isFunction,
      isArray : isArray,
      each : each
  };

  var each$1 = Util.each;

  /**
   * Represents a single media query, manages it's state and registered handlers for this query
   *
   * @constructor
   * @param {string} query the media query string
   * @param {boolean} [isUnconditional=false] whether the media query should run regardless of whether the conditions are met. Primarily for helping older browsers deal with mobile-first design
   */
  function MediaQuery(query, isUnconditional) {
      this.query = query;
      this.isUnconditional = isUnconditional;
      this.handlers = [];
      this.mql = window.matchMedia(query);

      var self = this;
      this.listener = function(mql) {
          // Chrome passes an MediaQueryListEvent object, while other browsers pass MediaQueryList directly
          self.mql = mql.currentTarget || mql;
          self.assess();
      };
      this.mql.addListener(this.listener);
  }

  MediaQuery.prototype = {

      constuctor : MediaQuery,

      /**
       * add a handler for this query, triggering if already active
       *
       * @param {object} handler
       * @param {function} handler.match callback for when query is activated
       * @param {function} [handler.unmatch] callback for when query is deactivated
       * @param {function} [handler.setup] callback for immediate execution when a query handler is registered
       * @param {boolean} [handler.deferSetup=false] should the setup callback be deferred until the first time the handler is matched?
       */
      addHandler : function(handler) {
          var qh = new QueryHandler_1(handler);
          this.handlers.push(qh);

          this.matches() && qh.on();
      },

      /**
       * removes the given handler from the collection, and calls it's destroy methods
       *
       * @param {object || function} handler the handler to remove
       */
      removeHandler : function(handler) {
          var handlers = this.handlers;
          each$1(handlers, function(h, i) {
              if(h.equals(handler)) {
                  h.destroy();
                  return !handlers.splice(i,1); //remove from array and exit each early
              }
          });
      },

      /**
       * Determine whether the media query should be considered a match
       *
       * @return {Boolean} true if media query can be considered a match, false otherwise
       */
      matches : function() {
          return this.mql.matches || this.isUnconditional;
      },

      /**
       * Clears all handlers and unbinds events
       */
      clear : function() {
          each$1(this.handlers, function(handler) {
              handler.destroy();
          });
          this.mql.removeListener(this.listener);
          this.handlers.length = 0; //clear array
      },

      /*
          * Assesses the query, turning on all handlers if it matches, turning them off if it doesn't match
          */
      assess : function() {
          var action = this.matches() ? 'on' : 'off';

          each$1(this.handlers, function(handler) {
              handler[action]();
          });
      }
  };

  var MediaQuery_1 = MediaQuery;

  var each$2 = Util.each;
  var isFunction$1 = Util.isFunction;
  var isArray$1 = Util.isArray;

  /**
   * Allows for registration of query handlers.
   * Manages the query handler's state and is responsible for wiring up browser events
   *
   * @constructor
   */
  function MediaQueryDispatch () {
      if(!window.matchMedia) {
          throw new Error('matchMedia not present, legacy browsers require a polyfill');
      }

      this.queries = {};
      this.browserIsIncapable = !window.matchMedia('only all').matches;
  }

  MediaQueryDispatch.prototype = {

      constructor : MediaQueryDispatch,

      /**
       * Registers a handler for the given media query
       *
       * @param {string} q the media query
       * @param {object || Array || Function} options either a single query handler object, a function, or an array of query handlers
       * @param {function} options.match fired when query matched
       * @param {function} [options.unmatch] fired when a query is no longer matched
       * @param {function} [options.setup] fired when handler first triggered
       * @param {boolean} [options.deferSetup=false] whether setup should be run immediately or deferred until query is first matched
       * @param {boolean} [shouldDegrade=false] whether this particular media query should always run on incapable browsers
       */
      register : function(q, options, shouldDegrade) {
          var queries         = this.queries,
              isUnconditional = shouldDegrade && this.browserIsIncapable;

          if(!queries[q]) {
              queries[q] = new MediaQuery_1(q, isUnconditional);
          }

          //normalise to object in an array
          if(isFunction$1(options)) {
              options = { match : options };
          }
          if(!isArray$1(options)) {
              options = [options];
          }
          each$2(options, function(handler) {
              if (isFunction$1(handler)) {
                  handler = { match : handler };
              }
              queries[q].addHandler(handler);
          });

          return this;
      },

      /**
       * unregisters a query and all it's handlers, or a specific handler for a query
       *
       * @param {string} q the media query to target
       * @param {object || function} [handler] specific handler to unregister
       */
      unregister : function(q, handler) {
          var query = this.queries[q];

          if(query) {
              if(handler) {
                  query.removeHandler(handler);
              }
              else {
                  query.clear();
                  delete this.queries[q];
              }
          }

          return this;
      }
  };

  var MediaQueryDispatch_1 = MediaQueryDispatch;

  var src = new MediaQueryDispatch_1();

  var row = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _extends5 = _interopRequireDefault(_extends$1);



  var _typeof3 = _interopRequireDefault(_typeof_1);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var _classnames2 = _interopRequireDefault(classnames);



  var _propTypes2 = _interopRequireDefault(PropTypes);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var __rest = function (s, e) {
      var t = {};
      for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      }if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
      }return t;
  };
  // matchMedia polyfill for
  // https://github.com/WickyNilliams/enquire.js/issues/82
  var enquire = void 0;
  if (typeof window !== 'undefined') {
      var matchMediaPolyfill = function matchMediaPolyfill(mediaQuery) {
          return {
              media: mediaQuery,
              matches: false,
              addListener: function addListener() {},
              removeListener: function removeListener() {}
          };
      };
      window.matchMedia = window.matchMedia || matchMediaPolyfill;
      enquire = src;
  }

  var responsiveArray = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];
  var responsiveMap = {
      xs: '(max-width: 575px)',
      sm: '(min-width: 576px)',
      md: '(min-width: 768px)',
      lg: '(min-width: 992px)',
      xl: '(min-width: 1200px)',
      xxl: '(min-width: 1600px)'
  };

  var Row = function (_React$Component) {
      (0, _inherits3['default'])(Row, _React$Component);

      function Row() {
          (0, _classCallCheck3['default'])(this, Row);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (Row.__proto__ || Object.getPrototypeOf(Row)).apply(this, arguments));

          _this.state = {
              screens: {}
          };
          return _this;
      }

      (0, _createClass3['default'])(Row, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              var _this2 = this;

              Object.keys(responsiveMap).map(function (screen) {
                  return enquire.register(responsiveMap[screen], {
                      match: function match() {
                          if ((0, _typeof3['default'])(_this2.props.gutter) !== 'object') {
                              return;
                          }
                          _this2.setState(function (prevState) {
                              return {
                                  screens: (0, _extends5['default'])({}, prevState.screens, (0, _defineProperty3['default'])({}, screen, true))
                              };
                          });
                      },
                      unmatch: function unmatch() {
                          if ((0, _typeof3['default'])(_this2.props.gutter) !== 'object') {
                              return;
                          }
                          _this2.setState(function (prevState) {
                              return {
                                  screens: (0, _extends5['default'])({}, prevState.screens, (0, _defineProperty3['default'])({}, screen, false))
                              };
                          });
                      },
                      // Keep a empty destory to avoid triggering unmatch when unregister
                      destroy: function destroy() {}
                  });
              });
          }
      }, {
          key: 'componentWillUnmount',
          value: function componentWillUnmount() {
              Object.keys(responsiveMap).map(function (screen) {
                  return enquire.unregister(responsiveMap[screen]);
              });
          }
      }, {
          key: 'getGutter',
          value: function getGutter() {
              var gutter = this.props.gutter;

              if ((typeof gutter === 'undefined' ? 'undefined' : (0, _typeof3['default'])(gutter)) === 'object') {
                  for (var i = 0; i <= responsiveArray.length; i++) {
                      var breakpoint = responsiveArray[i];
                      if (this.state.screens[breakpoint] && gutter[breakpoint] !== undefined) {
                          return gutter[breakpoint];
                      }
                  }
              }
              return gutter;
          }
      }, {
          key: 'render',
          value: function render() {
              var _classNames;

              var _a = this.props,
                  type = _a.type,
                  justify = _a.justify,
                  align = _a.align,
                  className = _a.className,
                  style = _a.style,
                  children = _a.children,
                  _a$prefixCls = _a.prefixCls,
                  prefixCls = _a$prefixCls === undefined ? 'ant-row' : _a$prefixCls,
                  others = __rest(_a, ["type", "justify", "align", "className", "style", "children", "prefixCls"]);
              var gutter = this.getGutter();
              var classes = (0, _classnames2['default'])((_classNames = {}, (0, _defineProperty3['default'])(_classNames, prefixCls, !type), (0, _defineProperty3['default'])(_classNames, prefixCls + '-' + type, type), (0, _defineProperty3['default'])(_classNames, prefixCls + '-' + type + '-' + justify, type && justify), (0, _defineProperty3['default'])(_classNames, prefixCls + '-' + type + '-' + align, type && align), _classNames), className);
              var rowStyle = gutter > 0 ? (0, _extends5['default'])({ marginLeft: gutter / -2, marginRight: gutter / -2 }, style) : style;
              var cols = React$1__default.Children.map(children, function (col) {
                  if (!col) {
                      return null;
                  }
                  if (col.props && gutter > 0) {
                      return (0, React$1__default.cloneElement)(col, {
                          style: (0, _extends5['default'])({ paddingLeft: gutter / 2, paddingRight: gutter / 2 }, col.props.style)
                      });
                  }
                  return col;
              });
              var otherProps = (0, _extends5['default'])({}, others);
              delete otherProps.gutter;
              return React.createElement(
                  'div',
                  (0, _extends5['default'])({}, otherProps, { className: classes, style: rowStyle }),
                  cols
              );
          }
      }]);
      return Row;
  }(React.Component);

  exports['default'] = Row;

  Row.defaultProps = {
      gutter: 0
  };
  Row.propTypes = {
      type: _propTypes2['default'].string,
      align: _propTypes2['default'].string,
      justify: _propTypes2['default'].string,
      className: _propTypes2['default'].string,
      children: _propTypes2['default'].node,
      gutter: _propTypes2['default'].oneOfType([_propTypes2['default'].object, _propTypes2['default'].number]),
      prefixCls: _propTypes2['default'].string
  };
  module.exports = exports['default'];
  });

  unwrapExports(row);

  var col = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _extends4 = _interopRequireDefault(_extends$1);



  var _typeof3 = _interopRequireDefault(_typeof_1);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _classnames2 = _interopRequireDefault(classnames);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var __rest = function (s, e) {
      var t = {};
      for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      }if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
      }return t;
  };

  var stringOrNumber = _propTypes2['default'].oneOfType([_propTypes2['default'].string, _propTypes2['default'].number]);
  var objectOrNumber = _propTypes2['default'].oneOfType([_propTypes2['default'].object, _propTypes2['default'].number]);

  var Col = function (_React$Component) {
      (0, _inherits3['default'])(Col, _React$Component);

      function Col() {
          (0, _classCallCheck3['default'])(this, Col);
          return (0, _possibleConstructorReturn3['default'])(this, (Col.__proto__ || Object.getPrototypeOf(Col)).apply(this, arguments));
      }

      (0, _createClass3['default'])(Col, [{
          key: 'render',
          value: function render() {
              var _classNames;

              var props = this.props;

              var span = props.span,
                  order = props.order,
                  offset = props.offset,
                  push = props.push,
                  pull = props.pull,
                  className = props.className,
                  children = props.children,
                  _props$prefixCls = props.prefixCls,
                  prefixCls = _props$prefixCls === undefined ? 'ant-col' : _props$prefixCls,
                  others = __rest(props, ["span", "order", "offset", "push", "pull", "className", "children", "prefixCls"]);

              var sizeClassObj = {};
              ['xs', 'sm', 'md', 'lg', 'xl', 'xxl'].forEach(function (size) {
                  var _extends2;

                  var sizeProps = {};
                  if (typeof props[size] === 'number') {
                      sizeProps.span = props[size];
                  } else if ((0, _typeof3['default'])(props[size]) === 'object') {
                      sizeProps = props[size] || {};
                  }
                  delete others[size];
                  sizeClassObj = (0, _extends4['default'])({}, sizeClassObj, (_extends2 = {}, (0, _defineProperty3['default'])(_extends2, prefixCls + '-' + size + '-' + sizeProps.span, sizeProps.span !== undefined), (0, _defineProperty3['default'])(_extends2, prefixCls + '-' + size + '-order-' + sizeProps.order, sizeProps.order || sizeProps.order === 0), (0, _defineProperty3['default'])(_extends2, prefixCls + '-' + size + '-offset-' + sizeProps.offset, sizeProps.offset || sizeProps.offset === 0), (0, _defineProperty3['default'])(_extends2, prefixCls + '-' + size + '-push-' + sizeProps.push, sizeProps.push || sizeProps.push === 0), (0, _defineProperty3['default'])(_extends2, prefixCls + '-' + size + '-pull-' + sizeProps.pull, sizeProps.pull || sizeProps.pull === 0), _extends2));
              });
              var classes = (0, _classnames2['default'])((_classNames = {}, (0, _defineProperty3['default'])(_classNames, prefixCls + '-' + span, span !== undefined), (0, _defineProperty3['default'])(_classNames, prefixCls + '-order-' + order, order), (0, _defineProperty3['default'])(_classNames, prefixCls + '-offset-' + offset, offset), (0, _defineProperty3['default'])(_classNames, prefixCls + '-push-' + push, push), (0, _defineProperty3['default'])(_classNames, prefixCls + '-pull-' + pull, pull), _classNames), className, sizeClassObj);
              return React.createElement(
                  'div',
                  (0, _extends4['default'])({}, others, { className: classes }),
                  children
              );
          }
      }]);
      return Col;
  }(React.Component);

  exports['default'] = Col;

  Col.propTypes = {
      span: stringOrNumber,
      order: stringOrNumber,
      offset: stringOrNumber,
      push: stringOrNumber,
      pull: stringOrNumber,
      className: _propTypes2['default'].string,
      children: _propTypes2['default'].node,
      xs: objectOrNumber,
      sm: objectOrNumber,
      md: objectOrNumber,
      lg: objectOrNumber,
      xl: objectOrNumber,
      xxl: objectOrNumber
  };
  module.exports = exports['default'];
  });

  unwrapExports(col);

  var grid = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Col = exports.Row = undefined;



  var _row2 = _interopRequireDefault(row);



  var _col2 = _interopRequireDefault(col);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  exports.Row = _row2['default'];
  exports.Col = _col2['default'];
  });

  unwrapExports(grid);
  var grid_1 = grid.Col;
  var grid_2 = grid.Row;

  var row$2 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  exports['default'] = grid.Row;
  module.exports = exports['default'];
  });

  var Row = unwrapExports(row$2);

  var col$2 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  exports['default'] = grid.Col;
  module.exports = exports['default'];
  });

  var Col = unwrapExports(col$2);

  function omit(obj, fields) {
    var shallowCopy = _extends$2({}, obj);
    for (var i = 0; i < fields.length; i++) {
      var key = fields[i];
      delete shallowCopy[key];
    }
    return shallowCopy;
  }

  var es = /*#__PURE__*/Object.freeze({
    default: omit
  });

  var _omit = getCjsExportFromNamespace(es);

  var icon = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var React = _interopRequireWildcard(React$1__default);



  var _classnames2 = _interopRequireDefault(classnames);



  var _omit2 = _interopRequireDefault(_omit);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var Icon = function Icon(props) {
      var type = props.type,
          _props$className = props.className,
          className = _props$className === undefined ? '' : _props$className,
          spin = props.spin;

      var classString = (0, _classnames2['default'])((0, _defineProperty3['default'])({
          anticon: true,
          'anticon-spin': !!spin || type === 'loading'
      }, 'anticon-' + type, true), className);
      return React.createElement('i', (0, _extends3['default'])({}, (0, _omit2['default'])(props, ['type', 'spin']), { className: classString }));
  };
  exports['default'] = Icon;
  module.exports = exports['default'];
  });

  var Icon = unwrapExports(icon);

  var button = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);





  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _classnames2 = _interopRequireDefault(classnames);



  var _omit2 = _interopRequireDefault(_omit);



  var _icon2 = _interopRequireDefault(icon);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var __rest = function (s, e) {
      var t = {};
      for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      }if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
      }return t;
  };

  var rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/;
  var isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
  function isString(str) {
      return typeof str === 'string';
  }
  // Insert one space between two chinese characters automatically.
  function insertSpace(child, needInserted) {
      // Check the child if is undefined or null.
      if (child == null) {
          return;
      }
      var SPACE = needInserted ? ' ' : '';
      // strictNullChecks oops.
      if (typeof child !== 'string' && typeof child !== 'number' && isString(child.type) && isTwoCNChar(child.props.children)) {
          return React.cloneElement(child, {}, child.props.children.split('').join(SPACE));
      }
      if (typeof child === 'string') {
          if (isTwoCNChar(child)) {
              child = child.split('').join(SPACE);
          }
          return React.createElement(
              'span',
              null,
              child
          );
      }
      return child;
  }

  var Button = function (_React$Component) {
      (0, _inherits3['default'])(Button, _React$Component);

      function Button(props) {
          (0, _classCallCheck3['default'])(this, Button);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (Button.__proto__ || Object.getPrototypeOf(Button)).call(this, props));

          _this.handleClick = function (e) {
              // Add click effect
              _this.setState({ clicked: true });
              clearTimeout(_this.timeout);
              _this.timeout = window.setTimeout(function () {
                  return _this.setState({ clicked: false });
              }, 500);
              var onClick = _this.props.onClick;
              if (onClick) {
                  onClick(e);
              }
          };
          _this.state = {
              loading: props.loading,
              clicked: false,
              hasTwoCNChar: false
          };
          return _this;
      }

      (0, _createClass3['default'])(Button, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              this.fixTwoCNChar();
          }
      }, {
          key: 'componentWillReceiveProps',
          value: function componentWillReceiveProps(nextProps) {
              var _this2 = this;

              var currentLoading = this.props.loading;
              var loading = nextProps.loading;
              if (currentLoading) {
                  clearTimeout(this.delayTimeout);
              }
              if (typeof loading !== 'boolean' && loading && loading.delay) {
                  this.delayTimeout = window.setTimeout(function () {
                      return _this2.setState({ loading: loading });
                  }, loading.delay);
              } else {
                  this.setState({ loading: loading });
              }
          }
      }, {
          key: 'componentDidUpdate',
          value: function componentDidUpdate() {
              this.fixTwoCNChar();
          }
      }, {
          key: 'componentWillUnmount',
          value: function componentWillUnmount() {
              if (this.timeout) {
                  clearTimeout(this.timeout);
              }
              if (this.delayTimeout) {
                  clearTimeout(this.delayTimeout);
              }
          }
      }, {
          key: 'fixTwoCNChar',
          value: function fixTwoCNChar() {
              // Fix for HOC usage like <FormatMessage />
              var node = (0, ReactDOM__default.findDOMNode)(this);
              var buttonText = node.textContent || node.innerText;
              if (this.isNeedInserted() && isTwoCNChar(buttonText)) {
                  if (!this.state.hasTwoCNChar) {
                      this.setState({
                          hasTwoCNChar: true
                      });
                  }
              } else if (this.state.hasTwoCNChar) {
                  this.setState({
                      hasTwoCNChar: false
                  });
              }
          }
      }, {
          key: 'isNeedInserted',
          value: function isNeedInserted() {
              var _props = this.props,
                  icon$$1 = _props.icon,
                  children = _props.children;

              return React.Children.count(children) === 1 && !icon$$1;
          }
      }, {
          key: 'render',
          value: function render() {
              var _classNames,
                  _this3 = this;

              var _a = this.props,
                  type = _a.type,
                  shape = _a.shape,
                  size = _a.size,
                  className = _a.className,
                  htmlType = _a.htmlType,
                  children = _a.children,
                  icon$$1 = _a.icon,
                  prefixCls = _a.prefixCls,
                  ghost = _a.ghost,
                  others = __rest(_a, ["type", "shape", "size", "className", "htmlType", "children", "icon", "prefixCls", "ghost"]);var _state = this.state,
                  loading = _state.loading,
                  clicked = _state.clicked,
                  hasTwoCNChar = _state.hasTwoCNChar;
              // large => lg
              // small => sm

              var sizeCls = '';
              switch (size) {
                  case 'large':
                      sizeCls = 'lg';
                      break;
                  case 'small':
                      sizeCls = 'sm';
                  default:
                      break;
              }
              var ComponentProp = others.href ? 'a' : 'button';
              var classes = (0, _classnames2['default'])(prefixCls, className, (_classNames = {}, (0, _defineProperty3['default'])(_classNames, prefixCls + '-' + type, type), (0, _defineProperty3['default'])(_classNames, prefixCls + '-' + shape, shape), (0, _defineProperty3['default'])(_classNames, prefixCls + '-' + sizeCls, sizeCls), (0, _defineProperty3['default'])(_classNames, prefixCls + '-icon-only', !children && icon$$1), (0, _defineProperty3['default'])(_classNames, prefixCls + '-loading', loading), (0, _defineProperty3['default'])(_classNames, prefixCls + '-clicked', clicked), (0, _defineProperty3['default'])(_classNames, prefixCls + '-background-ghost', ghost), (0, _defineProperty3['default'])(_classNames, prefixCls + '-two-chinese-chars', hasTwoCNChar), _classNames));
              var iconType = loading ? 'loading' : icon$$1;
              var iconNode = iconType ? React.createElement(_icon2['default'], { type: iconType }) : null;
              var kids = children || children === 0 ? React.Children.map(children, function (child) {
                  return insertSpace(child, _this3.isNeedInserted());
              }) : null;
              return React.createElement(
                  ComponentProp,
                  (0, _extends3['default'])({}, (0, _omit2['default'])(others, ['loading']), { type: others.href ? undefined : htmlType || 'button', className: classes, onClick: this.handleClick }),
                  iconNode,
                  kids
              );
          }
      }]);
      return Button;
  }(React.Component);

  exports['default'] = Button;

  Button.__ANT_BUTTON = true;
  Button.defaultProps = {
      prefixCls: 'ant-btn',
      loading: false,
      ghost: false
  };
  Button.propTypes = {
      type: _propTypes2['default'].string,
      shape: _propTypes2['default'].oneOf(['circle', 'circle-outline']),
      size: _propTypes2['default'].oneOf(['large', 'default', 'small']),
      htmlType: _propTypes2['default'].oneOf(['submit', 'button', 'reset']),
      onClick: _propTypes2['default'].func,
      loading: _propTypes2['default'].oneOfType([_propTypes2['default'].bool, _propTypes2['default'].object]),
      className: _propTypes2['default'].string,
      icon: _propTypes2['default'].string
  };
  module.exports = exports['default'];
  });

  unwrapExports(button);

  var buttonGroup = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var React = _interopRequireWildcard(React$1__default);



  var _classnames2 = _interopRequireDefault(classnames);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var __rest = function (s, e) {
      var t = {};
      for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      }if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
      }return t;
  };

  var ButtonGroup = function ButtonGroup(props) {
      var _props$prefixCls = props.prefixCls,
          prefixCls = _props$prefixCls === undefined ? 'ant-btn-group' : _props$prefixCls,
          size = props.size,
          className = props.className,
          others = __rest(props, ["prefixCls", "size", "className"]);
      // large => lg
      // small => sm


      var sizeCls = '';
      switch (size) {
          case 'large':
              sizeCls = 'lg';
              break;
          case 'small':
              sizeCls = 'sm';
          default:
              break;
      }
      var classes = (0, _classnames2['default'])(prefixCls, (0, _defineProperty3['default'])({}, prefixCls + '-' + sizeCls, sizeCls), className);
      return React.createElement('div', (0, _extends3['default'])({}, others, { className: classes }));
  };
  exports['default'] = ButtonGroup;
  module.exports = exports['default'];
  });

  unwrapExports(buttonGroup);

  var button$2 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _button2 = _interopRequireDefault(button);



  var _buttonGroup2 = _interopRequireDefault(buttonGroup);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  _button2['default'].Group = _buttonGroup2['default'];
  exports['default'] = _button2['default'];
  module.exports = exports['default'];
  });

  var Button = unwrapExports(button$2);

  var LocaleReceiver_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var _propTypes2 = _interopRequireDefault(PropTypes);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var LocaleReceiver = function (_React$Component) {
      (0, _inherits3['default'])(LocaleReceiver, _React$Component);

      function LocaleReceiver() {
          (0, _classCallCheck3['default'])(this, LocaleReceiver);
          return (0, _possibleConstructorReturn3['default'])(this, (LocaleReceiver.__proto__ || Object.getPrototypeOf(LocaleReceiver)).apply(this, arguments));
      }

      (0, _createClass3['default'])(LocaleReceiver, [{
          key: 'getLocale',
          value: function getLocale() {
              var _props = this.props,
                  componentName = _props.componentName,
                  defaultLocale = _props.defaultLocale;
              var antLocale = this.context.antLocale;

              var localeFromContext = antLocale && antLocale[componentName];
              return (0, _extends3['default'])({}, typeof defaultLocale === 'function' ? defaultLocale() : defaultLocale, localeFromContext || {});
          }
      }, {
          key: 'getLocaleCode',
          value: function getLocaleCode() {
              var antLocale = this.context.antLocale;

              var localeCode = antLocale && antLocale.locale;
              // Had use LocaleProvide but didn't set locale
              if (antLocale && antLocale.exist && !localeCode) {
                  return 'en-us';
              }
              return localeCode;
          }
      }, {
          key: 'render',
          value: function render() {
              return this.props.children(this.getLocale(), this.getLocaleCode());
          }
      }]);
      return LocaleReceiver;
  }(React.Component);

  exports['default'] = LocaleReceiver;

  LocaleReceiver.contextTypes = {
      antLocale: _propTypes2['default'].object
  };
  module.exports = exports['default'];
  });

  var LocaleReceiver = unwrapExports(LocaleReceiver_1);

  var _extends$3 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var _typeof$2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;

  function getClientPosition(elem) {
    var box = undefined;
    var x = undefined;
    var y = undefined;
    var doc = elem.ownerDocument;
    var body = doc.body;
    var docElem = doc && doc.documentElement;
    // 根据 GBS 最新数据，A-Grade Browsers 都已支持 getBoundingClientRect 方法，不用再考虑传统的实现方式
    box = elem.getBoundingClientRect();

    // 注：jQuery 还考虑减去 docElem.clientLeft/clientTop
    // 但测试发现，这样反而会导致当 html 和 body 有边距/边框样式时，获取的值不正确
    // 此外，ie6 会忽略 html 的 margin 值，幸运地是没有谁会去设置 html 的 margin

    x = box.left;
    y = box.top;

    // In IE, most of the time, 2 extra pixels are added to the top and left
    // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
    // IE6 standards mode, this border can be overridden by setting the
    // document element's border to zero -- thus, we cannot rely on the
    // offset always being 2 pixels.

    // In quirks mode, the offset can be determined by querying the body's
    // clientLeft/clientTop, but in standards mode, it is found by querying
    // the document element's clientLeft/clientTop.  Since we already called
    // getClientBoundingRect we have already forced a reflow, so it is not
    // too expensive just to query them all.

    // ie 下应该减去窗口的边框吧，毕竟默认 absolute 都是相对窗口定位的
    // 窗口边框标准是设 documentElement ,quirks 时设置 body
    // 最好禁止在 body 和 html 上边框 ，但 ie < 9 html 默认有 2px ，减去
    // 但是非 ie 不可能设置窗口边框，body html 也不是窗口 ,ie 可以通过 html,body 设置
    // 标准 ie 下 docElem.clientTop 就是 border-top
    // ie7 html 即窗口边框改变不了。永远为 2
    // 但标准 firefox/chrome/ie9 下 docElem.clientTop 是窗口边框，即使设了 border-top 也为 0

    x -= docElem.clientLeft || body.clientLeft || 0;
    y -= docElem.clientTop || body.clientTop || 0;

    return {
      left: x,
      top: y
    };
  }

  function getScroll(w, top) {
    var ret = w['page' + (top ? 'Y' : 'X') + 'Offset'];
    var method = 'scroll' + (top ? 'Top' : 'Left');
    if (typeof ret !== 'number') {
      var d = w.document;
      // ie6,7,8 standard mode
      ret = d.documentElement[method];
      if (typeof ret !== 'number') {
        // quirks mode
        ret = d.body[method];
      }
    }
    return ret;
  }

  function getScrollLeft(w) {
    return getScroll(w);
  }

  function getScrollTop(w) {
    return getScroll(w, true);
  }

  function getOffset(el) {
    var pos = getClientPosition(el);
    var doc = el.ownerDocument;
    var w = doc.defaultView || doc.parentWindow;
    pos.left += getScrollLeft(w);
    pos.top += getScrollTop(w);
    return pos;
  }
  function _getComputedStyle(elem, name, computedStyle_) {
    var val = '';
    var d = elem.ownerDocument;
    var computedStyle = computedStyle_ || d.defaultView.getComputedStyle(elem, null);

    // https://github.com/kissyteam/kissy/issues/61
    if (computedStyle) {
      val = computedStyle.getPropertyValue(name) || computedStyle[name];
    }

    return val;
  }

  var _RE_NUM_NO_PX = new RegExp('^(' + RE_NUM + ')(?!px)[a-z%]+$', 'i');
  var RE_POS = /^(top|right|bottom|left)$/;
  var CURRENT_STYLE = 'currentStyle';
  var RUNTIME_STYLE = 'runtimeStyle';
  var LEFT = 'left';
  var PX = 'px';

  function _getComputedStyleIE(elem, name) {
    // currentStyle maybe null
    // http://msdn.microsoft.com/en-us/library/ms535231.aspx
    var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];

    // 当 width/height 设置为百分比时，通过 pixelLeft 方式转换的 width/height 值
    // 一开始就处理了! CUSTOM_STYLE.height,CUSTOM_STYLE.width ,cssHook 解决@2011-08-19
    // 在 ie 下不对，需要直接用 offset 方式
    // borderWidth 等值也有问题，但考虑到 borderWidth 设为百分比的概率很小，这里就不考虑了

    // From the awesome hack by Dean Edwards
    // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
    // If we're not dealing with a regular pixel number
    // but a number that has a weird ending, we need to convert it to pixels
    // exclude left right for relativity
    if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
      // Remember the original values
      var style = elem.style;
      var left = style[LEFT];
      var rsLeft = elem[RUNTIME_STYLE][LEFT];

      // prevent flashing of content
      elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT];

      // Put in the new values to get a computed value out
      style[LEFT] = name === 'fontSize' ? '1em' : ret || 0;
      ret = style.pixelLeft + PX;

      // Revert the changed values
      style[LEFT] = left;

      elem[RUNTIME_STYLE][LEFT] = rsLeft;
    }
    return ret === '' ? 'auto' : ret;
  }

  var getComputedStyleX = undefined;
  if (typeof window !== 'undefined') {
    getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
  }

  function each$3(arr, fn) {
    for (var i = 0; i < arr.length; i++) {
      fn(arr[i]);
    }
  }

  function isBorderBoxFn(elem) {
    return getComputedStyleX(elem, 'boxSizing') === 'border-box';
  }

  var BOX_MODELS = ['margin', 'border', 'padding'];
  var CONTENT_INDEX = -1;
  var PADDING_INDEX = 2;
  var BORDER_INDEX = 1;
  var MARGIN_INDEX = 0;

  function swap(elem, options, callback) {
    var old = {};
    var style = elem.style;
    var name = undefined;

    // Remember the old values, and insert the new ones
    for (name in options) {
      if (options.hasOwnProperty(name)) {
        old[name] = style[name];
        style[name] = options[name];
      }
    }

    callback.call(elem);

    // Revert the old values
    for (name in options) {
      if (options.hasOwnProperty(name)) {
        style[name] = old[name];
      }
    }
  }

  function getPBMWidth(elem, props, which) {
    var value = 0;
    var prop = undefined;
    var j = undefined;
    var i = undefined;
    for (j = 0; j < props.length; j++) {
      prop = props[j];
      if (prop) {
        for (i = 0; i < which.length; i++) {
          var cssProp = undefined;
          if (prop === 'border') {
            cssProp = prop + which[i] + 'Width';
          } else {
            cssProp = prop + which[i];
          }
          value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
        }
      }
    }
    return value;
  }

  /**
   * A crude way of determining if an object is a window
   * @member util
   */
  function isWindow(obj) {
    // must use == for ie8
    /* eslint eqeqeq:0 */
    return obj != null && obj == obj.window;
  }

  var domUtils = {};

  each$3(['Width', 'Height'], function (name) {
    domUtils['doc' + name] = function (refWin) {
      var d = refWin.document;
      return Math.max(
      // firefox chrome documentElement.scrollHeight< body.scrollHeight
      // ie standard mode : documentElement.scrollHeight> body.scrollHeight
      d.documentElement['scroll' + name],
      // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
      d.body['scroll' + name], domUtils['viewport' + name](d));
    };

    domUtils['viewport' + name] = function (win) {
      // pc browser includes scrollbar in window.innerWidth
      var prop = 'client' + name;
      var doc = win.document;
      var body = doc.body;
      var documentElement = doc.documentElement;
      var documentElementProp = documentElement[prop];
      // 标准模式取 documentElement
      // backcompat 取 body
      return doc.compatMode === 'CSS1Compat' && documentElementProp || body && body[prop] || documentElementProp;
    };
  });

  /*
   得到元素的大小信息
   @param elem
   @param name
   @param {String} [extra]  'padding' : (css width) + padding
   'border' : (css width) + padding + border
   'margin' : (css width) + padding + border + margin
   */
  function getWH(elem, name, extra) {
    if (isWindow(elem)) {
      return name === 'width' ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
    } else if (elem.nodeType === 9) {
      return name === 'width' ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
    }
    var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
    var borderBoxValue = name === 'width' ? elem.offsetWidth : elem.offsetHeight;
    var computedStyle = getComputedStyleX(elem);
    var isBorderBox = isBorderBoxFn(elem, computedStyle);
    var cssBoxValue = 0;
    if (borderBoxValue == null || borderBoxValue <= 0) {
      borderBoxValue = undefined;
      // Fall back to computed then un computed css if necessary
      cssBoxValue = getComputedStyleX(elem, name);
      if (cssBoxValue == null || Number(cssBoxValue) < 0) {
        cssBoxValue = elem.style[name] || 0;
      }
      // Normalize '', auto, and prepare for extra
      cssBoxValue = parseFloat(cssBoxValue) || 0;
    }
    if (extra === undefined) {
      extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
    }
    var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
    var val = borderBoxValue || cssBoxValue;
    if (extra === CONTENT_INDEX) {
      if (borderBoxValueOrIsBorderBox) {
        return val - getPBMWidth(elem, ['border', 'padding'], which, computedStyle);
      }
      return cssBoxValue;
    }
    if (borderBoxValueOrIsBorderBox) {
      var padding = extra === PADDING_INDEX ? -getPBMWidth(elem, ['border'], which, computedStyle) : getPBMWidth(elem, ['margin'], which, computedStyle);
      return val + (extra === BORDER_INDEX ? 0 : padding);
    }
    return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which, computedStyle);
  }

  var cssShow = {
    position: 'absolute',
    visibility: 'hidden',
    display: 'block'
  };

  // fix #119 : https://github.com/kissyteam/kissy/issues/119
  function getWHIgnoreDisplay(elem) {
    var val = undefined;
    var args = arguments;
    // in case elem is window
    // elem.offsetWidth === undefined
    if (elem.offsetWidth !== 0) {
      val = getWH.apply(undefined, args);
    } else {
      swap(elem, cssShow, function () {
        val = getWH.apply(undefined, args);
      });
    }
    return val;
  }

  function css(el, name, v) {
    var value = v;
    if ((typeof name === 'undefined' ? 'undefined' : _typeof$2(name)) === 'object') {
      for (var i in name) {
        if (name.hasOwnProperty(i)) {
          css(el, i, name[i]);
        }
      }
      return undefined;
    }
    if (typeof value !== 'undefined') {
      if (typeof value === 'number') {
        value += 'px';
      }
      el.style[name] = value;
      return undefined;
    }
    return getComputedStyleX(el, name);
  }

  each$3(['width', 'height'], function (name) {
    var first = name.charAt(0).toUpperCase() + name.slice(1);
    domUtils['outer' + first] = function (el, includeMargin) {
      return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
    };
    var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];

    domUtils[name] = function (elem, val) {
      if (val !== undefined) {
        if (elem) {
          var computedStyle = getComputedStyleX(elem);
          var isBorderBox = isBorderBoxFn(elem);
          if (isBorderBox) {
            val += getPBMWidth(elem, ['padding', 'border'], which, computedStyle);
          }
          return css(elem, name, val);
        }
        return undefined;
      }
      return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
    };
  });

  // 设置 elem 相对 elem.ownerDocument 的坐标
  function setOffset(elem, offset) {
    // set position first, in-case top/left are set even on static elem
    if (css(elem, 'position') === 'static') {
      elem.style.position = 'relative';
    }

    var old = getOffset(elem);
    var ret = {};
    var current = undefined;
    var key = undefined;

    for (key in offset) {
      if (offset.hasOwnProperty(key)) {
        current = parseFloat(css(elem, key)) || 0;
        ret[key] = current + offset[key] - old[key];
      }
    }
    css(elem, ret);
  }

  var util = _extends$3({
    getWindow: function getWindow(node) {
      var doc = node.ownerDocument || node;
      return doc.defaultView || doc.parentWindow;
    },
    offset: function offset(el, value) {
      if (typeof value !== 'undefined') {
        setOffset(el, value);
      } else {
        return getOffset(el);
      }
    },

    isWindow: isWindow,
    each: each$3,
    css: css,
    clone: function clone(obj) {
      var ret = {};
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          ret[i] = obj[i];
        }
      }
      var overflow = obj.overflow;
      if (overflow) {
        for (var i in obj) {
          if (obj.hasOwnProperty(i)) {
            ret.overflow[i] = obj.overflow[i];
          }
        }
      }
      return ret;
    },
    scrollLeft: function scrollLeft(w, v) {
      if (isWindow(w)) {
        if (v === undefined) {
          return getScrollLeft(w);
        }
        window.scrollTo(v, getScrollTop(w));
      } else {
        if (v === undefined) {
          return w.scrollLeft;
        }
        w.scrollLeft = v;
      }
    },
    scrollTop: function scrollTop(w, v) {
      if (isWindow(w)) {
        if (v === undefined) {
          return getScrollTop(w);
        }
        window.scrollTo(getScrollLeft(w), v);
      } else {
        if (v === undefined) {
          return w.scrollTop;
        }
        w.scrollTop = v;
      }
    },

    viewportWidth: 0,
    viewportHeight: 0
  }, domUtils);

  function scrollIntoView(elem, container, config) {
    config = config || {};
    // document 归一化到 window
    if (container.nodeType === 9) {
      container = util.getWindow(container);
    }

    var allowHorizontalScroll = config.allowHorizontalScroll;
    var onlyScrollIfNeeded = config.onlyScrollIfNeeded;
    var alignWithTop = config.alignWithTop;
    var alignWithLeft = config.alignWithLeft;
    var offsetTop = config.offsetTop || 0;
    var offsetLeft = config.offsetLeft || 0;
    var offsetBottom = config.offsetBottom || 0;
    var offsetRight = config.offsetRight || 0;

    allowHorizontalScroll = allowHorizontalScroll === undefined ? true : allowHorizontalScroll;

    var isWin = util.isWindow(container);
    var elemOffset = util.offset(elem);
    var eh = util.outerHeight(elem);
    var ew = util.outerWidth(elem);
    var containerOffset = undefined;
    var ch = undefined;
    var cw = undefined;
    var containerScroll = undefined;
    var diffTop = undefined;
    var diffBottom = undefined;
    var win = undefined;
    var winScroll = undefined;
    var ww = undefined;
    var wh = undefined;

    if (isWin) {
      win = container;
      wh = util.height(win);
      ww = util.width(win);
      winScroll = {
        left: util.scrollLeft(win),
        top: util.scrollTop(win)
      };
      // elem 相对 container 可视视窗的距离
      diffTop = {
        left: elemOffset.left - winScroll.left - offsetLeft,
        top: elemOffset.top - winScroll.top - offsetTop
      };
      diffBottom = {
        left: elemOffset.left + ew - (winScroll.left + ww) + offsetRight,
        top: elemOffset.top + eh - (winScroll.top + wh) + offsetBottom
      };
      containerScroll = winScroll;
    } else {
      containerOffset = util.offset(container);
      ch = container.clientHeight;
      cw = container.clientWidth;
      containerScroll = {
        left: container.scrollLeft,
        top: container.scrollTop
      };
      // elem 相对 container 可视视窗的距离
      // 注意边框, offset 是边框到根节点
      diffTop = {
        left: elemOffset.left - (containerOffset.left + (parseFloat(util.css(container, 'borderLeftWidth')) || 0)) - offsetLeft,
        top: elemOffset.top - (containerOffset.top + (parseFloat(util.css(container, 'borderTopWidth')) || 0)) - offsetTop
      };
      diffBottom = {
        left: elemOffset.left + ew - (containerOffset.left + cw + (parseFloat(util.css(container, 'borderRightWidth')) || 0)) + offsetRight,
        top: elemOffset.top + eh - (containerOffset.top + ch + (parseFloat(util.css(container, 'borderBottomWidth')) || 0)) + offsetBottom
      };
    }

    if (diffTop.top < 0 || diffBottom.top > 0) {
      // 强制向上
      if (alignWithTop === true) {
        util.scrollTop(container, containerScroll.top + diffTop.top);
      } else if (alignWithTop === false) {
        util.scrollTop(container, containerScroll.top + diffBottom.top);
      } else {
        // 自动调整
        if (diffTop.top < 0) {
          util.scrollTop(container, containerScroll.top + diffTop.top);
        } else {
          util.scrollTop(container, containerScroll.top + diffBottom.top);
        }
      }
    } else {
      if (!onlyScrollIfNeeded) {
        alignWithTop = alignWithTop === undefined ? true : !!alignWithTop;
        if (alignWithTop) {
          util.scrollTop(container, containerScroll.top + diffTop.top);
        } else {
          util.scrollTop(container, containerScroll.top + diffBottom.top);
        }
      }
    }

    if (allowHorizontalScroll) {
      if (diffTop.left < 0 || diffBottom.left > 0) {
        // 强制向上
        if (alignWithLeft === true) {
          util.scrollLeft(container, containerScroll.left + diffTop.left);
        } else if (alignWithLeft === false) {
          util.scrollLeft(container, containerScroll.left + diffBottom.left);
        } else {
          // 自动调整
          if (diffTop.left < 0) {
            util.scrollLeft(container, containerScroll.left + diffTop.left);
          } else {
            util.scrollLeft(container, containerScroll.left + diffBottom.left);
          }
        }
      } else {
        if (!onlyScrollIfNeeded) {
          alignWithLeft = alignWithLeft === undefined ? true : !!alignWithLeft;
          if (alignWithLeft) {
            util.scrollLeft(container, containerScroll.left + diffTop.left);
          } else {
            util.scrollLeft(container, containerScroll.left + diffBottom.left);
          }
        }
      }
    }
  }

  var domScrollIntoView = scrollIntoView;

  var lib = domScrollIntoView;

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$1 = objectProto.hasOwnProperty;

  /**
   * The base implementation of `_.has` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */
  function baseHas(object, key) {
    return object != null && hasOwnProperty$1.call(object, key);
  }

  var _baseHas = baseHas;

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray$2 = Array.isArray;

  var isArray_1 = isArray$2;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

  var _freeGlobal = freeGlobal;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = _freeGlobal || freeSelf || Function('return this')();

  var _root = root;

  /** Built-in value references. */
  var Symbol$1 = _root.Symbol;

  var _Symbol = Symbol$1;

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto$1.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto$1.toString;

  /** Built-in value references. */
  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty$2.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
    } catch (e) {}

    var result = nativeObjectToString.call(value);
    {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }

  var _getRawTag = getRawTag;

  /** Used for built-in method references. */
  var objectProto$2 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$2.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString$1.call(value);
  }

  var _objectToString = objectToString;

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag$1 && symToStringTag$1 in Object(value))
      ? _getRawTag(value)
      : _objectToString(value);
  }

  var _baseGetTag = baseGetTag;

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  var isObjectLike_1 = isObjectLike;

  /** `Object#toString` result references. */
  var symbolTag = '[object Symbol]';

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol$1(value) {
    return typeof value == 'symbol' ||
      (isObjectLike_1(value) && _baseGetTag(value) == symbolTag);
  }

  var isSymbol_1 = isSymbol$1;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;

  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */
  function isKey(value, object) {
    if (isArray_1(value)) {
      return false;
    }
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' ||
        value == null || isSymbol_1(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
      (object != null && value in Object(object));
  }

  var _isKey = isKey;

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  var isObject_1 = isObject;

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction$2(value) {
    if (!isObject_1(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = _baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  var isFunction_1 = isFunction$2;

  /** Used to detect overreaching core-js shims. */
  var coreJsData = _root['__core-js_shared__'];

  var _coreJsData = coreJsData;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = (function() {
    var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
  }());

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && (maskSrcKey in func);
  }

  var _isMasked = isMasked;

  /** Used for built-in method references. */
  var funcProto = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return (func + '');
      } catch (e) {}
    }
    return '';
  }

  var _toSource = toSource;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto$1 = Function.prototype,
      objectProto$3 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$1 = funcProto$1.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
    funcToString$1.call(hasOwnProperty$3).replace(reRegExpChar, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject_1(value) || _isMasked(value)) {
      return false;
    }
    var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
    return pattern.test(_toSource(value));
  }

  var _baseIsNative = baseIsNative;

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  var _getValue = getValue;

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = _getValue(object, key);
    return _baseIsNative(value) ? value : undefined;
  }

  var _getNative = getNative;

  /* Built-in method references that are verified to be native. */
  var nativeCreate = _getNative(Object, 'create');

  var _nativeCreate = nativeCreate;

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
    this.size = 0;
  }

  var _hashClear = hashClear;

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  var _hashDelete = hashDelete;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$4 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$4 = objectProto$4.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (_nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty$4.call(data, key) ? data[key] : undefined;
  }

  var _hashGet = hashGet;

  /** Used for built-in method references. */
  var objectProto$5 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$5 = objectProto$5.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$5.call(data, key);
  }

  var _hashHas = hashHas;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
    return this;
  }

  var _hashSet = hashSet;

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = _hashClear;
  Hash.prototype['delete'] = _hashDelete;
  Hash.prototype.get = _hashGet;
  Hash.prototype.has = _hashHas;
  Hash.prototype.set = _hashSet;

  var _Hash = Hash;

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  var _listCacheClear = listCacheClear;

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }

  var eq_1 = eq;

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq_1(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  var _assocIndexOf = assocIndexOf;

  /** Used for built-in method references. */
  var arrayProto = Array.prototype;

  /** Built-in value references. */
  var splice = arrayProto.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  var _listCacheDelete = listCacheDelete;

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  var _listCacheGet = listCacheGet;

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return _assocIndexOf(this.__data__, key) > -1;
  }

  var _listCacheHas = listCacheHas;

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  var _listCacheSet = listCacheSet;

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = _listCacheClear;
  ListCache.prototype['delete'] = _listCacheDelete;
  ListCache.prototype.get = _listCacheGet;
  ListCache.prototype.has = _listCacheHas;
  ListCache.prototype.set = _listCacheSet;

  var _ListCache = ListCache;

  /* Built-in method references that are verified to be native. */
  var Map$1 = _getNative(_root, 'Map');

  var _Map = Map$1;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new _Hash,
      'map': new (_Map || _ListCache),
      'string': new _Hash
    };
  }

  var _mapCacheClear = mapCacheClear;

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
      ? (value !== '__proto__')
      : (value === null);
  }

  var _isKeyable = isKeyable;

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return _isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }

  var _getMapData = getMapData;

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = _getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  var _mapCacheDelete = mapCacheDelete;

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return _getMapData(this, key).get(key);
  }

  var _mapCacheGet = mapCacheGet;

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return _getMapData(this, key).has(key);
  }

  var _mapCacheHas = mapCacheHas;

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = _getMapData(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  var _mapCacheSet = mapCacheSet;

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = _mapCacheClear;
  MapCache.prototype['delete'] = _mapCacheDelete;
  MapCache.prototype.get = _mapCacheGet;
  MapCache.prototype.has = _mapCacheHas;
  MapCache.prototype.set = _mapCacheSet;

  var _MapCache = MapCache;

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize(func, resolver) {
    if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || _MapCache);
    return memoized;
  }

  // Expose `MapCache`.
  memoize.Cache = _MapCache;

  var memoize_1 = memoize;

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */
  function memoizeCapped(func) {
    var result = memoize_1(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });

    var cache = result.cache;
    return result;
  }

  var _memoizeCapped = memoizeCapped;

  /** Used to match property names within property paths. */
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */
  var stringToPath = _memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46 /* . */) {
      result.push('');
    }
    string.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
    });
    return result;
  });

  var _stringToPath = stringToPath;

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  var _arrayMap = arrayMap;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0;

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = _Symbol ? _Symbol.prototype : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;

  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }
    if (isArray_1(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return _arrayMap(value, baseToString) + '';
    }
    if (isSymbol_1(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
  }

  var _baseToString = baseToString;

  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */
  function toString$2(value) {
    return value == null ? '' : _baseToString(value);
  }

  var toString_1 = toString$2;

  /**
   * Casts `value` to a path array if it's not one.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {Object} [object] The object to query keys on.
   * @returns {Array} Returns the cast property path array.
   */
  function castPath(value, object) {
    if (isArray_1(value)) {
      return value;
    }
    return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
  }

  var _castPath = castPath;

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]';

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments(value) {
    return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
  }

  var _baseIsArguments = baseIsArguments;

  /** Used for built-in method references. */
  var objectProto$6 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$6 = objectProto$6.hasOwnProperty;

  /** Built-in value references. */
  var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
    return isObjectLike_1(value) && hasOwnProperty$6.call(value, 'callee') &&
      !propertyIsEnumerable.call(value, 'callee');
  };

  var isArguments_1 = isArguments;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;

    return !!length &&
      (type == 'number' ||
        (type != 'symbol' && reIsUint.test(value))) &&
          (value > -1 && value % 1 == 0 && value < length);
  }

  var _isIndex = isIndex;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$1 = 9007199254740991;

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
  }

  var isLength_1 = isLength;

  /** Used as references for various `Number` constants. */
  var INFINITY$1 = 1 / 0;

  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */
  function toKey(value) {
    if (typeof value == 'string' || isSymbol_1(value)) {
      return value;
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
  }

  var _toKey = toKey;

  /**
   * Checks if `path` exists on `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @param {Function} hasFunc The function to check properties.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   */
  function hasPath(object, path, hasFunc) {
    path = _castPath(path, object);

    var index = -1,
        length = path.length,
        result = false;

    while (++index < length) {
      var key = _toKey(path[index]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index != length) {
      return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength_1(length) && _isIndex(key, length) &&
      (isArray_1(object) || isArguments_1(object));
  }

  var _hasPath = hasPath;

  /**
   * Checks if `path` is a direct property of `object`.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = { 'a': { 'b': 2 } };
   * var other = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.has(object, 'a');
   * // => true
   *
   * _.has(object, 'a.b');
   * // => true
   *
   * _.has(object, ['a', 'b']);
   * // => true
   *
   * _.has(other, 'a');
   * // => false
   */
  function has(object, path) {
    return object != null && _hasPath(object, path, _baseHas);
  }

  var has_1 = has;

  var objectWithoutProperties = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;

  exports.default = function (obj, keys) {
    var target = {};

    for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
      target[i] = obj[i];
    }

    return target;
  };
  });

  var _objectWithoutProperties$1 = unwrapExports(objectWithoutProperties);

  // call something on iterator step with safe closing on error

  var _iterCall = function (iterator, fn, value, entries) {
    try {
      return entries ? fn(_anObject(value)[0], value[1]) : fn(value);
    // 7.4.6 IteratorClose(iterator, completion)
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined) _anObject(ret.call(iterator));
      throw e;
    }
  };

  // check on default Array iterator

  var ITERATOR$1 = _wks('iterator');
  var ArrayProto = Array.prototype;

  var _isArrayIter = function (it) {
    return it !== undefined && (_iterators.Array === it || ArrayProto[ITERATOR$1] === it);
  };

  var _createProperty = function (object, index, value) {
    if (index in object) _objectDp.f(object, index, _propertyDesc(0, value));
    else object[index] = value;
  };

  // getting tag from 19.1.3.6 Object.prototype.toString()

  var TAG$1 = _wks('toStringTag');
  // ES3 wrong here
  var ARG = _cof(function () { return arguments; }()) == 'Arguments';

  // fallback for IE11 Script Access Denied error
  var tryGet = function (it, key) {
    try {
      return it[key];
    } catch (e) { /* empty */ }
  };

  var _classof = function (it) {
    var O, T, B;
    return it === undefined ? 'Undefined' : it === null ? 'Null'
      // @@toStringTag case
      : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T
      // builtinTag case
      : ARG ? _cof(O)
      // ES3 arguments fallback
      : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };

  var ITERATOR$2 = _wks('iterator');

  var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
    if (it != undefined) return it[ITERATOR$2]
      || it['@@iterator']
      || _iterators[_classof(it)];
  };

  var ITERATOR$3 = _wks('iterator');
  var SAFE_CLOSING = false;

  try {
    var riter = [7][ITERATOR$3]();
    riter['return'] = function () { SAFE_CLOSING = true; };
  } catch (e) { /* empty */ }

  var _iterDetect = function (exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING) return false;
    var safe = false;
    try {
      var arr = [7];
      var iter = arr[ITERATOR$3]();
      iter.next = function () { return { done: safe = true }; };
      arr[ITERATOR$3] = function () { return iter; };
      exec(arr);
    } catch (e) { /* empty */ }
    return safe;
  };

  _export(_export.S + _export.F * !_iterDetect(function (iter) { }), 'Array', {
    // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
    from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
      var O = _toObject(arrayLike);
      var C = typeof this == 'function' ? this : Array;
      var aLen = arguments.length;
      var mapfn = aLen > 1 ? arguments[1] : undefined;
      var mapping = mapfn !== undefined;
      var index = 0;
      var iterFn = core_getIteratorMethod(O);
      var length, result, step, iterator;
      if (mapping) mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
      // if object isn't iterable or it's array with default iterator - use simple case
      if (iterFn != undefined && !(C == Array && _isArrayIter(iterFn))) {
        for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
          _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);
        }
      } else {
        length = _toLength(O.length);
        for (result = new C(length); length > index; index++) {
          _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
        }
      }
      result.length = index;
      return result;
    }
  });

  var from_1 = _core.Array.from;

  var from_1$1 = createCommonjsModule(function (module) {
  module.exports = { "default": from_1, __esModule: true };
  });

  unwrapExports(from_1$1);

  var toConsumableArray = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _from2 = _interopRequireDefault(from_1$1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    } else {
      return (0, _from2.default)(arr);
    }
  };
  });

  unwrapExports(toConsumableArray);

  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  /* eslint-disable no-unused-vars */
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty$7 = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;

  function toObject(val) {
  	if (val === null || val === undefined) {
  		throw new TypeError('Object.assign cannot be called with null or undefined');
  	}

  	return Object(val);
  }

  function shouldUseNative() {
  	try {
  		if (!Object.assign) {
  			return false;
  		}

  		// Detect buggy property enumeration order in older V8 versions.

  		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
  		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
  		test1[5] = 'de';
  		if (Object.getOwnPropertyNames(test1)[0] === '5') {
  			return false;
  		}

  		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
  		var test2 = {};
  		for (var i = 0; i < 10; i++) {
  			test2['_' + String.fromCharCode(i)] = i;
  		}
  		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
  			return test2[n];
  		});
  		if (order2.join('') !== '0123456789') {
  			return false;
  		}

  		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
  		var test3 = {};
  		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
  			test3[letter] = letter;
  		});
  		if (Object.keys(Object.assign({}, test3)).join('') !==
  				'abcdefghijklmnopqrst') {
  			return false;
  		}

  		return true;
  	} catch (err) {
  		// We don't expect any of the above to throw, but better to be safe.
  		return false;
  	}
  }

  var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
  	var from;
  	var to = toObject(target);
  	var symbols;

  	for (var s = 1; s < arguments.length; s++) {
  		from = Object(arguments[s]);

  		for (var key in from) {
  			if (hasOwnProperty$7.call(from, key)) {
  				to[key] = from[key];
  			}
  		}

  		if (getOwnPropertySymbols) {
  			symbols = getOwnPropertySymbols(from);
  			for (var i = 0; i < symbols.length; i++) {
  				if (propIsEnumerable.call(from, symbols[i])) {
  					to[symbols[i]] = from[symbols[i]];
  				}
  			}
  		}
  	}

  	return to;
  };

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   */

  var emptyObject = {};

  var emptyObject_1 = emptyObject;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   */

  /**
   * Use invariant() to assert state which your program assumes to be true.
   *
   * Provide sprintf-style format (only %s is supported) and arguments
   * to provide information about what broke and what you were
   * expecting.
   *
   * The invariant message will be stripped in production, but the invariant
   * will remain to ensure logic does not differ in production.
   */

  var validateFormat = function validateFormat(format) {};

  function invariant(condition, format, a, b, c, d, e, f) {
    validateFormat(format);

    if (!condition) {
      var error;
      if (format === undefined) {
        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return args[argIndex++];
        }));
        error.name = 'Invariant Violation';
      }

      error.framesToPop = 1; // we don't care about invariant's own frame
      throw error;
    }
  }

  var invariant_1 = invariant;

  var MIXINS_KEY = 'mixins';

  // Helper function to allow the creation of anonymous functions which do not
  // have .name set to the name of the variable being assigned to.
  function identity(fn) {
    return fn;
  }

  function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
    /**
     * Policies that describe methods in `ReactClassInterface`.
     */

    var injectedMixins = [];

    /**
     * Composite components are higher-level components that compose other composite
     * or host components.
     *
     * To create a new type of `ReactClass`, pass a specification of
     * your new class to `React.createClass`. The only requirement of your class
     * specification is that you implement a `render` method.
     *
     *   var MyComponent = React.createClass({
     *     render: function() {
     *       return <div>Hello World</div>;
     *     }
     *   });
     *
     * The class specification supports a specific protocol of methods that have
     * special meaning (e.g. `render`). See `ReactClassInterface` for
     * more the comprehensive protocol. Any other properties and methods in the
     * class specification will be available on the prototype.
     *
     * @interface ReactClassInterface
     * @internal
     */
    var ReactClassInterface = {
      /**
       * An array of Mixin objects to include when defining your component.
       *
       * @type {array}
       * @optional
       */
      mixins: 'DEFINE_MANY',

      /**
       * An object containing properties and methods that should be defined on
       * the component's constructor instead of its prototype (static methods).
       *
       * @type {object}
       * @optional
       */
      statics: 'DEFINE_MANY',

      /**
       * Definition of prop types for this component.
       *
       * @type {object}
       * @optional
       */
      propTypes: 'DEFINE_MANY',

      /**
       * Definition of context types for this component.
       *
       * @type {object}
       * @optional
       */
      contextTypes: 'DEFINE_MANY',

      /**
       * Definition of context types this component sets for its children.
       *
       * @type {object}
       * @optional
       */
      childContextTypes: 'DEFINE_MANY',

      // ==== Definition methods ====

      /**
       * Invoked when the component is mounted. Values in the mapping will be set on
       * `this.props` if that prop is not specified (i.e. using an `in` check).
       *
       * This method is invoked before `getInitialState` and therefore cannot rely
       * on `this.state` or use `this.setState`.
       *
       * @return {object}
       * @optional
       */
      getDefaultProps: 'DEFINE_MANY_MERGED',

      /**
       * Invoked once before the component is mounted. The return value will be used
       * as the initial value of `this.state`.
       *
       *   getInitialState: function() {
       *     return {
       *       isOn: false,
       *       fooBaz: new BazFoo()
       *     }
       *   }
       *
       * @return {object}
       * @optional
       */
      getInitialState: 'DEFINE_MANY_MERGED',

      /**
       * @return {object}
       * @optional
       */
      getChildContext: 'DEFINE_MANY_MERGED',

      /**
       * Uses props from `this.props` and state from `this.state` to render the
       * structure of the component.
       *
       * No guarantees are made about when or how often this method is invoked, so
       * it must not have side effects.
       *
       *   render: function() {
       *     var name = this.props.name;
       *     return <div>Hello, {name}!</div>;
       *   }
       *
       * @return {ReactComponent}
       * @required
       */
      render: 'DEFINE_ONCE',

      // ==== Delegate methods ====

      /**
       * Invoked when the component is initially created and about to be mounted.
       * This may have side effects, but any external subscriptions or data created
       * by this method must be cleaned up in `componentWillUnmount`.
       *
       * @optional
       */
      componentWillMount: 'DEFINE_MANY',

      /**
       * Invoked when the component has been mounted and has a DOM representation.
       * However, there is no guarantee that the DOM node is in the document.
       *
       * Use this as an opportunity to operate on the DOM when the component has
       * been mounted (initialized and rendered) for the first time.
       *
       * @param {DOMElement} rootNode DOM element representing the component.
       * @optional
       */
      componentDidMount: 'DEFINE_MANY',

      /**
       * Invoked before the component receives new props.
       *
       * Use this as an opportunity to react to a prop transition by updating the
       * state using `this.setState`. Current props are accessed via `this.props`.
       *
       *   componentWillReceiveProps: function(nextProps, nextContext) {
       *     this.setState({
       *       likesIncreasing: nextProps.likeCount > this.props.likeCount
       *     });
       *   }
       *
       * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
       * transition may cause a state change, but the opposite is not true. If you
       * need it, you are probably looking for `componentWillUpdate`.
       *
       * @param {object} nextProps
       * @optional
       */
      componentWillReceiveProps: 'DEFINE_MANY',

      /**
       * Invoked while deciding if the component should be updated as a result of
       * receiving new props, state and/or context.
       *
       * Use this as an opportunity to `return false` when you're certain that the
       * transition to the new props/state/context will not require a component
       * update.
       *
       *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
       *     return !equal(nextProps, this.props) ||
       *       !equal(nextState, this.state) ||
       *       !equal(nextContext, this.context);
       *   }
       *
       * @param {object} nextProps
       * @param {?object} nextState
       * @param {?object} nextContext
       * @return {boolean} True if the component should update.
       * @optional
       */
      shouldComponentUpdate: 'DEFINE_ONCE',

      /**
       * Invoked when the component is about to update due to a transition from
       * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
       * and `nextContext`.
       *
       * Use this as an opportunity to perform preparation before an update occurs.
       *
       * NOTE: You **cannot** use `this.setState()` in this method.
       *
       * @param {object} nextProps
       * @param {?object} nextState
       * @param {?object} nextContext
       * @param {ReactReconcileTransaction} transaction
       * @optional
       */
      componentWillUpdate: 'DEFINE_MANY',

      /**
       * Invoked when the component's DOM representation has been updated.
       *
       * Use this as an opportunity to operate on the DOM when the component has
       * been updated.
       *
       * @param {object} prevProps
       * @param {?object} prevState
       * @param {?object} prevContext
       * @param {DOMElement} rootNode DOM element representing the component.
       * @optional
       */
      componentDidUpdate: 'DEFINE_MANY',

      /**
       * Invoked when the component is about to be removed from its parent and have
       * its DOM representation destroyed.
       *
       * Use this as an opportunity to deallocate any external resources.
       *
       * NOTE: There is no `componentDidUnmount` since your component will have been
       * destroyed by that point.
       *
       * @optional
       */
      componentWillUnmount: 'DEFINE_MANY',

      /**
       * Replacement for (deprecated) `componentWillMount`.
       *
       * @optional
       */
      UNSAFE_componentWillMount: 'DEFINE_MANY',

      /**
       * Replacement for (deprecated) `componentWillReceiveProps`.
       *
       * @optional
       */
      UNSAFE_componentWillReceiveProps: 'DEFINE_MANY',

      /**
       * Replacement for (deprecated) `componentWillUpdate`.
       *
       * @optional
       */
      UNSAFE_componentWillUpdate: 'DEFINE_MANY',

      // ==== Advanced methods ====

      /**
       * Updates the component's currently mounted DOM representation.
       *
       * By default, this implements React's rendering and reconciliation algorithm.
       * Sophisticated clients may wish to override this.
       *
       * @param {ReactReconcileTransaction} transaction
       * @internal
       * @overridable
       */
      updateComponent: 'OVERRIDE_BASE'
    };

    /**
     * Similar to ReactClassInterface but for static methods.
     */
    var ReactClassStaticInterface = {
      /**
       * This method is invoked after a component is instantiated and when it
       * receives new props. Return an object to update state in response to
       * prop changes. Return null to indicate no change to state.
       *
       * If an object is returned, its keys will be merged into the existing state.
       *
       * @return {object || null}
       * @optional
       */
      getDerivedStateFromProps: 'DEFINE_MANY_MERGED'
    };

    /**
     * Mapping from class specification keys to special processing functions.
     *
     * Although these are declared like instance properties in the specification
     * when defining classes using `React.createClass`, they are actually static
     * and are accessible on the constructor instead of the prototype. Despite
     * being static, they must be defined outside of the "statics" key under
     * which all other static methods are defined.
     */
    var RESERVED_SPEC_KEYS = {
      displayName: function(Constructor, displayName) {
        Constructor.displayName = displayName;
      },
      mixins: function(Constructor, mixins) {
        if (mixins) {
          for (var i = 0; i < mixins.length; i++) {
            mixSpecIntoComponent(Constructor, mixins[i]);
          }
        }
      },
      childContextTypes: function(Constructor, childContextTypes) {
        Constructor.childContextTypes = objectAssign(
          {},
          Constructor.childContextTypes,
          childContextTypes
        );
      },
      contextTypes: function(Constructor, contextTypes) {
        Constructor.contextTypes = objectAssign(
          {},
          Constructor.contextTypes,
          contextTypes
        );
      },
      /**
       * Special case getDefaultProps which should move into statics but requires
       * automatic merging.
       */
      getDefaultProps: function(Constructor, getDefaultProps) {
        if (Constructor.getDefaultProps) {
          Constructor.getDefaultProps = createMergedResultFunction(
            Constructor.getDefaultProps,
            getDefaultProps
          );
        } else {
          Constructor.getDefaultProps = getDefaultProps;
        }
      },
      propTypes: function(Constructor, propTypes) {
        Constructor.propTypes = objectAssign({}, Constructor.propTypes, propTypes);
      },
      statics: function(Constructor, statics) {
        mixStaticSpecIntoComponent(Constructor, statics);
      },
      autobind: function() {}
    };

    function validateMethodOverride(isAlreadyDefined, name) {
      var specPolicy = ReactClassInterface.hasOwnProperty(name)
        ? ReactClassInterface[name]
        : null;

      // Disallow overriding of base class methods unless explicitly allowed.
      if (ReactClassMixin.hasOwnProperty(name)) {
        invariant_1(
          specPolicy === 'OVERRIDE_BASE',
          'ReactClassInterface: You are attempting to override ' +
            '`%s` from your class specification. Ensure that your method names ' +
            'do not overlap with React methods.',
          name
        );
      }

      // Disallow defining methods more than once unless explicitly allowed.
      if (isAlreadyDefined) {
        invariant_1(
          specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED',
          'ReactClassInterface: You are attempting to define ' +
            '`%s` on your component more than once. This conflict may be due ' +
            'to a mixin.',
          name
        );
      }
    }

    /**
     * Mixin helper which handles policy validation and reserved
     * specification keys when building React classes.
     */
    function mixSpecIntoComponent(Constructor, spec) {
      if (!spec) {

        return;
      }

      invariant_1(
        typeof spec !== 'function',
        "ReactClass: You're attempting to " +
          'use a component class or function as a mixin. Instead, just use a ' +
          'regular object.'
      );
      invariant_1(
        !isValidElement(spec),
        "ReactClass: You're attempting to " +
          'use a component as a mixin. Instead, just use a regular object.'
      );

      var proto = Constructor.prototype;
      var autoBindPairs = proto.__reactAutoBindPairs;

      // By handling mixins before any other properties, we ensure the same
      // chaining order is applied to methods with DEFINE_MANY policy, whether
      // mixins are listed before or after these methods in the spec.
      if (spec.hasOwnProperty(MIXINS_KEY)) {
        RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
      }

      for (var name in spec) {
        if (!spec.hasOwnProperty(name)) {
          continue;
        }

        if (name === MIXINS_KEY) {
          // We have already handled mixins in a special case above.
          continue;
        }

        var property = spec[name];
        var isAlreadyDefined = proto.hasOwnProperty(name);
        validateMethodOverride(isAlreadyDefined, name);

        if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
          RESERVED_SPEC_KEYS[name](Constructor, property);
        } else {
          // Setup methods on prototype:
          // The following member methods should not be automatically bound:
          // 1. Expected ReactClass methods (in the "interface").
          // 2. Overridden methods (that were mixed in).
          var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
          var isFunction = typeof property === 'function';
          var shouldAutoBind =
            isFunction &&
            !isReactClassMethod &&
            !isAlreadyDefined &&
            spec.autobind !== false;

          if (shouldAutoBind) {
            autoBindPairs.push(name, property);
            proto[name] = property;
          } else {
            if (isAlreadyDefined) {
              var specPolicy = ReactClassInterface[name];

              // These cases should already be caught by validateMethodOverride.
              invariant_1(
                isReactClassMethod &&
                  (specPolicy === 'DEFINE_MANY_MERGED' ||
                    specPolicy === 'DEFINE_MANY'),
                'ReactClass: Unexpected spec policy %s for key %s ' +
                  'when mixing in component specs.',
                specPolicy,
                name
              );

              // For methods which are defined more than once, call the existing
              // methods before calling the new property, merging if appropriate.
              if (specPolicy === 'DEFINE_MANY_MERGED') {
                proto[name] = createMergedResultFunction(proto[name], property);
              } else if (specPolicy === 'DEFINE_MANY') {
                proto[name] = createChainedFunction(proto[name], property);
              }
            } else {
              proto[name] = property;
            }
          }
        }
      }
    }

    function mixStaticSpecIntoComponent(Constructor, statics) {
      if (!statics) {
        return;
      }

      for (var name in statics) {
        var property = statics[name];
        if (!statics.hasOwnProperty(name)) {
          continue;
        }

        var isReserved = name in RESERVED_SPEC_KEYS;
        invariant_1(
          !isReserved,
          'ReactClass: You are attempting to define a reserved ' +
            'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' +
            'as an instance property instead; it will still be accessible on the ' +
            'constructor.',
          name
        );

        var isAlreadyDefined = name in Constructor;
        if (isAlreadyDefined) {
          var specPolicy = ReactClassStaticInterface.hasOwnProperty(name)
            ? ReactClassStaticInterface[name]
            : null;

          invariant_1(
            specPolicy === 'DEFINE_MANY_MERGED',
            'ReactClass: You are attempting to define ' +
              '`%s` on your component more than once. This conflict may be ' +
              'due to a mixin.',
            name
          );

          Constructor[name] = createMergedResultFunction(Constructor[name], property);

          return;
        }

        Constructor[name] = property;
      }
    }

    /**
     * Merge two objects, but throw if both contain the same key.
     *
     * @param {object} one The first object, which is mutated.
     * @param {object} two The second object
     * @return {object} one after it has been mutated to contain everything in two.
     */
    function mergeIntoWithNoDuplicateKeys(one, two) {
      invariant_1(
        one && two && typeof one === 'object' && typeof two === 'object',
        'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.'
      );

      for (var key in two) {
        if (two.hasOwnProperty(key)) {
          invariant_1(
            one[key] === undefined,
            'mergeIntoWithNoDuplicateKeys(): ' +
              'Tried to merge two objects with the same key: `%s`. This conflict ' +
              'may be due to a mixin; in particular, this may be caused by two ' +
              'getInitialState() or getDefaultProps() methods returning objects ' +
              'with clashing keys.',
            key
          );
          one[key] = two[key];
        }
      }
      return one;
    }

    /**
     * Creates a function that invokes two functions and merges their return values.
     *
     * @param {function} one Function to invoke first.
     * @param {function} two Function to invoke second.
     * @return {function} Function that invokes the two argument functions.
     * @private
     */
    function createMergedResultFunction(one, two) {
      return function mergedResult() {
        var a = one.apply(this, arguments);
        var b = two.apply(this, arguments);
        if (a == null) {
          return b;
        } else if (b == null) {
          return a;
        }
        var c = {};
        mergeIntoWithNoDuplicateKeys(c, a);
        mergeIntoWithNoDuplicateKeys(c, b);
        return c;
      };
    }

    /**
     * Creates a function that invokes two functions and ignores their return vales.
     *
     * @param {function} one Function to invoke first.
     * @param {function} two Function to invoke second.
     * @return {function} Function that invokes the two argument functions.
     * @private
     */
    function createChainedFunction(one, two) {
      return function chainedFunction() {
        one.apply(this, arguments);
        two.apply(this, arguments);
      };
    }

    /**
     * Binds a method to the component.
     *
     * @param {object} component Component whose method is going to be bound.
     * @param {function} method Method to be bound.
     * @return {function} The bound method.
     */
    function bindAutoBindMethod(component, method) {
      var boundMethod = method.bind(component);
      return boundMethod;
    }

    /**
     * Binds all auto-bound methods in a component.
     *
     * @param {object} component Component whose method is going to be bound.
     */
    function bindAutoBindMethods(component) {
      var pairs = component.__reactAutoBindPairs;
      for (var i = 0; i < pairs.length; i += 2) {
        var autoBindKey = pairs[i];
        var method = pairs[i + 1];
        component[autoBindKey] = bindAutoBindMethod(component, method);
      }
    }

    var IsMountedPreMixin = {
      componentDidMount: function() {
        this.__isMounted = true;
      }
    };

    var IsMountedPostMixin = {
      componentWillUnmount: function() {
        this.__isMounted = false;
      }
    };

    /**
     * Add more to the ReactClass base class. These are all legacy features and
     * therefore not already part of the modern ReactComponent.
     */
    var ReactClassMixin = {
      /**
       * TODO: This will be deprecated because state should always keep a consistent
       * type signature and the only use case for this, is to avoid that.
       */
      replaceState: function(newState, callback) {
        this.updater.enqueueReplaceState(this, newState, callback);
      },

      /**
       * Checks whether or not this composite component is mounted.
       * @return {boolean} True if mounted, false otherwise.
       * @protected
       * @final
       */
      isMounted: function() {
        return !!this.__isMounted;
      }
    };

    var ReactClassComponent = function() {};
    objectAssign(
      ReactClassComponent.prototype,
      ReactComponent.prototype,
      ReactClassMixin
    );

    /**
     * Creates a composite component class given a class specification.
     * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
     *
     * @param {object} spec Class specification (which must define `render`).
     * @return {function} Component constructor function.
     * @public
     */
    function createClass(spec) {
      // To keep our warnings more understandable, we'll use a little hack here to
      // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
      // unnecessarily identify a class without displayName as 'Constructor'.
      var Constructor = identity(function(props, context, updater) {

        // Wire up auto-binding
        if (this.__reactAutoBindPairs.length) {
          bindAutoBindMethods(this);
        }

        this.props = props;
        this.context = context;
        this.refs = emptyObject_1;
        this.updater = updater || ReactNoopUpdateQueue;

        this.state = null;

        // ReactClasses doesn't have constructors. Instead, they use the
        // getInitialState and componentWillMount methods for initialization.

        var initialState = this.getInitialState ? this.getInitialState() : null;
        invariant_1(
          typeof initialState === 'object' && !Array.isArray(initialState),
          '%s.getInitialState(): must return an object or null',
          Constructor.displayName || 'ReactCompositeComponent'
        );

        this.state = initialState;
      });
      Constructor.prototype = new ReactClassComponent();
      Constructor.prototype.constructor = Constructor;
      Constructor.prototype.__reactAutoBindPairs = [];

      injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

      mixSpecIntoComponent(Constructor, IsMountedPreMixin);
      mixSpecIntoComponent(Constructor, spec);
      mixSpecIntoComponent(Constructor, IsMountedPostMixin);

      // Initialize the defaultProps property after all mixins have been merged.
      if (Constructor.getDefaultProps) {
        Constructor.defaultProps = Constructor.getDefaultProps();
      }

      invariant_1(
        Constructor.prototype.render,
        'createClass(...): Class specification must implement a `render` method.'
      );

      // Reduce time spent doing lookups by setting these on the prototype.
      for (var methodName in ReactClassInterface) {
        if (!Constructor.prototype[methodName]) {
          Constructor.prototype[methodName] = null;
        }
      }

      return Constructor;
    }

    return createClass;
  }

  var factory_1 = factory;

  if (typeof React$1__default === 'undefined') {
    throw Error(
      'create-react-class could not find the React object. If you are using script tags, ' +
        'make sure that React is being loaded before create-react-class.'
    );
  }

  // Hack to grab NoopUpdateQueue from isomorphic React
  var ReactNoopUpdateQueue = new React$1__default.Component().updater;

  var createReactClass = factory_1(
    React$1__default.Component,
    React$1__default.isValidElement,
    ReactNoopUpdateQueue
  );

  var formatRegExp = /%[sdj%]/g;

  var warning$2 = function warning() {};

  function format() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var i = 1;
    var f = args[0];
    var len = args.length;
    if (typeof f === 'function') {
      return f.apply(null, args.slice(1));
    }
    if (typeof f === 'string') {
      var str = String(f).replace(formatRegExp, function (x) {
        if (x === '%%') {
          return '%';
        }
        if (i >= len) {
          return x;
        }
        switch (x) {
          case '%s':
            return String(args[i++]);
          case '%d':
            return Number(args[i++]);
          case '%j':
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return '[Circular]';
            }
            break;
          default:
            return x;
        }
      });
      for (var arg = args[i]; i < len; arg = args[++i]) {
        str += ' ' + arg;
      }
      return str;
    }
    return f;
  }

  function isNativeStringType(type) {
    return type === 'string' || type === 'url' || type === 'hex' || type === 'email' || type === 'pattern';
  }

  function isEmptyValue(value, type) {
    if (value === undefined || value === null) {
      return true;
    }
    if (type === 'array' && Array.isArray(value) && !value.length) {
      return true;
    }
    if (isNativeStringType(type) && typeof value === 'string' && !value) {
      return true;
    }
    return false;
  }

  function asyncParallelArray(arr, func, callback) {
    var results = [];
    var total = 0;
    var arrLength = arr.length;

    function count(errors) {
      results.push.apply(results, errors);
      total++;
      if (total === arrLength) {
        callback(results);
      }
    }

    arr.forEach(function (a) {
      func(a, count);
    });
  }

  function asyncSerialArray(arr, func, callback) {
    var index = 0;
    var arrLength = arr.length;

    function next(errors) {
      if (errors && errors.length) {
        callback(errors);
        return;
      }
      var original = index;
      index = index + 1;
      if (original < arrLength) {
        func(arr[original], next);
      } else {
        callback([]);
      }
    }

    next([]);
  }

  function flattenObjArr(objArr) {
    var ret = [];
    Object.keys(objArr).forEach(function (k) {
      ret.push.apply(ret, objArr[k]);
    });
    return ret;
  }

  function asyncMap(objArr, option, func, callback) {
    if (option.first) {
      var flattenArr = flattenObjArr(objArr);
      return asyncSerialArray(flattenArr, func, callback);
    }
    var firstFields = option.firstFields || [];
    if (firstFields === true) {
      firstFields = Object.keys(objArr);
    }
    var objArrKeys = Object.keys(objArr);
    var objArrLength = objArrKeys.length;
    var total = 0;
    var results = [];
    var next = function next(errors) {
      results.push.apply(results, errors);
      total++;
      if (total === objArrLength) {
        callback(results);
      }
    };
    objArrKeys.forEach(function (key) {
      var arr = objArr[key];
      if (firstFields.indexOf(key) !== -1) {
        asyncSerialArray(arr, func, next);
      } else {
        asyncParallelArray(arr, func, next);
      }
    });
  }

  function complementError(rule) {
    return function (oe) {
      if (oe && oe.message) {
        oe.field = oe.field || rule.fullField;
        return oe;
      }
      return {
        message: oe,
        field: oe.field || rule.fullField
      };
    };
  }

  function deepMerge(target, source) {
    if (source) {
      for (var s in source) {
        if (source.hasOwnProperty(s)) {
          var value = source[s];
          if ((typeof value === 'undefined' ? 'undefined' : _typeof$1(value)) === 'object' && _typeof$1(target[s]) === 'object') {
            target[s] = _extends$2({}, target[s], value);
          } else {
            target[s] = value;
          }
        }
      }
    }
    return target;
  }

  /**
   *  Rule for validating required fields.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param source The source object being validated.
   *  @param errors An array of errors that this rule may add
   *  validation errors to.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */
  function required(rule, value, source, errors, options, type) {
    if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type || rule.type))) {
      errors.push(format(options.messages.required, rule.fullField));
    }
  }

  /**
   *  Rule for validating whitespace.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param source The source object being validated.
   *  @param errors An array of errors that this rule may add
   *  validation errors to.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */
  function whitespace(rule, value, source, errors, options) {
    if (/^\s+$/.test(value) || value === '') {
      errors.push(format(options.messages.whitespace, rule.fullField));
    }
  }

  /* eslint max-len:0 */

  var pattern = {
    // http://emailregex.com/
    email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
    url: new RegExp('^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$', 'i'),
    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
  };

  var types = {
    integer: function integer(value) {
      return types.number(value) && parseInt(value, 10) === value;
    },
    float: function float(value) {
      return types.number(value) && !types.integer(value);
    },
    array: function array(value) {
      return Array.isArray(value);
    },
    regexp: function regexp(value) {
      if (value instanceof RegExp) {
        return true;
      }
      try {
        return !!new RegExp(value);
      } catch (e) {
        return false;
      }
    },
    date: function date(value) {
      return typeof value.getTime === 'function' && typeof value.getMonth === 'function' && typeof value.getYear === 'function';
    },
    number: function number(value) {
      if (isNaN(value)) {
        return false;
      }
      return typeof value === 'number';
    },
    object: function object(value) {
      return (typeof value === 'undefined' ? 'undefined' : _typeof$1(value)) === 'object' && !types.array(value);
    },
    method: function method(value) {
      return typeof value === 'function';
    },
    email: function email(value) {
      return typeof value === 'string' && !!value.match(pattern.email) && value.length < 255;
    },
    url: function url(value) {
      return typeof value === 'string' && !!value.match(pattern.url);
    },
    hex: function hex(value) {
      return typeof value === 'string' && !!value.match(pattern.hex);
    }
  };

  /**
   *  Rule for validating the type of a value.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param source The source object being validated.
   *  @param errors An array of errors that this rule may add
   *  validation errors to.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */
  function type(rule, value, source, errors, options) {
    if (rule.required && value === undefined) {
      required(rule, value, source, errors, options);
      return;
    }
    var custom = ['integer', 'float', 'array', 'regexp', 'object', 'method', 'email', 'number', 'date', 'url', 'hex'];
    var ruleType = rule.type;
    if (custom.indexOf(ruleType) > -1) {
      if (!types[ruleType](value)) {
        errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
      }
      // straight typeof check
    } else if (ruleType && (typeof value === 'undefined' ? 'undefined' : _typeof$1(value)) !== rule.type) {
      errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
    }
  }

  /**
   *  Rule for validating minimum and maximum allowed values.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param source The source object being validated.
   *  @param errors An array of errors that this rule may add
   *  validation errors to.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */
  function range(rule, value, source, errors, options) {
    var len = typeof rule.len === 'number';
    var min = typeof rule.min === 'number';
    var max = typeof rule.max === 'number';
    // 正则匹配码点范围从U+010000一直到U+10FFFF的文字（补充平面Supplementary Plane）
    var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var val = value;
    var key = null;
    var num = typeof value === 'number';
    var str = typeof value === 'string';
    var arr = Array.isArray(value);
    if (num) {
      key = 'number';
    } else if (str) {
      key = 'string';
    } else if (arr) {
      key = 'array';
    }
    // if the value is not of a supported type for range validation
    // the validation rule rule should use the
    // type property to also test for a particular type
    if (!key) {
      return false;
    }
    if (arr) {
      val = value.length;
    }
    if (str) {
      // 处理码点大于U+010000的文字length属性不准确的bug，如"𠮷𠮷𠮷".lenght !== 3
      val = value.replace(spRegexp, '_').length;
    }
    if (len) {
      if (val !== rule.len) {
        errors.push(format(options.messages[key].len, rule.fullField, rule.len));
      }
    } else if (min && !max && val < rule.min) {
      errors.push(format(options.messages[key].min, rule.fullField, rule.min));
    } else if (max && !min && val > rule.max) {
      errors.push(format(options.messages[key].max, rule.fullField, rule.max));
    } else if (min && max && (val < rule.min || val > rule.max)) {
      errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
    }
  }

  var ENUM = 'enum';

  /**
   *  Rule for validating a value exists in an enumerable list.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param source The source object being validated.
   *  @param errors An array of errors that this rule may add
   *  validation errors to.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */
  function enumerable(rule, value, source, errors, options) {
    rule[ENUM] = Array.isArray(rule[ENUM]) ? rule[ENUM] : [];
    if (rule[ENUM].indexOf(value) === -1) {
      errors.push(format(options.messages[ENUM], rule.fullField, rule[ENUM].join(', ')));
    }
  }

  /**
   *  Rule for validating a regular expression pattern.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param source The source object being validated.
   *  @param errors An array of errors that this rule may add
   *  validation errors to.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */
  function pattern$1(rule, value, source, errors, options) {
    if (rule.pattern) {
      if (rule.pattern instanceof RegExp) {
        // if a RegExp instance is passed, reset `lastIndex` in case its `global`
        // flag is accidentally set to `true`, which in a validation scenario
        // is not necessary and the result might be misleading
        rule.pattern.lastIndex = 0;
        if (!rule.pattern.test(value)) {
          errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        }
      } else if (typeof rule.pattern === 'string') {
        var _pattern = new RegExp(rule.pattern);
        if (!_pattern.test(value)) {
          errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        }
      }
    }
  }

  var rules = {
    required: required,
    whitespace: whitespace,
    type: type,
    range: range,
    'enum': enumerable,
    pattern: pattern$1
  };

  /**
   *  Performs validation for string types.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */
  function string(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, 'string') && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, 'string');
      if (!isEmptyValue(value, 'string')) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
        rules.pattern(rule, value, source, errors, options);
        if (rule.whitespace === true) {
          rules.whitespace(rule, value, source, errors, options);
        }
      }
    }
    callback(errors);
  }

  /**
   *  Validates a function.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */
  function method(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== undefined) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  }

  /**
   *  Validates a number.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */
  function number(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== undefined) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  }

  /**
   *  Validates a boolean.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */
  function boolean(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== undefined) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  }

  /**
   *  Validates the regular expression type.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */
  function regexp(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value)) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  }

  /**
   *  Validates a number is an integer.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */
  function integer(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== undefined) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  }

  /**
   *  Validates a number is a floating point number.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */
  function floatFn(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== undefined) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  }

  /**
   *  Validates an array.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */
  function array(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, 'array') && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, 'array');
      if (!isEmptyValue(value, 'array')) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  }

  /**
   *  Validates an object.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */
  function object(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== undefined) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  }

  var ENUM$1 = 'enum';

  /**
   *  Validates an enumerable list.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */
  function enumerable$1(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value) {
        rules[ENUM$1](rule, value, source, errors, options);
      }
    }
    callback(errors);
  }

  /**
   *  Validates a regular expression pattern.
   *
   *  Performs validation when a rule only contains
   *  a pattern property but is not declared as a string type.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */
  function pattern$2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, 'string') && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value, 'string')) {
        rules.pattern(rule, value, source, errors, options);
      }
    }
    callback(errors);
  }

  function date(rule, value, callback, source, options) {
    // console.log('integer rule called %j', rule);
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    // console.log('validate on %s value', value);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value)) {
        var dateObject = void 0;

        if (typeof value === 'number') {
          dateObject = new Date(value);
        } else {
          dateObject = value;
        }

        rules.type(rule, dateObject, source, errors, options);
        if (dateObject) {
          rules.range(rule, dateObject.getTime(), source, errors, options);
        }
      }
    }
    callback(errors);
  }

  function required$1(rule, value, callback, source, options) {
    var errors = [];
    var type = Array.isArray(value) ? 'array' : typeof value === 'undefined' ? 'undefined' : _typeof$1(value);
    rules.required(rule, value, source, errors, options, type);
    callback(errors);
  }

  function type$1(rule, value, callback, source, options) {
    var ruleType = rule.type;
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, ruleType) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, ruleType);
      if (!isEmptyValue(value, ruleType)) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  }

  var validators = {
    string: string,
    method: method,
    number: number,
    boolean: boolean,
    regexp: regexp,
    integer: integer,
    float: floatFn,
    array: array,
    object: object,
    'enum': enumerable$1,
    pattern: pattern$2,
    date: date,
    url: type$1,
    hex: type$1,
    email: type$1,
    required: required$1
  };

  function newMessages() {
    return {
      'default': 'Validation error on field %s',
      required: '%s is required',
      'enum': '%s must be one of %s',
      whitespace: '%s cannot be empty',
      date: {
        format: '%s date %s is invalid for format %s',
        parse: '%s date could not be parsed, %s is invalid ',
        invalid: '%s date %s is invalid'
      },
      types: {
        string: '%s is not a %s',
        method: '%s is not a %s (function)',
        array: '%s is not an %s',
        object: '%s is not an %s',
        number: '%s is not a %s',
        date: '%s is not a %s',
        boolean: '%s is not a %s',
        integer: '%s is not an %s',
        float: '%s is not a %s',
        regexp: '%s is not a valid %s',
        email: '%s is not a valid %s',
        url: '%s is not a valid %s',
        hex: '%s is not a valid %s'
      },
      string: {
        len: '%s must be exactly %s characters',
        min: '%s must be at least %s characters',
        max: '%s cannot be longer than %s characters',
        range: '%s must be between %s and %s characters'
      },
      number: {
        len: '%s must equal %s',
        min: '%s cannot be less than %s',
        max: '%s cannot be greater than %s',
        range: '%s must be between %s and %s'
      },
      array: {
        len: '%s must be exactly %s in length',
        min: '%s cannot be less than %s in length',
        max: '%s cannot be greater than %s in length',
        range: '%s must be between %s and %s in length'
      },
      pattern: {
        mismatch: '%s value %s does not match pattern %s'
      },
      clone: function clone() {
        var cloned = JSON.parse(JSON.stringify(this));
        cloned.clone = this.clone;
        return cloned;
      }
    };
  }

  var messages = newMessages();

  /**
   *  Encapsulates a validation schema.
   *
   *  @param descriptor An object declaring validation rules
   *  for this schema.
   */
  function Schema(descriptor) {
    this.rules = null;
    this._messages = messages;
    this.define(descriptor);
  }

  Schema.prototype = {
    messages: function messages$$1(_messages) {
      if (_messages) {
        this._messages = deepMerge(newMessages(), _messages);
      }
      return this._messages;
    },
    define: function define(rules) {
      if (!rules) {
        throw new Error('Cannot configure a schema with no rules');
      }
      if ((typeof rules === 'undefined' ? 'undefined' : _typeof$1(rules)) !== 'object' || Array.isArray(rules)) {
        throw new Error('Rules must be an object');
      }
      this.rules = {};
      var z = void 0;
      var item = void 0;
      for (z in rules) {
        if (rules.hasOwnProperty(z)) {
          item = rules[z];
          this.rules[z] = Array.isArray(item) ? item : [item];
        }
      }
    },
    validate: function validate(source_) {
      var _this = this;

      var o = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var oc = arguments[2];

      var source = source_;
      var options = o;
      var callback = oc;
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      if (!this.rules || Object.keys(this.rules).length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      function complete(results) {
        var i = void 0;
        var field = void 0;
        var errors = [];
        var fields = {};

        function add(e) {
          if (Array.isArray(e)) {
            errors = errors.concat.apply(errors, e);
          } else {
            errors.push(e);
          }
        }

        for (i = 0; i < results.length; i++) {
          add(results[i]);
        }
        if (!errors.length) {
          errors = null;
          fields = null;
        } else {
          for (i = 0; i < errors.length; i++) {
            field = errors[i].field;
            fields[field] = fields[field] || [];
            fields[field].push(errors[i]);
          }
        }
        callback(errors, fields);
      }

      if (options.messages) {
        var messages$$1 = this.messages();
        if (messages$$1 === messages) {
          messages$$1 = newMessages();
        }
        deepMerge(messages$$1, options.messages);
        options.messages = messages$$1;
      } else {
        options.messages = this.messages();
      }
      var arr = void 0;
      var value = void 0;
      var series = {};
      var keys = options.keys || Object.keys(this.rules);
      keys.forEach(function (z) {
        arr = _this.rules[z];
        value = source[z];
        arr.forEach(function (r) {
          var rule = r;
          if (typeof rule.transform === 'function') {
            if (source === source_) {
              source = _extends$2({}, source);
            }
            value = source[z] = rule.transform(value);
          }
          if (typeof rule === 'function') {
            rule = {
              validator: rule
            };
          } else {
            rule = _extends$2({}, rule);
          }
          rule.validator = _this.getValidationMethod(rule);
          rule.field = z;
          rule.fullField = rule.fullField || z;
          rule.type = _this.getType(rule);
          if (!rule.validator) {
            return;
          }
          series[z] = series[z] || [];
          series[z].push({
            rule: rule,
            value: value,
            source: source,
            field: z
          });
        });
      });
      var errorFields = {};
      asyncMap(series, options, function (data, doIt) {
        var rule = data.rule;
        var deep = (rule.type === 'object' || rule.type === 'array') && (_typeof$1(rule.fields) === 'object' || _typeof$1(rule.defaultField) === 'object');
        deep = deep && (rule.required || !rule.required && data.value);
        rule.field = data.field;
        function addFullfield(key, schema) {
          return _extends$2({}, schema, {
            fullField: rule.fullField + '.' + key
          });
        }

        function cb() {
          var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

          var errors = e;
          if (!Array.isArray(errors)) {
            errors = [errors];
          }
          if (errors.length) {
            warning$2('async-validator:', errors);
          }
          if (errors.length && rule.message) {
            errors = [].concat(rule.message);
          }

          errors = errors.map(complementError(rule));

          if (options.first && errors.length) {
            errorFields[rule.field] = 1;
            return doIt(errors);
          }
          if (!deep) {
            doIt(errors);
          } else {
            // if rule is required but the target object
            // does not exist fail at the rule level and don't
            // go deeper
            if (rule.required && !data.value) {
              if (rule.message) {
                errors = [].concat(rule.message).map(complementError(rule));
              } else if (options.error) {
                errors = [options.error(rule, format(options.messages.required, rule.field))];
              } else {
                errors = [];
              }
              return doIt(errors);
            }

            var fieldsSchema = {};
            if (rule.defaultField) {
              for (var k in data.value) {
                if (data.value.hasOwnProperty(k)) {
                  fieldsSchema[k] = rule.defaultField;
                }
              }
            }
            fieldsSchema = _extends$2({}, fieldsSchema, data.rule.fields);
            for (var f in fieldsSchema) {
              if (fieldsSchema.hasOwnProperty(f)) {
                var fieldSchema = Array.isArray(fieldsSchema[f]) ? fieldsSchema[f] : [fieldsSchema[f]];
                fieldsSchema[f] = fieldSchema.map(addFullfield.bind(null, f));
              }
            }
            var schema = new Schema(fieldsSchema);
            schema.messages(options.messages);
            if (data.rule.options) {
              data.rule.options.messages = options.messages;
              data.rule.options.error = options.error;
            }
            schema.validate(data.value, data.rule.options || options, function (errs) {
              doIt(errs && errs.length ? errors.concat(errs) : errs);
            });
          }
        }

        var res = rule.validator(rule, data.value, cb, data.source, options);
        if (res && res.then) {
          res.then(function () {
            return cb();
          }, function (e) {
            return cb(e);
          });
        }
      }, function (results) {
        complete(results);
      });
    },
    getType: function getType(rule) {
      if (rule.type === undefined && rule.pattern instanceof RegExp) {
        rule.type = 'pattern';
      }
      if (typeof rule.validator !== 'function' && rule.type && !validators.hasOwnProperty(rule.type)) {
        throw new Error(format('Unknown rule type %s', rule.type));
      }
      return rule.type || 'string';
    },
    getValidationMethod: function getValidationMethod(rule) {
      if (typeof rule.validator === 'function') {
        return rule.validator;
      }
      var keys = Object.keys(rule);
      var messageIndex = keys.indexOf('message');
      if (messageIndex !== -1) {
        keys.splice(messageIndex, 1);
      }
      if (keys.length === 1 && keys[0] === 'required') {
        return validators.required;
      }
      return validators[this.getType(rule)] || false;
    }
  };

  Schema.register = function register(type, validator) {
    if (typeof validator !== 'function') {
      throw new Error('Cannot register a validator by type, validator is not a function');
    }
    validators[type] = validator;
  };

  Schema.messages = messages;

  var es$1 = /*#__PURE__*/Object.freeze({
    default: Schema
  });

  /**
   * Copyright 2014-2015, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   */

  var warning$3 = function() {};

  var warning_1$1 = warning$3;

  /**
   * The base implementation of `_.get` without support for default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @returns {*} Returns the resolved value.
   */
  function baseGet(object, path) {
    path = _castPath(path, object);

    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[_toKey(path[index++])];
    }
    return (index && index == length) ? object : undefined;
  }

  var _baseGet = baseGet;

  /**
   * Gets the value at `path` of `object`. If the resolved value is
   * `undefined`, the `defaultValue` is returned in its place.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.get(object, 'a[0].b.c');
   * // => 3
   *
   * _.get(object, ['a', '0', 'b', 'c']);
   * // => 3
   *
   * _.get(object, 'a.b.c', 'default');
   * // => 'default'
   */
  function get(object, path, defaultValue) {
    var result = object == null ? undefined : _baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }

  var get_1 = get;

  var defineProperty$5 = (function() {
    try {
      var func = _getNative(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }());

  var _defineProperty$2 = defineProperty$5;

  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && _defineProperty$2) {
      _defineProperty$2(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  var _baseAssignValue = baseAssignValue;

  /** Used for built-in method references. */
  var objectProto$7 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$8 = objectProto$7.hasOwnProperty;

  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty$8.call(object, key) && eq_1(objValue, value)) ||
        (value === undefined && !(key in object))) {
      _baseAssignValue(object, key, value);
    }
  }

  var _assignValue = assignValue;

  /**
   * The base implementation of `_.set`.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {Array|string} path The path of the property to set.
   * @param {*} value The value to set.
   * @param {Function} [customizer] The function to customize path creation.
   * @returns {Object} Returns `object`.
   */
  function baseSet(object, path, value, customizer) {
    if (!isObject_1(object)) {
      return object;
    }
    path = _castPath(path, object);

    var index = -1,
        length = path.length,
        lastIndex = length - 1,
        nested = object;

    while (nested != null && ++index < length) {
      var key = _toKey(path[index]),
          newValue = value;

      if (index != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : undefined;
        if (newValue === undefined) {
          newValue = isObject_1(objValue)
            ? objValue
            : (_isIndex(path[index + 1]) ? [] : {});
        }
      }
      _assignValue(nested, key, newValue);
      nested = nested[key];
    }
    return object;
  }

  var _baseSet = baseSet;

  /**
   * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
   * it's created. Arrays are created for missing index properties while objects
   * are created for all other missing properties. Use `_.setWith` to customize
   * `path` creation.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to modify.
   * @param {Array|string} path The path of the property to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns `object`.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.set(object, 'a[0].b.c', 4);
   * console.log(object.a[0].b.c);
   * // => 4
   *
   * _.set(object, ['x', '0', 'y', 'z'], 5);
   * console.log(object.x[0].y.z);
   * // => 5
   */
  function set$1(object, path, value) {
    return object == null ? object : _baseSet(object, path, value);
  }

  var set_1 = set$1;

  var createFormField_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);

  exports.isFormField = isFormField;
  exports["default"] = createFormField;

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  var Field = function Field(fields) {
    (0, _classCallCheck3["default"])(this, Field);

    (0, _extends3["default"])(this, fields);
  };

  function isFormField(obj) {
    return obj instanceof Field;
  }

  function createFormField(field) {
    if (isFormField(field)) {
      return field;
    }
    return new Field(field);
  }
  });

  unwrapExports(createFormField_1);
  var createFormField_2 = createFormField_1.isFormField;

  /**
   * Copyright 2015, Yahoo! Inc.
   * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
   */
  var REACT_STATICS = {
      childContextTypes: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
  };

  var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
  };

  var defineProperty$6 = Object.defineProperty;
  var getOwnPropertyNames = Object.getOwnPropertyNames;
  var getOwnPropertySymbols$1 = Object.getOwnPropertySymbols;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectPrototype = getPrototypeOf && getPrototypeOf(Object);

  function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components

          if (objectPrototype) {
              var inheritedComponent = getPrototypeOf(sourceComponent);
              if (inheritedComponent && inheritedComponent !== objectPrototype) {
                  hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
              }
          }

          var keys = getOwnPropertyNames(sourceComponent);

          if (getOwnPropertySymbols$1) {
              keys = keys.concat(getOwnPropertySymbols$1(sourceComponent));
          }

          for (var i = 0; i < keys.length; ++i) {
              var key = keys[i];
              if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                  var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                  try { // Avoid failures from read-only properties
                      defineProperty$6(targetComponent, key, descriptor);
                  } catch (e) {}
              }
          }

          return targetComponent;
      }

      return targetComponent;
  }

  var hoistNonReactStatics_cjs = hoistNonReactStatics;

  var utils = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);

  exports.argumentContainer = argumentContainer;
  exports.identity = identity;
  exports.flattenArray = flattenArray;
  exports.treeTraverse = treeTraverse;
  exports.flattenFields = flattenFields;
  exports.normalizeValidateRules = normalizeValidateRules;
  exports.getValidateTriggers = getValidateTriggers;
  exports.getValueFromEvent = getValueFromEvent;
  exports.getErrorStrs = getErrorStrs;
  exports.getParams = getParams;
  exports.isEmptyObject = isEmptyObject;
  exports.hasRules = hasRules;
  exports.startsWith = startsWith;



  var _hoistNonReactStatics2 = _interopRequireDefault(hoistNonReactStatics_cjs);



  var _warning2 = _interopRequireDefault(warning_1$1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function getDisplayName(WrappedComponent) {
    return WrappedComponent.displayName || WrappedComponent.name || 'WrappedComponent';
  }

  function argumentContainer(Container, WrappedComponent) {
    /* eslint no-param-reassign:0 */
    Container.displayName = 'Form(' + getDisplayName(WrappedComponent) + ')';
    Container.WrappedComponent = WrappedComponent;
    return (0, _hoistNonReactStatics2['default'])(Container, WrappedComponent);
  }

  function identity(obj) {
    return obj;
  }

  function flattenArray(arr) {
    return Array.prototype.concat.apply([], arr);
  }

  function treeTraverse() {
    var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var tree = arguments[1];
    var isLeafNode = arguments[2];
    var errorMessage = arguments[3];
    var callback = arguments[4];

    if (isLeafNode(path, tree)) {
      callback(path, tree);
    } else if (tree === undefined || tree === null) ; else if (Array.isArray(tree)) {
      tree.forEach(function (subTree, index) {
        return treeTraverse(path + '[' + index + ']', subTree, isLeafNode, errorMessage, callback);
      });
    } else {
      // It's object and not a leaf node
      if (typeof tree !== 'object') {
        (0, _warning2['default'])(false, errorMessage);
        return;
      }
      Object.keys(tree).forEach(function (subTreeKey) {
        var subTree = tree[subTreeKey];
        treeTraverse('' + path + (path ? '.' : '') + subTreeKey, subTree, isLeafNode, errorMessage, callback);
      });
    }
  }

  function flattenFields(maybeNestedFields, isLeafNode, errorMessage) {
    var fields = {};
    treeTraverse(undefined, maybeNestedFields, isLeafNode, errorMessage, function (path, node) {
      fields[path] = node;
    });
    return fields;
  }

  function normalizeValidateRules(validate, rules, validateTrigger) {
    var validateRules = validate.map(function (item) {
      var newItem = (0, _extends3['default'])({}, item, {
        trigger: item.trigger || []
      });
      if (typeof newItem.trigger === 'string') {
        newItem.trigger = [newItem.trigger];
      }
      return newItem;
    });
    if (rules) {
      validateRules.push({
        trigger: validateTrigger ? [].concat(validateTrigger) : [],
        rules: rules
      });
    }
    return validateRules;
  }

  function getValidateTriggers(validateRules) {
    return validateRules.filter(function (item) {
      return !!item.rules && item.rules.length;
    }).map(function (item) {
      return item.trigger;
    }).reduce(function (pre, curr) {
      return pre.concat(curr);
    }, []);
  }

  function getValueFromEvent(e) {
    // To support custom element
    if (!e || !e.target) {
      return e;
    }
    var target = e.target;

    return target.type === 'checkbox' ? target.checked : target.value;
  }

  function getErrorStrs(errors) {
    if (errors) {
      return errors.map(function (e) {
        if (e && e.message) {
          return e.message;
        }
        return e;
      });
    }
    return errors;
  }

  function getParams(ns, opt, cb) {
    var names = ns;
    var options = opt;
    var callback = cb;
    if (cb === undefined) {
      if (typeof names === 'function') {
        callback = names;
        options = {};
        names = undefined;
      } else if (Array.isArray(names)) {
        if (typeof options === 'function') {
          callback = options;
          options = {};
        } else {
          options = options || {};
        }
      } else {
        callback = options;
        options = names || {};
        names = undefined;
      }
    }
    return {
      names: names,
      options: options,
      callback: callback
    };
  }

  function isEmptyObject(obj) {
    return Object.keys(obj).length === 0;
  }

  function hasRules(validate) {
    if (validate) {
      return validate.some(function (item) {
        return item.rules && item.rules.length;
      });
    }
    return false;
  }

  function startsWith(str, prefix) {
    return str.lastIndexOf(prefix, 0) === 0;
  }
  });

  unwrapExports(utils);
  var utils_1 = utils.argumentContainer;
  var utils_2 = utils.identity;
  var utils_3 = utils.flattenArray;
  var utils_4 = utils.treeTraverse;
  var utils_5 = utils.flattenFields;
  var utils_6 = utils.normalizeValidateRules;
  var utils_7 = utils.getValidateTriggers;
  var utils_8 = utils.getValueFromEvent;
  var utils_9 = utils.getErrorStrs;
  var utils_10 = utils.getParams;
  var utils_11 = utils.isEmptyObject;
  var utils_12 = utils.hasRules;
  var utils_13 = utils.startsWith;

  var createFieldsStore_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _extends3 = _interopRequireDefault(_extends$1);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);

  exports['default'] = createFieldsStore;



  var _set2 = _interopRequireDefault(set_1);



  var _createFormField2 = _interopRequireDefault(createFormField_1);



  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function partOf(a, b) {
    return b.indexOf(a) === 0 && ['.', '['].indexOf(b[a.length]) !== -1;
  }

  function internalFlattenFields(fields) {
    return (0, utils.flattenFields)(fields, function (_, node) {
      return (0, createFormField_1.isFormField)(node);
    }, 'You must wrap field data with `createFormField`.');
  }

  var FieldsStore = function () {
    function FieldsStore(fields) {
      (0, _classCallCheck3['default'])(this, FieldsStore);

      _initialiseProps.call(this);

      this.fields = internalFlattenFields(fields);
      this.fieldsMeta = {};
    }

    (0, _createClass3['default'])(FieldsStore, [{
      key: 'updateFields',
      value: function updateFields(fields) {
        this.fields = internalFlattenFields(fields);
      }
    }, {
      key: 'flattenRegisteredFields',
      value: function flattenRegisteredFields(fields) {
        var validFieldsName = this.getAllFieldsName();
        return (0, utils.flattenFields)(fields, function (path) {
          return validFieldsName.indexOf(path) >= 0;
        }, 'You cannot set a form field before rendering a field associated with the value.');
      }
    }, {
      key: 'setFields',
      value: function setFields(fields) {
        var _this = this;

        var fieldsMeta = this.fieldsMeta;
        var nowFields = (0, _extends3['default'])({}, this.fields, fields);
        var nowValues = {};
        Object.keys(fieldsMeta).forEach(function (f) {
          nowValues[f] = _this.getValueFromFields(f, nowFields);
        });
        Object.keys(nowValues).forEach(function (f) {
          var value = nowValues[f];
          var fieldMeta = _this.getFieldMeta(f);
          if (fieldMeta && fieldMeta.normalize) {
            var nowValue = fieldMeta.normalize(value, _this.getValueFromFields(f, _this.fields), nowValues);
            if (nowValue !== value) {
              nowFields[f] = (0, _extends3['default'])({}, nowFields[f], {
                value: nowValue
              });
            }
          }
        });
        this.fields = nowFields;
      }
    }, {
      key: 'resetFields',
      value: function resetFields(ns) {
        var fields = this.fields;

        var names = ns ? this.getValidFieldsFullName(ns) : this.getAllFieldsName();
        return names.reduce(function (acc, name) {
          var field = fields[name];
          if (field && 'value' in field) {
            acc[name] = {};
          }
          return acc;
        }, {});
      }
    }, {
      key: 'setFieldMeta',
      value: function setFieldMeta(name, meta) {
        this.fieldsMeta[name] = meta;
      }
    }, {
      key: 'getFieldMeta',
      value: function getFieldMeta(name) {
        this.fieldsMeta[name] = this.fieldsMeta[name] || {};
        return this.fieldsMeta[name];
      }
    }, {
      key: 'getValueFromFields',
      value: function getValueFromFields(name, fields) {
        var field = fields[name];
        if (field && 'value' in field) {
          return field.value;
        }
        var fieldMeta = this.getFieldMeta(name);
        return fieldMeta && fieldMeta.initialValue;
      }
    }, {
      key: 'getValidFieldsName',
      value: function getValidFieldsName() {
        var _this2 = this;

        var fieldsMeta = this.fieldsMeta;

        return fieldsMeta ? Object.keys(fieldsMeta).filter(function (name) {
          return !_this2.getFieldMeta(name).hidden;
        }) : [];
      }
    }, {
      key: 'getAllFieldsName',
      value: function getAllFieldsName() {
        var fieldsMeta = this.fieldsMeta;

        return fieldsMeta ? Object.keys(fieldsMeta) : [];
      }
    }, {
      key: 'getValidFieldsFullName',
      value: function getValidFieldsFullName(maybePartialName) {
        var maybePartialNames = Array.isArray(maybePartialName) ? maybePartialName : [maybePartialName];
        return this.getValidFieldsName().filter(function (fullName) {
          return maybePartialNames.some(function (partialName) {
            return fullName === partialName || (0, utils.startsWith)(fullName, partialName) && ['.', '['].indexOf(fullName[partialName.length]) >= 0;
          });
        });
      }
    }, {
      key: 'getFieldValuePropValue',
      value: function getFieldValuePropValue(fieldMeta) {
        var name = fieldMeta.name,
            getValueProps = fieldMeta.getValueProps,
            valuePropName = fieldMeta.valuePropName;

        var field = this.getField(name);
        var fieldValue = 'value' in field ? field.value : fieldMeta.initialValue;
        if (getValueProps) {
          return getValueProps(fieldValue);
        }
        return (0, _defineProperty3['default'])({}, valuePropName, fieldValue);
      }
    }, {
      key: 'getField',
      value: function getField(name) {
        return (0, _extends3['default'])({}, this.fields[name], {
          name: name
        });
      }
    }, {
      key: 'getNotCollectedFields',
      value: function getNotCollectedFields() {
        var _this3 = this;

        var fieldsName = this.getValidFieldsName();
        return fieldsName.filter(function (name) {
          return !_this3.fields[name];
        }).map(function (name) {
          return {
            name: name,
            dirty: false,
            value: _this3.getFieldMeta(name).initialValue
          };
        }).reduce(function (acc, field) {
          return (0, _set2['default'])(acc, field.name, (0, _createFormField2['default'])(field));
        }, {});
      }
    }, {
      key: 'getNestedAllFields',
      value: function getNestedAllFields() {
        var _this4 = this;

        return Object.keys(this.fields).reduce(function (acc, name) {
          return (0, _set2['default'])(acc, name, (0, _createFormField2['default'])(_this4.fields[name]));
        }, this.getNotCollectedFields());
      }
    }, {
      key: 'getFieldMember',
      value: function getFieldMember(name, member) {
        return this.getField(name)[member];
      }
    }, {
      key: 'getNestedFields',
      value: function getNestedFields(names, getter) {
        var fields = names || this.getValidFieldsName();
        return fields.reduce(function (acc, f) {
          return (0, _set2['default'])(acc, f, getter(f));
        }, {});
      }
    }, {
      key: 'getNestedField',
      value: function getNestedField(name, getter) {
        var fullNames = this.getValidFieldsFullName(name);
        if (fullNames.length === 0 || // Not registered
        fullNames.length === 1 && fullNames[0] === name // Name already is full name.
        ) {
            return getter(name);
          }
        var isArrayValue = fullNames[0][name.length] === '[';
        var suffixNameStartIndex = isArrayValue ? name.length : name.length + 1;
        return fullNames.reduce(function (acc, fullName) {
          return (0, _set2['default'])(acc, fullName.slice(suffixNameStartIndex), getter(fullName));
        }, isArrayValue ? [] : {});
      }
    }, {
      key: 'isValidNestedFieldName',


      // @private
      // BG: `a` and `a.b` cannot be use in the same form
      value: function isValidNestedFieldName(name) {
        var names = this.getAllFieldsName();
        return names.every(function (n) {
          return !partOf(n, name) && !partOf(name, n);
        });
      }
    }, {
      key: 'clearField',
      value: function clearField(name) {
        delete this.fields[name];
        delete this.fieldsMeta[name];
      }
    }]);
    return FieldsStore;
  }();

  var _initialiseProps = function _initialiseProps() {
    var _this5 = this;

    this.setFieldsInitialValue = function (initialValues) {
      var flattenedInitialValues = _this5.flattenRegisteredFields(initialValues);
      var fieldsMeta = _this5.fieldsMeta;
      Object.keys(flattenedInitialValues).forEach(function (name) {
        if (fieldsMeta[name]) {
          _this5.setFieldMeta(name, (0, _extends3['default'])({}, _this5.getFieldMeta(name), {
            initialValue: flattenedInitialValues[name]
          }));
        }
      });
    };

    this.getAllValues = function () {
      var fieldsMeta = _this5.fieldsMeta,
          fields = _this5.fields;

      return Object.keys(fieldsMeta).reduce(function (acc, name) {
        return (0, _set2['default'])(acc, name, _this5.getValueFromFields(name, fields));
      }, {});
    };

    this.getFieldsValue = function (names) {
      return _this5.getNestedFields(names, _this5.getFieldValue);
    };

    this.getFieldValue = function (name) {
      var fields = _this5.fields;

      return _this5.getNestedField(name, function (fullName) {
        return _this5.getValueFromFields(fullName, fields);
      });
    };

    this.getFieldsError = function (names) {
      return _this5.getNestedFields(names, _this5.getFieldError);
    };

    this.getFieldError = function (name) {
      return _this5.getNestedField(name, function (fullName) {
        return (0, utils.getErrorStrs)(_this5.getFieldMember(fullName, 'errors'));
      });
    };

    this.isFieldValidating = function (name) {
      return _this5.getFieldMember(name, 'validating');
    };

    this.isFieldsValidating = function (ns) {
      var names = ns || _this5.getValidFieldsName();
      return names.some(function (n) {
        return _this5.isFieldValidating(n);
      });
    };

    this.isFieldTouched = function (name) {
      return _this5.getFieldMember(name, 'touched');
    };

    this.isFieldsTouched = function (ns) {
      var names = ns || _this5.getValidFieldsName();
      return names.some(function (n) {
        return _this5.isFieldTouched(n);
      });
    };
  };

  function createFieldsStore(fields) {
    return new FieldsStore(fields);
  }
  module.exports = exports['default'];
  });

  unwrapExports(createFieldsStore_1);

  var _asyncValidator = getCjsExportFromNamespace(es$1);

  var createBaseForm_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _objectWithoutProperties3 = _interopRequireDefault(objectWithoutProperties);



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _extends3 = _interopRequireDefault(_extends$1);



  var _toConsumableArray3 = _interopRequireDefault(toConsumableArray);



  var _react2 = _interopRequireDefault(React$1__default);



  var _createReactClass2 = _interopRequireDefault(createReactClass);



  var _asyncValidator2 = _interopRequireDefault(_asyncValidator);



  var _warning2 = _interopRequireDefault(warning_1$1);



  var _get2 = _interopRequireDefault(get_1);



  var _set2 = _interopRequireDefault(set_1);



  var _createFieldsStore2 = _interopRequireDefault(createFieldsStore_1);



  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  /* eslint-disable react/prefer-es6-class */
  /* eslint-disable prefer-promise-reject-errors */

  var DEFAULT_TRIGGER = 'onChange';

  function createBaseForm() {
    var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var mixins = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var validateMessages = option.validateMessages,
        onFieldsChange = option.onFieldsChange,
        onValuesChange = option.onValuesChange,
        _option$mapProps = option.mapProps,
        mapProps = _option$mapProps === undefined ? utils.identity : _option$mapProps,
        mapPropsToFields = option.mapPropsToFields,
        fieldNameProp = option.fieldNameProp,
        fieldMetaProp = option.fieldMetaProp,
        fieldDataProp = option.fieldDataProp,
        _option$formPropName = option.formPropName,
        formPropName = _option$formPropName === undefined ? 'form' : _option$formPropName,
        formName = option.name,
        withRef = option.withRef;


    return function decorate(WrappedComponent) {
      var Form = (0, _createReactClass2['default'])({
        displayName: 'Form',

        mixins: mixins,

        getInitialState: function getInitialState() {
          var _this = this;

          var fields = mapPropsToFields && mapPropsToFields(this.props);
          this.fieldsStore = (0, _createFieldsStore2['default'])(fields || {});

          this.instances = {};
          this.cachedBind = {};
          this.clearedFieldMetaCache = {};

          this.renderFields = {};
          this.domFields = {};

          // HACK: https://github.com/ant-design/ant-design/issues/6406
          ['getFieldsValue', 'getFieldValue', 'setFieldsInitialValue', 'getFieldsError', 'getFieldError', 'isFieldValidating', 'isFieldsValidating', 'isFieldsTouched', 'isFieldTouched'].forEach(function (key) {
            _this[key] = function () {
              var _fieldsStore;
              return (_fieldsStore = _this.fieldsStore)[key].apply(_fieldsStore, arguments);
            };
          });

          return {
            submitting: false
          };
        },
        componentDidMount: function componentDidMount() {
          this.cleanUpUselessFields();
        },
        componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
          if (mapPropsToFields) {
            this.fieldsStore.updateFields(mapPropsToFields(nextProps));
          }
        },
        componentDidUpdate: function componentDidUpdate() {
          this.cleanUpUselessFields();
        },
        onCollectCommon: function onCollectCommon(name, action, args) {
          var fieldMeta = this.fieldsStore.getFieldMeta(name);
          if (fieldMeta[action]) {
            fieldMeta[action].apply(fieldMeta, (0, _toConsumableArray3['default'])(args));
          } else if (fieldMeta.originalProps && fieldMeta.originalProps[action]) {
            var _fieldMeta$originalPr;

            (_fieldMeta$originalPr = fieldMeta.originalProps)[action].apply(_fieldMeta$originalPr, (0, _toConsumableArray3['default'])(args));
          }
          var value = fieldMeta.getValueFromEvent ? fieldMeta.getValueFromEvent.apply(fieldMeta, (0, _toConsumableArray3['default'])(args)) : utils.getValueFromEvent.apply(undefined, (0, _toConsumableArray3['default'])(args));
          if (onValuesChange && value !== this.fieldsStore.getFieldValue(name)) {
            var valuesAll = this.fieldsStore.getAllValues();
            var valuesAllSet = {};
            valuesAll[name] = value;
            Object.keys(valuesAll).forEach(function (key) {
              return (0, _set2['default'])(valuesAllSet, key, valuesAll[key]);
            });
            onValuesChange(this.props, (0, _set2['default'])({}, name, value), valuesAllSet);
          }
          var field = this.fieldsStore.getField(name);
          return { name: name, field: (0, _extends3['default'])({}, field, { value: value, touched: true }), fieldMeta: fieldMeta };
        },
        onCollect: function onCollect(name_, action) {
          for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }

          var _onCollectCommon = this.onCollectCommon(name_, action, args),
              name = _onCollectCommon.name,
              field = _onCollectCommon.field,
              fieldMeta = _onCollectCommon.fieldMeta;

          var validate = fieldMeta.validate;

          var newField = (0, _extends3['default'])({}, field, {
            dirty: (0, utils.hasRules)(validate)
          });
          this.setFields((0, _defineProperty3['default'])({}, name, newField));
        },
        onCollectValidate: function onCollectValidate(name_, action) {
          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }

          var _onCollectCommon2 = this.onCollectCommon(name_, action, args),
              field = _onCollectCommon2.field,
              fieldMeta = _onCollectCommon2.fieldMeta;

          var newField = (0, _extends3['default'])({}, field, {
            dirty: true
          });
          this.validateFieldsInternal([newField], {
            action: action,
            options: {
              firstFields: !!fieldMeta.validateFirst
            }
          });
        },
        getCacheBind: function getCacheBind(name, action, fn) {
          if (!this.cachedBind[name]) {
            this.cachedBind[name] = {};
          }
          var cache = this.cachedBind[name];
          if (!cache[action] || cache[action].oriFn !== fn) {
            cache[action] = {
              fn: fn.bind(this, name, action),
              oriFn: fn
            };
          }
          return cache[action].fn;
        },
        getFieldDecorator: function getFieldDecorator(name, fieldOption) {
          var _this2 = this;

          var props = this.getFieldProps(name, fieldOption);
          return function (fieldElem) {
            // We should put field in record if it is rendered
            _this2.renderFields[name] = true;

            var fieldMeta = _this2.fieldsStore.getFieldMeta(name);
            var originalProps = fieldElem.props;
            fieldMeta.originalProps = originalProps;
            fieldMeta.ref = fieldElem.ref;
            return _react2['default'].cloneElement(fieldElem, (0, _extends3['default'])({}, props, _this2.fieldsStore.getFieldValuePropValue(fieldMeta)));
          };
        },
        getFieldProps: function getFieldProps(name) {
          var _this3 = this;

          var usersFieldOption = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          if (!name) {
            throw new Error('Must call `getFieldProps` with valid name string!');
          }

          delete this.clearedFieldMetaCache[name];

          var fieldOption = (0, _extends3['default'])({
            name: name,
            trigger: DEFAULT_TRIGGER,
            valuePropName: 'value',
            validate: []
          }, usersFieldOption);

          var rules = fieldOption.rules,
              trigger = fieldOption.trigger,
              _fieldOption$validate = fieldOption.validateTrigger,
              validateTrigger = _fieldOption$validate === undefined ? trigger : _fieldOption$validate,
              validate = fieldOption.validate;


          var fieldMeta = this.fieldsStore.getFieldMeta(name);
          if ('initialValue' in fieldOption) {
            fieldMeta.initialValue = fieldOption.initialValue;
          }

          var inputProps = (0, _extends3['default'])({}, this.fieldsStore.getFieldValuePropValue(fieldOption), {
            ref: this.getCacheBind(name, name + '__ref', this.saveRef)
          });
          if (fieldNameProp) {
            inputProps[fieldNameProp] = formName ? formName + '_' + name : name;
          }

          var validateRules = (0, utils.normalizeValidateRules)(validate, rules, validateTrigger);
          var validateTriggers = (0, utils.getValidateTriggers)(validateRules);
          validateTriggers.forEach(function (action) {
            if (inputProps[action]) return;
            inputProps[action] = _this3.getCacheBind(name, action, _this3.onCollectValidate);
          });

          // make sure that the value will be collect
          if (trigger && validateTriggers.indexOf(trigger) === -1) {
            inputProps[trigger] = this.getCacheBind(name, trigger, this.onCollect);
          }

          var meta = (0, _extends3['default'])({}, fieldMeta, fieldOption, {
            validate: validateRules
          });
          this.fieldsStore.setFieldMeta(name, meta);
          if (fieldMetaProp) {
            inputProps[fieldMetaProp] = meta;
          }

          if (fieldDataProp) {
            inputProps[fieldDataProp] = this.fieldsStore.getField(name);
          }

          // This field is rendered, record it
          this.renderFields[name] = true;

          return inputProps;
        },
        getFieldInstance: function getFieldInstance(name) {
          return this.instances[name];
        },
        getRules: function getRules(fieldMeta, action) {
          var actionRules = fieldMeta.validate.filter(function (item) {
            return !action || item.trigger.indexOf(action) >= 0;
          }).map(function (item) {
            return item.rules;
          });
          return (0, utils.flattenArray)(actionRules);
        },
        setFields: function setFields(maybeNestedFields, callback) {
          var _this4 = this;

          var fields = this.fieldsStore.flattenRegisteredFields(maybeNestedFields);
          this.fieldsStore.setFields(fields);
          if (onFieldsChange) {
            var changedFields = Object.keys(fields).reduce(function (acc, name) {
              return (0, _set2['default'])(acc, name, _this4.fieldsStore.getField(name));
            }, {});
            onFieldsChange(this.props, changedFields, this.fieldsStore.getNestedAllFields());
          }
          this.forceUpdate(callback);
        },
        setFieldsValue: function setFieldsValue(changedValues, callback) {
          var fieldsMeta = this.fieldsStore.fieldsMeta;

          var values = this.fieldsStore.flattenRegisteredFields(changedValues);
          var newFields = Object.keys(values).reduce(function (acc, name) {
            var isRegistered = fieldsMeta[name];
            if (isRegistered) {
              var value = values[name];
              acc[name] = {
                value: value
              };
            }
            return acc;
          }, {});
          this.setFields(newFields, callback);
          if (onValuesChange) {
            var allValues = this.fieldsStore.getAllValues();
            onValuesChange(this.props, changedValues, allValues);
          }
        },
        saveRef: function saveRef(name, _, component) {
          if (!component) {
            // after destroy, delete data
            this.clearedFieldMetaCache[name] = {
              field: this.fieldsStore.getField(name),
              meta: this.fieldsStore.getFieldMeta(name)
            };
            this.clearField(name);
            delete this.domFields[name];
            return;
          }
          this.domFields[name] = true;
          this.recoverClearedField(name);
          var fieldMeta = this.fieldsStore.getFieldMeta(name);
          if (fieldMeta) {
            var ref = fieldMeta.ref;
            if (ref) {
              if (typeof ref === 'string') {
                throw new Error('can not set ref string for ' + name);
              } else if (typeof ref === 'function') {
                ref(component);
              } else if (Object.prototype.hasOwnProperty.call(ref, 'current')) {
                ref.current = component;
              }
            }
          }
          this.instances[name] = component;
        },
        cleanUpUselessFields: function cleanUpUselessFields() {
          var _this5 = this;

          var fieldList = this.fieldsStore.getAllFieldsName();
          var removedList = fieldList.filter(function (field) {
            return !_this5.renderFields[field] && !_this5.domFields[field];
          });
          if (removedList.length) {
            removedList.forEach(this.clearField);
          }
          this.renderFields = {};
        },
        clearField: function clearField(name) {
          this.fieldsStore.clearField(name);
          delete this.instances[name];
          delete this.cachedBind[name];
        },
        resetFields: function resetFields(ns) {
          var _this6 = this;

          var newFields = this.fieldsStore.resetFields(ns);
          if (Object.keys(newFields).length > 0) {
            this.setFields(newFields);
          }
          if (ns) {
            var names = Array.isArray(ns) ? ns : [ns];
            names.forEach(function (name) {
              return delete _this6.clearedFieldMetaCache[name];
            });
          } else {
            this.clearedFieldMetaCache = {};
          }
        },
        recoverClearedField: function recoverClearedField(name) {
          if (this.clearedFieldMetaCache[name]) {
            this.fieldsStore.setFields((0, _defineProperty3['default'])({}, name, this.clearedFieldMetaCache[name].field));
            this.fieldsStore.setFieldMeta(name, this.clearedFieldMetaCache[name].meta);
            delete this.clearedFieldMetaCache[name];
          }
        },
        validateFieldsInternal: function validateFieldsInternal(fields, _ref, callback) {
          var _this7 = this;

          var fieldNames = _ref.fieldNames,
              action = _ref.action,
              _ref$options = _ref.options,
              options = _ref$options === undefined ? {} : _ref$options;

          var allRules = {};
          var allValues = {};
          var allFields = {};
          var alreadyErrors = {};
          fields.forEach(function (field) {
            var name = field.name;
            if (options.force !== true && field.dirty === false) {
              if (field.errors) {
                (0, _set2['default'])(alreadyErrors, name, { errors: field.errors });
              }
              return;
            }
            var fieldMeta = _this7.fieldsStore.getFieldMeta(name);
            var newField = (0, _extends3['default'])({}, field);
            newField.errors = undefined;
            newField.validating = true;
            newField.dirty = true;
            allRules[name] = _this7.getRules(fieldMeta, action);
            allValues[name] = newField.value;
            allFields[name] = newField;
          });
          this.setFields(allFields);
          // in case normalize
          Object.keys(allValues).forEach(function (f) {
            allValues[f] = _this7.fieldsStore.getFieldValue(f);
          });
          if (callback && (0, utils.isEmptyObject)(allFields)) {
            callback((0, utils.isEmptyObject)(alreadyErrors) ? null : alreadyErrors, this.fieldsStore.getFieldsValue(fieldNames));
            return;
          }
          var validator = new _asyncValidator2['default'](allRules);
          if (validateMessages) {
            validator.messages(validateMessages);
          }
          validator.validate(allValues, options, function (errors) {
            var errorsGroup = (0, _extends3['default'])({}, alreadyErrors);
            if (errors && errors.length) {
              errors.forEach(function (e) {
                var fieldName = e.field;
                var field = (0, _get2['default'])(errorsGroup, fieldName);
                if (typeof field !== 'object' || Array.isArray(field)) {
                  (0, _set2['default'])(errorsGroup, fieldName, { errors: [] });
                }
                var fieldErrors = (0, _get2['default'])(errorsGroup, fieldName.concat('.errors'));
                fieldErrors.push(e);
              });
            }
            var expired = [];
            var nowAllFields = {};
            Object.keys(allRules).forEach(function (name) {
              var fieldErrors = (0, _get2['default'])(errorsGroup, name);
              var nowField = _this7.fieldsStore.getField(name);
              // avoid concurrency problems
              if (nowField.value !== allValues[name]) {
                expired.push({
                  name: name
                });
              } else {
                nowField.errors = fieldErrors && fieldErrors.errors;
                nowField.value = allValues[name];
                nowField.validating = false;
                nowField.dirty = false;
                nowAllFields[name] = nowField;
              }
            });
            _this7.setFields(nowAllFields);
            if (callback) {
              if (expired.length) {
                expired.forEach(function (_ref2) {
                  var name = _ref2.name;

                  var fieldErrors = [{
                    message: name + ' need to revalidate',
                    field: name
                  }];
                  (0, _set2['default'])(errorsGroup, name, {
                    expired: true,
                    errors: fieldErrors
                  });
                });
              }

              callback((0, utils.isEmptyObject)(errorsGroup) ? null : errorsGroup, _this7.fieldsStore.getFieldsValue(fieldNames));
            }
          });
        },
        validateFields: function validateFields(ns, opt, cb) {
          var _this8 = this;

          var pending = new Promise(function (resolve, reject) {
            var _getParams = (0, utils.getParams)(ns, opt, cb),
                names = _getParams.names,
                options = _getParams.options;

            var _getParams2 = (0, utils.getParams)(ns, opt, cb),
                callback = _getParams2.callback;

            if (!callback || typeof callback === 'function') {
              var oldCb = callback;
              callback = function callback(errors, values) {
                if (oldCb) {
                  oldCb(errors, values);
                } else if (errors) {
                  reject({ errors: errors, values: values });
                } else {
                  resolve(values);
                }
              };
            }
            var fieldNames = names ? _this8.fieldsStore.getValidFieldsFullName(names) : _this8.fieldsStore.getValidFieldsName();
            var fields = fieldNames.filter(function (name) {
              var fieldMeta = _this8.fieldsStore.getFieldMeta(name);
              return (0, utils.hasRules)(fieldMeta.validate);
            }).map(function (name) {
              var field = _this8.fieldsStore.getField(name);
              field.value = _this8.fieldsStore.getFieldValue(name);
              return field;
            });
            if (!fields.length) {
              if (callback) {
                callback(null, _this8.fieldsStore.getFieldsValue(fieldNames));
              }
              return;
            }
            if (!('firstFields' in options)) {
              options.firstFields = fieldNames.filter(function (name) {
                var fieldMeta = _this8.fieldsStore.getFieldMeta(name);
                return !!fieldMeta.validateFirst;
              });
            }
            _this8.validateFieldsInternal(fields, {
              fieldNames: fieldNames,
              options: options
            }, callback);
          });
          pending['catch'](function (e) {
            return e;
          });
          return pending;
        },
        isSubmitting: function isSubmitting() {
          return this.state.submitting;
        },
        submit: function submit(callback) {
          var _this9 = this;
          var fn = function fn() {
            _this9.setState({
              submitting: false
            });
          };
          this.setState({
            submitting: true
          });
          callback(fn);
        },
        render: function render() {
          var _props = this.props,
              wrappedComponentRef = _props.wrappedComponentRef,
              restProps = (0, _objectWithoutProperties3['default'])(_props, ['wrappedComponentRef']);

          var formProps = (0, _defineProperty3['default'])({}, formPropName, this.getForm());
          if (withRef) {
            formProps.ref = 'wrappedComponent';
          } else if (wrappedComponentRef) {
            formProps.ref = wrappedComponentRef;
          }
          var props = mapProps.call(this, (0, _extends3['default'])({}, formProps, restProps));
          return _react2['default'].createElement(WrappedComponent, props);
        }
      });

      return (0, utils.argumentContainer)(Form, WrappedComponent);
    };
  }

  exports['default'] = createBaseForm;
  module.exports = exports['default'];
  });

  unwrapExports(createBaseForm_1);

  var createForm_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.mixin = undefined;



  var _createBaseForm2 = _interopRequireDefault(createBaseForm_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var mixin = exports.mixin = {
    getForm: function getForm() {
      return {
        getFieldsValue: this.fieldsStore.getFieldsValue,
        getFieldValue: this.fieldsStore.getFieldValue,
        getFieldInstance: this.getFieldInstance,
        setFieldsValue: this.setFieldsValue,
        setFields: this.setFields,
        setFieldsInitialValue: this.fieldsStore.setFieldsInitialValue,
        getFieldDecorator: this.getFieldDecorator,
        getFieldProps: this.getFieldProps,
        getFieldsError: this.fieldsStore.getFieldsError,
        getFieldError: this.fieldsStore.getFieldError,
        isFieldValidating: this.fieldsStore.isFieldValidating,
        isFieldsValidating: this.fieldsStore.isFieldsValidating,
        isFieldsTouched: this.fieldsStore.isFieldsTouched,
        isFieldTouched: this.fieldsStore.isFieldTouched,
        isSubmitting: this.isSubmitting,
        submit: this.submit,
        validateFields: this.validateFields,
        resetFields: this.resetFields
      };
    }
  };

  function createForm(options) {
    return (0, _createBaseForm2['default'])(options, [mixin]);
  }

  exports['default'] = createForm;
  });

  unwrapExports(createForm_1);
  var createForm_2 = createForm_1.mixin;

  var createDOMForm_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _reactDom2 = _interopRequireDefault(ReactDOM__default);



  var _domScrollIntoView2 = _interopRequireDefault(lib);



  var _has2 = _interopRequireDefault(has_1);



  var _createBaseForm2 = _interopRequireDefault(createBaseForm_1);





  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function computedStyle(el, prop) {
    var getComputedStyle = window.getComputedStyle;
    var style =
    // If we have getComputedStyle
    getComputedStyle ?
    // Query it
    // TODO: From CSS-Query notes, we might need (node, null) for FF
    getComputedStyle(el) :

    // Otherwise, we are in IE and use currentStyle
    el.currentStyle;
    if (style) {
      return style[
      // Switch to camelCase for CSSOM
      // DEV: Grabbed from jQuery
      // https://github.com/jquery/jquery/blob/1.9-stable/src/css.js#L191-L194
      // https://github.com/jquery/jquery/blob/1.9-stable/src/core.js#L593-L597
      prop.replace(/-(\w)/gi, function (word, letter) {
        return letter.toUpperCase();
      })];
    }
    return undefined;
  }

  function getScrollableContainer(n) {
    var node = n;
    var nodeName = void 0;
    /* eslint no-cond-assign:0 */
    while ((nodeName = node.nodeName.toLowerCase()) !== 'body') {
      var overflowY = computedStyle(node, 'overflowY');
      // https://stackoverflow.com/a/36900407/3040605
      if (node !== n && (overflowY === 'auto' || overflowY === 'scroll') && node.scrollHeight > node.clientHeight) {
        return node;
      }
      node = node.parentNode;
    }
    return nodeName === 'body' ? node.ownerDocument : node;
  }

  var mixin = {
    getForm: function getForm() {
      return (0, _extends3['default'])({}, createForm_1.mixin.getForm.call(this), {
        validateFieldsAndScroll: this.validateFieldsAndScroll
      });
    },
    validateFieldsAndScroll: function validateFieldsAndScroll(ns, opt, cb) {
      var _this = this;

      var _getParams = (0, utils.getParams)(ns, opt, cb),
          names = _getParams.names,
          callback = _getParams.callback,
          options = _getParams.options;

      var newCb = function newCb(error, values) {
        if (error) {
          var validNames = _this.fieldsStore.getValidFieldsName();
          var firstNode = void 0;
          var firstTop = void 0;

          validNames.forEach(function (name) {
            if ((0, _has2['default'])(error, name)) {
              var instance = _this.getFieldInstance(name);
              if (instance) {
                var node = _reactDom2['default'].findDOMNode(instance);
                var top = node.getBoundingClientRect().top;
                if (node.type !== 'hidden' && (firstTop === undefined || firstTop > top)) {
                  firstTop = top;
                  firstNode = node;
                }
              }
            }
          });

          if (firstNode) {
            var c = options.container || getScrollableContainer(firstNode);
            (0, _domScrollIntoView2['default'])(firstNode, c, (0, _extends3['default'])({
              onlyScrollIfNeeded: true
            }, options.scroll));
          }
        }

        if (typeof callback === 'function') {
          callback(error, values);
        }
      };

      return this.validateFields(names, options, newCb);
    }
  };

  function createDOMForm(option) {
    return (0, _createBaseForm2['default'])((0, _extends3['default'])({}, option), [mixin]);
  }

  exports['default'] = createDOMForm;
  module.exports = exports['default'];
  });

  unwrapExports(createDOMForm_1);

  var warning$4 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _warning2 = _interopRequireDefault(warning_1$1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var warned = {};

  exports['default'] = function (valid, message) {
      if (!valid && !warned[message]) {
          (0, _warning2['default'])(false, message);
          warned[message] = true;
      }
  };

  module.exports = exports['default'];
  });

  unwrapExports(warning$4);

  function toArrayChildren(children) {
    var ret = [];
    React$1__default.Children.forEach(children, function (child) {
      ret.push(child);
    });
    return ret;
  }

  function findChildInChildrenByKey(children, key) {
    var ret = null;
    if (children) {
      children.forEach(function (child) {
        if (ret) {
          return;
        }
        if (child && child.key === key) {
          ret = child;
        }
      });
    }
    return ret;
  }

  function findShownChildInChildrenByKey(children, key, showProp) {
    var ret = null;
    if (children) {
      children.forEach(function (child) {
        if (child && child.key === key && child.props[showProp]) {
          if (ret) {
            throw new Error('two child with same key for <rc-animate> children');
          }
          ret = child;
        }
      });
    }
    return ret;
  }

  function isSameChildren(c1, c2, showProp) {
    var same = c1.length === c2.length;
    if (same) {
      c1.forEach(function (child, index) {
        var child2 = c2[index];
        if (child && child2) {
          if (child && !child2 || !child && child2) {
            same = false;
          } else if (child.key !== child2.key) {
            same = false;
          } else if (showProp && child.props[showProp] !== child2.props[showProp]) {
            same = false;
          }
        }
      });
    }
    return same;
  }

  function mergeChildren(prev, next) {
    var ret = [];

    // For each key of `next`, the list of keys to insert before that key in
    // the combined list
    var nextChildrenPending = {};
    var pendingChildren = [];
    prev.forEach(function (child) {
      if (child && findChildInChildrenByKey(next, child.key)) {
        if (pendingChildren.length) {
          nextChildrenPending[child.key] = pendingChildren;
          pendingChildren = [];
        }
      } else {
        pendingChildren.push(child);
      }
    });

    next.forEach(function (child) {
      if (child && Object.prototype.hasOwnProperty.call(nextChildrenPending, child.key)) {
        ret = ret.concat(nextChildrenPending[child.key]);
      }
      ret.push(child);
    });

    ret = ret.concat(pendingChildren);

    return ret;
  }

  var START_EVENT_NAME_MAP = {
    transitionstart: {
      transition: 'transitionstart',
      WebkitTransition: 'webkitTransitionStart',
      MozTransition: 'mozTransitionStart',
      OTransition: 'oTransitionStart',
      msTransition: 'MSTransitionStart'
    },

    animationstart: {
      animation: 'animationstart',
      WebkitAnimation: 'webkitAnimationStart',
      MozAnimation: 'mozAnimationStart',
      OAnimation: 'oAnimationStart',
      msAnimation: 'MSAnimationStart'
    }
  };

  var END_EVENT_NAME_MAP = {
    transitionend: {
      transition: 'transitionend',
      WebkitTransition: 'webkitTransitionEnd',
      MozTransition: 'mozTransitionEnd',
      OTransition: 'oTransitionEnd',
      msTransition: 'MSTransitionEnd'
    },

    animationend: {
      animation: 'animationend',
      WebkitAnimation: 'webkitAnimationEnd',
      MozAnimation: 'mozAnimationEnd',
      OAnimation: 'oAnimationEnd',
      msAnimation: 'MSAnimationEnd'
    }
  };

  var startEvents = [];
  var endEvents = [];

  function detectEvents() {
    var testEl = document.createElement('div');
    var style = testEl.style;

    if (!('AnimationEvent' in window)) {
      delete START_EVENT_NAME_MAP.animationstart.animation;
      delete END_EVENT_NAME_MAP.animationend.animation;
    }

    if (!('TransitionEvent' in window)) {
      delete START_EVENT_NAME_MAP.transitionstart.transition;
      delete END_EVENT_NAME_MAP.transitionend.transition;
    }

    function process(EVENT_NAME_MAP, events) {
      for (var baseEventName in EVENT_NAME_MAP) {
        if (EVENT_NAME_MAP.hasOwnProperty(baseEventName)) {
          var baseEvents = EVENT_NAME_MAP[baseEventName];
          for (var styleName in baseEvents) {
            if (styleName in style) {
              events.push(baseEvents[styleName]);
              break;
            }
          }
        }
      }
    }

    process(START_EVENT_NAME_MAP, startEvents);
    process(END_EVENT_NAME_MAP, endEvents);
  }

  if (typeof window !== 'undefined' && typeof document !== 'undefined') {
    detectEvents();
  }

  function addEventListener(node, eventName, eventListener) {
    node.addEventListener(eventName, eventListener, false);
  }

  function removeEventListener(node, eventName, eventListener) {
    node.removeEventListener(eventName, eventListener, false);
  }

  var TransitionEvents = {
    // Start events
    startEvents: startEvents,

    addStartEventListener: function addStartEventListener(node, eventListener) {
      if (startEvents.length === 0) {
        window.setTimeout(eventListener, 0);
        return;
      }
      startEvents.forEach(function (startEvent) {
        addEventListener(node, startEvent, eventListener);
      });
    },
    removeStartEventListener: function removeStartEventListener(node, eventListener) {
      if (startEvents.length === 0) {
        return;
      }
      startEvents.forEach(function (startEvent) {
        removeEventListener(node, startEvent, eventListener);
      });
    },


    // End events
    endEvents: endEvents,

    addEndEventListener: function addEndEventListener(node, eventListener) {
      if (endEvents.length === 0) {
        window.setTimeout(eventListener, 0);
        return;
      }
      endEvents.forEach(function (endEvent) {
        addEventListener(node, endEvent, eventListener);
      });
    },
    removeEndEventListener: function removeEndEventListener(node, eventListener) {
      if (endEvents.length === 0) {
        return;
      }
      endEvents.forEach(function (endEvent) {
        removeEventListener(node, endEvent, eventListener);
      });
    }
  };

  var indexOf = [].indexOf;

  var indexof = function(arr, obj){
    if (indexOf) return arr.indexOf(obj);
    for (var i = 0; i < arr.length; ++i) {
      if (arr[i] === obj) return i;
    }
    return -1;
  };

  var componentIndexof = function(arr, obj){
    if (arr.indexOf) return arr.indexOf(obj);
    for (var i = 0; i < arr.length; ++i) {
      if (arr[i] === obj) return i;
    }
    return -1;
  };

  /**
   * Module dependencies.
   */

  try {
    var index$1 = indexof;
  } catch (err) {
    var index$1 = componentIndexof;
  }

  /**
   * Whitespace regexp.
   */

  var re = /\s+/;

  /**
   * toString reference.
   */

  var toString$3 = Object.prototype.toString;

  /**
   * Wrap `el` in a `ClassList`.
   *
   * @param {Element} el
   * @return {ClassList}
   * @api public
   */

  var componentClasses = function(el){
    return new ClassList(el);
  };

  /**
   * Initialize a new ClassList for `el`.
   *
   * @param {Element} el
   * @api private
   */

  function ClassList(el) {
    if (!el || !el.nodeType) {
      throw new Error('A DOM element reference is required');
    }
    this.el = el;
    this.list = el.classList;
  }

  /**
   * Add class `name` if not already present.
   *
   * @param {String} name
   * @return {ClassList}
   * @api public
   */

  ClassList.prototype.add = function(name){
    // classList
    if (this.list) {
      this.list.add(name);
      return this;
    }

    // fallback
    var arr = this.array();
    var i = index$1(arr, name);
    if (!~i) arr.push(name);
    this.el.className = arr.join(' ');
    return this;
  };

  /**
   * Remove class `name` when present, or
   * pass a regular expression to remove
   * any which match.
   *
   * @param {String|RegExp} name
   * @return {ClassList}
   * @api public
   */

  ClassList.prototype.remove = function(name){
    if ('[object RegExp]' == toString$3.call(name)) {
      return this.removeMatching(name);
    }

    // classList
    if (this.list) {
      this.list.remove(name);
      return this;
    }

    // fallback
    var arr = this.array();
    var i = index$1(arr, name);
    if (~i) arr.splice(i, 1);
    this.el.className = arr.join(' ');
    return this;
  };

  /**
   * Remove all classes matching `re`.
   *
   * @param {RegExp} re
   * @return {ClassList}
   * @api private
   */

  ClassList.prototype.removeMatching = function(re){
    var arr = this.array();
    for (var i = 0; i < arr.length; i++) {
      if (re.test(arr[i])) {
        this.remove(arr[i]);
      }
    }
    return this;
  };

  /**
   * Toggle class `name`, can force state via `force`.
   *
   * For browsers that support classList, but do not support `force` yet,
   * the mistake will be detected and corrected.
   *
   * @param {String} name
   * @param {Boolean} force
   * @return {ClassList}
   * @api public
   */

  ClassList.prototype.toggle = function(name, force){
    // classList
    if (this.list) {
      if ("undefined" !== typeof force) {
        if (force !== this.list.toggle(name, force)) {
          this.list.toggle(name); // toggle again to correct
        }
      } else {
        this.list.toggle(name);
      }
      return this;
    }

    // fallback
    if ("undefined" !== typeof force) {
      if (!force) {
        this.remove(name);
      } else {
        this.add(name);
      }
    } else {
      if (this.has(name)) {
        this.remove(name);
      } else {
        this.add(name);
      }
    }

    return this;
  };

  /**
   * Return an array of classes.
   *
   * @return {Array}
   * @api public
   */

  ClassList.prototype.array = function(){
    var className = this.el.getAttribute('class') || '';
    var str = className.replace(/^\s+|\s+$/g, '');
    var arr = str.split(re);
    if ('' === arr[0]) arr.shift();
    return arr;
  };

  /**
   * Check if class `name` is present.
   *
   * @param {String} name
   * @return {ClassList}
   * @api public
   */

  ClassList.prototype.has =
  ClassList.prototype.contains = function(name){
    return this.list
      ? this.list.contains(name)
      : !! ~index$1(this.array(), name);
  };

  var isCssAnimationSupported = TransitionEvents.endEvents.length !== 0;
  var capitalPrefixes = ['Webkit', 'Moz', 'O',
  // ms is special .... !
  'ms'];
  var prefixes = ['-webkit-', '-moz-', '-o-', 'ms-', ''];

  function getStyleProperty(node, name) {
    // old ff need null, https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle
    var style = window.getComputedStyle(node, null);
    var ret = '';
    for (var i = 0; i < prefixes.length; i++) {
      ret = style.getPropertyValue(prefixes[i] + name);
      if (ret) {
        break;
      }
    }
    return ret;
  }

  function fixBrowserByTimeout(node) {
    if (isCssAnimationSupported) {
      var transitionDelay = parseFloat(getStyleProperty(node, 'transition-delay')) || 0;
      var transitionDuration = parseFloat(getStyleProperty(node, 'transition-duration')) || 0;
      var animationDelay = parseFloat(getStyleProperty(node, 'animation-delay')) || 0;
      var animationDuration = parseFloat(getStyleProperty(node, 'animation-duration')) || 0;
      var time = Math.max(transitionDuration + transitionDelay, animationDuration + animationDelay);
      // sometimes, browser bug
      node.rcEndAnimTimeout = setTimeout(function () {
        node.rcEndAnimTimeout = null;
        if (node.rcEndListener) {
          node.rcEndListener();
        }
      }, time * 1000 + 200);
    }
  }

  function clearBrowserBugTimeout(node) {
    if (node.rcEndAnimTimeout) {
      clearTimeout(node.rcEndAnimTimeout);
      node.rcEndAnimTimeout = null;
    }
  }

  var cssAnimation = function cssAnimation(node, transitionName, endCallback) {
    var nameIsObj = (typeof transitionName === 'undefined' ? 'undefined' : _typeof$1(transitionName)) === 'object';
    var className = nameIsObj ? transitionName.name : transitionName;
    var activeClassName = nameIsObj ? transitionName.active : transitionName + '-active';
    var end = endCallback;
    var start = void 0;
    var active = void 0;
    var nodeClasses = componentClasses(node);

    if (endCallback && Object.prototype.toString.call(endCallback) === '[object Object]') {
      end = endCallback.end;
      start = endCallback.start;
      active = endCallback.active;
    }

    if (node.rcEndListener) {
      node.rcEndListener();
    }

    node.rcEndListener = function (e) {
      if (e && e.target !== node) {
        return;
      }

      if (node.rcAnimTimeout) {
        clearTimeout(node.rcAnimTimeout);
        node.rcAnimTimeout = null;
      }

      clearBrowserBugTimeout(node);

      nodeClasses.remove(className);
      nodeClasses.remove(activeClassName);

      TransitionEvents.removeEndEventListener(node, node.rcEndListener);
      node.rcEndListener = null;

      // Usually this optional end is used for informing an owner of
      // a leave animation and telling it to remove the child.
      if (end) {
        end();
      }
    };

    TransitionEvents.addEndEventListener(node, node.rcEndListener);

    if (start) {
      start();
    }
    nodeClasses.add(className);

    node.rcAnimTimeout = setTimeout(function () {
      node.rcAnimTimeout = null;
      nodeClasses.add(activeClassName);
      if (active) {
        setTimeout(active, 0);
      }
      fixBrowserByTimeout(node);
      // 30ms for firefox
    }, 30);

    return {
      stop: function stop() {
        if (node.rcEndListener) {
          node.rcEndListener();
        }
      }
    };
  };

  cssAnimation.style = function (node, style, callback) {
    if (node.rcEndListener) {
      node.rcEndListener();
    }

    node.rcEndListener = function (e) {
      if (e && e.target !== node) {
        return;
      }

      if (node.rcAnimTimeout) {
        clearTimeout(node.rcAnimTimeout);
        node.rcAnimTimeout = null;
      }

      clearBrowserBugTimeout(node);

      TransitionEvents.removeEndEventListener(node, node.rcEndListener);
      node.rcEndListener = null;

      // Usually this optional callback is used for informing an owner of
      // a leave animation and telling it to remove the child.
      if (callback) {
        callback();
      }
    };

    TransitionEvents.addEndEventListener(node, node.rcEndListener);

    node.rcAnimTimeout = setTimeout(function () {
      for (var s in style) {
        if (style.hasOwnProperty(s)) {
          node.style[s] = style[s];
        }
      }
      node.rcAnimTimeout = null;
      fixBrowserByTimeout(node);
    }, 0);
  };

  cssAnimation.setTransition = function (node, p, value) {
    var property = p;
    var v = value;
    if (value === undefined) {
      v = property;
      property = '';
    }
    property = property || '';
    capitalPrefixes.forEach(function (prefix) {
      node.style[prefix + 'Transition' + property] = v;
    });
  };

  cssAnimation.isCssAnimationSupported = isCssAnimationSupported;

  var es$2 = /*#__PURE__*/Object.freeze({
    isCssAnimationSupported: isCssAnimationSupported,
    default: cssAnimation
  });

  var util$1 = {
    isAppearSupported: function isAppearSupported(props) {
      return props.transitionName && props.transitionAppear || props.animation.appear;
    },
    isEnterSupported: function isEnterSupported(props) {
      return props.transitionName && props.transitionEnter || props.animation.enter;
    },
    isLeaveSupported: function isLeaveSupported(props) {
      return props.transitionName && props.transitionLeave || props.animation.leave;
    },
    allowAppearCallback: function allowAppearCallback(props) {
      return props.transitionAppear || props.animation.appear;
    },
    allowEnterCallback: function allowEnterCallback(props) {
      return props.transitionEnter || props.animation.enter;
    },
    allowLeaveCallback: function allowLeaveCallback(props) {
      return props.transitionLeave || props.animation.leave;
    }
  };

  var transitionMap = {
    enter: 'transitionEnter',
    appear: 'transitionAppear',
    leave: 'transitionLeave'
  };

  var AnimateChild = function (_React$Component) {
    _inherits$1(AnimateChild, _React$Component);

    function AnimateChild() {
      _classCallCheck$1(this, AnimateChild);

      return _possibleConstructorReturn$1(this, (AnimateChild.__proto__ || Object.getPrototypeOf(AnimateChild)).apply(this, arguments));
    }

    _createClass$1(AnimateChild, [{
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        this.stop();
      }
    }, {
      key: 'componentWillEnter',
      value: function componentWillEnter(done) {
        if (util$1.isEnterSupported(this.props)) {
          this.transition('enter', done);
        } else {
          done();
        }
      }
    }, {
      key: 'componentWillAppear',
      value: function componentWillAppear(done) {
        if (util$1.isAppearSupported(this.props)) {
          this.transition('appear', done);
        } else {
          done();
        }
      }
    }, {
      key: 'componentWillLeave',
      value: function componentWillLeave(done) {
        if (util$1.isLeaveSupported(this.props)) {
          this.transition('leave', done);
        } else {
          // always sync, do not interupt with react component life cycle
          // update hidden -> animate hidden ->
          // didUpdate -> animate leave -> unmount (if animate is none)
          done();
        }
      }
    }, {
      key: 'transition',
      value: function transition(animationType, finishCallback) {
        var _this2 = this;

        var node = ReactDOM__default.findDOMNode(this);
        var props = this.props;
        var transitionName = props.transitionName;
        var nameIsObj = typeof transitionName === 'object';
        this.stop();
        var end = function end() {
          _this2.stopper = null;
          finishCallback();
        };
        if ((isCssAnimationSupported || !props.animation[animationType]) && transitionName && props[transitionMap[animationType]]) {
          var name = nameIsObj ? transitionName[animationType] : transitionName + '-' + animationType;
          var activeName = name + '-active';
          if (nameIsObj && transitionName[animationType + 'Active']) {
            activeName = transitionName[animationType + 'Active'];
          }
          this.stopper = cssAnimation(node, {
            name: name,
            active: activeName
          }, end);
        } else {
          this.stopper = props.animation[animationType](node, end);
        }
      }
    }, {
      key: 'stop',
      value: function stop() {
        var stopper = this.stopper;
        if (stopper) {
          this.stopper = null;
          stopper.stop();
        }
      }
    }, {
      key: 'render',
      value: function render() {
        return this.props.children;
      }
    }]);

    return AnimateChild;
  }(React$1__default.Component);

  AnimateChild.propTypes = {
    children: PropTypes.any
  };

  var defaultKey = 'rc_animate_' + Date.now();

  function getChildrenFromProps(props) {
    var children = props.children;
    if (React$1__default.isValidElement(children)) {
      if (!children.key) {
        return React$1__default.cloneElement(children, {
          key: defaultKey
        });
      }
    }
    return children;
  }

  function noop() {}

  var Animate = function (_React$Component) {
    _inherits$1(Animate, _React$Component);

    // eslint-disable-line

    function Animate(props) {
      _classCallCheck$1(this, Animate);

      var _this = _possibleConstructorReturn$1(this, (Animate.__proto__ || Object.getPrototypeOf(Animate)).call(this, props));

      _initialiseProps.call(_this);

      _this.currentlyAnimatingKeys = {};
      _this.keysToEnter = [];
      _this.keysToLeave = [];

      _this.state = {
        children: toArrayChildren(getChildrenFromProps(props))
      };

      _this.childrenRefs = {};
      return _this;
    }

    _createClass$1(Animate, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        var _this2 = this;

        var showProp = this.props.showProp;
        var children = this.state.children;
        if (showProp) {
          children = children.filter(function (child) {
            return !!child.props[showProp];
          });
        }
        children.forEach(function (child) {
          if (child) {
            _this2.performAppear(child.key);
          }
        });
      }
    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        var _this3 = this;

        this.nextProps = nextProps;
        var nextChildren = toArrayChildren(getChildrenFromProps(nextProps));
        var props = this.props;
        // exclusive needs immediate response
        if (props.exclusive) {
          Object.keys(this.currentlyAnimatingKeys).forEach(function (key) {
            _this3.stop(key);
          });
        }
        var showProp = props.showProp;
        var currentlyAnimatingKeys = this.currentlyAnimatingKeys;
        // last props children if exclusive
        var currentChildren = props.exclusive ? toArrayChildren(getChildrenFromProps(props)) : this.state.children;
        // in case destroy in showProp mode
        var newChildren = [];
        if (showProp) {
          currentChildren.forEach(function (currentChild) {
            var nextChild = currentChild && findChildInChildrenByKey(nextChildren, currentChild.key);
            var newChild = void 0;
            if ((!nextChild || !nextChild.props[showProp]) && currentChild.props[showProp]) {
              newChild = React$1__default.cloneElement(nextChild || currentChild, _defineProperty$1({}, showProp, true));
            } else {
              newChild = nextChild;
            }
            if (newChild) {
              newChildren.push(newChild);
            }
          });
          nextChildren.forEach(function (nextChild) {
            if (!nextChild || !findChildInChildrenByKey(currentChildren, nextChild.key)) {
              newChildren.push(nextChild);
            }
          });
        } else {
          newChildren = mergeChildren(currentChildren, nextChildren);
        }

        // need render to avoid update
        this.setState({
          children: newChildren
        });

        nextChildren.forEach(function (child) {
          var key = child && child.key;
          if (child && currentlyAnimatingKeys[key]) {
            return;
          }
          var hasPrev = child && findChildInChildrenByKey(currentChildren, key);
          if (showProp) {
            var showInNext = child.props[showProp];
            if (hasPrev) {
              var showInNow = findShownChildInChildrenByKey(currentChildren, key, showProp);
              if (!showInNow && showInNext) {
                _this3.keysToEnter.push(key);
              }
            } else if (showInNext) {
              _this3.keysToEnter.push(key);
            }
          } else if (!hasPrev) {
            _this3.keysToEnter.push(key);
          }
        });

        currentChildren.forEach(function (child) {
          var key = child && child.key;
          if (child && currentlyAnimatingKeys[key]) {
            return;
          }
          var hasNext = child && findChildInChildrenByKey(nextChildren, key);
          if (showProp) {
            var showInNow = child.props[showProp];
            if (hasNext) {
              var showInNext = findShownChildInChildrenByKey(nextChildren, key, showProp);
              if (!showInNext && showInNow) {
                _this3.keysToLeave.push(key);
              }
            } else if (showInNow) {
              _this3.keysToLeave.push(key);
            }
          } else if (!hasNext) {
            _this3.keysToLeave.push(key);
          }
        });
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate() {
        var keysToEnter = this.keysToEnter;
        this.keysToEnter = [];
        keysToEnter.forEach(this.performEnter);
        var keysToLeave = this.keysToLeave;
        this.keysToLeave = [];
        keysToLeave.forEach(this.performLeave);
      }
    }, {
      key: 'isValidChildByKey',
      value: function isValidChildByKey(currentChildren, key) {
        var showProp = this.props.showProp;
        if (showProp) {
          return findShownChildInChildrenByKey(currentChildren, key, showProp);
        }
        return findChildInChildrenByKey(currentChildren, key);
      }
    }, {
      key: 'stop',
      value: function stop(key) {
        delete this.currentlyAnimatingKeys[key];
        var component = this.childrenRefs[key];
        if (component) {
          component.stop();
        }
      }
    }, {
      key: 'render',
      value: function render() {
        var _this4 = this;

        var props = this.props;
        this.nextProps = props;
        var stateChildren = this.state.children;
        var children = null;
        if (stateChildren) {
          children = stateChildren.map(function (child) {
            if (child === null || child === undefined) {
              return child;
            }
            if (!child.key) {
              throw new Error('must set key for <rc-animate> children');
            }
            return React$1__default.createElement(
              AnimateChild,
              {
                key: child.key,
                ref: function ref(node) {
                  _this4.childrenRefs[child.key] = node;
                },
                animation: props.animation,
                transitionName: props.transitionName,
                transitionEnter: props.transitionEnter,
                transitionAppear: props.transitionAppear,
                transitionLeave: props.transitionLeave
              },
              child
            );
          });
        }
        var Component = props.component;
        if (Component) {
          var passedProps = props;
          if (typeof Component === 'string') {
            passedProps = _extends$2({
              className: props.className,
              style: props.style
            }, props.componentProps);
          }
          return React$1__default.createElement(
            Component,
            passedProps,
            children
          );
        }
        return children[0] || null;
      }
    }]);

    return Animate;
  }(React$1__default.Component);

  Animate.isAnimate = true;
  Animate.propTypes = {
    component: PropTypes.any,
    componentProps: PropTypes.object,
    animation: PropTypes.object,
    transitionName: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
    transitionEnter: PropTypes.bool,
    transitionAppear: PropTypes.bool,
    exclusive: PropTypes.bool,
    transitionLeave: PropTypes.bool,
    onEnd: PropTypes.func,
    onEnter: PropTypes.func,
    onLeave: PropTypes.func,
    onAppear: PropTypes.func,
    showProp: PropTypes.string,
    children: PropTypes.node
  };
  Animate.defaultProps = {
    animation: {},
    component: 'span',
    componentProps: {},
    transitionEnter: true,
    transitionLeave: true,
    transitionAppear: false,
    onEnd: noop,
    onEnter: noop,
    onLeave: noop,
    onAppear: noop
  };

  var _initialiseProps = function _initialiseProps() {
    var _this5 = this;

    this.performEnter = function (key) {
      // may already remove by exclusive
      if (_this5.childrenRefs[key]) {
        _this5.currentlyAnimatingKeys[key] = true;
        _this5.childrenRefs[key].componentWillEnter(_this5.handleDoneAdding.bind(_this5, key, 'enter'));
      }
    };

    this.performAppear = function (key) {
      if (_this5.childrenRefs[key]) {
        _this5.currentlyAnimatingKeys[key] = true;
        _this5.childrenRefs[key].componentWillAppear(_this5.handleDoneAdding.bind(_this5, key, 'appear'));
      }
    };

    this.handleDoneAdding = function (key, type) {
      var props = _this5.props;
      delete _this5.currentlyAnimatingKeys[key];
      // if update on exclusive mode, skip check
      if (props.exclusive && props !== _this5.nextProps) {
        return;
      }
      var currentChildren = toArrayChildren(getChildrenFromProps(props));
      if (!_this5.isValidChildByKey(currentChildren, key)) {
        // exclusive will not need this
        _this5.performLeave(key);
      } else if (type === 'appear') {
        if (util$1.allowAppearCallback(props)) {
          props.onAppear(key);
          props.onEnd(key, true);
        }
      } else if (util$1.allowEnterCallback(props)) {
        props.onEnter(key);
        props.onEnd(key, true);
      }
    };

    this.performLeave = function (key) {
      // may already remove by exclusive
      if (_this5.childrenRefs[key]) {
        _this5.currentlyAnimatingKeys[key] = true;
        _this5.childrenRefs[key].componentWillLeave(_this5.handleDoneLeaving.bind(_this5, key));
      }
    };

    this.handleDoneLeaving = function (key) {
      var props = _this5.props;
      delete _this5.currentlyAnimatingKeys[key];
      // if update on exclusive mode, skip check
      if (props.exclusive && props !== _this5.nextProps) {
        return;
      }
      var currentChildren = toArrayChildren(getChildrenFromProps(props));
      // in case state change is too fast
      if (_this5.isValidChildByKey(currentChildren, key)) {
        _this5.performEnter(key);
      } else {
        var end = function end() {
          if (util$1.allowLeaveCallback(props)) {
            props.onLeave(key);
            props.onEnd(key, false);
          }
        };
        if (!isSameChildren(_this5.state.children, currentChildren, props.showProp)) {
          _this5.setState({
            children: currentChildren
          }, end);
        } else {
          end();
        }
      }
    };
  };

  var Animate$1 = /*#__PURE__*/Object.freeze({
    default: Animate
  });

  var constants = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var FIELD_META_PROP = exports.FIELD_META_PROP = 'data-__meta';
  var FIELD_DATA_PROP = exports.FIELD_DATA_PROP = 'data-__field';
  });

  unwrapExports(constants);
  var constants_1 = constants.FIELD_META_PROP;
  var constants_2 = constants.FIELD_DATA_PROP;

  var _rcAnimate = getCjsExportFromNamespace(Animate$1);

  var FormItem_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _extends3 = _interopRequireDefault(_extends$1);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var ReactDOM$$1 = _interopRequireWildcard(ReactDOM__default);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _classnames2 = _interopRequireDefault(classnames);



  var _rcAnimate2 = _interopRequireDefault(_rcAnimate);



  var _row2 = _interopRequireDefault(row);



  var _col2 = _interopRequireDefault(col);



  var _warning2 = _interopRequireDefault(warning$4);



  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var FormItem = function (_React$Component) {
      (0, _inherits3['default'])(FormItem, _React$Component);

      function FormItem() {
          (0, _classCallCheck3['default'])(this, FormItem);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (FormItem.__proto__ || Object.getPrototypeOf(FormItem)).apply(this, arguments));

          _this.state = { helpShow: false };
          _this.onHelpAnimEnd = function (_key, helpShow) {
              _this.setState({ helpShow: helpShow });
          };
          // Resolve duplicated ids bug between different forms
          // https://github.com/ant-design/ant-design/issues/7351
          _this.onLabelClick = function (e) {
              var label = _this.props.label;

              var id = _this.props.id || _this.getId();
              if (!id) {
                  return;
              }
              var controls = document.querySelectorAll('[id="' + id + '"]');
              if (controls.length !== 1) {
                  // Only prevent in default situation
                  // Avoid preventing event in `label={<a href="xx">link</a>}``
                  if (typeof label === 'string') {
                      e.preventDefault();
                  }
                  var formItemNode = ReactDOM$$1.findDOMNode(_this);
                  var control = formItemNode.querySelector('[id="' + id + '"]');
                  if (control && control.focus) {
                      control.focus();
                  }
              }
          };
          return _this;
      }

      (0, _createClass3['default'])(FormItem, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              (0, _warning2['default'])(this.getControls(this.props.children, true).length <= 1, '`Form.Item` cannot generate `validateStatus` and `help` automatically, ' + 'while there are more than one `getFieldDecorator` in it.');
          }
      }, {
          key: 'getHelpMsg',
          value: function getHelpMsg() {
              var props = this.props;
              var onlyControl = this.getOnlyControl();
              if (props.help === undefined && onlyControl) {
                  var errors = this.getField().errors;
                  return errors ? errors.map(function (e) {
                      return e.message;
                  }).join(', ') : '';
              }
              return props.help;
          }
      }, {
          key: 'getControls',
          value: function getControls(children, recursively) {
              var controls = [];
              var childrenArray = React.Children.toArray(children);
              for (var i = 0; i < childrenArray.length; i++) {
                  if (!recursively && controls.length > 0) {
                      break;
                  }
                  var child = childrenArray[i];
                  if (child.type && (child.type === FormItem || child.type.displayName === 'FormItem')) {
                      continue;
                  }
                  if (!child.props) {
                      continue;
                  }
                  if (constants.FIELD_META_PROP in child.props) {
                      // And means FIELD_DATA_PROP in chidl.props, too.
                      controls.push(child);
                  } else if (child.props.children) {
                      controls = controls.concat(this.getControls(child.props.children, recursively));
                  }
              }
              return controls;
          }
      }, {
          key: 'getOnlyControl',
          value: function getOnlyControl() {
              var child = this.getControls(this.props.children, false)[0];
              return child !== undefined ? child : null;
          }
      }, {
          key: 'getChildProp',
          value: function getChildProp(prop) {
              var child = this.getOnlyControl();
              return child && child.props && child.props[prop];
          }
      }, {
          key: 'getId',
          value: function getId() {
              return this.getChildProp('id');
          }
      }, {
          key: 'getMeta',
          value: function getMeta() {
              return this.getChildProp(constants.FIELD_META_PROP);
          }
      }, {
          key: 'getField',
          value: function getField() {
              return this.getChildProp(constants.FIELD_DATA_PROP);
          }
      }, {
          key: 'renderHelp',
          value: function renderHelp() {
              var prefixCls = this.props.prefixCls;
              var help = this.getHelpMsg();
              var children = help ? React.createElement(
                  'div',
                  { className: prefixCls + '-explain', key: 'help' },
                  help
              ) : null;
              return React.createElement(
                  _rcAnimate2['default'],
                  { transitionName: 'show-help', component: '', transitionAppear: true, key: 'help', onEnd: this.onHelpAnimEnd },
                  children
              );
          }
      }, {
          key: 'renderExtra',
          value: function renderExtra() {
              var _props = this.props,
                  prefixCls = _props.prefixCls,
                  extra = _props.extra;

              return extra ? React.createElement(
                  'div',
                  { className: prefixCls + '-extra' },
                  extra
              ) : null;
          }
      }, {
          key: 'getValidateStatus',
          value: function getValidateStatus() {
              var onlyControl = this.getOnlyControl();
              if (!onlyControl) {
                  return '';
              }
              var field = this.getField();
              if (field.validating) {
                  return 'validating';
              }
              if (field.errors) {
                  return 'error';
              }
              var fieldValue = 'value' in field ? field.value : this.getMeta().initialValue;
              if (fieldValue !== undefined && fieldValue !== null && fieldValue !== '') {
                  return 'success';
              }
              return '';
          }
      }, {
          key: 'renderValidateWrapper',
          value: function renderValidateWrapper(c1, c2, c3) {
              var props = this.props;
              var onlyControl = this.getOnlyControl;
              var validateStatus = props.validateStatus === undefined && onlyControl ? this.getValidateStatus() : props.validateStatus;
              var classes = this.props.prefixCls + '-item-control';
              if (validateStatus) {
                  classes = (0, _classnames2['default'])(this.props.prefixCls + '-item-control', {
                      'has-feedback': props.hasFeedback || validateStatus === 'validating',
                      'has-success': validateStatus === 'success',
                      'has-warning': validateStatus === 'warning',
                      'has-error': validateStatus === 'error',
                      'is-validating': validateStatus === 'validating'
                  });
              }
              return React.createElement(
                  'div',
                  { className: classes },
                  React.createElement(
                      'span',
                      { className: this.props.prefixCls + '-item-children' },
                      c1
                  ),
                  c2,
                  c3
              );
          }
      }, {
          key: 'renderWrapper',
          value: function renderWrapper(children) {
              var _props2 = this.props,
                  prefixCls = _props2.prefixCls,
                  wrapperCol = _props2.wrapperCol;

              var className = (0, _classnames2['default'])(prefixCls + '-item-control-wrapper', wrapperCol && wrapperCol.className);
              return React.createElement(
                  _col2['default'],
                  (0, _extends3['default'])({}, wrapperCol, { className: className, key: 'wrapper' }),
                  children
              );
          }
      }, {
          key: 'isRequired',
          value: function isRequired() {
              var required = this.props.required;

              if (required !== undefined) {
                  return required;
              }
              if (this.getOnlyControl()) {
                  var meta = this.getMeta() || {};
                  var validate = meta.validate || [];
                  return validate.filter(function (item) {
                      return !!item.rules;
                  }).some(function (item) {
                      return item.rules.some(function (rule) {
                          return rule.required;
                      });
                  });
              }
              return false;
          }
      }, {
          key: 'renderLabel',
          value: function renderLabel() {
              var _props3 = this.props,
                  prefixCls = _props3.prefixCls,
                  label = _props3.label,
                  labelCol = _props3.labelCol,
                  colon = _props3.colon,
                  id = _props3.id;

              var context = this.context;
              var required = this.isRequired();
              var labelColClassName = (0, _classnames2['default'])(prefixCls + '-item-label', labelCol && labelCol.className);
              var labelClassName = (0, _classnames2['default'])((0, _defineProperty3['default'])({}, prefixCls + '-item-required', required));
              var labelChildren = label;
              // Keep label is original where there should have no colon
              var haveColon = colon && !context.vertical;
              // Remove duplicated user input colon
              if (haveColon && typeof label === 'string' && label.trim() !== '') {
                  labelChildren = label.replace(/[：|:]\s*$/, '');
              }
              return label ? React.createElement(
                  _col2['default'],
                  (0, _extends3['default'])({}, labelCol, { className: labelColClassName, key: 'label' }),
                  React.createElement(
                      'label',
                      { htmlFor: id || this.getId(), className: labelClassName, title: typeof label === 'string' ? label : '', onClick: this.onLabelClick },
                      labelChildren
                  )
              ) : null;
          }
      }, {
          key: 'renderChildren',
          value: function renderChildren() {
              var children = this.props.children;

              return [this.renderLabel(), this.renderWrapper(this.renderValidateWrapper(children, this.renderHelp(), this.renderExtra()))];
          }
      }, {
          key: 'renderFormItem',
          value: function renderFormItem(children) {
              var _itemClassName;

              var props = this.props;
              var prefixCls = props.prefixCls;
              var style = props.style;
              var itemClassName = (_itemClassName = {}, (0, _defineProperty3['default'])(_itemClassName, prefixCls + '-item', true), (0, _defineProperty3['default'])(_itemClassName, prefixCls + '-item-with-help', !!this.getHelpMsg() || this.state.helpShow), (0, _defineProperty3['default'])(_itemClassName, prefixCls + '-item-no-colon', !props.colon), (0, _defineProperty3['default'])(_itemClassName, '' + props.className, !!props.className), _itemClassName);
              return React.createElement(
                  _row2['default'],
                  { className: (0, _classnames2['default'])(itemClassName), style: style },
                  children
              );
          }
      }, {
          key: 'render',
          value: function render() {
              var children = this.renderChildren();
              return this.renderFormItem(children);
          }
      }]);
      return FormItem;
  }(React.Component);

  exports['default'] = FormItem;

  FormItem.defaultProps = {
      hasFeedback: false,
      prefixCls: 'ant-form',
      colon: true
  };
  FormItem.propTypes = {
      prefixCls: _propTypes2['default'].string,
      label: _propTypes2['default'].oneOfType([_propTypes2['default'].string, _propTypes2['default'].node]),
      labelCol: _propTypes2['default'].object,
      help: _propTypes2['default'].oneOfType([_propTypes2['default'].node, _propTypes2['default'].bool]),
      validateStatus: _propTypes2['default'].oneOf(['', 'success', 'warning', 'error', 'validating']),
      hasFeedback: _propTypes2['default'].bool,
      wrapperCol: _propTypes2['default'].object,
      className: _propTypes2['default'].string,
      id: _propTypes2['default'].string,
      children: _propTypes2['default'].node,
      colon: _propTypes2['default'].bool
  };
  FormItem.contextTypes = {
      vertical: _propTypes2['default'].bool
  };
  module.exports = exports['default'];
  });

  unwrapExports(FormItem_1);

  var Form_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _classnames2 = _interopRequireDefault(classnames);



  var _createDOMForm2 = _interopRequireDefault(createDOMForm_1);



  var _createFormField2 = _interopRequireDefault(createFormField_1);



  var _omit2 = _interopRequireDefault(_omit);



  var _warning2 = _interopRequireDefault(warning$4);



  var _FormItem2 = _interopRequireDefault(FormItem_1);



  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var Form = function (_React$Component) {
      (0, _inherits3['default'])(Form, _React$Component);

      function Form(props) {
          (0, _classCallCheck3['default'])(this, Form);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (Form.__proto__ || Object.getPrototypeOf(Form)).call(this, props));

          (0, _warning2['default'])(!props.form, 'It is unnecessary to pass `form` to `Form` after antd@1.7.0.');
          return _this;
      }

      (0, _createClass3['default'])(Form, [{
          key: 'getChildContext',
          value: function getChildContext() {
              var layout = this.props.layout;

              return {
                  vertical: layout === 'vertical'
              };
          }
      }, {
          key: 'render',
          value: function render() {
              var _classNames;

              var _props = this.props,
                  prefixCls = _props.prefixCls,
                  hideRequiredMark = _props.hideRequiredMark,
                  _props$className = _props.className,
                  className = _props$className === undefined ? '' : _props$className,
                  layout = _props.layout;

              var formClassName = (0, _classnames2['default'])(prefixCls, (_classNames = {}, (0, _defineProperty3['default'])(_classNames, prefixCls + '-horizontal', layout === 'horizontal'), (0, _defineProperty3['default'])(_classNames, prefixCls + '-vertical', layout === 'vertical'), (0, _defineProperty3['default'])(_classNames, prefixCls + '-inline', layout === 'inline'), (0, _defineProperty3['default'])(_classNames, prefixCls + '-hide-required-mark', hideRequiredMark), _classNames), className);
              var formProps = (0, _omit2['default'])(this.props, ['prefixCls', 'className', 'layout', 'form', 'hideRequiredMark']);
              return React.createElement('form', (0, _extends3['default'])({}, formProps, { className: formClassName }));
          }
      }]);
      return Form;
  }(React.Component);

  exports['default'] = Form;

  Form.defaultProps = {
      prefixCls: 'ant-form',
      layout: 'horizontal',
      hideRequiredMark: false,
      onSubmit: function onSubmit(e) {
          e.preventDefault();
      }
  };
  Form.propTypes = {
      prefixCls: _propTypes2['default'].string,
      layout: _propTypes2['default'].oneOf(['horizontal', 'inline', 'vertical']),
      children: _propTypes2['default'].any,
      onSubmit: _propTypes2['default'].func,
      hideRequiredMark: _propTypes2['default'].bool
  };
  Form.childContextTypes = {
      vertical: _propTypes2['default'].bool
  };
  Form.Item = _FormItem2['default'];
  Form.createFormField = _createFormField2['default'];
  Form.create = function () {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return (0, _createDOMForm2['default'])((0, _extends3['default'])({ fieldNameProp: 'id' }, options, { fieldMetaProp: constants.FIELD_META_PROP, fieldDataProp: constants.FIELD_DATA_PROP }));
  };
  module.exports = exports['default'];
  });

  unwrapExports(Form_1);

  var form = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _Form2 = _interopRequireDefault(Form_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  exports['default'] = _Form2['default'];
  module.exports = exports['default'];
  });

  var Form$1 = unwrapExports(form);

  var FormCreate = Form$1.create;

  var BaseForm =
  /*#__PURE__*/
  function (_Component) {
    _inherits(BaseForm, _Component);

    function BaseForm() {
      _classCallCheck(this, BaseForm);

      return _possibleConstructorReturn(this, _getPrototypeOf(BaseForm).apply(this, arguments));
    }

    _createClass(BaseForm, [{
      key: "getChildContext",
      value: function getChildContext() {
        var _this$props = this.props,
            form$$1 = _this$props.form,
            itemLayout = _this$props.itemLayout;
        return {
          formRef: form$$1,
          formLayout: itemLayout
        };
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props2 = this.props,
            autoSubmitForm = _this$props2.autoSubmitForm,
            itemLayout = _this$props2.itemLayout,
            children = _this$props2.children,
            otherProps = _objectWithoutProperties(_this$props2, ["autoSubmitForm", "itemLayout", "children"]);

        return React$1__default.createElement(Form$1, otherProps, children);
      }
    }]);

    return BaseForm;
  }(React$1.Component);

  _defineProperty(BaseForm, "childContextTypes", {
    formRef: PropTypes.any,
    formLayout: PropTypes.object
  });

  _defineProperty(BaseForm, "propTypes", {
    layout: PropTypes.oneOf(['horizontal', 'inline', 'vertical']),
    itemLayout: PropTypes.object
  });

  _defineProperty(BaseForm, "defaultProps", {
    prefixCls: 'ant-form',
    layout: 'horizontal',
    itemLayout: {
      labelCol: {
        span: 6
      },
      wrapperCol: {
        span: 18
      }
    }
  });

  var SubmitForm = FormCreate()(BaseForm);
  /**

   * [AdvancedForm  高级Form组件带valuesChange特征]
   */

  var AdvancedForm =
  /*#__PURE__*/
  function (_SubmitForm) {
    _inherits(AdvancedForm, _SubmitForm);

    function AdvancedForm() {
      _classCallCheck(this, AdvancedForm);

      return _possibleConstructorReturn(this, _getPrototypeOf(AdvancedForm).apply(this, arguments));
    }

    return AdvancedForm;
  }(SubmitForm);

  _defineProperty(AdvancedForm, "propTypes", {
    layout: PropTypes.oneOf(['horizontal', 'inline', 'vertical']),
    itemLayout: PropTypes.object
  });

  _defineProperty(AdvancedForm, "defaultProps", {
    // containerTo:true,
    prefixCls: 'ant-form',
    layout: "horizontal",
    itemLayout: {
      labelCol: {
        span: 6
      },
      wrapperCol: {
        span: 18
      }
    }
  });

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  function componentWillMount() {
    // Call this.constructor.gDSFP to support sub-classes.
    var state = this.constructor.getDerivedStateFromProps(this.props, this.state);
    if (state !== null && state !== undefined) {
      this.setState(state);
    }
  }

  function componentWillReceiveProps(nextProps) {
    // Call this.constructor.gDSFP to support sub-classes.
    // Use the setState() updater to ensure state isn't stale in certain edge cases.
    function updater(prevState) {
      var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);
      return state !== null && state !== undefined ? state : null;
    }
    // Binding "this" is important for shallow renderer support.
    this.setState(updater.bind(this));
  }

  function componentWillUpdate(nextProps, nextState) {
    try {
      var prevProps = this.props;
      var prevState = this.state;
      this.props = nextProps;
      this.state = nextState;
      this.__reactInternalSnapshotFlag = true;
      this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(
        prevProps,
        prevState
      );
    } finally {
      this.props = prevProps;
      this.state = prevState;
    }
  }

  // React may warn about cWM/cWRP/cWU methods being deprecated.
  // Add a flag to suppress these warnings for this special case.
  componentWillMount.__suppressDeprecationWarning = true;
  componentWillReceiveProps.__suppressDeprecationWarning = true;
  componentWillUpdate.__suppressDeprecationWarning = true;

  function polyfill(Component) {
    var prototype = Component.prototype;

    if (!prototype || !prototype.isReactComponent) {
      throw new Error('Can only polyfill class components');
    }

    if (
      typeof Component.getDerivedStateFromProps !== 'function' &&
      typeof prototype.getSnapshotBeforeUpdate !== 'function'
    ) {
      return Component;
    }

    // If new component APIs are defined, "unsafe" lifecycles won't be called.
    // Error if any of these lifecycles are present,
    // Because they would work differently between older and newer (16.3+) versions of React.
    var foundWillMountName = null;
    var foundWillReceivePropsName = null;
    var foundWillUpdateName = null;
    if (typeof prototype.componentWillMount === 'function') {
      foundWillMountName = 'componentWillMount';
    } else if (typeof prototype.UNSAFE_componentWillMount === 'function') {
      foundWillMountName = 'UNSAFE_componentWillMount';
    }
    if (typeof prototype.componentWillReceiveProps === 'function') {
      foundWillReceivePropsName = 'componentWillReceiveProps';
    } else if (typeof prototype.UNSAFE_componentWillReceiveProps === 'function') {
      foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
    }
    if (typeof prototype.componentWillUpdate === 'function') {
      foundWillUpdateName = 'componentWillUpdate';
    } else if (typeof prototype.UNSAFE_componentWillUpdate === 'function') {
      foundWillUpdateName = 'UNSAFE_componentWillUpdate';
    }
    if (
      foundWillMountName !== null ||
      foundWillReceivePropsName !== null ||
      foundWillUpdateName !== null
    ) {
      var componentName = Component.displayName || Component.name;
      var newApiName =
        typeof Component.getDerivedStateFromProps === 'function'
          ? 'getDerivedStateFromProps()'
          : 'getSnapshotBeforeUpdate()';

      throw Error(
        'Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n' +
          componentName +
          ' uses ' +
          newApiName +
          ' but also contains the following legacy lifecycles:' +
          (foundWillMountName !== null ? '\n  ' + foundWillMountName : '') +
          (foundWillReceivePropsName !== null
            ? '\n  ' + foundWillReceivePropsName
            : '') +
          (foundWillUpdateName !== null ? '\n  ' + foundWillUpdateName : '') +
          '\n\nThe above lifecycles should be removed. Learn more about this warning here:\n' +
          'https://fb.me/react-async-component-lifecycle-hooks'
      );
    }

    // React <= 16.2 does not support static getDerivedStateFromProps.
    // As a workaround, use cWM and cWRP to invoke the new static lifecycle.
    // Newer versions of React will ignore these lifecycles if gDSFP exists.
    if (typeof Component.getDerivedStateFromProps === 'function') {
      prototype.componentWillMount = componentWillMount;
      prototype.componentWillReceiveProps = componentWillReceiveProps;
    }

    // React <= 16.2 does not support getSnapshotBeforeUpdate.
    // As a workaround, use cWU to invoke the new lifecycle.
    // Newer versions of React will ignore that lifecycle if gSBU exists.
    if (typeof prototype.getSnapshotBeforeUpdate === 'function') {
      if (typeof prototype.componentDidUpdate !== 'function') {
        throw new Error(
          'Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype'
        );
      }

      prototype.componentWillUpdate = componentWillUpdate;

      var componentDidUpdate = prototype.componentDidUpdate;

      prototype.componentDidUpdate = function componentDidUpdatePolyfill(
        prevProps,
        prevState,
        maybeSnapshot
      ) {
        // 16.3+ will not execute our will-update method;
        // It will pass a snapshot value to did-update though.
        // Older versions will require our polyfilled will-update value.
        // We need to handle both cases, but can't just check for the presence of "maybeSnapshot",
        // Because for <= 15.x versions this might be a "prevContext" object.
        // We also can't just check "__reactInternalSnapshot",
        // Because get-snapshot might return a falsy value.
        // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.
        var snapshot = this.__reactInternalSnapshotFlag
          ? this.__reactInternalSnapshot
          : maybeSnapshot;

        componentDidUpdate.call(this, prevProps, prevState, snapshot);
      };
    }

    return Component;
  }

  var reactLifecyclesCompat_es = /*#__PURE__*/Object.freeze({
    polyfill: polyfill
  });

  /**
   * @ignore
   * some key-codes definition and utils from closure-library
   * @author yiminghe@gmail.com
   */

  var KeyCode = {
    /**
     * MAC_ENTER
     */
    MAC_ENTER: 3,
    /**
     * BACKSPACE
     */
    BACKSPACE: 8,
    /**
     * TAB
     */
    TAB: 9,
    /**
     * NUMLOCK on FF/Safari Mac
     */
    NUM_CENTER: 12, // NUMLOCK on FF/Safari Mac
    /**
     * ENTER
     */
    ENTER: 13,
    /**
     * SHIFT
     */
    SHIFT: 16,
    /**
     * CTRL
     */
    CTRL: 17,
    /**
     * ALT
     */
    ALT: 18,
    /**
     * PAUSE
     */
    PAUSE: 19,
    /**
     * CAPS_LOCK
     */
    CAPS_LOCK: 20,
    /**
     * ESC
     */
    ESC: 27,
    /**
     * SPACE
     */
    SPACE: 32,
    /**
     * PAGE_UP
     */
    PAGE_UP: 33, // also NUM_NORTH_EAST
    /**
     * PAGE_DOWN
     */
    PAGE_DOWN: 34, // also NUM_SOUTH_EAST
    /**
     * END
     */
    END: 35, // also NUM_SOUTH_WEST
    /**
     * HOME
     */
    HOME: 36, // also NUM_NORTH_WEST
    /**
     * LEFT
     */
    LEFT: 37, // also NUM_WEST
    /**
     * UP
     */
    UP: 38, // also NUM_NORTH
    /**
     * RIGHT
     */
    RIGHT: 39, // also NUM_EAST
    /**
     * DOWN
     */
    DOWN: 40, // also NUM_SOUTH
    /**
     * PRINT_SCREEN
     */
    PRINT_SCREEN: 44,
    /**
     * INSERT
     */
    INSERT: 45, // also NUM_INSERT
    /**
     * DELETE
     */
    DELETE: 46, // also NUM_DELETE
    /**
     * ZERO
     */
    ZERO: 48,
    /**
     * ONE
     */
    ONE: 49,
    /**
     * TWO
     */
    TWO: 50,
    /**
     * THREE
     */
    THREE: 51,
    /**
     * FOUR
     */
    FOUR: 52,
    /**
     * FIVE
     */
    FIVE: 53,
    /**
     * SIX
     */
    SIX: 54,
    /**
     * SEVEN
     */
    SEVEN: 55,
    /**
     * EIGHT
     */
    EIGHT: 56,
    /**
     * NINE
     */
    NINE: 57,
    /**
     * QUESTION_MARK
     */
    QUESTION_MARK: 63, // needs localization
    /**
     * A
     */
    A: 65,
    /**
     * B
     */
    B: 66,
    /**
     * C
     */
    C: 67,
    /**
     * D
     */
    D: 68,
    /**
     * E
     */
    E: 69,
    /**
     * F
     */
    F: 70,
    /**
     * G
     */
    G: 71,
    /**
     * H
     */
    H: 72,
    /**
     * I
     */
    I: 73,
    /**
     * J
     */
    J: 74,
    /**
     * K
     */
    K: 75,
    /**
     * L
     */
    L: 76,
    /**
     * M
     */
    M: 77,
    /**
     * N
     */
    N: 78,
    /**
     * O
     */
    O: 79,
    /**
     * P
     */
    P: 80,
    /**
     * Q
     */
    Q: 81,
    /**
     * R
     */
    R: 82,
    /**
     * S
     */
    S: 83,
    /**
     * T
     */
    T: 84,
    /**
     * U
     */
    U: 85,
    /**
     * V
     */
    V: 86,
    /**
     * W
     */
    W: 87,
    /**
     * X
     */
    X: 88,
    /**
     * Y
     */
    Y: 89,
    /**
     * Z
     */
    Z: 90,
    /**
     * META
     */
    META: 91, // WIN_KEY_LEFT
    /**
     * WIN_KEY_RIGHT
     */
    WIN_KEY_RIGHT: 92,
    /**
     * CONTEXT_MENU
     */
    CONTEXT_MENU: 93,
    /**
     * NUM_ZERO
     */
    NUM_ZERO: 96,
    /**
     * NUM_ONE
     */
    NUM_ONE: 97,
    /**
     * NUM_TWO
     */
    NUM_TWO: 98,
    /**
     * NUM_THREE
     */
    NUM_THREE: 99,
    /**
     * NUM_FOUR
     */
    NUM_FOUR: 100,
    /**
     * NUM_FIVE
     */
    NUM_FIVE: 101,
    /**
     * NUM_SIX
     */
    NUM_SIX: 102,
    /**
     * NUM_SEVEN
     */
    NUM_SEVEN: 103,
    /**
     * NUM_EIGHT
     */
    NUM_EIGHT: 104,
    /**
     * NUM_NINE
     */
    NUM_NINE: 105,
    /**
     * NUM_MULTIPLY
     */
    NUM_MULTIPLY: 106,
    /**
     * NUM_PLUS
     */
    NUM_PLUS: 107,
    /**
     * NUM_MINUS
     */
    NUM_MINUS: 109,
    /**
     * NUM_PERIOD
     */
    NUM_PERIOD: 110,
    /**
     * NUM_DIVISION
     */
    NUM_DIVISION: 111,
    /**
     * F1
     */
    F1: 112,
    /**
     * F2
     */
    F2: 113,
    /**
     * F3
     */
    F3: 114,
    /**
     * F4
     */
    F4: 115,
    /**
     * F5
     */
    F5: 116,
    /**
     * F6
     */
    F6: 117,
    /**
     * F7
     */
    F7: 118,
    /**
     * F8
     */
    F8: 119,
    /**
     * F9
     */
    F9: 120,
    /**
     * F10
     */
    F10: 121,
    /**
     * F11
     */
    F11: 122,
    /**
     * F12
     */
    F12: 123,
    /**
     * NUMLOCK
     */
    NUMLOCK: 144,
    /**
     * SEMICOLON
     */
    SEMICOLON: 186, // needs localization
    /**
     * DASH
     */
    DASH: 189, // needs localization
    /**
     * EQUALS
     */
    EQUALS: 187, // needs localization
    /**
     * COMMA
     */
    COMMA: 188, // needs localization
    /**
     * PERIOD
     */
    PERIOD: 190, // needs localization
    /**
     * SLASH
     */
    SLASH: 191, // needs localization
    /**
     * APOSTROPHE
     */
    APOSTROPHE: 192, // needs localization
    /**
     * SINGLE_QUOTE
     */
    SINGLE_QUOTE: 222, // needs localization
    /**
     * OPEN_SQUARE_BRACKET
     */
    OPEN_SQUARE_BRACKET: 219, // needs localization
    /**
     * BACKSLASH
     */
    BACKSLASH: 220, // needs localization
    /**
     * CLOSE_SQUARE_BRACKET
     */
    CLOSE_SQUARE_BRACKET: 221, // needs localization
    /**
     * WIN_KEY
     */
    WIN_KEY: 224,
    /**
     * MAC_FF_META
     */
    MAC_FF_META: 224, // Firefox (Gecko) fires this for the meta key instead of 91
    /**
     * WIN_IME
     */
    WIN_IME: 229
  };

  /*
   whether text and modified key is entered at the same time.
   */
  KeyCode.isTextModifyingKeyEvent = function isTextModifyingKeyEvent(e) {
    var keyCode = e.keyCode;
    if (e.altKey && !e.ctrlKey || e.metaKey ||
    // Function keys don't generate text
    keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
      return false;
    }

    // The following keys are quite harmless, even in combination with
    // CTRL, ALT or SHIFT.
    switch (keyCode) {
      case KeyCode.ALT:
      case KeyCode.CAPS_LOCK:
      case KeyCode.CONTEXT_MENU:
      case KeyCode.CTRL:
      case KeyCode.DOWN:
      case KeyCode.END:
      case KeyCode.ESC:
      case KeyCode.HOME:
      case KeyCode.INSERT:
      case KeyCode.LEFT:
      case KeyCode.MAC_FF_META:
      case KeyCode.META:
      case KeyCode.NUMLOCK:
      case KeyCode.NUM_CENTER:
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
      case KeyCode.PAUSE:
      case KeyCode.PRINT_SCREEN:
      case KeyCode.RIGHT:
      case KeyCode.SHIFT:
      case KeyCode.UP:
      case KeyCode.WIN_KEY:
      case KeyCode.WIN_KEY_RIGHT:
        return false;
      default:
        return true;
    }
  };

  /*
   whether character is entered.
   */
  KeyCode.isCharacterKey = function isCharacterKey(keyCode) {
    if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
      return true;
    }

    if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
      return true;
    }

    if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
      return true;
    }

    // Safari sends zero key code for non-latin characters.
    if (window.navigation.userAgent.indexOf('WebKit') !== -1 && keyCode === 0) {
      return true;
    }

    switch (keyCode) {
      case KeyCode.SPACE:
      case KeyCode.QUESTION_MARK:
      case KeyCode.NUM_PLUS:
      case KeyCode.NUM_MINUS:
      case KeyCode.NUM_PERIOD:
      case KeyCode.NUM_DIVISION:
      case KeyCode.SEMICOLON:
      case KeyCode.DASH:
      case KeyCode.EQUALS:
      case KeyCode.COMMA:
      case KeyCode.PERIOD:
      case KeyCode.SLASH:
      case KeyCode.APOSTROPHE:
      case KeyCode.SINGLE_QUOTE:
      case KeyCode.OPEN_SQUARE_BRACKET:
      case KeyCode.BACKSLASH:
      case KeyCode.CLOSE_SQUARE_BRACKET:
        return true;
      default:
        return false;
    }
  };

  function toArray(children) {
    var ret = [];
    React$1__default.Children.forEach(children, function (c) {
      ret.push(c);
    });
    return ret;
  }

  var PropTypes$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.storeShape = undefined;



  var _propTypes2 = _interopRequireDefault(PropTypes);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var storeShape = exports.storeShape = _propTypes2.default.shape({
    subscribe: _propTypes2.default.func.isRequired,
    setState: _propTypes2.default.func.isRequired,
    getState: _propTypes2.default.func.isRequired
  });
  });

  unwrapExports(PropTypes$1);
  var PropTypes_1 = PropTypes$1.storeShape;

  var Provider_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



  var _react2 = _interopRequireDefault(React$1__default);



  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Provider = function (_Component) {
    _inherits(Provider, _Component);

    function Provider() {
      _classCallCheck(this, Provider);

      return _possibleConstructorReturn(this, (Provider.__proto__ || Object.getPrototypeOf(Provider)).apply(this, arguments));
    }

    _createClass(Provider, [{
      key: 'getChildContext',
      value: function getChildContext() {
        return {
          miniStore: this.props.store
        };
      }
    }, {
      key: 'render',
      value: function render() {
        return React$1__default.Children.only(this.props.children);
      }
    }]);

    return Provider;
  }(React$1__default.Component);

  Provider.propTypes = {
    store: PropTypes$1.storeShape.isRequired
  };
  Provider.childContextTypes = {
    miniStore: PropTypes$1.storeShape.isRequired
  };
  exports.default = Provider;
  });

  unwrapExports(Provider_1);

  //

  var shallowequal = function shallowEqual(objA, objB, compare, compareContext) {
    var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

    if (ret !== void 0) {
      return !!ret;
    }

    if (objA === objB) {
      return true;
    }

    if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
      return false;
    }

    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);

    if (keysA.length !== keysB.length) {
      return false;
    }

    var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);

    // Test for A's keys different from B.
    for (var idx = 0; idx < keysA.length; idx++) {
      var key = keysA[idx];

      if (!bHasOwnProperty(key)) {
        return false;
      }

      var valueA = objA[key];
      var valueB = objB[key];

      ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;

      if (ret === false || (ret === void 0 && valueA !== valueB)) {
        return false;
      }
    }

    return true;
  };

  var connect_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  exports.default = connect;



  var _react2 = _interopRequireDefault(React$1__default);



  var _shallowequal2 = _interopRequireDefault(shallowequal);



  var _hoistNonReactStatics2 = _interopRequireDefault(hoistNonReactStatics_cjs);





  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  function getDisplayName(WrappedComponent) {
    return WrappedComponent.displayName || WrappedComponent.name || 'Component';
  }

  function isStateless(Component) {
    return !Component.prototype.render;
  }

  var defaultMapStateToProps = function defaultMapStateToProps() {
    return {};
  };

  function connect(mapStateToProps) {
    var shouldSubscribe = !!mapStateToProps;
    var finnalMapStateToProps = mapStateToProps || defaultMapStateToProps;

    return function wrapWithConnect(WrappedComponent) {
      var Connect = function (_Component) {
        _inherits(Connect, _Component);

        _createClass(Connect, null, [{
          key: 'getDerivedStateFromProps',
          value: function getDerivedStateFromProps(props, prevState) {
            // using ownProps
            if (mapStateToProps && mapStateToProps.length === 2 && props !== prevState.props) {
              return {
                subscribed: finnalMapStateToProps(prevState.store.getState(), props),
                props: props
              };
            }
            return { props: props };
          }
        }]);

        function Connect(props, context) {
          _classCallCheck(this, Connect);

          var _this = _possibleConstructorReturn(this, (Connect.__proto__ || Object.getPrototypeOf(Connect)).call(this, props, context));

          _this.handleChange = function () {
            if (!_this.unsubscribe) {
              return;
            }
            var nextState = finnalMapStateToProps(_this.store.getState(), _this.props);
            _this.setState({ subscribed: nextState });
          };

          _this.store = context.miniStore;
          _this.state = {
            subscribed: finnalMapStateToProps(_this.store.getState(), props),
            store: _this.store,
            props: props
          };
          return _this;
        }

        _createClass(Connect, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
            this.trySubscribe();
          }
        }, {
          key: 'componentWillUnmount',
          value: function componentWillUnmount() {
            this.tryUnsubscribe();
          }
        }, {
          key: 'shouldComponentUpdate',
          value: function shouldComponentUpdate(nextProps, nextState) {
            return !(0, _shallowequal2.default)(this.props, nextProps) || !(0, _shallowequal2.default)(this.state.subscribed, nextState.subscribed);
          }
        }, {
          key: 'trySubscribe',
          value: function trySubscribe() {
            if (shouldSubscribe) {
              this.unsubscribe = this.store.subscribe(this.handleChange);
              this.handleChange();
            }
          }
        }, {
          key: 'tryUnsubscribe',
          value: function tryUnsubscribe() {
            if (this.unsubscribe) {
              this.unsubscribe();
              this.unsubscribe = null;
            }
          }
        }, {
          key: 'getWrappedInstance',
          value: function getWrappedInstance() {
            return this.wrappedInstance;
          }
        }, {
          key: 'render',
          value: function render() {
            var _this2 = this;

            var props = _extends({}, this.props, this.state.subscribed, {
              store: this.store
            });

            if (!isStateless(WrappedComponent)) {
              props = _extends({}, props, {
                ref: function ref(c) {
                  return _this2.wrappedInstance = c;
                }
              });
            }

            return _react2.default.createElement(WrappedComponent, props);
          }
        }]);

        return Connect;
      }(React$1__default.Component);

      Connect.displayName = 'Connect(' + getDisplayName(WrappedComponent) + ')';
      Connect.contextTypes = {
        miniStore: PropTypes$1.storeShape.isRequired
      };


      (0, reactLifecyclesCompat_es.polyfill)(Connect);

      return (0, _hoistNonReactStatics2.default)(Connect, WrappedComponent);
    };
  }
  });

  unwrapExports(connect_1);

  var create_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  exports.default = create;
  function create(initialState) {
    var state = initialState;
    var listeners = [];

    function setState(partial) {
      state = _extends({}, state, partial);
      for (var i = 0; i < listeners.length; i++) {
        listeners[i]();
      }
    }

    function getState() {
      return state;
    }

    function subscribe(listener) {
      listeners.push(listener);

      return function unsubscribe() {
        var index = listeners.indexOf(listener);
        listeners.splice(index, 1);
      };
    }

    return {
      setState: setState,
      getState: getState,
      subscribe: subscribe
    };
  }
  });

  unwrapExports(create_1);

  var lib$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.create = exports.connect = exports.Provider = undefined;



  var _Provider3 = _interopRequireDefault(Provider_1);



  var _connect3 = _interopRequireDefault(connect_1);



  var _create3 = _interopRequireDefault(create_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.Provider = _Provider3.default;
  exports.connect = _connect3.default;
  exports.create = _create3.default;
  });

  unwrapExports(lib$1);
  var lib_1 = lib$1.create;
  var lib_2 = lib$1.connect;
  var lib_3 = lib$1.Provider;

  /**
   * Safe chained function
   *
   * Will only create a new function if needed,
   * otherwise will pass back existing functions or null.
   *
   * @returns {function|null}
   */
  function createChainedFunction() {
    var args = [].slice.call(arguments, 0);
    if (args.length === 1) {
      return args[0];
    }

    return function chainedFunction() {
      for (var i = 0; i < args.length; i++) {
        if (args[i] && args[i].apply) {
          args[i].apply(this, arguments);
        }
      }
    };
  }

  function noop$1() {}

  function getKeyFromChildrenIndex(child, menuEventKey, index) {
    var prefix = menuEventKey || '';
    return child.key || prefix + 'item_' + index;
  }

  function getMenuIdFromSubMenuEventKey(eventKey) {
    return eventKey + '-menu-';
  }

  function loopMenuItem(children, cb) {
    var index = -1;
    React$1__default.Children.forEach(children, function (c) {
      index++;
      if (c && c.type && c.type.isMenuItemGroup) {
        React$1__default.Children.forEach(c.props.children, function (c2) {
          index++;
          cb(c2, index);
        });
      } else {
        cb(c, index);
      }
    });
  }

  function loopMenuItemRecursively(children, keys, ret) {
    /* istanbul ignore if */
    if (!children || ret.find) {
      return;
    }
    React$1__default.Children.forEach(children, function (c) {
      if (c) {
        var construct = c.type;
        if (!construct || !(construct.isSubMenu || construct.isMenuItem || construct.isMenuItemGroup)) {
          return;
        }
        if (keys.indexOf(c.key) !== -1) {
          ret.find = true;
        } else if (c.props.children) {
          loopMenuItemRecursively(c.props.children, keys, ret);
        }
      }
    });
  }

  var menuAllProps = ['defaultSelectedKeys', 'selectedKeys', 'defaultOpenKeys', 'openKeys', 'mode', 'getPopupContainer', 'onSelect', 'onDeselect', 'onDestroy', 'openTransitionName', 'openAnimation', 'subMenuOpenDelay', 'subMenuCloseDelay', 'forceSubMenuRender', 'triggerSubMenuAction', 'level', 'selectable', 'multiple', 'onOpenChange', 'visible', 'focusable', 'defaultActiveFirst', 'prefixCls', 'inlineIndent', 'parentMenu', 'title', 'rootPrefixCls', 'eventKey', 'active', 'onItemHover', 'onTitleMouseEnter', 'onTitleMouseLeave', 'onTitleClick', 'popupAlign', 'popupOffset', 'isOpen', 'renderMenuItem', 'manualRef', 'subMenuKey', 'disabled', 'index', 'isSelected', 'store', 'activeKey', 'builtinPlacements', 'overflowedIndicator',

  // the following keys found need to be removed from test regression
  'attribute', 'value', 'popupClassName', 'inlineCollapsed', 'menu', 'theme', 'itemIcon', 'expandIcon'];

  var getWidth = function getWidth(elem) {
    return elem && typeof elem.getBoundingClientRect === 'function' && elem.getBoundingClientRect().width || 0;
  };

  var setStyle = function setStyle(elem, styleProperty, value) {
    if (elem && typeof elem.style === 'object') {
      elem.style[styleProperty] = value;
    }
  };

  /**
   * A collection of shims that provide minimal functionality of the ES6 collections.
   *
   * These implementations are not meant to be used outside of the ResizeObserver
   * modules as they cover only a limited range of use cases.
   */
  /* eslint-disable require-jsdoc, valid-jsdoc */
  var MapShim = (function () {
      if (typeof Map !== 'undefined') {
          return Map;
      }
      /**
       * Returns index in provided array that matches the specified key.
       *
       * @param {Array<Array>} arr
       * @param {*} key
       * @returns {number}
       */
      function getIndex(arr, key) {
          var result = -1;
          arr.some(function (entry, index) {
              if (entry[0] === key) {
                  result = index;
                  return true;
              }
              return false;
          });
          return result;
      }
      return /** @class */ (function () {
          function class_1() {
              this.__entries__ = [];
          }
          Object.defineProperty(class_1.prototype, "size", {
              /**
               * @returns {boolean}
               */
              get: function () {
                  return this.__entries__.length;
              },
              enumerable: true,
              configurable: true
          });
          /**
           * @param {*} key
           * @returns {*}
           */
          class_1.prototype.get = function (key) {
              var index = getIndex(this.__entries__, key);
              var entry = this.__entries__[index];
              return entry && entry[1];
          };
          /**
           * @param {*} key
           * @param {*} value
           * @returns {void}
           */
          class_1.prototype.set = function (key, value) {
              var index = getIndex(this.__entries__, key);
              if (~index) {
                  this.__entries__[index][1] = value;
              }
              else {
                  this.__entries__.push([key, value]);
              }
          };
          /**
           * @param {*} key
           * @returns {void}
           */
          class_1.prototype.delete = function (key) {
              var entries = this.__entries__;
              var index = getIndex(entries, key);
              if (~index) {
                  entries.splice(index, 1);
              }
          };
          /**
           * @param {*} key
           * @returns {void}
           */
          class_1.prototype.has = function (key) {
              return !!~getIndex(this.__entries__, key);
          };
          /**
           * @returns {void}
           */
          class_1.prototype.clear = function () {
              this.__entries__.splice(0);
          };
          /**
           * @param {Function} callback
           * @param {*} [ctx=null]
           * @returns {void}
           */
          class_1.prototype.forEach = function (callback, ctx) {
              if (ctx === void 0) { ctx = null; }
              for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                  var entry = _a[_i];
                  callback.call(ctx, entry[1], entry[0]);
              }
          };
          return class_1;
      }());
  })();

  /**
   * Detects whether window and document objects are available in current environment.
   */
  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

  // Returns global object of a current environment.
  var global$1 = (function () {
      if (typeof global !== 'undefined' && global.Math === Math) {
          return global;
      }
      if (typeof self !== 'undefined' && self.Math === Math) {
          return self;
      }
      if (typeof window !== 'undefined' && window.Math === Math) {
          return window;
      }
      // eslint-disable-next-line no-new-func
      return Function('return this')();
  })();

  /**
   * A shim for the requestAnimationFrame which falls back to the setTimeout if
   * first one is not supported.
   *
   * @returns {number} Requests' identifier.
   */
  var requestAnimationFrame$1 = (function () {
      if (typeof requestAnimationFrame === 'function') {
          // It's required to use a bounded function because IE sometimes throws
          // an "Invalid calling object" error if rAF is invoked without the global
          // object on the left hand side.
          return requestAnimationFrame.bind(global$1);
      }
      return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
  })();

  // Defines minimum timeout before adding a trailing call.
  var trailingTimeout = 2;
  /**
   * Creates a wrapper function which ensures that provided callback will be
   * invoked only once during the specified delay period.
   *
   * @param {Function} callback - Function to be invoked after the delay period.
   * @param {number} delay - Delay after which to invoke callback.
   * @returns {Function}
   */
  function throttle (callback, delay) {
      var leadingCall = false, trailingCall = false, lastCallTime = 0;
      /**
       * Invokes the original callback function and schedules new invocation if
       * the "proxy" was called during current request.
       *
       * @returns {void}
       */
      function resolvePending() {
          if (leadingCall) {
              leadingCall = false;
              callback();
          }
          if (trailingCall) {
              proxy();
          }
      }
      /**
       * Callback invoked after the specified delay. It will further postpone
       * invocation of the original function delegating it to the
       * requestAnimationFrame.
       *
       * @returns {void}
       */
      function timeoutCallback() {
          requestAnimationFrame$1(resolvePending);
      }
      /**
       * Schedules invocation of the original function.
       *
       * @returns {void}
       */
      function proxy() {
          var timeStamp = Date.now();
          if (leadingCall) {
              // Reject immediately following calls.
              if (timeStamp - lastCallTime < trailingTimeout) {
                  return;
              }
              // Schedule new call to be in invoked when the pending one is resolved.
              // This is important for "transitions" which never actually start
              // immediately so there is a chance that we might miss one if change
              // happens amids the pending invocation.
              trailingCall = true;
          }
          else {
              leadingCall = true;
              trailingCall = false;
              setTimeout(timeoutCallback, delay);
          }
          lastCallTime = timeStamp;
      }
      return proxy;
  }

  // Minimum delay before invoking the update of observers.
  var REFRESH_DELAY = 20;
  // A list of substrings of CSS properties used to find transition events that
  // might affect dimensions of observed elements.
  var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
  // Check if MutationObserver is available.
  var mutationObserverSupported = typeof MutationObserver !== 'undefined';
  /**
   * Singleton controller class which handles updates of ResizeObserver instances.
   */
  var ResizeObserverController = /** @class */ (function () {
      /**
       * Creates a new instance of ResizeObserverController.
       *
       * @private
       */
      function ResizeObserverController() {
          /**
           * Indicates whether DOM listeners have been added.
           *
           * @private {boolean}
           */
          this.connected_ = false;
          /**
           * Tells that controller has subscribed for Mutation Events.
           *
           * @private {boolean}
           */
          this.mutationEventsAdded_ = false;
          /**
           * Keeps reference to the instance of MutationObserver.
           *
           * @private {MutationObserver}
           */
          this.mutationsObserver_ = null;
          /**
           * A list of connected observers.
           *
           * @private {Array<ResizeObserverSPI>}
           */
          this.observers_ = [];
          this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
          this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
      }
      /**
       * Adds observer to observers list.
       *
       * @param {ResizeObserverSPI} observer - Observer to be added.
       * @returns {void}
       */
      ResizeObserverController.prototype.addObserver = function (observer) {
          if (!~this.observers_.indexOf(observer)) {
              this.observers_.push(observer);
          }
          // Add listeners if they haven't been added yet.
          if (!this.connected_) {
              this.connect_();
          }
      };
      /**
       * Removes observer from observers list.
       *
       * @param {ResizeObserverSPI} observer - Observer to be removed.
       * @returns {void}
       */
      ResizeObserverController.prototype.removeObserver = function (observer) {
          var observers = this.observers_;
          var index = observers.indexOf(observer);
          // Remove observer if it's present in registry.
          if (~index) {
              observers.splice(index, 1);
          }
          // Remove listeners if controller has no connected observers.
          if (!observers.length && this.connected_) {
              this.disconnect_();
          }
      };
      /**
       * Invokes the update of observers. It will continue running updates insofar
       * it detects changes.
       *
       * @returns {void}
       */
      ResizeObserverController.prototype.refresh = function () {
          var changesDetected = this.updateObservers_();
          // Continue running updates if changes have been detected as there might
          // be future ones caused by CSS transitions.
          if (changesDetected) {
              this.refresh();
          }
      };
      /**
       * Updates every observer from observers list and notifies them of queued
       * entries.
       *
       * @private
       * @returns {boolean} Returns "true" if any observer has detected changes in
       *      dimensions of it's elements.
       */
      ResizeObserverController.prototype.updateObservers_ = function () {
          // Collect observers that have active observations.
          var activeObservers = this.observers_.filter(function (observer) {
              return observer.gatherActive(), observer.hasActive();
          });
          // Deliver notifications in a separate cycle in order to avoid any
          // collisions between observers, e.g. when multiple instances of
          // ResizeObserver are tracking the same element and the callback of one
          // of them changes content dimensions of the observed target. Sometimes
          // this may result in notifications being blocked for the rest of observers.
          activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
          return activeObservers.length > 0;
      };
      /**
       * Initializes DOM listeners.
       *
       * @private
       * @returns {void}
       */
      ResizeObserverController.prototype.connect_ = function () {
          // Do nothing if running in a non-browser environment or if listeners
          // have been already added.
          if (!isBrowser || this.connected_) {
              return;
          }
          // Subscription to the "Transitionend" event is used as a workaround for
          // delayed transitions. This way it's possible to capture at least the
          // final state of an element.
          document.addEventListener('transitionend', this.onTransitionEnd_);
          window.addEventListener('resize', this.refresh);
          if (mutationObserverSupported) {
              this.mutationsObserver_ = new MutationObserver(this.refresh);
              this.mutationsObserver_.observe(document, {
                  attributes: true,
                  childList: true,
                  characterData: true,
                  subtree: true
              });
          }
          else {
              document.addEventListener('DOMSubtreeModified', this.refresh);
              this.mutationEventsAdded_ = true;
          }
          this.connected_ = true;
      };
      /**
       * Removes DOM listeners.
       *
       * @private
       * @returns {void}
       */
      ResizeObserverController.prototype.disconnect_ = function () {
          // Do nothing if running in a non-browser environment or if listeners
          // have been already removed.
          if (!isBrowser || !this.connected_) {
              return;
          }
          document.removeEventListener('transitionend', this.onTransitionEnd_);
          window.removeEventListener('resize', this.refresh);
          if (this.mutationsObserver_) {
              this.mutationsObserver_.disconnect();
          }
          if (this.mutationEventsAdded_) {
              document.removeEventListener('DOMSubtreeModified', this.refresh);
          }
          this.mutationsObserver_ = null;
          this.mutationEventsAdded_ = false;
          this.connected_ = false;
      };
      /**
       * "Transitionend" event handler.
       *
       * @private
       * @param {TransitionEvent} event
       * @returns {void}
       */
      ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
          var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
          // Detect whether transition may affect dimensions of an element.
          var isReflowProperty = transitionKeys.some(function (key) {
              return !!~propertyName.indexOf(key);
          });
          if (isReflowProperty) {
              this.refresh();
          }
      };
      /**
       * Returns instance of the ResizeObserverController.
       *
       * @returns {ResizeObserverController}
       */
      ResizeObserverController.getInstance = function () {
          if (!this.instance_) {
              this.instance_ = new ResizeObserverController();
          }
          return this.instance_;
      };
      /**
       * Holds reference to the controller's instance.
       *
       * @private {ResizeObserverController}
       */
      ResizeObserverController.instance_ = null;
      return ResizeObserverController;
  }());

  /**
   * Defines non-writable/enumerable properties of the provided target object.
   *
   * @param {Object} target - Object for which to define properties.
   * @param {Object} props - Properties to be defined.
   * @returns {Object} Target object.
   */
  var defineConfigurable = (function (target, props) {
      for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
          var key = _a[_i];
          Object.defineProperty(target, key, {
              value: props[key],
              enumerable: false,
              writable: false,
              configurable: true
          });
      }
      return target;
  });

  /**
   * Returns the global object associated with provided element.
   *
   * @param {Object} target
   * @returns {Object}
   */
  var getWindowOf = (function (target) {
      // Assume that the element is an instance of Node, which means that it
      // has the "ownerDocument" property from which we can retrieve a
      // corresponding global object.
      var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
      // Return the local global object if it's not possible extract one from
      // provided element.
      return ownerGlobal || global$1;
  });

  // Placeholder of an empty content rectangle.
  var emptyRect = createRectInit(0, 0, 0, 0);
  /**
   * Converts provided string to a number.
   *
   * @param {number|string} value
   * @returns {number}
   */
  function toFloat(value) {
      return parseFloat(value) || 0;
  }
  /**
   * Extracts borders size from provided styles.
   *
   * @param {CSSStyleDeclaration} styles
   * @param {...string} positions - Borders positions (top, right, ...)
   * @returns {number}
   */
  function getBordersSize(styles) {
      var positions = [];
      for (var _i = 1; _i < arguments.length; _i++) {
          positions[_i - 1] = arguments[_i];
      }
      return positions.reduce(function (size, position) {
          var value = styles['border-' + position + '-width'];
          return size + toFloat(value);
      }, 0);
  }
  /**
   * Extracts paddings sizes from provided styles.
   *
   * @param {CSSStyleDeclaration} styles
   * @returns {Object} Paddings box.
   */
  function getPaddings(styles) {
      var positions = ['top', 'right', 'bottom', 'left'];
      var paddings = {};
      for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
          var position = positions_1[_i];
          var value = styles['padding-' + position];
          paddings[position] = toFloat(value);
      }
      return paddings;
  }
  /**
   * Calculates content rectangle of provided SVG element.
   *
   * @param {SVGGraphicsElement} target - Element content rectangle of which needs
   *      to be calculated.
   * @returns {DOMRectInit}
   */
  function getSVGContentRect(target) {
      var bbox = target.getBBox();
      return createRectInit(0, 0, bbox.width, bbox.height);
  }
  /**
   * Calculates content rectangle of provided HTMLElement.
   *
   * @param {HTMLElement} target - Element for which to calculate the content rectangle.
   * @returns {DOMRectInit}
   */
  function getHTMLElementContentRect(target) {
      // Client width & height properties can't be
      // used exclusively as they provide rounded values.
      var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
      // By this condition we can catch all non-replaced inline, hidden and
      // detached elements. Though elements with width & height properties less
      // than 0.5 will be discarded as well.
      //
      // Without it we would need to implement separate methods for each of
      // those cases and it's not possible to perform a precise and performance
      // effective test for hidden elements. E.g. even jQuery's ':visible' filter
      // gives wrong results for elements with width & height less than 0.5.
      if (!clientWidth && !clientHeight) {
          return emptyRect;
      }
      var styles = getWindowOf(target).getComputedStyle(target);
      var paddings = getPaddings(styles);
      var horizPad = paddings.left + paddings.right;
      var vertPad = paddings.top + paddings.bottom;
      // Computed styles of width & height are being used because they are the
      // only dimensions available to JS that contain non-rounded values. It could
      // be possible to utilize the getBoundingClientRect if only it's data wasn't
      // affected by CSS transformations let alone paddings, borders and scroll bars.
      var width = toFloat(styles.width), height = toFloat(styles.height);
      // Width & height include paddings and borders when the 'border-box' box
      // model is applied (except for IE).
      if (styles.boxSizing === 'border-box') {
          // Following conditions are required to handle Internet Explorer which
          // doesn't include paddings and borders to computed CSS dimensions.
          //
          // We can say that if CSS dimensions + paddings are equal to the "client"
          // properties then it's either IE, and thus we don't need to subtract
          // anything, or an element merely doesn't have paddings/borders styles.
          if (Math.round(width + horizPad) !== clientWidth) {
              width -= getBordersSize(styles, 'left', 'right') + horizPad;
          }
          if (Math.round(height + vertPad) !== clientHeight) {
              height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
          }
      }
      // Following steps can't be applied to the document's root element as its
      // client[Width/Height] properties represent viewport area of the window.
      // Besides, it's as well not necessary as the <html> itself neither has
      // rendered scroll bars nor it can be clipped.
      if (!isDocumentElement(target)) {
          // In some browsers (only in Firefox, actually) CSS width & height
          // include scroll bars size which can be removed at this step as scroll
          // bars are the only difference between rounded dimensions + paddings
          // and "client" properties, though that is not always true in Chrome.
          var vertScrollbar = Math.round(width + horizPad) - clientWidth;
          var horizScrollbar = Math.round(height + vertPad) - clientHeight;
          // Chrome has a rather weird rounding of "client" properties.
          // E.g. for an element with content width of 314.2px it sometimes gives
          // the client width of 315px and for the width of 314.7px it may give
          // 314px. And it doesn't happen all the time. So just ignore this delta
          // as a non-relevant.
          if (Math.abs(vertScrollbar) !== 1) {
              width -= vertScrollbar;
          }
          if (Math.abs(horizScrollbar) !== 1) {
              height -= horizScrollbar;
          }
      }
      return createRectInit(paddings.left, paddings.top, width, height);
  }
  /**
   * Checks whether provided element is an instance of the SVGGraphicsElement.
   *
   * @param {Element} target - Element to be checked.
   * @returns {boolean}
   */
  var isSVGGraphicsElement = (function () {
      // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
      // interface.
      if (typeof SVGGraphicsElement !== 'undefined') {
          return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
      }
      // If it's so, then check that element is at least an instance of the
      // SVGElement and that it has the "getBBox" method.
      // eslint-disable-next-line no-extra-parens
      return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
          typeof target.getBBox === 'function'); };
  })();
  /**
   * Checks whether provided element is a document element (<html>).
   *
   * @param {Element} target - Element to be checked.
   * @returns {boolean}
   */
  function isDocumentElement(target) {
      return target === getWindowOf(target).document.documentElement;
  }
  /**
   * Calculates an appropriate content rectangle for provided html or svg element.
   *
   * @param {Element} target - Element content rectangle of which needs to be calculated.
   * @returns {DOMRectInit}
   */
  function getContentRect(target) {
      if (!isBrowser) {
          return emptyRect;
      }
      if (isSVGGraphicsElement(target)) {
          return getSVGContentRect(target);
      }
      return getHTMLElementContentRect(target);
  }
  /**
   * Creates rectangle with an interface of the DOMRectReadOnly.
   * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
   *
   * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
   * @returns {DOMRectReadOnly}
   */
  function createReadOnlyRect(_a) {
      var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
      // If DOMRectReadOnly is available use it as a prototype for the rectangle.
      var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
      var rect = Object.create(Constr.prototype);
      // Rectangle's properties are not writable and non-enumerable.
      defineConfigurable(rect, {
          x: x, y: y, width: width, height: height,
          top: y,
          right: x + width,
          bottom: height + y,
          left: x
      });
      return rect;
  }
  /**
   * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
   * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
   *
   * @param {number} x - X coordinate.
   * @param {number} y - Y coordinate.
   * @param {number} width - Rectangle's width.
   * @param {number} height - Rectangle's height.
   * @returns {DOMRectInit}
   */
  function createRectInit(x, y, width, height) {
      return { x: x, y: y, width: width, height: height };
  }

  /**
   * Class that is responsible for computations of the content rectangle of
   * provided DOM element and for keeping track of it's changes.
   */
  var ResizeObservation = /** @class */ (function () {
      /**
       * Creates an instance of ResizeObservation.
       *
       * @param {Element} target - Element to be observed.
       */
      function ResizeObservation(target) {
          /**
           * Broadcasted width of content rectangle.
           *
           * @type {number}
           */
          this.broadcastWidth = 0;
          /**
           * Broadcasted height of content rectangle.
           *
           * @type {number}
           */
          this.broadcastHeight = 0;
          /**
           * Reference to the last observed content rectangle.
           *
           * @private {DOMRectInit}
           */
          this.contentRect_ = createRectInit(0, 0, 0, 0);
          this.target = target;
      }
      /**
       * Updates content rectangle and tells whether it's width or height properties
       * have changed since the last broadcast.
       *
       * @returns {boolean}
       */
      ResizeObservation.prototype.isActive = function () {
          var rect = getContentRect(this.target);
          this.contentRect_ = rect;
          return (rect.width !== this.broadcastWidth ||
              rect.height !== this.broadcastHeight);
      };
      /**
       * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
       * from the corresponding properties of the last observed content rectangle.
       *
       * @returns {DOMRectInit} Last observed content rectangle.
       */
      ResizeObservation.prototype.broadcastRect = function () {
          var rect = this.contentRect_;
          this.broadcastWidth = rect.width;
          this.broadcastHeight = rect.height;
          return rect;
      };
      return ResizeObservation;
  }());

  var ResizeObserverEntry = /** @class */ (function () {
      /**
       * Creates an instance of ResizeObserverEntry.
       *
       * @param {Element} target - Element that is being observed.
       * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
       */
      function ResizeObserverEntry(target, rectInit) {
          var contentRect = createReadOnlyRect(rectInit);
          // According to the specification following properties are not writable
          // and are also not enumerable in the native implementation.
          //
          // Property accessors are not being used as they'd require to define a
          // private WeakMap storage which may cause memory leaks in browsers that
          // don't support this type of collections.
          defineConfigurable(this, { target: target, contentRect: contentRect });
      }
      return ResizeObserverEntry;
  }());

  var ResizeObserverSPI = /** @class */ (function () {
      /**
       * Creates a new instance of ResizeObserver.
       *
       * @param {ResizeObserverCallback} callback - Callback function that is invoked
       *      when one of the observed elements changes it's content dimensions.
       * @param {ResizeObserverController} controller - Controller instance which
       *      is responsible for the updates of observer.
       * @param {ResizeObserver} callbackCtx - Reference to the public
       *      ResizeObserver instance which will be passed to callback function.
       */
      function ResizeObserverSPI(callback, controller, callbackCtx) {
          /**
           * Collection of resize observations that have detected changes in dimensions
           * of elements.
           *
           * @private {Array<ResizeObservation>}
           */
          this.activeObservations_ = [];
          /**
           * Registry of the ResizeObservation instances.
           *
           * @private {Map<Element, ResizeObservation>}
           */
          this.observations_ = new MapShim();
          if (typeof callback !== 'function') {
              throw new TypeError('The callback provided as parameter 1 is not a function.');
          }
          this.callback_ = callback;
          this.controller_ = controller;
          this.callbackCtx_ = callbackCtx;
      }
      /**
       * Starts observing provided element.
       *
       * @param {Element} target - Element to be observed.
       * @returns {void}
       */
      ResizeObserverSPI.prototype.observe = function (target) {
          if (!arguments.length) {
              throw new TypeError('1 argument required, but only 0 present.');
          }
          // Do nothing if current environment doesn't have the Element interface.
          if (typeof Element === 'undefined' || !(Element instanceof Object)) {
              return;
          }
          if (!(target instanceof getWindowOf(target).Element)) {
              throw new TypeError('parameter 1 is not of type "Element".');
          }
          var observations = this.observations_;
          // Do nothing if element is already being observed.
          if (observations.has(target)) {
              return;
          }
          observations.set(target, new ResizeObservation(target));
          this.controller_.addObserver(this);
          // Force the update of observations.
          this.controller_.refresh();
      };
      /**
       * Stops observing provided element.
       *
       * @param {Element} target - Element to stop observing.
       * @returns {void}
       */
      ResizeObserverSPI.prototype.unobserve = function (target) {
          if (!arguments.length) {
              throw new TypeError('1 argument required, but only 0 present.');
          }
          // Do nothing if current environment doesn't have the Element interface.
          if (typeof Element === 'undefined' || !(Element instanceof Object)) {
              return;
          }
          if (!(target instanceof getWindowOf(target).Element)) {
              throw new TypeError('parameter 1 is not of type "Element".');
          }
          var observations = this.observations_;
          // Do nothing if element is not being observed.
          if (!observations.has(target)) {
              return;
          }
          observations.delete(target);
          if (!observations.size) {
              this.controller_.removeObserver(this);
          }
      };
      /**
       * Stops observing all elements.
       *
       * @returns {void}
       */
      ResizeObserverSPI.prototype.disconnect = function () {
          this.clearActive();
          this.observations_.clear();
          this.controller_.removeObserver(this);
      };
      /**
       * Collects observation instances the associated element of which has changed
       * it's content rectangle.
       *
       * @returns {void}
       */
      ResizeObserverSPI.prototype.gatherActive = function () {
          var _this = this;
          this.clearActive();
          this.observations_.forEach(function (observation) {
              if (observation.isActive()) {
                  _this.activeObservations_.push(observation);
              }
          });
      };
      /**
       * Invokes initial callback function with a list of ResizeObserverEntry
       * instances collected from active resize observations.
       *
       * @returns {void}
       */
      ResizeObserverSPI.prototype.broadcastActive = function () {
          // Do nothing if observer doesn't have active observations.
          if (!this.hasActive()) {
              return;
          }
          var ctx = this.callbackCtx_;
          // Create ResizeObserverEntry instance for every active observation.
          var entries = this.activeObservations_.map(function (observation) {
              return new ResizeObserverEntry(observation.target, observation.broadcastRect());
          });
          this.callback_.call(ctx, entries, ctx);
          this.clearActive();
      };
      /**
       * Clears the collection of active observations.
       *
       * @returns {void}
       */
      ResizeObserverSPI.prototype.clearActive = function () {
          this.activeObservations_.splice(0);
      };
      /**
       * Tells whether observer has active observations.
       *
       * @returns {boolean}
       */
      ResizeObserverSPI.prototype.hasActive = function () {
          return this.activeObservations_.length > 0;
      };
      return ResizeObserverSPI;
  }());

  // Registry of internal observers. If WeakMap is not available use current shim
  // for the Map collection as it has all required methods and because WeakMap
  // can't be fully polyfilled anyway.
  var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
  /**
   * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
   * exposing only those methods and properties that are defined in the spec.
   */
  var ResizeObserver = /** @class */ (function () {
      /**
       * Creates a new instance of ResizeObserver.
       *
       * @param {ResizeObserverCallback} callback - Callback that is invoked when
       *      dimensions of the observed elements change.
       */
      function ResizeObserver(callback) {
          if (!(this instanceof ResizeObserver)) {
              throw new TypeError('Cannot call a class as a function.');
          }
          if (!arguments.length) {
              throw new TypeError('1 argument required, but only 0 present.');
          }
          var controller = ResizeObserverController.getInstance();
          var observer = new ResizeObserverSPI(callback, controller, this);
          observers.set(this, observer);
      }
      return ResizeObserver;
  }());
  // Expose public methods of ResizeObserver.
  [
      'observe',
      'unobserve',
      'disconnect'
  ].forEach(function (method) {
      ResizeObserver.prototype[method] = function () {
          var _a;
          return (_a = observers.get(this))[method].apply(_a, arguments);
      };
  });

  var index$3 = (function () {
      // Export existing implementation if available.
      if (typeof global$1.ResizeObserver !== 'undefined') {
          return global$1.ResizeObserver;
      }
      return ResizeObserver;
  })();

  function contains(root, n) {
    var node = n;
    while (node) {
      if (node === root) {
        return true;
      }
      node = node.parentNode;
    }

    return false;
  }

  var EventBaseObject_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function returnFalse() {
    return false;
  }

  function returnTrue() {
    return true;
  }

  function EventBaseObject() {
    this.timeStamp = Date.now();
    this.target = undefined;
    this.currentTarget = undefined;
  }

  EventBaseObject.prototype = {
    isEventObject: 1,

    constructor: EventBaseObject,

    isDefaultPrevented: returnFalse,

    isPropagationStopped: returnFalse,

    isImmediatePropagationStopped: returnFalse,

    preventDefault: function preventDefault() {
      this.isDefaultPrevented = returnTrue;
    },

    stopPropagation: function stopPropagation() {
      this.isPropagationStopped = returnTrue;
    },

    stopImmediatePropagation: function stopImmediatePropagation() {
      this.isImmediatePropagationStopped = returnTrue;
      // fixed 1.2
      // call stopPropagation implicitly
      this.stopPropagation();
    },

    halt: function halt(immediate) {
      if (immediate) {
        this.stopImmediatePropagation();
      } else {
        this.stopPropagation();
      }
      this.preventDefault();
    }
  };

  exports["default"] = EventBaseObject;
  module.exports = exports["default"];
  });

  unwrapExports(EventBaseObject_1);

  var EventObject = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, '__esModule', {
    value: true
  });

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



  var _EventBaseObject2 = _interopRequireDefault(EventBaseObject_1);



  var _objectAssign2 = _interopRequireDefault(objectAssign);

  var TRUE = true;
  var FALSE = false;
  var commonProps = ['altKey', 'bubbles', 'cancelable', 'ctrlKey', 'currentTarget', 'eventPhase', 'metaKey', 'shiftKey', 'target', 'timeStamp', 'view', 'type'];

  function isNullOrUndefined(w) {
    return w === null || w === undefined;
  }

  var eventNormalizers = [{
    reg: /^key/,
    props: ['char', 'charCode', 'key', 'keyCode', 'which'],
    fix: function fix(event, nativeEvent) {
      if (isNullOrUndefined(event.which)) {
        event.which = !isNullOrUndefined(nativeEvent.charCode) ? nativeEvent.charCode : nativeEvent.keyCode;
      }

      // add metaKey to non-Mac browsers (use ctrl for PC 's and Meta for Macs)
      if (event.metaKey === undefined) {
        event.metaKey = event.ctrlKey;
      }
    }
  }, {
    reg: /^touch/,
    props: ['touches', 'changedTouches', 'targetTouches']
  }, {
    reg: /^hashchange$/,
    props: ['newURL', 'oldURL']
  }, {
    reg: /^gesturechange$/i,
    props: ['rotation', 'scale']
  }, {
    reg: /^(mousewheel|DOMMouseScroll)$/,
    props: [],
    fix: function fix(event, nativeEvent) {
      var deltaX = undefined;
      var deltaY = undefined;
      var delta = undefined;
      var wheelDelta = nativeEvent.wheelDelta;
      var axis = nativeEvent.axis;
      var wheelDeltaY = nativeEvent.wheelDeltaY;
      var wheelDeltaX = nativeEvent.wheelDeltaX;
      var detail = nativeEvent.detail;

      // ie/webkit
      if (wheelDelta) {
        delta = wheelDelta / 120;
      }

      // gecko
      if (detail) {
        // press control e.detail == 1 else e.detail == 3
        delta = 0 - (detail % 3 === 0 ? detail / 3 : detail);
      }

      // Gecko
      if (axis !== undefined) {
        if (axis === event.HORIZONTAL_AXIS) {
          deltaY = 0;
          deltaX = 0 - delta;
        } else if (axis === event.VERTICAL_AXIS) {
          deltaX = 0;
          deltaY = delta;
        }
      }

      // Webkit
      if (wheelDeltaY !== undefined) {
        deltaY = wheelDeltaY / 120;
      }
      if (wheelDeltaX !== undefined) {
        deltaX = -1 * wheelDeltaX / 120;
      }

      // 默认 deltaY (ie)
      if (!deltaX && !deltaY) {
        deltaY = delta;
      }

      if (deltaX !== undefined) {
        /**
         * deltaX of mousewheel event
         * @property deltaX
         * @member Event.DomEvent.Object
         */
        event.deltaX = deltaX;
      }

      if (deltaY !== undefined) {
        /**
         * deltaY of mousewheel event
         * @property deltaY
         * @member Event.DomEvent.Object
         */
        event.deltaY = deltaY;
      }

      if (delta !== undefined) {
        /**
         * delta of mousewheel event
         * @property delta
         * @member Event.DomEvent.Object
         */
        event.delta = delta;
      }
    }
  }, {
    reg: /^mouse|contextmenu|click|mspointer|(^DOMMouseScroll$)/i,
    props: ['buttons', 'clientX', 'clientY', 'button', 'offsetX', 'relatedTarget', 'which', 'fromElement', 'toElement', 'offsetY', 'pageX', 'pageY', 'screenX', 'screenY'],
    fix: function fix(event, nativeEvent) {
      var eventDoc = undefined;
      var doc = undefined;
      var body = undefined;
      var target = event.target;
      var button = nativeEvent.button;

      // Calculate pageX/Y if missing and clientX/Y available
      if (target && isNullOrUndefined(event.pageX) && !isNullOrUndefined(nativeEvent.clientX)) {
        eventDoc = target.ownerDocument || document;
        doc = eventDoc.documentElement;
        body = eventDoc.body;
        event.pageX = nativeEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
        event.pageY = nativeEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
      }

      // which for click: 1 === left; 2 === middle; 3 === right
      // do not use button
      if (!event.which && button !== undefined) {
        if (button & 1) {
          event.which = 1;
        } else if (button & 2) {
          event.which = 3;
        } else if (button & 4) {
          event.which = 2;
        } else {
          event.which = 0;
        }
      }

      // add relatedTarget, if necessary
      if (!event.relatedTarget && event.fromElement) {
        event.relatedTarget = event.fromElement === target ? event.toElement : event.fromElement;
      }

      return event;
    }
  }];

  function retTrue() {
    return TRUE;
  }

  function retFalse() {
    return FALSE;
  }

  function DomEventObject(nativeEvent) {
    var type = nativeEvent.type;

    var isNative = typeof nativeEvent.stopPropagation === 'function' || typeof nativeEvent.cancelBubble === 'boolean';

    _EventBaseObject2['default'].call(this);

    this.nativeEvent = nativeEvent;

    // in case dom event has been mark as default prevented by lower dom node
    var isDefaultPrevented = retFalse;
    if ('defaultPrevented' in nativeEvent) {
      isDefaultPrevented = nativeEvent.defaultPrevented ? retTrue : retFalse;
    } else if ('getPreventDefault' in nativeEvent) {
      // https://bugzilla.mozilla.org/show_bug.cgi?id=691151
      isDefaultPrevented = nativeEvent.getPreventDefault() ? retTrue : retFalse;
    } else if ('returnValue' in nativeEvent) {
      isDefaultPrevented = nativeEvent.returnValue === FALSE ? retTrue : retFalse;
    }

    this.isDefaultPrevented = isDefaultPrevented;

    var fixFns = [];
    var fixFn = undefined;
    var l = undefined;
    var prop = undefined;
    var props = commonProps.concat();

    eventNormalizers.forEach(function (normalizer) {
      if (type.match(normalizer.reg)) {
        props = props.concat(normalizer.props);
        if (normalizer.fix) {
          fixFns.push(normalizer.fix);
        }
      }
    });

    l = props.length;

    // clone properties of the original event object
    while (l) {
      prop = props[--l];
      this[prop] = nativeEvent[prop];
    }

    // fix target property, if necessary
    if (!this.target && isNative) {
      this.target = nativeEvent.srcElement || document; // srcElement might not be defined either
    }

    // check if target is a text node (safari)
    if (this.target && this.target.nodeType === 3) {
      this.target = this.target.parentNode;
    }

    l = fixFns.length;

    while (l) {
      fixFn = fixFns[--l];
      fixFn(this, nativeEvent);
    }

    this.timeStamp = nativeEvent.timeStamp || Date.now();
  }

  var EventBaseObjectProto = _EventBaseObject2['default'].prototype;

  (0, _objectAssign2['default'])(DomEventObject.prototype, EventBaseObjectProto, {
    constructor: DomEventObject,

    preventDefault: function preventDefault() {
      var e = this.nativeEvent;

      // if preventDefault exists run it on the original event
      if (e.preventDefault) {
        e.preventDefault();
      } else {
        // otherwise set the returnValue property of the original event to FALSE (IE)
        e.returnValue = FALSE;
      }

      EventBaseObjectProto.preventDefault.call(this);
    },

    stopPropagation: function stopPropagation() {
      var e = this.nativeEvent;

      // if stopPropagation exists run it on the original event
      if (e.stopPropagation) {
        e.stopPropagation();
      } else {
        // otherwise set the cancelBubble property of the original event to TRUE (IE)
        e.cancelBubble = TRUE;
      }

      EventBaseObjectProto.stopPropagation.call(this);
    }
  });

  exports['default'] = DomEventObject;
  module.exports = exports['default'];
  });

  unwrapExports(EventObject);

  var lib$2 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports['default'] = addEventListener;

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



  var _EventObject2 = _interopRequireDefault(EventObject);

  function addEventListener(target, eventType, callback, option) {
    function wrapCallback(e) {
      var ne = new _EventObject2['default'](e);
      callback.call(target, ne);
    }

    if (target.addEventListener) {
      var _ret = (function () {
        var useCapture = false;
        if (typeof option === 'object') {
          useCapture = option.capture || false;
        } else if (typeof option === 'boolean') {
          useCapture = option;
        }

        target.addEventListener(eventType, wrapCallback, option || false);

        return {
          v: {
            remove: function remove() {
              target.removeEventListener(eventType, wrapCallback, useCapture);
            }
          }
        };
      })();

      if (typeof _ret === 'object') return _ret.v;
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, wrapCallback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, wrapCallback);
        }
      };
    }
  }

  module.exports = exports['default'];
  });

  var addDOMEventListener = unwrapExports(lib$2);

  function addEventListenerWrap(target, eventType, cb, option) {
    /* eslint camelcase: 2 */
    var callback = ReactDOM__default.unstable_batchedUpdates ? function run(e) {
      ReactDOM__default.unstable_batchedUpdates(cb, e);
    } : cb;
    return addDOMEventListener(target, eventType, callback, option);
  }

  var ContainerRender = function (_React$Component) {
    _inherits$1(ContainerRender, _React$Component);

    function ContainerRender() {
      var _ref;

      var _temp, _this, _ret;

      _classCallCheck$1(this, ContainerRender);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn$1(this, (_ref = ContainerRender.__proto__ || Object.getPrototypeOf(ContainerRender)).call.apply(_ref, [this].concat(args))), _this), _this.removeContainer = function () {
        if (_this.container) {
          ReactDOM__default.unmountComponentAtNode(_this.container);
          _this.container.parentNode.removeChild(_this.container);
          _this.container = null;
        }
      }, _this.renderComponent = function (props, ready) {
        var _this$props = _this.props,
            visible = _this$props.visible,
            getComponent = _this$props.getComponent,
            forceRender = _this$props.forceRender,
            getContainer = _this$props.getContainer,
            parent = _this$props.parent;

        if (visible || parent._component || forceRender) {
          if (!_this.container) {
            _this.container = getContainer();
          }
          ReactDOM__default.unstable_renderSubtreeIntoContainer(parent, getComponent(props), _this.container, function callback() {
            if (ready) {
              ready.call(this);
            }
          });
        }
      }, _temp), _possibleConstructorReturn$1(_this, _ret);
    }

    _createClass$1(ContainerRender, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        if (this.props.autoMount) {
          this.renderComponent();
        }
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate() {
        if (this.props.autoMount) {
          this.renderComponent();
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        if (this.props.autoDestroy) {
          this.removeContainer();
        }
      }
    }, {
      key: 'render',
      value: function render() {
        return this.props.children({
          renderComponent: this.renderComponent,
          removeContainer: this.removeContainer
        });
      }
    }]);

    return ContainerRender;
  }(React$1__default.Component);

  ContainerRender.propTypes = {
    autoMount: PropTypes.bool,
    autoDestroy: PropTypes.bool,
    visible: PropTypes.bool,
    forceRender: PropTypes.bool,
    parent: PropTypes.any,
    getComponent: PropTypes.func.isRequired,
    getContainer: PropTypes.func.isRequired,
    children: PropTypes.func.isRequired
  };
  ContainerRender.defaultProps = {
    autoMount: true,
    autoDestroy: true,
    forceRender: false
  };

  var Portal = function (_React$Component) {
    _inherits$1(Portal, _React$Component);

    function Portal() {
      _classCallCheck$1(this, Portal);

      return _possibleConstructorReturn$1(this, (Portal.__proto__ || Object.getPrototypeOf(Portal)).apply(this, arguments));
    }

    _createClass$1(Portal, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        this.createContainer();
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate(prevProps) {
        var didUpdate = this.props.didUpdate;

        if (didUpdate) {
          didUpdate(prevProps);
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        this.removeContainer();
      }
    }, {
      key: 'createContainer',
      value: function createContainer() {
        this._container = this.props.getContainer();
        this.forceUpdate();
      }
    }, {
      key: 'removeContainer',
      value: function removeContainer() {
        if (this._container) {
          this._container.parentNode.removeChild(this._container);
        }
      }
    }, {
      key: 'render',
      value: function render() {
        if (this._container) {
          return ReactDOM__default.createPortal(this.props.children, this._container);
        }
        return null;
      }
    }]);

    return Portal;
  }(React$1__default.Component);

  Portal.propTypes = {
    getContainer: PropTypes.func.isRequired,
    children: PropTypes.node.isRequired,
    didUpdate: PropTypes.func
  };

  function isPointsEq(a1, a2, isAlignPoint) {
    if (isAlignPoint) {
      return a1[0] === a2[0];
    }
    return a1[0] === a2[0] && a1[1] === a2[1];
  }

  function getAlignFromPlacement(builtinPlacements, placementStr, align) {
    var baseAlign = builtinPlacements[placementStr] || {};
    return _extends$2({}, baseAlign, align);
  }

  function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
    var points = align.points;
    for (var placement in builtinPlacements) {
      if (builtinPlacements.hasOwnProperty(placement)) {
        if (isPointsEq(builtinPlacements[placement].points, points, isAlignPoint)) {
          return prefixCls + '-placement-' + placement;
        }
      }
    }
    return '';
  }

  function saveRef(name, component) {
    this[name] = component;
  }

  var vendorPrefix = void 0;

  var jsCssMap = {
    Webkit: '-webkit-',
    Moz: '-moz-',
    // IE did it wrong again ...
    ms: '-ms-',
    O: '-o-'
  };

  function getVendorPrefix() {
    if (vendorPrefix !== undefined) {
      return vendorPrefix;
    }
    vendorPrefix = '';
    var style = document.createElement('p').style;
    var testProp = 'Transform';
    for (var key in jsCssMap) {
      if (key + testProp in style) {
        vendorPrefix = key;
      }
    }
    return vendorPrefix;
  }

  function getTransitionName() {
    return getVendorPrefix() ? getVendorPrefix() + 'TransitionProperty' : 'transitionProperty';
  }

  function getTransformName() {
    return getVendorPrefix() ? getVendorPrefix() + 'Transform' : 'transform';
  }

  function setTransitionProperty(node, value) {
    var name = getTransitionName();
    if (name) {
      node.style[name] = value;
      if (name !== 'transitionProperty') {
        node.style.transitionProperty = value;
      }
    }
  }

  function setTransform(node, value) {
    var name = getTransformName();
    if (name) {
      node.style[name] = value;
      if (name !== 'transform') {
        node.style.transform = value;
      }
    }
  }

  function getTransitionProperty(node) {
    return node.style.transitionProperty || node.style[getTransitionName()];
  }

  function getTransformXY(node) {
    var style = window.getComputedStyle(node, null);
    var transform = style.getPropertyValue('transform') || style.getPropertyValue(getTransformName());
    if (transform && transform !== 'none') {
      var matrix = transform.replace(/[^0-9\-.,]/g, '').split(',');
      return { x: parseFloat(matrix[12] || matrix[4], 0), y: parseFloat(matrix[13] || matrix[5], 0) };
    }
    return {
      x: 0,
      y: 0
    };
  }

  var matrix2d = /matrix\((.*)\)/;
  var matrix3d = /matrix3d\((.*)\)/;

  function setTransformXY(node, xy) {
    var style = window.getComputedStyle(node, null);
    var transform = style.getPropertyValue('transform') || style.getPropertyValue(getTransformName());
    if (transform && transform !== 'none') {
      var arr = void 0;
      var match2d = transform.match(matrix2d);
      if (match2d) {
        match2d = match2d[1];
        arr = match2d.split(',').map(function (item) {
          return parseFloat(item, 10);
        });
        arr[4] = xy.x;
        arr[5] = xy.y;
        setTransform(node, 'matrix(' + arr.join(',') + ')');
      } else {
        var match3d = transform.match(matrix3d)[1];
        arr = match3d.split(',').map(function (item) {
          return parseFloat(item, 10);
        });
        arr[12] = xy.x;
        arr[13] = xy.y;
        setTransform(node, 'matrix3d(' + arr.join(',') + ')');
      }
    } else {
      setTransform(node, 'translateX(' + xy.x + 'px) translateY(' + xy.y + 'px) translateZ(0)');
    }
  }

  var _typeof$3 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var RE_NUM$1 = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;

  var getComputedStyleX$1 = void 0;

  // https://stackoverflow.com/a/3485654/3040605
  function forceRelayout(elem) {
    var originalStyle = elem.style.display;
    elem.style.display = 'none';
    elem.offsetHeight; // eslint-disable-line
    elem.style.display = originalStyle;
  }

  function css$1(el, name, v) {
    var value = v;
    if ((typeof name === 'undefined' ? 'undefined' : _typeof$3(name)) === 'object') {
      for (var i in name) {
        if (name.hasOwnProperty(i)) {
          css$1(el, i, name[i]);
        }
      }
      return undefined;
    }
    if (typeof value !== 'undefined') {
      if (typeof value === 'number') {
        value = value + 'px';
      }
      el.style[name] = value;
      return undefined;
    }
    return getComputedStyleX$1(el, name);
  }

  function getClientPosition$1(elem) {
    var box = void 0;
    var x = void 0;
    var y = void 0;
    var doc = elem.ownerDocument;
    var body = doc.body;
    var docElem = doc && doc.documentElement;
    // 根据 GBS 最新数据，A-Grade Browsers 都已支持 getBoundingClientRect 方法，不用再考虑传统的实现方式
    box = elem.getBoundingClientRect();

    // 注：jQuery 还考虑减去 docElem.clientLeft/clientTop
    // 但测试发现，这样反而会导致当 html 和 body 有边距/边框样式时，获取的值不正确
    // 此外，ie6 会忽略 html 的 margin 值，幸运地是没有谁会去设置 html 的 margin

    x = box.left;
    y = box.top;

    // In IE, most of the time, 2 extra pixels are added to the top and left
    // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
    // IE6 standards mode, this border can be overridden by setting the
    // document element's border to zero -- thus, we cannot rely on the
    // offset always being 2 pixels.

    // In quirks mode, the offset can be determined by querying the body's
    // clientLeft/clientTop, but in standards mode, it is found by querying
    // the document element's clientLeft/clientTop.  Since we already called
    // getClientBoundingRect we have already forced a reflow, so it is not
    // too expensive just to query them all.

    // ie 下应该减去窗口的边框吧，毕竟默认 absolute 都是相对窗口定位的
    // 窗口边框标准是设 documentElement ,quirks 时设置 body
    // 最好禁止在 body 和 html 上边框 ，但 ie < 9 html 默认有 2px ，减去
    // 但是非 ie 不可能设置窗口边框，body html 也不是窗口 ,ie 可以通过 html,body 设置
    // 标准 ie 下 docElem.clientTop 就是 border-top
    // ie7 html 即窗口边框改变不了。永远为 2
    // 但标准 firefox/chrome/ie9 下 docElem.clientTop 是窗口边框，即使设了 border-top 也为 0

    x -= docElem.clientLeft || body.clientLeft || 0;
    y -= docElem.clientTop || body.clientTop || 0;

    return {
      left: x,
      top: y
    };
  }

  function getScroll$1(w, top) {
    var ret = w['page' + (top ? 'Y' : 'X') + 'Offset'];
    var method = 'scroll' + (top ? 'Top' : 'Left');
    if (typeof ret !== 'number') {
      var d = w.document;
      // ie6,7,8 standard mode
      ret = d.documentElement[method];
      if (typeof ret !== 'number') {
        // quirks mode
        ret = d.body[method];
      }
    }
    return ret;
  }

  function getScrollLeft$1(w) {
    return getScroll$1(w);
  }

  function getScrollTop$1(w) {
    return getScroll$1(w, true);
  }

  function getOffset$1(el) {
    var pos = getClientPosition$1(el);
    var doc = el.ownerDocument;
    var w = doc.defaultView || doc.parentWindow;
    pos.left += getScrollLeft$1(w);
    pos.top += getScrollTop$1(w);
    return pos;
  }

  /**
   * A crude way of determining if an object is a window
   * @member util
   */
  function isWindow$1(obj) {
    // must use == for ie8
    /* eslint eqeqeq:0 */
    return obj !== null && obj !== undefined && obj == obj.window;
  }

  function getDocument(node) {
    if (isWindow$1(node)) {
      return node.document;
    }
    if (node.nodeType === 9) {
      return node;
    }
    return node.ownerDocument;
  }

  function _getComputedStyle$1(elem, name, cs) {
    var computedStyle = cs;
    var val = '';
    var d = getDocument(elem);
    computedStyle = computedStyle || d.defaultView.getComputedStyle(elem, null);

    // https://github.com/kissyteam/kissy/issues/61
    if (computedStyle) {
      val = computedStyle.getPropertyValue(name) || computedStyle[name];
    }

    return val;
  }

  var _RE_NUM_NO_PX$1 = new RegExp('^(' + RE_NUM$1 + ')(?!px)[a-z%]+$', 'i');
  var RE_POS$1 = /^(top|right|bottom|left)$/;
  var CURRENT_STYLE$1 = 'currentStyle';
  var RUNTIME_STYLE$1 = 'runtimeStyle';
  var LEFT$1 = 'left';
  var PX$1 = 'px';

  function _getComputedStyleIE$1(elem, name) {
    // currentStyle maybe null
    // http://msdn.microsoft.com/en-us/library/ms535231.aspx
    var ret = elem[CURRENT_STYLE$1] && elem[CURRENT_STYLE$1][name];

    // 当 width/height 设置为百分比时，通过 pixelLeft 方式转换的 width/height 值
    // 一开始就处理了! CUSTOM_STYLE.height,CUSTOM_STYLE.width ,cssHook 解决@2011-08-19
    // 在 ie 下不对，需要直接用 offset 方式
    // borderWidth 等值也有问题，但考虑到 borderWidth 设为百分比的概率很小，这里就不考虑了

    // From the awesome hack by Dean Edwards
    // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
    // If we're not dealing with a regular pixel number
    // but a number that has a weird ending, we need to convert it to pixels
    // exclude left right for relativity
    if (_RE_NUM_NO_PX$1.test(ret) && !RE_POS$1.test(name)) {
      // Remember the original values
      var style = elem.style;
      var left = style[LEFT$1];
      var rsLeft = elem[RUNTIME_STYLE$1][LEFT$1];

      // prevent flashing of content
      elem[RUNTIME_STYLE$1][LEFT$1] = elem[CURRENT_STYLE$1][LEFT$1];

      // Put in the new values to get a computed value out
      style[LEFT$1] = name === 'fontSize' ? '1em' : ret || 0;
      ret = style.pixelLeft + PX$1;

      // Revert the changed values
      style[LEFT$1] = left;

      elem[RUNTIME_STYLE$1][LEFT$1] = rsLeft;
    }
    return ret === '' ? 'auto' : ret;
  }

  if (typeof window !== 'undefined') {
    getComputedStyleX$1 = window.getComputedStyle ? _getComputedStyle$1 : _getComputedStyleIE$1;
  }

  function getOffsetDirection(dir, option) {
    if (dir === 'left') {
      return option.useCssRight ? 'right' : dir;
    }
    return option.useCssBottom ? 'bottom' : dir;
  }

  function oppositeOffsetDirection(dir) {
    if (dir === 'left') {
      return 'right';
    } else if (dir === 'right') {
      return 'left';
    } else if (dir === 'top') {
      return 'bottom';
    } else if (dir === 'bottom') {
      return 'top';
    }
  }

  // 设置 elem 相对 elem.ownerDocument 的坐标
  function setLeftTop(elem, offset, option) {
    // set position first, in-case top/left are set even on static elem
    if (css$1(elem, 'position') === 'static') {
      elem.style.position = 'relative';
    }
    var presetH = -999;
    var presetV = -999;
    var horizontalProperty = getOffsetDirection('left', option);
    var verticalProperty = getOffsetDirection('top', option);
    var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
    var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);

    if (horizontalProperty !== 'left') {
      presetH = 999;
    }

    if (verticalProperty !== 'top') {
      presetV = 999;
    }
    var originalTransition = '';
    var originalOffset = getOffset$1(elem);
    if ('left' in offset || 'top' in offset) {
      originalTransition = getTransitionProperty(elem) || '';
      setTransitionProperty(elem, 'none');
    }
    if ('left' in offset) {
      elem.style[oppositeHorizontalProperty] = '';
      elem.style[horizontalProperty] = presetH + 'px';
    }
    if ('top' in offset) {
      elem.style[oppositeVerticalProperty] = '';
      elem.style[verticalProperty] = presetV + 'px';
    }
    // force relayout
    forceRelayout(elem);
    var old = getOffset$1(elem);
    var originalStyle = {};
    for (var key in offset) {
      if (offset.hasOwnProperty(key)) {
        var dir = getOffsetDirection(key, option);
        var preset = key === 'left' ? presetH : presetV;
        var off = originalOffset[key] - old[key];
        if (dir === key) {
          originalStyle[dir] = preset + off;
        } else {
          originalStyle[dir] = preset - off;
        }
      }
    }
    css$1(elem, originalStyle);
    // force relayout
    forceRelayout(elem);
    if ('left' in offset || 'top' in offset) {
      setTransitionProperty(elem, originalTransition);
    }
    var ret = {};
    for (var _key in offset) {
      if (offset.hasOwnProperty(_key)) {
        var _dir = getOffsetDirection(_key, option);
        var _off = offset[_key] - originalOffset[_key];
        if (_key === _dir) {
          ret[_dir] = originalStyle[_dir] + _off;
        } else {
          ret[_dir] = originalStyle[_dir] - _off;
        }
      }
    }
    css$1(elem, ret);
  }

  function setTransform$1(elem, offset) {
    var originalOffset = getOffset$1(elem);
    var originalXY = getTransformXY(elem);
    var resultXY = { x: originalXY.x, y: originalXY.y };
    if ('left' in offset) {
      resultXY.x = originalXY.x + offset.left - originalOffset.left;
    }
    if ('top' in offset) {
      resultXY.y = originalXY.y + offset.top - originalOffset.top;
    }
    setTransformXY(elem, resultXY);
  }

  function setOffset$1(elem, offset, option) {
    if (option.ignoreShake) {
      var oriOffset = getOffset$1(elem);

      var oLeft = oriOffset.left.toFixed(0);
      var oTop = oriOffset.top.toFixed(0);
      var tLeft = offset.left.toFixed(0);
      var tTop = offset.top.toFixed(0);

      if (oLeft === tLeft && oTop === tTop) {
        return;
      }
    }

    if (option.useCssRight || option.useCssBottom) {
      setLeftTop(elem, offset, option);
    } else if (option.useCssTransform && getTransformName() in document.body.style) {
      setTransform$1(elem, offset, option);
    } else {
      setLeftTop(elem, offset, option);
    }
  }

  function each$4(arr, fn) {
    for (var i = 0; i < arr.length; i++) {
      fn(arr[i]);
    }
  }

  function isBorderBoxFn$1(elem) {
    return getComputedStyleX$1(elem, 'boxSizing') === 'border-box';
  }

  var BOX_MODELS$1 = ['margin', 'border', 'padding'];
  var CONTENT_INDEX$1 = -1;
  var PADDING_INDEX$1 = 2;
  var BORDER_INDEX$1 = 1;
  var MARGIN_INDEX$1 = 0;

  function swap$1(elem, options, callback) {
    var old = {};
    var style = elem.style;
    var name = void 0;

    // Remember the old values, and insert the new ones
    for (name in options) {
      if (options.hasOwnProperty(name)) {
        old[name] = style[name];
        style[name] = options[name];
      }
    }

    callback.call(elem);

    // Revert the old values
    for (name in options) {
      if (options.hasOwnProperty(name)) {
        style[name] = old[name];
      }
    }
  }

  function getPBMWidth$1(elem, props, which) {
    var value = 0;
    var prop = void 0;
    var j = void 0;
    var i = void 0;
    for (j = 0; j < props.length; j++) {
      prop = props[j];
      if (prop) {
        for (i = 0; i < which.length; i++) {
          var cssProp = void 0;
          if (prop === 'border') {
            cssProp = '' + prop + which[i] + 'Width';
          } else {
            cssProp = prop + which[i];
          }
          value += parseFloat(getComputedStyleX$1(elem, cssProp)) || 0;
        }
      }
    }
    return value;
  }

  var domUtils$1 = {};

  each$4(['Width', 'Height'], function (name) {
    domUtils$1['doc' + name] = function (refWin) {
      var d = refWin.document;
      return Math.max(
      // firefox chrome documentElement.scrollHeight< body.scrollHeight
      // ie standard mode : documentElement.scrollHeight> body.scrollHeight
      d.documentElement['scroll' + name],
      // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
      d.body['scroll' + name], domUtils$1['viewport' + name](d));
    };

    domUtils$1['viewport' + name] = function (win) {
      // pc browser includes scrollbar in window.innerWidth
      var prop = 'client' + name;
      var doc = win.document;
      var body = doc.body;
      var documentElement = doc.documentElement;
      var documentElementProp = documentElement[prop];
      // 标准模式取 documentElement
      // backcompat 取 body
      return doc.compatMode === 'CSS1Compat' && documentElementProp || body && body[prop] || documentElementProp;
    };
  });

  /*
   得到元素的大小信息
   @param elem
   @param name
   @param {String} [extra]  'padding' : (css width) + padding
   'border' : (css width) + padding + border
   'margin' : (css width) + padding + border + margin
   */
  function getWH$1(elem, name, ex) {
    var extra = ex;
    if (isWindow$1(elem)) {
      return name === 'width' ? domUtils$1.viewportWidth(elem) : domUtils$1.viewportHeight(elem);
    } else if (elem.nodeType === 9) {
      return name === 'width' ? domUtils$1.docWidth(elem) : domUtils$1.docHeight(elem);
    }
    var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
    var borderBoxValue = name === 'width' ? elem.getBoundingClientRect().width : elem.getBoundingClientRect().height;
    var computedStyle = getComputedStyleX$1(elem);
    var isBorderBox = isBorderBoxFn$1(elem, computedStyle);
    var cssBoxValue = 0;
    if (borderBoxValue === null || borderBoxValue === undefined || borderBoxValue <= 0) {
      borderBoxValue = undefined;
      // Fall back to computed then un computed css if necessary
      cssBoxValue = getComputedStyleX$1(elem, name);
      if (cssBoxValue === null || cssBoxValue === undefined || Number(cssBoxValue) < 0) {
        cssBoxValue = elem.style[name] || 0;
      }
      // Normalize '', auto, and prepare for extra
      cssBoxValue = parseFloat(cssBoxValue) || 0;
    }
    if (extra === undefined) {
      extra = isBorderBox ? BORDER_INDEX$1 : CONTENT_INDEX$1;
    }
    var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
    var val = borderBoxValue || cssBoxValue;
    if (extra === CONTENT_INDEX$1) {
      if (borderBoxValueOrIsBorderBox) {
        return val - getPBMWidth$1(elem, ['border', 'padding'], which, computedStyle);
      }
      return cssBoxValue;
    } else if (borderBoxValueOrIsBorderBox) {
      if (extra === BORDER_INDEX$1) {
        return val;
      }
      return val + (extra === PADDING_INDEX$1 ? -getPBMWidth$1(elem, ['border'], which, computedStyle) : getPBMWidth$1(elem, ['margin'], which, computedStyle));
    }
    return cssBoxValue + getPBMWidth$1(elem, BOX_MODELS$1.slice(extra), which, computedStyle);
  }

  var cssShow$1 = {
    position: 'absolute',
    visibility: 'hidden',
    display: 'block'
  };

  // fix #119 : https://github.com/kissyteam/kissy/issues/119
  function getWHIgnoreDisplay$1() {
    for (var _len = arguments.length, args = Array(_len), _key2 = 0; _key2 < _len; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var val = void 0;
    var elem = args[0];
    // in case elem is window
    // elem.offsetWidth === undefined
    if (elem.offsetWidth !== 0) {
      val = getWH$1.apply(undefined, args);
    } else {
      swap$1(elem, cssShow$1, function () {
        val = getWH$1.apply(undefined, args);
      });
    }
    return val;
  }

  each$4(['width', 'height'], function (name) {
    var first = name.charAt(0).toUpperCase() + name.slice(1);
    domUtils$1['outer' + first] = function (el, includeMargin) {
      return el && getWHIgnoreDisplay$1(el, name, includeMargin ? MARGIN_INDEX$1 : BORDER_INDEX$1);
    };
    var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];

    domUtils$1[name] = function (elem, v) {
      var val = v;
      if (val !== undefined) {
        if (elem) {
          var computedStyle = getComputedStyleX$1(elem);
          var isBorderBox = isBorderBoxFn$1(elem);
          if (isBorderBox) {
            val += getPBMWidth$1(elem, ['padding', 'border'], which, computedStyle);
          }
          return css$1(elem, name, val);
        }
        return undefined;
      }
      return elem && getWHIgnoreDisplay$1(elem, name, CONTENT_INDEX$1);
    };
  });

  function mix(to, from) {
    for (var i in from) {
      if (from.hasOwnProperty(i)) {
        to[i] = from[i];
      }
    }
    return to;
  }

  var utils$2 = {
    getWindow: function getWindow(node) {
      if (node && node.document && node.setTimeout) {
        return node;
      }
      var doc = node.ownerDocument || node;
      return doc.defaultView || doc.parentWindow;
    },

    getDocument: getDocument,
    offset: function offset(el, value, option) {
      if (typeof value !== 'undefined') {
        setOffset$1(el, value, option || {});
      } else {
        return getOffset$1(el);
      }
    },

    isWindow: isWindow$1,
    each: each$4,
    css: css$1,
    clone: function clone(obj) {
      var i = void 0;
      var ret = {};
      for (i in obj) {
        if (obj.hasOwnProperty(i)) {
          ret[i] = obj[i];
        }
      }
      var overflow = obj.overflow;
      if (overflow) {
        for (i in obj) {
          if (obj.hasOwnProperty(i)) {
            ret.overflow[i] = obj.overflow[i];
          }
        }
      }
      return ret;
    },

    mix: mix,
    getWindowScrollLeft: function getWindowScrollLeft(w) {
      return getScrollLeft$1(w);
    },
    getWindowScrollTop: function getWindowScrollTop(w) {
      return getScrollTop$1(w);
    },
    merge: function merge() {
      var ret = {};

      for (var _len2 = arguments.length, args = Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
        args[_key3] = arguments[_key3];
      }

      for (var i = 0; i < args.length; i++) {
        utils$2.mix(ret, args[i]);
      }
      return ret;
    },

    viewportWidth: 0,
    viewportHeight: 0
  };

  mix(utils$2, domUtils$1);

  /**
   * 得到会导致元素显示不全的祖先元素
   */

  function getOffsetParent(element) {
    if (utils$2.isWindow(element) || element.nodeType === 9) {
      return null;
    }
    // ie 这个也不是完全可行
    /*
     <div style="width: 50px;height: 100px;overflow: hidden">
     <div style="width: 50px;height: 100px;position: relative;" id="d6">
     元素 6 高 100px 宽 50px<br/>
     </div>
     </div>
     */
    // element.offsetParent does the right thing in ie7 and below. Return parent with layout!
    //  In other browsers it only includes elements with position absolute, relative or
    // fixed, not elements with overflow set to auto or scroll.
    //        if (UA.ie && ieMode < 8) {
    //            return element.offsetParent;
    //        }
    // 统一的 offsetParent 方法
    var doc = utils$2.getDocument(element);
    var body = doc.body;
    var parent = void 0;
    var positionStyle = utils$2.css(element, 'position');
    var skipStatic = positionStyle === 'fixed' || positionStyle === 'absolute';

    if (!skipStatic) {
      return element.nodeName.toLowerCase() === 'html' ? null : element.parentNode;
    }

    for (parent = element.parentNode; parent && parent !== body; parent = parent.parentNode) {
      positionStyle = utils$2.css(parent, 'position');
      if (positionStyle !== 'static') {
        return parent;
      }
    }
    return null;
  }

  function isAncestorFixed(element) {
    if (utils$2.isWindow(element) || element.nodeType === 9) {
      return false;
    }

    var doc = utils$2.getDocument(element);
    var body = doc.body;
    var parent = null;
    for (parent = element.parentNode; parent && parent !== body; parent = parent.parentNode) {
      var positionStyle = utils$2.css(parent, 'position');
      if (positionStyle === 'fixed') {
        return true;
      }
    }
    return false;
  }

  /**
   * 获得元素的显示部分的区域
   */
  function getVisibleRectForElement(element) {
    var visibleRect = {
      left: 0,
      right: Infinity,
      top: 0,
      bottom: Infinity
    };
    var el = getOffsetParent(element);
    var doc = utils$2.getDocument(element);
    var win = doc.defaultView || doc.parentWindow;
    var body = doc.body;
    var documentElement = doc.documentElement;

    // Determine the size of the visible rect by climbing the dom accounting for
    // all scrollable containers.
    while (el) {
      // clientWidth is zero for inline block elements in ie.
      if ((navigator.userAgent.indexOf('MSIE') === -1 || el.clientWidth !== 0) &&
      // body may have overflow set on it, yet we still get the entire
      // viewport. In some browsers, el.offsetParent may be
      // document.documentElement, so check for that too.
      el !== body && el !== documentElement && utils$2.css(el, 'overflow') !== 'visible') {
        var pos = utils$2.offset(el);
        // add border
        pos.left += el.clientLeft;
        pos.top += el.clientTop;
        visibleRect.top = Math.max(visibleRect.top, pos.top);
        visibleRect.right = Math.min(visibleRect.right,
        // consider area without scrollBar
        pos.left + el.clientWidth);
        visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);
        visibleRect.left = Math.max(visibleRect.left, pos.left);
      } else if (el === body || el === documentElement) {
        break;
      }
      el = getOffsetParent(el);
    }

    // Set element position to fixed
    // make sure absolute element itself don't affect it's visible area
    // https://github.com/ant-design/ant-design/issues/7601
    var originalPosition = null;
    if (!utils$2.isWindow(element) && element.nodeType !== 9) {
      originalPosition = element.style.position;
      var position = utils$2.css(element, 'position');
      if (position === 'absolute') {
        element.style.position = 'fixed';
      }
    }

    var scrollX = utils$2.getWindowScrollLeft(win);
    var scrollY = utils$2.getWindowScrollTop(win);
    var viewportWidth = utils$2.viewportWidth(win);
    var viewportHeight = utils$2.viewportHeight(win);
    var documentWidth = documentElement.scrollWidth;
    var documentHeight = documentElement.scrollHeight;

    // Reset element position after calculate the visible area
    if (element.style) {
      element.style.position = originalPosition;
    }

    if (isAncestorFixed(element)) {
      // Clip by viewport's size.
      visibleRect.left = Math.max(visibleRect.left, scrollX);
      visibleRect.top = Math.max(visibleRect.top, scrollY);
      visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);
      visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);
    } else {
      // Clip by document's size.
      var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);
      visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);

      var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);
      visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);
    }

    return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
  }

  function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
    var pos = utils$2.clone(elFuturePos);
    var size = {
      width: elRegion.width,
      height: elRegion.height
    };

    if (overflow.adjustX && pos.left < visibleRect.left) {
      pos.left = visibleRect.left;
    }

    // Left edge inside and right edge outside viewport, try to resize it.
    if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) {
      size.width -= pos.left + size.width - visibleRect.right;
    }

    // Right edge outside viewport, try to move it.
    if (overflow.adjustX && pos.left + size.width > visibleRect.right) {
      // 保证左边界和可视区域左边界对齐
      pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);
    }

    // Top edge outside viewport, try to move it.
    if (overflow.adjustY && pos.top < visibleRect.top) {
      pos.top = visibleRect.top;
    }

    // Top edge inside and bottom edge outside viewport, try to resize it.
    if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) {
      size.height -= pos.top + size.height - visibleRect.bottom;
    }

    // Bottom edge outside viewport, try to move it.
    if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) {
      // 保证上边界和可视区域上边界对齐
      pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);
    }

    return utils$2.mix(pos, size);
  }

  function getRegion(node) {
    var offset = void 0;
    var w = void 0;
    var h = void 0;
    if (!utils$2.isWindow(node) && node.nodeType !== 9) {
      offset = utils$2.offset(node);
      w = utils$2.outerWidth(node);
      h = utils$2.outerHeight(node);
    } else {
      var win = utils$2.getWindow(node);
      offset = {
        left: utils$2.getWindowScrollLeft(win),
        top: utils$2.getWindowScrollTop(win)
      };
      w = utils$2.viewportWidth(win);
      h = utils$2.viewportHeight(win);
    }
    offset.width = w;
    offset.height = h;
    return offset;
  }

  /**
   * 获取 node 上的 align 对齐点 相对于页面的坐标
   */

  function getAlignOffset(region, align) {
    var V = align.charAt(0);
    var H = align.charAt(1);
    var w = region.width;
    var h = region.height;

    var x = region.left;
    var y = region.top;

    if (V === 'c') {
      y += h / 2;
    } else if (V === 'b') {
      y += h;
    }

    if (H === 'c') {
      x += w / 2;
    } else if (H === 'r') {
      x += w;
    }

    return {
      left: x,
      top: y
    };
  }

  function getElFuturePos(elRegion, refNodeRegion, points, offset, targetOffset) {
    var p1 = getAlignOffset(refNodeRegion, points[1]);
    var p2 = getAlignOffset(elRegion, points[0]);
    var diff = [p2.left - p1.left, p2.top - p1.top];

    return {
      left: elRegion.left - diff[0] + offset[0] - targetOffset[0],
      top: elRegion.top - diff[1] + offset[1] - targetOffset[1]
    };
  }

  /**
   * align dom node flexibly
   * @author yiminghe@gmail.com
   */

  // http://yiminghe.iteye.com/blog/1124720

  function isFailX(elFuturePos, elRegion, visibleRect) {
    return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
  }

  function isFailY(elFuturePos, elRegion, visibleRect) {
    return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
  }

  function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
    return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
  }

  function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
    return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
  }

  function flip(points, reg, map) {
    var ret = [];
    utils$2.each(points, function (p) {
      ret.push(p.replace(reg, function (m) {
        return map[m];
      }));
    });
    return ret;
  }

  function flipOffset(offset, index) {
    offset[index] = -offset[index];
    return offset;
  }

  function convertOffset(str, offsetLen) {
    var n = void 0;
    if (/%$/.test(str)) {
      n = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
    } else {
      n = parseInt(str, 10);
    }
    return n || 0;
  }

  function normalizeOffset(offset, el) {
    offset[0] = convertOffset(offset[0], el.width);
    offset[1] = convertOffset(offset[1], el.height);
  }

  /**
   * @param el
   * @param tgtRegion 参照节点所占的区域: { left, top, width, height }
   * @param align
   */
  function doAlign(el, tgtRegion, align, isTgtRegionVisible) {
    var points = align.points;
    var offset = align.offset || [0, 0];
    var targetOffset = align.targetOffset || [0, 0];
    var overflow = align.overflow;
    var source = align.source || el;
    offset = [].concat(offset);
    targetOffset = [].concat(targetOffset);
    overflow = overflow || {};
    var newOverflowCfg = {};
    var fail = 0;
    // 当前节点可以被放置的显示区域
    var visibleRect = getVisibleRectForElement(source);
    // 当前节点所占的区域, left/top/width/height
    var elRegion = getRegion(source);
    // 将 offset 转换成数值，支持百分比
    normalizeOffset(offset, elRegion);
    normalizeOffset(targetOffset, tgtRegion);
    // 当前节点将要被放置的位置
    var elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset, targetOffset);
    // 当前节点将要所处的区域
    var newElRegion = utils$2.merge(elRegion, elFuturePos);

    // 如果可视区域不能完全放置当前节点时允许调整
    if (visibleRect && (overflow.adjustX || overflow.adjustY) && isTgtRegionVisible) {
      if (overflow.adjustX) {
        // 如果横向不能放下
        if (isFailX(elFuturePos, elRegion, visibleRect)) {
          // 对齐位置反下
          var newPoints = flip(points, /[lr]/ig, {
            l: 'r',
            r: 'l'
          });
          // 偏移量也反下
          var newOffset = flipOffset(offset, 0);
          var newTargetOffset = flipOffset(targetOffset, 0);
          var newElFuturePos = getElFuturePos(elRegion, tgtRegion, newPoints, newOffset, newTargetOffset);

          if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
            fail = 1;
            points = newPoints;
            offset = newOffset;
            targetOffset = newTargetOffset;
          }
        }
      }

      if (overflow.adjustY) {
        // 如果纵向不能放下
        if (isFailY(elFuturePos, elRegion, visibleRect)) {
          // 对齐位置反下
          var _newPoints = flip(points, /[tb]/ig, {
            t: 'b',
            b: 't'
          });
          // 偏移量也反下
          var _newOffset = flipOffset(offset, 1);
          var _newTargetOffset = flipOffset(targetOffset, 1);
          var _newElFuturePos = getElFuturePos(elRegion, tgtRegion, _newPoints, _newOffset, _newTargetOffset);

          if (!isCompleteFailY(_newElFuturePos, elRegion, visibleRect)) {
            fail = 1;
            points = _newPoints;
            offset = _newOffset;
            targetOffset = _newTargetOffset;
          }
        }
      }

      // 如果失败，重新计算当前节点将要被放置的位置
      if (fail) {
        elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset, targetOffset);
        utils$2.mix(newElRegion, elFuturePos);
      }
      var isStillFailX = isFailX(elFuturePos, elRegion, visibleRect);
      var isStillFailY = isFailY(elFuturePos, elRegion, visibleRect);
      // 检查反下后的位置是否可以放下了，如果仍然放不下：
      // 1. 复原修改过的定位参数
      if (isStillFailX || isStillFailY) {
        points = align.points;
        offset = align.offset || [0, 0];
        targetOffset = align.targetOffset || [0, 0];
      }
      // 2. 只有指定了可以调整当前方向才调整
      newOverflowCfg.adjustX = overflow.adjustX && isStillFailX;
      newOverflowCfg.adjustY = overflow.adjustY && isStillFailY;

      // 确实要调整，甚至可能会调整高度宽度
      if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
        newElRegion = adjustForViewport(elFuturePos, elRegion, visibleRect, newOverflowCfg);
      }
    }

    // need judge to in case set fixed with in css on height auto element
    if (newElRegion.width !== elRegion.width) {
      utils$2.css(source, 'width', utils$2.width(source) + newElRegion.width - elRegion.width);
    }

    if (newElRegion.height !== elRegion.height) {
      utils$2.css(source, 'height', utils$2.height(source) + newElRegion.height - elRegion.height);
    }

    // https://github.com/kissyteam/kissy/issues/190
    // 相对于屏幕位置没变，而 left/top 变了
    // 例如 <div 'relative'><el absolute></div>
    utils$2.offset(source, {
      left: newElRegion.left,
      top: newElRegion.top
    }, {
      useCssRight: align.useCssRight,
      useCssBottom: align.useCssBottom,
      useCssTransform: align.useCssTransform,
      ignoreShake: align.ignoreShake
    });

    return {
      points: points,
      offset: offset,
      targetOffset: targetOffset,
      overflow: newOverflowCfg
    };
  }
  /**
   *  2012-04-26 yiminghe@gmail.com
   *   - 优化智能对齐算法
   *   - 慎用 resizeXX
   *
   *  2011-07-13 yiminghe@gmail.com note:
   *   - 增加智能对齐，以及大小调整选项
   **/

  function isOutOfVisibleRect(target) {
    var visibleRect = getVisibleRectForElement(target);
    var targetRegion = getRegion(target);

    return !visibleRect || targetRegion.left + targetRegion.width <= visibleRect.left || targetRegion.top + targetRegion.height <= visibleRect.top || targetRegion.left >= visibleRect.right || targetRegion.top >= visibleRect.bottom;
  }

  function alignElement(el, refNode, align) {
    var target = align.target || refNode;
    var refNodeRegion = getRegion(target);

    var isTargetNotOutOfVisible = !isOutOfVisibleRect(target);

    return doAlign(el, refNodeRegion, align, isTargetNotOutOfVisible);
  }

  alignElement.__getOffsetParent = getOffsetParent;

  alignElement.__getVisibleRectForElement = getVisibleRectForElement;

  var _extends$4 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  /**
   * `tgtPoint`: { pageX, pageY } or { clientX, clientY }.
   * If client position provided, will internal convert to page position.
   */

  function alignPoint(el, tgtPoint, align) {
    var pageX = void 0;
    var pageY = void 0;

    var doc = utils$2.getDocument(el);
    var win = doc.defaultView || doc.parentWindow;

    var scrollX = utils$2.getWindowScrollLeft(win);
    var scrollY = utils$2.getWindowScrollTop(win);
    var viewportWidth = utils$2.viewportWidth(win);
    var viewportHeight = utils$2.viewportHeight(win);

    if ('pageX' in tgtPoint) {
      pageX = tgtPoint.pageX;
    } else {
      pageX = scrollX + tgtPoint.clientX;
    }

    if ('pageY' in tgtPoint) {
      pageY = tgtPoint.pageY;
    } else {
      pageY = scrollY + tgtPoint.clientY;
    }

    var tgtRegion = {
      left: pageX,
      top: pageY,
      width: 0,
      height: 0
    };

    var pointInView = pageX >= 0 && pageX <= scrollX + viewportWidth && pageY >= 0 && pageY <= scrollY + viewportHeight;

    // Provide default target point
    var points = [align.points[0], 'cc'];

    return doAlign(el, tgtRegion, _extends$4({}, align, { points: points }), pointInView);
  }

  function buffer(fn, ms) {
    var timer = void 0;

    function clear() {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
    }

    function bufferFn() {
      clear();
      timer = setTimeout(fn, ms);
    }

    bufferFn.clear = clear;

    return bufferFn;
  }

  function isSamePoint(prev, next) {
    if (prev === next) return true;
    if (!prev || !next) return false;

    if ('pageX' in next && 'pageY' in next) {
      return prev.pageX === next.pageX && prev.pageY === next.pageY;
    }

    if ('clientX' in next && 'clientY' in next) {
      return prev.clientX === next.clientX && prev.clientY === next.clientY;
    }

    return false;
  }

  function isWindow$2(obj) {
    return obj && typeof obj === 'object' && obj.window === obj;
  }

  function getElement(func) {
    if (typeof func !== 'function' || !func) return null;
    return func();
  }

  function getPoint(point) {
    if (typeof point !== 'object' || !point) return null;
    return point;
  }

  var Align = function (_Component) {
    _inherits$1(Align, _Component);

    function Align() {
      var _temp, _this, _ret;

      _classCallCheck$1(this, Align);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn$1(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.forceAlign = function () {
        var _this$props = _this.props,
            disabled = _this$props.disabled,
            target = _this$props.target,
            align = _this$props.align,
            onAlign = _this$props.onAlign;

        if (!disabled && target) {
          var source = ReactDOM__default.findDOMNode(_this);

          var result = void 0;
          var element = getElement(target);
          var point = getPoint(target);

          if (element) {
            result = alignElement(source, element, align);
          } else if (point) {
            result = alignPoint(source, point, align);
          }

          if (onAlign) {
            onAlign(source, result);
          }
        }
      }, _temp), _possibleConstructorReturn$1(_this, _ret);
    }

    Align.prototype.componentDidMount = function componentDidMount() {
      var props = this.props;
      // if parent ref not attached .... use document.getElementById
      this.forceAlign();
      if (!props.disabled && props.monitorWindowResize) {
        this.startMonitorWindowResize();
      }
    };

    Align.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
      var reAlign = false;
      var props = this.props;

      if (!props.disabled) {
        var source = ReactDOM__default.findDOMNode(this);
        var sourceRect = source ? source.getBoundingClientRect() : null;

        if (prevProps.disabled) {
          reAlign = true;
        } else {
          var lastElement = getElement(prevProps.target);
          var currentElement = getElement(props.target);
          var lastPoint = getPoint(prevProps.target);
          var currentPoint = getPoint(props.target);

          if (isWindow$2(lastElement) && isWindow$2(currentElement)) {
            // Skip if is window
            reAlign = false;
          } else if (lastElement !== currentElement || // Element change
          lastElement && !currentElement && currentPoint || // Change from element to point
          lastPoint && currentPoint && currentElement || // Change from point to element
          currentPoint && !isSamePoint(lastPoint, currentPoint)) {
            reAlign = true;
          }

          // If source element size changed
          var preRect = this.sourceRect || {};
          if (!reAlign && source && (preRect.width !== sourceRect.width || preRect.height !== sourceRect.height)) {
            reAlign = true;
          }
        }

        this.sourceRect = sourceRect;
      }

      if (reAlign) {
        this.forceAlign();
      }

      if (props.monitorWindowResize && !props.disabled) {
        this.startMonitorWindowResize();
      } else {
        this.stopMonitorWindowResize();
      }
    };

    Align.prototype.componentWillUnmount = function componentWillUnmount() {
      this.stopMonitorWindowResize();
    };

    Align.prototype.startMonitorWindowResize = function startMonitorWindowResize() {
      if (!this.resizeHandler) {
        this.bufferMonitor = buffer(this.forceAlign, this.props.monitorBufferTime);
        this.resizeHandler = addEventListenerWrap(window, 'resize', this.bufferMonitor);
      }
    };

    Align.prototype.stopMonitorWindowResize = function stopMonitorWindowResize() {
      if (this.resizeHandler) {
        this.bufferMonitor.clear();
        this.resizeHandler.remove();
        this.resizeHandler = null;
      }
    };

    Align.prototype.render = function render() {
      var _this2 = this;

      var _props = this.props,
          childrenProps = _props.childrenProps,
          children = _props.children;

      var child = React$1__default.Children.only(children);
      if (childrenProps) {
        var newProps = {};
        var propList = Object.keys(childrenProps);
        propList.forEach(function (prop) {
          newProps[prop] = _this2.props[childrenProps[prop]];
        });

        return React$1__default.cloneElement(child, newProps);
      }
      return child;
    };

    return Align;
  }(React$1.Component);

  Align.propTypes = {
    childrenProps: PropTypes.object,
    align: PropTypes.object.isRequired,
    target: PropTypes.oneOfType([PropTypes.func, PropTypes.shape({
      clientX: PropTypes.number,
      clientY: PropTypes.number,
      pageX: PropTypes.number,
      pageY: PropTypes.number
    })]),
    onAlign: PropTypes.func,
    monitorBufferTime: PropTypes.number,
    monitorWindowResize: PropTypes.bool,
    disabled: PropTypes.bool,
    children: PropTypes.any
  };
  Align.defaultProps = {
    target: function target() {
      return window;
    },
    monitorBufferTime: 50,
    monitorWindowResize: false,
    disabled: false
  };

  // export this package's api

  var LazyRenderBox = function (_Component) {
    _inherits$1(LazyRenderBox, _Component);

    function LazyRenderBox() {
      _classCallCheck$1(this, LazyRenderBox);

      return _possibleConstructorReturn$1(this, _Component.apply(this, arguments));
    }

    LazyRenderBox.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      return nextProps.hiddenClassName || nextProps.visible;
    };

    LazyRenderBox.prototype.render = function render() {
      var _props = this.props,
          hiddenClassName = _props.hiddenClassName,
          visible = _props.visible,
          props = _objectWithoutProperties$1(_props, ['hiddenClassName', 'visible']);

      if (hiddenClassName || React$1__default.Children.count(props.children) > 1) {
        if (!visible && hiddenClassName) {
          props.className += ' ' + hiddenClassName;
        }
        return React$1__default.createElement('div', props);
      }

      return React$1__default.Children.only(props.children);
    };

    return LazyRenderBox;
  }(React$1.Component);

  LazyRenderBox.propTypes = {
    children: PropTypes.any,
    className: PropTypes.string,
    visible: PropTypes.bool,
    hiddenClassName: PropTypes.string
  };

  var PopupInner = function (_Component) {
    _inherits$1(PopupInner, _Component);

    function PopupInner() {
      _classCallCheck$1(this, PopupInner);

      return _possibleConstructorReturn$1(this, _Component.apply(this, arguments));
    }

    PopupInner.prototype.render = function render() {
      var props = this.props;
      var className = props.className;
      if (!props.visible) {
        className += ' ' + props.hiddenClassName;
      }
      return React$1__default.createElement(
        'div',
        {
          className: className,
          onMouseEnter: props.onMouseEnter,
          onMouseLeave: props.onMouseLeave,
          onMouseDown: props.onMouseDown,
          onTouchStart: props.onTouchStart,
          style: props.style
        },
        React$1__default.createElement(
          LazyRenderBox,
          { className: props.prefixCls + '-content', visible: props.visible },
          props.children
        )
      );
    };

    return PopupInner;
  }(React$1.Component);

  PopupInner.propTypes = {
    hiddenClassName: PropTypes.string,
    className: PropTypes.string,
    prefixCls: PropTypes.string,
    onMouseEnter: PropTypes.func,
    onMouseLeave: PropTypes.func,
    onMouseDown: PropTypes.func,
    onTouchStart: PropTypes.func,
    children: PropTypes.any
  };

  var Popup = function (_Component) {
    _inherits$1(Popup, _Component);

    function Popup(props) {
      _classCallCheck$1(this, Popup);

      var _this = _possibleConstructorReturn$1(this, _Component.call(this, props));

      _initialiseProps$1.call(_this);

      _this.state = {
        // Used for stretch
        stretchChecked: false,
        targetWidth: undefined,
        targetHeight: undefined
      };

      _this.savePopupRef = saveRef.bind(_this, 'popupInstance');
      _this.saveAlignRef = saveRef.bind(_this, 'alignInstance');
      return _this;
    }

    Popup.prototype.componentDidMount = function componentDidMount() {
      this.rootNode = this.getPopupDomNode();
      this.setStretchSize();
    };

    Popup.prototype.componentDidUpdate = function componentDidUpdate() {
      this.setStretchSize();
    };

    // Record size if stretch needed


    Popup.prototype.getPopupDomNode = function getPopupDomNode() {
      return ReactDOM__default.findDOMNode(this.popupInstance);
    };

    // `target` on `rc-align` can accept as a function to get the bind element or a point.
    // ref: https://www.npmjs.com/package/rc-align


    Popup.prototype.getMaskTransitionName = function getMaskTransitionName() {
      var props = this.props;
      var transitionName = props.maskTransitionName;
      var animation = props.maskAnimation;
      if (!transitionName && animation) {
        transitionName = props.prefixCls + '-' + animation;
      }
      return transitionName;
    };

    Popup.prototype.getTransitionName = function getTransitionName() {
      var props = this.props;
      var transitionName = props.transitionName;
      if (!transitionName && props.animation) {
        transitionName = props.prefixCls + '-' + props.animation;
      }
      return transitionName;
    };

    Popup.prototype.getClassName = function getClassName(currentAlignClassName) {
      return this.props.prefixCls + ' ' + this.props.className + ' ' + currentAlignClassName;
    };

    Popup.prototype.getPopupElement = function getPopupElement() {
      var _this2 = this;

      var savePopupRef = this.savePopupRef;
      var _state = this.state,
          stretchChecked = _state.stretchChecked,
          targetHeight = _state.targetHeight,
          targetWidth = _state.targetWidth;
      var _props = this.props,
          align = _props.align,
          visible = _props.visible,
          prefixCls = _props.prefixCls,
          style = _props.style,
          getClassNameFromAlign = _props.getClassNameFromAlign,
          destroyPopupOnHide = _props.destroyPopupOnHide,
          stretch = _props.stretch,
          children = _props.children,
          onMouseEnter = _props.onMouseEnter,
          onMouseLeave = _props.onMouseLeave,
          onMouseDown = _props.onMouseDown,
          onTouchStart = _props.onTouchStart;

      var className = this.getClassName(this.currentAlignClassName || getClassNameFromAlign(align));
      var hiddenClassName = prefixCls + '-hidden';

      if (!visible) {
        this.currentAlignClassName = null;
      }

      var sizeStyle = {};
      if (stretch) {
        // Stretch with target
        if (stretch.indexOf('height') !== -1) {
          sizeStyle.height = targetHeight;
        } else if (stretch.indexOf('minHeight') !== -1) {
          sizeStyle.minHeight = targetHeight;
        }
        if (stretch.indexOf('width') !== -1) {
          sizeStyle.width = targetWidth;
        } else if (stretch.indexOf('minWidth') !== -1) {
          sizeStyle.minWidth = targetWidth;
        }

        // Delay force align to makes ui smooth
        if (!stretchChecked) {
          sizeStyle.visibility = 'hidden';
          setTimeout(function () {
            if (_this2.alignInstance) {
              _this2.alignInstance.forceAlign();
            }
          }, 0);
        }
      }

      var newStyle = _extends$2({}, sizeStyle, style, this.getZIndexStyle());

      var popupInnerProps = {
        className: className,
        prefixCls: prefixCls,
        ref: savePopupRef,
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
        onMouseDown: onMouseDown,
        onTouchStart: onTouchStart,
        style: newStyle
      };
      if (destroyPopupOnHide) {
        return React$1__default.createElement(
          Animate,
          {
            component: '',
            exclusive: true,
            transitionAppear: true,
            transitionName: this.getTransitionName()
          },
          visible ? React$1__default.createElement(
            Align,
            {
              target: this.getAlignTarget(),
              key: 'popup',
              ref: this.saveAlignRef,
              monitorWindowResize: true,
              align: align,
              onAlign: this.onAlign
            },
            React$1__default.createElement(
              PopupInner,
              _extends$2({
                visible: true
              }, popupInnerProps),
              children
            )
          ) : null
        );
      }

      return React$1__default.createElement(
        Animate,
        {
          component: '',
          exclusive: true,
          transitionAppear: true,
          transitionName: this.getTransitionName(),
          showProp: 'xVisible'
        },
        React$1__default.createElement(
          Align,
          {
            target: this.getAlignTarget(),
            key: 'popup',
            ref: this.saveAlignRef,
            monitorWindowResize: true,
            xVisible: visible,
            childrenProps: { visible: 'xVisible' },
            disabled: !visible,
            align: align,
            onAlign: this.onAlign
          },
          React$1__default.createElement(
            PopupInner,
            _extends$2({
              hiddenClassName: hiddenClassName
            }, popupInnerProps),
            children
          )
        )
      );
    };

    Popup.prototype.getZIndexStyle = function getZIndexStyle() {
      var style = {};
      var props = this.props;
      if (props.zIndex !== undefined) {
        style.zIndex = props.zIndex;
      }
      return style;
    };

    Popup.prototype.getMaskElement = function getMaskElement() {
      var props = this.props;
      var maskElement = void 0;
      if (props.mask) {
        var maskTransition = this.getMaskTransitionName();
        maskElement = React$1__default.createElement(LazyRenderBox, {
          style: this.getZIndexStyle(),
          key: 'mask',
          className: props.prefixCls + '-mask',
          hiddenClassName: props.prefixCls + '-mask-hidden',
          visible: props.visible
        });
        if (maskTransition) {
          maskElement = React$1__default.createElement(
            Animate,
            {
              key: 'mask',
              showProp: 'visible',
              transitionAppear: true,
              component: '',
              transitionName: maskTransition
            },
            maskElement
          );
        }
      }
      return maskElement;
    };

    Popup.prototype.render = function render() {
      return React$1__default.createElement(
        'div',
        null,
        this.getMaskElement(),
        this.getPopupElement()
      );
    };

    return Popup;
  }(React$1.Component);

  Popup.propTypes = {
    visible: PropTypes.bool,
    style: PropTypes.object,
    getClassNameFromAlign: PropTypes.func,
    onAlign: PropTypes.func,
    getRootDomNode: PropTypes.func,
    align: PropTypes.any,
    destroyPopupOnHide: PropTypes.bool,
    className: PropTypes.string,
    prefixCls: PropTypes.string,
    onMouseEnter: PropTypes.func,
    onMouseLeave: PropTypes.func,
    onMouseDown: PropTypes.func,
    onTouchStart: PropTypes.func,
    stretch: PropTypes.string,
    children: PropTypes.node,
    point: PropTypes.shape({
      pageX: PropTypes.number,
      pageY: PropTypes.number
    })
  };

  var _initialiseProps$1 = function _initialiseProps() {
    var _this3 = this;

    this.onAlign = function (popupDomNode, align) {
      var props = _this3.props;
      var currentAlignClassName = props.getClassNameFromAlign(align);
      // FIX: https://github.com/react-component/trigger/issues/56
      // FIX: https://github.com/react-component/tooltip/issues/79
      if (_this3.currentAlignClassName !== currentAlignClassName) {
        _this3.currentAlignClassName = currentAlignClassName;
        popupDomNode.className = _this3.getClassName(currentAlignClassName);
      }
      props.onAlign(popupDomNode, align);
    };

    this.setStretchSize = function () {
      var _props2 = _this3.props,
          stretch = _props2.stretch,
          getRootDomNode = _props2.getRootDomNode,
          visible = _props2.visible;
      var _state2 = _this3.state,
          stretchChecked = _state2.stretchChecked,
          targetHeight = _state2.targetHeight,
          targetWidth = _state2.targetWidth;


      if (!stretch || !visible) {
        if (stretchChecked) {
          _this3.setState({ stretchChecked: false });
        }
        return;
      }

      var $ele = getRootDomNode();
      if (!$ele) return;

      var height = $ele.offsetHeight;
      var width = $ele.offsetWidth;

      if (targetHeight !== height || targetWidth !== width || !stretchChecked) {
        _this3.setState({
          stretchChecked: true,
          targetHeight: height,
          targetWidth: width
        });
      }
    };

    this.getTargetElement = function () {
      return _this3.props.getRootDomNode();
    };

    this.getAlignTarget = function () {
      var point = _this3.props.point;

      if (point) {
        return point;
      }
      return _this3.getTargetElement;
    };
  };

  function noop$2() {}

  function returnEmptyString() {
    return '';
  }

  function returnDocument() {
    return window.document;
  }

  var ALL_HANDLERS = ['onClick', 'onMouseDown', 'onTouchStart', 'onMouseEnter', 'onMouseLeave', 'onFocus', 'onBlur', 'onContextMenu'];

  var IS_REACT_16 = !!ReactDOM.createPortal;

  var contextTypes = {
    rcTrigger: PropTypes.shape({
      onPopupMouseDown: PropTypes.func
    })
  };

  var Trigger = function (_React$Component) {
    _inherits$1(Trigger, _React$Component);

    function Trigger(props) {
      _classCallCheck$1(this, Trigger);

      var _this = _possibleConstructorReturn$1(this, _React$Component.call(this, props));

      _initialiseProps$2.call(_this);

      var popupVisible = void 0;
      if ('popupVisible' in props) {
        popupVisible = !!props.popupVisible;
      } else {
        popupVisible = !!props.defaultPopupVisible;
      }

      _this.prevPopupVisible = popupVisible;

      _this.state = {
        popupVisible: popupVisible
      };
      return _this;
    }

    Trigger.prototype.getChildContext = function getChildContext() {
      return {
        rcTrigger: {
          onPopupMouseDown: this.onPopupMouseDown
        }
      };
    };

    Trigger.prototype.componentWillMount = function componentWillMount() {
      var _this2 = this;

      ALL_HANDLERS.forEach(function (h) {
        _this2['fire' + h] = function (e) {
          _this2.fireEvents(h, e);
        };
      });
    };

    Trigger.prototype.componentDidMount = function componentDidMount() {
      this.componentDidUpdate({}, {
        popupVisible: this.state.popupVisible
      });
    };

    Trigger.prototype.componentWillReceiveProps = function componentWillReceiveProps(_ref) {
      var popupVisible = _ref.popupVisible;

      if (popupVisible !== undefined) {
        this.setState({
          popupVisible: popupVisible
        });
      }
    };

    Trigger.prototype.componentDidUpdate = function componentDidUpdate(_, prevState) {
      var props = this.props;
      var state = this.state;
      var triggerAfterPopupVisibleChange = function triggerAfterPopupVisibleChange() {
        if (prevState.popupVisible !== state.popupVisible) {
          props.afterPopupVisibleChange(state.popupVisible);
        }
      };
      if (!IS_REACT_16) {
        this.renderComponent(null, triggerAfterPopupVisibleChange);
      }

      this.prevPopupVisible = prevState.popupVisible;

      // We must listen to `mousedown` or `touchstart`, edge case:
      // https://github.com/ant-design/ant-design/issues/5804
      // https://github.com/react-component/calendar/issues/250
      // https://github.com/react-component/trigger/issues/50
      if (state.popupVisible) {
        var currentDocument = void 0;
        if (!this.clickOutsideHandler && (this.isClickToHide() || this.isContextMenuToShow())) {
          currentDocument = props.getDocument();
          this.clickOutsideHandler = addEventListenerWrap(currentDocument, 'mousedown', this.onDocumentClick);
        }
        // always hide on mobile
        if (!this.touchOutsideHandler) {
          currentDocument = currentDocument || props.getDocument();
          this.touchOutsideHandler = addEventListenerWrap(currentDocument, 'touchstart', this.onDocumentClick);
        }
        // close popup when trigger type contains 'onContextMenu' and document is scrolling.
        if (!this.contextMenuOutsideHandler1 && this.isContextMenuToShow()) {
          currentDocument = currentDocument || props.getDocument();
          this.contextMenuOutsideHandler1 = addEventListenerWrap(currentDocument, 'scroll', this.onContextMenuClose);
        }
        // close popup when trigger type contains 'onContextMenu' and window is blur.
        if (!this.contextMenuOutsideHandler2 && this.isContextMenuToShow()) {
          this.contextMenuOutsideHandler2 = addEventListenerWrap(window, 'blur', this.onContextMenuClose);
        }
        return;
      }

      this.clearOutsideHandler();
    };

    Trigger.prototype.componentWillUnmount = function componentWillUnmount() {
      this.clearDelayTimer();
      this.clearOutsideHandler();
      clearTimeout(this.mouseDownTimeout);
    };

    Trigger.prototype.getPopupDomNode = function getPopupDomNode() {
      // for test
      if (this._component && this._component.getPopupDomNode) {
        return this._component.getPopupDomNode();
      }
      return null;
    };

    Trigger.prototype.getPopupAlign = function getPopupAlign() {
      var props = this.props;
      var popupPlacement = props.popupPlacement,
          popupAlign = props.popupAlign,
          builtinPlacements = props.builtinPlacements;

      if (popupPlacement && builtinPlacements) {
        return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
      }
      return popupAlign;
    };

    /**
     * @param popupVisible    Show or not the popup element
     * @param event           SyntheticEvent, used for `pointAlign`
     */
    Trigger.prototype.setPopupVisible = function setPopupVisible(popupVisible, event) {
      var alignPoint = this.props.alignPoint;


      this.clearDelayTimer();

      if (this.state.popupVisible !== popupVisible) {
        if (!('popupVisible' in this.props)) {
          this.setState({ popupVisible: popupVisible });
        }
        this.props.onPopupVisibleChange(popupVisible);
      }

      // Always record the point position since mouseEnterDelay will delay the show
      if (alignPoint && event) {
        this.setPoint(event);
      }
    };

    Trigger.prototype.delaySetPopupVisible = function delaySetPopupVisible(visible, delayS, event) {
      var _this3 = this;

      var delay = delayS * 1000;
      this.clearDelayTimer();
      if (delay) {
        var point = event ? { pageX: event.pageX, pageY: event.pageY } : null;
        this.delayTimer = setTimeout(function () {
          _this3.setPopupVisible(visible, point);
          _this3.clearDelayTimer();
        }, delay);
      } else {
        this.setPopupVisible(visible, event);
      }
    };

    Trigger.prototype.clearDelayTimer = function clearDelayTimer() {
      if (this.delayTimer) {
        clearTimeout(this.delayTimer);
        this.delayTimer = null;
      }
    };

    Trigger.prototype.clearOutsideHandler = function clearOutsideHandler() {
      if (this.clickOutsideHandler) {
        this.clickOutsideHandler.remove();
        this.clickOutsideHandler = null;
      }

      if (this.contextMenuOutsideHandler1) {
        this.contextMenuOutsideHandler1.remove();
        this.contextMenuOutsideHandler1 = null;
      }

      if (this.contextMenuOutsideHandler2) {
        this.contextMenuOutsideHandler2.remove();
        this.contextMenuOutsideHandler2 = null;
      }

      if (this.touchOutsideHandler) {
        this.touchOutsideHandler.remove();
        this.touchOutsideHandler = null;
      }
    };

    Trigger.prototype.createTwoChains = function createTwoChains(event) {
      var childPros = this.props.children.props;
      var props = this.props;
      if (childPros[event] && props[event]) {
        return this['fire' + event];
      }
      return childPros[event] || props[event];
    };

    Trigger.prototype.isClickToShow = function isClickToShow() {
      var _props = this.props,
          action = _props.action,
          showAction = _props.showAction;

      return action.indexOf('click') !== -1 || showAction.indexOf('click') !== -1;
    };

    Trigger.prototype.isContextMenuToShow = function isContextMenuToShow() {
      var _props2 = this.props,
          action = _props2.action,
          showAction = _props2.showAction;

      return action.indexOf('contextMenu') !== -1 || showAction.indexOf('contextMenu') !== -1;
    };

    Trigger.prototype.isClickToHide = function isClickToHide() {
      var _props3 = this.props,
          action = _props3.action,
          hideAction = _props3.hideAction;

      return action.indexOf('click') !== -1 || hideAction.indexOf('click') !== -1;
    };

    Trigger.prototype.isMouseEnterToShow = function isMouseEnterToShow() {
      var _props4 = this.props,
          action = _props4.action,
          showAction = _props4.showAction;

      return action.indexOf('hover') !== -1 || showAction.indexOf('mouseEnter') !== -1;
    };

    Trigger.prototype.isMouseLeaveToHide = function isMouseLeaveToHide() {
      var _props5 = this.props,
          action = _props5.action,
          hideAction = _props5.hideAction;

      return action.indexOf('hover') !== -1 || hideAction.indexOf('mouseLeave') !== -1;
    };

    Trigger.prototype.isFocusToShow = function isFocusToShow() {
      var _props6 = this.props,
          action = _props6.action,
          showAction = _props6.showAction;

      return action.indexOf('focus') !== -1 || showAction.indexOf('focus') !== -1;
    };

    Trigger.prototype.isBlurToHide = function isBlurToHide() {
      var _props7 = this.props,
          action = _props7.action,
          hideAction = _props7.hideAction;

      return action.indexOf('focus') !== -1 || hideAction.indexOf('blur') !== -1;
    };

    Trigger.prototype.forcePopupAlign = function forcePopupAlign() {
      if (this.state.popupVisible && this._component && this._component.alignInstance) {
        this._component.alignInstance.forceAlign();
      }
    };

    Trigger.prototype.fireEvents = function fireEvents(type, e) {
      var childCallback = this.props.children.props[type];
      if (childCallback) {
        childCallback(e);
      }
      var callback = this.props[type];
      if (callback) {
        callback(e);
      }
    };

    Trigger.prototype.close = function close() {
      this.setPopupVisible(false);
    };

    Trigger.prototype.render = function render() {
      var _this4 = this;

      var popupVisible = this.state.popupVisible;
      var _props8 = this.props,
          children = _props8.children,
          forceRender = _props8.forceRender,
          alignPoint = _props8.alignPoint,
          className = _props8.className;

      var child = React$1__default.Children.only(children);
      var newChildProps = { key: 'trigger' };

      if (this.isContextMenuToShow()) {
        newChildProps.onContextMenu = this.onContextMenu;
      } else {
        newChildProps.onContextMenu = this.createTwoChains('onContextMenu');
      }

      if (this.isClickToHide() || this.isClickToShow()) {
        newChildProps.onClick = this.onClick;
        newChildProps.onMouseDown = this.onMouseDown;
        newChildProps.onTouchStart = this.onTouchStart;
      } else {
        newChildProps.onClick = this.createTwoChains('onClick');
        newChildProps.onMouseDown = this.createTwoChains('onMouseDown');
        newChildProps.onTouchStart = this.createTwoChains('onTouchStart');
      }
      if (this.isMouseEnterToShow()) {
        newChildProps.onMouseEnter = this.onMouseEnter;
        if (alignPoint) {
          newChildProps.onMouseMove = this.onMouseMove;
        }
      } else {
        newChildProps.onMouseEnter = this.createTwoChains('onMouseEnter');
      }
      if (this.isMouseLeaveToHide()) {
        newChildProps.onMouseLeave = this.onMouseLeave;
      } else {
        newChildProps.onMouseLeave = this.createTwoChains('onMouseLeave');
      }
      if (this.isFocusToShow() || this.isBlurToHide()) {
        newChildProps.onFocus = this.onFocus;
        newChildProps.onBlur = this.onBlur;
      } else {
        newChildProps.onFocus = this.createTwoChains('onFocus');
        newChildProps.onBlur = this.createTwoChains('onBlur');
      }

      var childrenClassName = classnames(child && child.props && child.props.className, className);
      if (childrenClassName) {
        newChildProps.className = childrenClassName;
      }
      var trigger = React$1__default.cloneElement(child, newChildProps);

      if (!IS_REACT_16) {
        return React$1__default.createElement(
          ContainerRender,
          {
            parent: this,
            visible: popupVisible,
            autoMount: false,
            forceRender: forceRender,
            getComponent: this.getComponent,
            getContainer: this.getContainer
          },
          function (_ref2) {
            var renderComponent = _ref2.renderComponent;

            _this4.renderComponent = renderComponent;
            return trigger;
          }
        );
      }

      var portal = void 0;
      // prevent unmounting after it's rendered
      if (popupVisible || this._component || forceRender) {
        portal = React$1__default.createElement(
          Portal,
          {
            key: 'portal',
            getContainer: this.getContainer,
            didUpdate: this.handlePortalUpdate
          },
          this.getComponent()
        );
      }

      return [trigger, portal];
    };

    return Trigger;
  }(React$1__default.Component);

  Trigger.propTypes = {
    children: PropTypes.any,
    action: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),
    showAction: PropTypes.any,
    hideAction: PropTypes.any,
    getPopupClassNameFromAlign: PropTypes.any,
    onPopupVisibleChange: PropTypes.func,
    afterPopupVisibleChange: PropTypes.func,
    popup: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,
    popupStyle: PropTypes.object,
    prefixCls: PropTypes.string,
    popupClassName: PropTypes.string,
    className: PropTypes.string,
    popupPlacement: PropTypes.string,
    builtinPlacements: PropTypes.object,
    popupTransitionName: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
    popupAnimation: PropTypes.any,
    mouseEnterDelay: PropTypes.number,
    mouseLeaveDelay: PropTypes.number,
    zIndex: PropTypes.number,
    focusDelay: PropTypes.number,
    blurDelay: PropTypes.number,
    getPopupContainer: PropTypes.func,
    getDocument: PropTypes.func,
    forceRender: PropTypes.bool,
    destroyPopupOnHide: PropTypes.bool,
    mask: PropTypes.bool,
    maskClosable: PropTypes.bool,
    onPopupAlign: PropTypes.func,
    popupAlign: PropTypes.object,
    popupVisible: PropTypes.bool,
    defaultPopupVisible: PropTypes.bool,
    maskTransitionName: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
    maskAnimation: PropTypes.string,
    stretch: PropTypes.string,
    alignPoint: PropTypes.bool // Maybe we can support user pass position in the future
  };
  Trigger.contextTypes = contextTypes;
  Trigger.childContextTypes = contextTypes;
  Trigger.defaultProps = {
    prefixCls: 'rc-trigger-popup',
    getPopupClassNameFromAlign: returnEmptyString,
    getDocument: returnDocument,
    onPopupVisibleChange: noop$2,
    afterPopupVisibleChange: noop$2,
    onPopupAlign: noop$2,
    popupClassName: '',
    mouseEnterDelay: 0,
    mouseLeaveDelay: 0.1,
    focusDelay: 0,
    blurDelay: 0.15,
    popupStyle: {},
    destroyPopupOnHide: false,
    popupAlign: {},
    defaultPopupVisible: false,
    mask: false,
    maskClosable: true,
    action: [],
    showAction: [],
    hideAction: []
  };

  var _initialiseProps$2 = function _initialiseProps() {
    var _this5 = this;

    this.onMouseEnter = function (e) {
      var mouseEnterDelay = _this5.props.mouseEnterDelay;

      _this5.fireEvents('onMouseEnter', e);
      _this5.delaySetPopupVisible(true, mouseEnterDelay, mouseEnterDelay ? null : e);
    };

    this.onMouseMove = function (e) {
      _this5.fireEvents('onMouseMove', e);
      _this5.setPoint(e);
    };

    this.onMouseLeave = function (e) {
      _this5.fireEvents('onMouseLeave', e);
      _this5.delaySetPopupVisible(false, _this5.props.mouseLeaveDelay);
    };

    this.onPopupMouseEnter = function () {
      _this5.clearDelayTimer();
    };

    this.onPopupMouseLeave = function (e) {
      // https://github.com/react-component/trigger/pull/13
      // react bug?
      if (e.relatedTarget && !e.relatedTarget.setTimeout && _this5._component && _this5._component.getPopupDomNode && contains(_this5._component.getPopupDomNode(), e.relatedTarget)) {
        return;
      }
      _this5.delaySetPopupVisible(false, _this5.props.mouseLeaveDelay);
    };

    this.onFocus = function (e) {
      _this5.fireEvents('onFocus', e);
      // incase focusin and focusout
      _this5.clearDelayTimer();
      if (_this5.isFocusToShow()) {
        _this5.focusTime = Date.now();
        _this5.delaySetPopupVisible(true, _this5.props.focusDelay);
      }
    };

    this.onMouseDown = function (e) {
      _this5.fireEvents('onMouseDown', e);
      _this5.preClickTime = Date.now();
    };

    this.onTouchStart = function (e) {
      _this5.fireEvents('onTouchStart', e);
      _this5.preTouchTime = Date.now();
    };

    this.onBlur = function (e) {
      _this5.fireEvents('onBlur', e);
      _this5.clearDelayTimer();
      if (_this5.isBlurToHide()) {
        _this5.delaySetPopupVisible(false, _this5.props.blurDelay);
      }
    };

    this.onContextMenu = function (e) {
      e.preventDefault();
      _this5.fireEvents('onContextMenu', e);
      _this5.setPopupVisible(true, e);
    };

    this.onContextMenuClose = function () {
      if (_this5.isContextMenuToShow()) {
        _this5.close();
      }
    };

    this.onClick = function (event) {
      _this5.fireEvents('onClick', event);
      // focus will trigger click
      if (_this5.focusTime) {
        var preTime = void 0;
        if (_this5.preClickTime && _this5.preTouchTime) {
          preTime = Math.min(_this5.preClickTime, _this5.preTouchTime);
        } else if (_this5.preClickTime) {
          preTime = _this5.preClickTime;
        } else if (_this5.preTouchTime) {
          preTime = _this5.preTouchTime;
        }
        if (Math.abs(preTime - _this5.focusTime) < 20) {
          return;
        }
        _this5.focusTime = 0;
      }
      _this5.preClickTime = 0;
      _this5.preTouchTime = 0;
      if (event && event.preventDefault) {
        event.preventDefault();
      }
      var nextVisible = !_this5.state.popupVisible;
      if (_this5.isClickToHide() && !nextVisible || nextVisible && _this5.isClickToShow()) {
        _this5.setPopupVisible(!_this5.state.popupVisible, event);
      }
    };

    this.onPopupMouseDown = function () {
      var _context$rcTrigger = _this5.context.rcTrigger,
          rcTrigger = _context$rcTrigger === undefined ? {} : _context$rcTrigger;

      _this5.hasPopupMouseDown = true;

      clearTimeout(_this5.mouseDownTimeout);
      _this5.mouseDownTimeout = setTimeout(function () {
        _this5.hasPopupMouseDown = false;
      }, 0);

      if (rcTrigger.onPopupMouseDown) {
        rcTrigger.onPopupMouseDown.apply(rcTrigger, arguments);
      }
    };

    this.onDocumentClick = function (event) {
      if (_this5.props.mask && !_this5.props.maskClosable) {
        return;
      }

      var target = event.target;
      var root = ReactDOM.findDOMNode(_this5);
      if (!contains(root, target) && !_this5.hasPopupMouseDown) {
        _this5.close();
      }
    };

    this.getRootDomNode = function () {
      return ReactDOM.findDOMNode(_this5);
    };

    this.getPopupClassNameFromAlign = function (align) {
      var className = [];
      var _props9 = _this5.props,
          popupPlacement = _props9.popupPlacement,
          builtinPlacements = _props9.builtinPlacements,
          prefixCls = _props9.prefixCls,
          alignPoint = _props9.alignPoint,
          getPopupClassNameFromAlign = _props9.getPopupClassNameFromAlign;

      if (popupPlacement && builtinPlacements) {
        className.push(getAlignPopupClassName(builtinPlacements, prefixCls, align, alignPoint));
      }
      if (getPopupClassNameFromAlign) {
        className.push(getPopupClassNameFromAlign(align));
      }
      return className.join(' ');
    };

    this.getComponent = function () {
      var _props10 = _this5.props,
          prefixCls = _props10.prefixCls,
          destroyPopupOnHide = _props10.destroyPopupOnHide,
          popupClassName = _props10.popupClassName,
          action = _props10.action,
          onPopupAlign = _props10.onPopupAlign,
          popupAnimation = _props10.popupAnimation,
          popupTransitionName = _props10.popupTransitionName,
          popupStyle = _props10.popupStyle,
          mask = _props10.mask,
          maskAnimation = _props10.maskAnimation,
          maskTransitionName = _props10.maskTransitionName,
          zIndex = _props10.zIndex,
          popup = _props10.popup,
          stretch = _props10.stretch,
          alignPoint = _props10.alignPoint;
      var _state = _this5.state,
          popupVisible = _state.popupVisible,
          point = _state.point;


      var align = _this5.getPopupAlign();

      var mouseProps = {};
      if (_this5.isMouseEnterToShow()) {
        mouseProps.onMouseEnter = _this5.onPopupMouseEnter;
      }
      if (_this5.isMouseLeaveToHide()) {
        mouseProps.onMouseLeave = _this5.onPopupMouseLeave;
      }

      mouseProps.onMouseDown = _this5.onPopupMouseDown;
      mouseProps.onTouchStart = _this5.onPopupMouseDown;

      return React$1__default.createElement(
        Popup,
        _extends$2({
          prefixCls: prefixCls,
          destroyPopupOnHide: destroyPopupOnHide,
          visible: popupVisible,
          point: alignPoint && point,
          className: popupClassName,
          action: action,
          align: align,
          onAlign: onPopupAlign,
          animation: popupAnimation,
          getClassNameFromAlign: _this5.getPopupClassNameFromAlign
        }, mouseProps, {
          stretch: stretch,
          getRootDomNode: _this5.getRootDomNode,
          style: popupStyle,
          mask: mask,
          zIndex: zIndex,
          transitionName: popupTransitionName,
          maskAnimation: maskAnimation,
          maskTransitionName: maskTransitionName,
          ref: _this5.savePopup
        }),
        typeof popup === 'function' ? popup() : popup
      );
    };

    this.getContainer = function () {
      var props = _this5.props;

      var popupContainer = document.createElement('div');
      // Make sure default popup container will never cause scrollbar appearing
      // https://github.com/react-component/trigger/issues/41
      popupContainer.style.position = 'absolute';
      popupContainer.style.top = '0';
      popupContainer.style.left = '0';
      popupContainer.style.width = '100%';
      var mountNode = props.getPopupContainer ? props.getPopupContainer(ReactDOM.findDOMNode(_this5)) : props.getDocument().body;
      mountNode.appendChild(popupContainer);
      return popupContainer;
    };

    this.setPoint = function (point) {
      var alignPoint = _this5.props.alignPoint;

      if (!alignPoint || !point) return;

      _this5.setState({
        point: {
          pageX: point.pageX,
          pageY: point.pageY
        }
      });
    };

    this.handlePortalUpdate = function () {
      if (_this5.prevPopupVisible !== _this5.state.popupVisible) {
        _this5.props.afterPopupVisibleChange(_this5.state.popupVisible);
      }
    };

    this.savePopup = function (node) {
      _this5._component = node;
    };
  };

  var es$3 = /*#__PURE__*/Object.freeze({
    default: Trigger
  });

  var autoAdjustOverflow = {
    adjustX: 1,
    adjustY: 1
  };

  var placements = {
    topLeft: {
      points: ['bl', 'tl'],
      overflow: autoAdjustOverflow,
      offset: [0, -7]
    },
    bottomLeft: {
      points: ['tl', 'bl'],
      overflow: autoAdjustOverflow,
      offset: [0, 7]
    },
    leftTop: {
      points: ['tr', 'tl'],
      overflow: autoAdjustOverflow,
      offset: [-4, 0]
    },
    rightTop: {
      points: ['tl', 'tr'],
      overflow: autoAdjustOverflow,
      offset: [4, 0]
    }
  };

  var guid = 0;

  var popupPlacementMap = {
    horizontal: 'bottomLeft',
    vertical: 'rightTop',
    'vertical-left': 'rightTop',
    'vertical-right': 'leftTop'
  };

  var updateDefaultActiveFirst = function updateDefaultActiveFirst(store, eventKey, defaultActiveFirst) {
    var _extends2;

    var menuId = getMenuIdFromSubMenuEventKey(eventKey);
    var state = store.getState();
    store.setState({
      defaultActiveFirst: _extends$2({}, state.defaultActiveFirst, (_extends2 = {}, _extends2[menuId] = defaultActiveFirst, _extends2))
    });
  };

  var SubMenu = function (_React$Component) {
    _inherits$1(SubMenu, _React$Component);

    function SubMenu(props) {
      _classCallCheck$1(this, SubMenu);

      var _this = _possibleConstructorReturn$1(this, _React$Component.call(this, props));

      _initialiseProps$3.call(_this);

      var store = props.store;
      var eventKey = props.eventKey;
      var defaultActiveFirst = store.getState().defaultActiveFirst;

      _this.isRootMenu = false;

      var value = false;

      if (defaultActiveFirst) {
        value = defaultActiveFirst[eventKey];
      }

      updateDefaultActiveFirst(store, eventKey, value);
      return _this;
    }

    SubMenu.prototype.componentDidMount = function componentDidMount() {
      this.componentDidUpdate();
    };

    SubMenu.prototype.componentDidUpdate = function componentDidUpdate() {
      var _this2 = this;

      var _props = this.props,
          mode = _props.mode,
          parentMenu = _props.parentMenu,
          manualRef = _props.manualRef;

      // invoke customized ref to expose component to mixin

      if (manualRef) {
        manualRef(this);
      }

      if (mode !== 'horizontal' || !parentMenu.isRootMenu || !this.props.isOpen) {
        return;
      }

      this.minWidthTimeout = setTimeout(function () {
        return _this2.adjustWidth();
      }, 0);
    };

    SubMenu.prototype.componentWillUnmount = function componentWillUnmount() {
      var _props2 = this.props,
          onDestroy = _props2.onDestroy,
          eventKey = _props2.eventKey;

      if (onDestroy) {
        onDestroy(eventKey);
      }

      /* istanbul ignore if */
      if (this.minWidthTimeout) {
        clearTimeout(this.minWidthTimeout);
      }

      /* istanbul ignore if */
      if (this.mouseenterTimeout) {
        clearTimeout(this.mouseenterTimeout);
      }
    };

    SubMenu.prototype.renderChildren = function renderChildren(children) {
      var props = this.props;
      var baseProps = {
        mode: props.mode === 'horizontal' ? 'vertical' : props.mode,
        visible: this.props.isOpen,
        level: props.level + 1,
        inlineIndent: props.inlineIndent,
        focusable: false,
        onClick: this.onSubMenuClick,
        onSelect: this.onSelect,
        onDeselect: this.onDeselect,
        onDestroy: this.onDestroy,
        selectedKeys: props.selectedKeys,
        eventKey: props.eventKey + '-menu-',
        openKeys: props.openKeys,
        openTransitionName: props.openTransitionName,
        openAnimation: props.openAnimation,
        onOpenChange: this.onOpenChange,
        subMenuOpenDelay: props.subMenuOpenDelay,
        parentMenu: this,
        subMenuCloseDelay: props.subMenuCloseDelay,
        forceSubMenuRender: props.forceSubMenuRender,
        triggerSubMenuAction: props.triggerSubMenuAction,
        builtinPlacements: props.builtinPlacements,
        defaultActiveFirst: props.store.getState().defaultActiveFirst[getMenuIdFromSubMenuEventKey(props.eventKey)],
        multiple: props.multiple,
        prefixCls: props.rootPrefixCls,
        id: this._menuId,
        manualRef: this.saveMenuInstance,
        itemIcon: props.itemIcon,
        expandIcon: props.expandIcon
      };

      var haveRendered = this.haveRendered;
      this.haveRendered = true;

      this.haveOpened = this.haveOpened || baseProps.visible || baseProps.forceSubMenuRender;
      // never rendered not planning to, don't render
      if (!this.haveOpened) {
        return React$1__default.createElement('div', null);
      }

      // don't show transition on first rendering (no animation for opened menu)
      // show appear transition if it's not visible (not sure why)
      // show appear transition if it's not inline mode
      var transitionAppear = haveRendered || !baseProps.visible || !baseProps.mode === 'inline';

      baseProps.className = ' ' + baseProps.prefixCls + '-sub';
      var animProps = {};

      if (baseProps.openTransitionName) {
        animProps.transitionName = baseProps.openTransitionName;
      } else if (typeof baseProps.openAnimation === 'object') {
        animProps.animation = _extends$2({}, baseProps.openAnimation);
        if (!transitionAppear) {
          delete animProps.animation.appear;
        }
      }

      return React$1__default.createElement(
        Animate,
        _extends$2({}, animProps, {
          showProp: 'visible',
          component: '',
          transitionAppear: transitionAppear
        }),
        React$1__default.createElement(
          connected$1,
          _extends$2({}, baseProps, { id: this._menuId }),
          children
        )
      );
    };

    SubMenu.prototype.render = function render() {
      var _classNames;

      var props = _extends$2({}, this.props);
      var isOpen = props.isOpen;
      var prefixCls = this.getPrefixCls();
      var isInlineMode = props.mode === 'inline';
      var className = classnames(prefixCls, prefixCls + '-' + props.mode, (_classNames = {}, _classNames[props.className] = !!props.className, _classNames[this.getOpenClassName()] = isOpen, _classNames[this.getActiveClassName()] = props.active || isOpen && !isInlineMode, _classNames[this.getDisabledClassName()] = props.disabled, _classNames[this.getSelectedClassName()] = this.isChildrenSelected(), _classNames));

      if (!this._menuId) {
        if (props.eventKey) {
          this._menuId = props.eventKey + '$Menu';
        } else {
          this._menuId = '$__$' + ++guid + '$Menu';
        }
      }

      var mouseEvents = {};
      var titleClickEvents = {};
      var titleMouseEvents = {};
      if (!props.disabled) {
        mouseEvents = {
          onMouseLeave: this.onMouseLeave,
          onMouseEnter: this.onMouseEnter
        };

        // only works in title, not outer li
        titleClickEvents = {
          onClick: this.onTitleClick
        };
        titleMouseEvents = {
          onMouseEnter: this.onTitleMouseEnter,
          onMouseLeave: this.onTitleMouseLeave
        };
      }

      var style = {};
      if (isInlineMode) {
        style.paddingLeft = props.inlineIndent * props.level;
      }

      var ariaOwns = {};
      // only set aria-owns when menu is open
      // otherwise it would be an invalid aria-owns value
      // since corresponding node cannot be found
      if (this.props.isOpen) {
        ariaOwns = {
          'aria-owns': this._menuId
        };
      }

      // expand custom icon should NOT be displayed in menu with horizontal mode.
      var icon = null;
      if (props.mode !== 'horizontal') {
        icon = this.props.expandIcon; // ReactNode
        if (typeof this.props.expandIcon === 'function') {
          icon = React$1__default.createElement(this.props.expandIcon, _extends$2({}, this.props));
        }
      }

      var title = React$1__default.createElement(
        'div',
        _extends$2({
          ref: this.saveSubMenuTitle,
          style: style,
          className: prefixCls + '-title'
        }, titleMouseEvents, titleClickEvents, {
          'aria-expanded': isOpen
        }, ariaOwns, {
          'aria-haspopup': 'true',
          title: typeof props.title === 'string' ? props.title : undefined
        }),
        props.title,
        icon || React$1__default.createElement('i', { className: prefixCls + '-arrow' })
      );
      var children = this.renderChildren(props.children);

      var getPopupContainer = props.parentMenu.isRootMenu ? props.parentMenu.props.getPopupContainer : function (triggerNode) {
        return triggerNode.parentNode;
      };
      var popupPlacement = popupPlacementMap[props.mode];
      var popupAlign = props.popupOffset ? { offset: props.popupOffset } : {};
      var popupClassName = props.mode === 'inline' ? '' : props.popupClassName;
      var disabled = props.disabled,
          triggerSubMenuAction = props.triggerSubMenuAction,
          subMenuOpenDelay = props.subMenuOpenDelay,
          forceSubMenuRender = props.forceSubMenuRender,
          subMenuCloseDelay = props.subMenuCloseDelay,
          builtinPlacements = props.builtinPlacements;

      menuAllProps.forEach(function (key) {
        return delete props[key];
      });
      // Set onClick to null, to ignore propagated onClick event
      delete props.onClick;

      return React$1__default.createElement(
        'li',
        _extends$2({}, props, mouseEvents, {
          className: className,
          role: 'menuitem'
        }),
        isInlineMode && title,
        isInlineMode && children,
        !isInlineMode && React$1__default.createElement(
          Trigger,
          {
            prefixCls: prefixCls,
            popupClassName: prefixCls + '-popup ' + popupClassName,
            getPopupContainer: getPopupContainer,
            builtinPlacements: _extends$2({}, placements, builtinPlacements),
            popupPlacement: popupPlacement,
            popupVisible: isOpen,
            popupAlign: popupAlign,
            popup: children,
            action: disabled ? [] : [triggerSubMenuAction],
            mouseEnterDelay: subMenuOpenDelay,
            mouseLeaveDelay: subMenuCloseDelay,
            onPopupVisibleChange: this.onPopupVisibleChange,
            forceRender: forceSubMenuRender
          },
          title
        )
      );
    };

    return SubMenu;
  }(React$1__default.Component);

  SubMenu.propTypes = {
    parentMenu: PropTypes.object,
    title: PropTypes.node,
    children: PropTypes.any,
    selectedKeys: PropTypes.array,
    openKeys: PropTypes.array,
    onClick: PropTypes.func,
    onOpenChange: PropTypes.func,
    rootPrefixCls: PropTypes.string,
    eventKey: PropTypes.string,
    multiple: PropTypes.bool,
    active: PropTypes.bool, // TODO: remove
    onItemHover: PropTypes.func,
    onSelect: PropTypes.func,
    triggerSubMenuAction: PropTypes.string,
    onDeselect: PropTypes.func,
    onDestroy: PropTypes.func,
    onMouseEnter: PropTypes.func,
    onMouseLeave: PropTypes.func,
    onTitleMouseEnter: PropTypes.func,
    onTitleMouseLeave: PropTypes.func,
    onTitleClick: PropTypes.func,
    popupOffset: PropTypes.array,
    isOpen: PropTypes.bool,
    store: PropTypes.object,
    mode: PropTypes.oneOf(['horizontal', 'vertical', 'vertical-left', 'vertical-right', 'inline']),
    manualRef: PropTypes.func,
    itemIcon: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),
    expandIcon: PropTypes.oneOfType([PropTypes.func, PropTypes.node])
  };
  SubMenu.defaultProps = {
    onMouseEnter: noop$1,
    onMouseLeave: noop$1,
    onTitleMouseEnter: noop$1,
    onTitleMouseLeave: noop$1,
    onTitleClick: noop$1,
    manualRef: noop$1,
    mode: 'vertical',
    title: ''
  };

  var _initialiseProps$3 = function _initialiseProps() {
    var _this3 = this;

    this.onDestroy = function (key) {
      _this3.props.onDestroy(key);
    };

    this.onKeyDown = function (e) {
      var keyCode = e.keyCode;
      var menu = _this3.menuInstance;
      var _props3 = _this3.props,
          isOpen = _props3.isOpen,
          store = _props3.store;


      if (keyCode === KeyCode.ENTER) {
        _this3.onTitleClick(e);
        updateDefaultActiveFirst(store, _this3.props.eventKey, true);
        return true;
      }

      if (keyCode === KeyCode.RIGHT) {
        if (isOpen) {
          menu.onKeyDown(e);
        } else {
          _this3.triggerOpenChange(true);
          // need to update current menu's defaultActiveFirst value
          updateDefaultActiveFirst(store, _this3.props.eventKey, true);
        }
        return true;
      }
      if (keyCode === KeyCode.LEFT) {
        var handled = void 0;
        if (isOpen) {
          handled = menu.onKeyDown(e);
        } else {
          return undefined;
        }
        if (!handled) {
          _this3.triggerOpenChange(false);
          handled = true;
        }
        return handled;
      }

      if (isOpen && (keyCode === KeyCode.UP || keyCode === KeyCode.DOWN)) {
        return menu.onKeyDown(e);
      }
    };

    this.onOpenChange = function (e) {
      _this3.props.onOpenChange(e);
    };

    this.onPopupVisibleChange = function (visible) {
      _this3.triggerOpenChange(visible, visible ? 'mouseenter' : 'mouseleave');
    };

    this.onMouseEnter = function (e) {
      var _props4 = _this3.props,
          key = _props4.eventKey,
          onMouseEnter = _props4.onMouseEnter,
          store = _props4.store;

      updateDefaultActiveFirst(store, _this3.props.eventKey, false);
      onMouseEnter({
        key: key,
        domEvent: e
      });
    };

    this.onMouseLeave = function (e) {
      var _props5 = _this3.props,
          parentMenu = _props5.parentMenu,
          eventKey = _props5.eventKey,
          onMouseLeave = _props5.onMouseLeave;

      parentMenu.subMenuInstance = _this3;
      onMouseLeave({
        key: eventKey,
        domEvent: e
      });
    };

    this.onTitleMouseEnter = function (domEvent) {
      var _props6 = _this3.props,
          key = _props6.eventKey,
          onItemHover = _props6.onItemHover,
          onTitleMouseEnter = _props6.onTitleMouseEnter;

      onItemHover({
        key: key,
        hover: true
      });
      onTitleMouseEnter({
        key: key,
        domEvent: domEvent
      });
    };

    this.onTitleMouseLeave = function (e) {
      var _props7 = _this3.props,
          parentMenu = _props7.parentMenu,
          eventKey = _props7.eventKey,
          onItemHover = _props7.onItemHover,
          onTitleMouseLeave = _props7.onTitleMouseLeave;

      parentMenu.subMenuInstance = _this3;
      onItemHover({
        key: eventKey,
        hover: false
      });
      onTitleMouseLeave({
        key: eventKey,
        domEvent: e
      });
    };

    this.onTitleClick = function (e) {
      var props = _this3.props;

      props.onTitleClick({
        key: props.eventKey,
        domEvent: e
      });
      if (props.triggerSubMenuAction === 'hover') {
        return;
      }
      _this3.triggerOpenChange(!props.isOpen, 'click');
      updateDefaultActiveFirst(props.store, _this3.props.eventKey, false);
    };

    this.onSubMenuClick = function (info) {
      // in the case of overflowed submenu
      // onClick is not copied over
      if (typeof _this3.props.onClick === 'function') {
        _this3.props.onClick(_this3.addKeyPath(info));
      }
    };

    this.onSelect = function (info) {
      _this3.props.onSelect(info);
    };

    this.onDeselect = function (info) {
      _this3.props.onDeselect(info);
    };

    this.getPrefixCls = function () {
      return _this3.props.rootPrefixCls + '-submenu';
    };

    this.getActiveClassName = function () {
      return _this3.getPrefixCls() + '-active';
    };

    this.getDisabledClassName = function () {
      return _this3.getPrefixCls() + '-disabled';
    };

    this.getSelectedClassName = function () {
      return _this3.getPrefixCls() + '-selected';
    };

    this.getOpenClassName = function () {
      return _this3.props.rootPrefixCls + '-submenu-open';
    };

    this.saveMenuInstance = function (c) {
      // children menu instance
      _this3.menuInstance = c;
    };

    this.addKeyPath = function (info) {
      return _extends$2({}, info, {
        keyPath: (info.keyPath || []).concat(_this3.props.eventKey)
      });
    };

    this.triggerOpenChange = function (open, type) {
      var key = _this3.props.eventKey;
      var openChange = function openChange() {
        _this3.onOpenChange({
          key: key,
          item: _this3,
          trigger: type,
          open: open
        });
      };
      if (type === 'mouseenter') {
        // make sure mouseenter happen after other menu item's mouseleave
        _this3.mouseenterTimeout = setTimeout(function () {
          openChange();
        }, 0);
      } else {
        openChange();
      }
    };

    this.isChildrenSelected = function () {
      var ret = { find: false };
      loopMenuItemRecursively(_this3.props.children, _this3.props.selectedKeys, ret);
      return ret.find;
    };

    this.isOpen = function () {
      return _this3.props.openKeys.indexOf(_this3.props.eventKey) !== -1;
    };

    this.adjustWidth = function () {
      /* istanbul ignore if */
      if (!_this3.subMenuTitle || !_this3.menuInstance) {
        return;
      }
      var popupMenu = ReactDOM__default.findDOMNode(_this3.menuInstance);
      if (popupMenu.offsetWidth >= _this3.subMenuTitle.offsetWidth) {
        return;
      }

      /* istanbul ignore next */
      popupMenu.style.minWidth = _this3.subMenuTitle.offsetWidth + 'px';
    };

    this.saveSubMenuTitle = function (subMenuTitle) {
      _this3.subMenuTitle = subMenuTitle;
    };
  };

  var connected = lib_2(function (_ref, _ref2) {
    var openKeys = _ref.openKeys,
        activeKey = _ref.activeKey,
        selectedKeys = _ref.selectedKeys;
    var eventKey = _ref2.eventKey,
        subMenuKey = _ref2.subMenuKey;
    return {
      isOpen: openKeys.indexOf(eventKey) > -1,
      active: activeKey[subMenuKey] === eventKey,
      selectedKeys: selectedKeys
    };
  })(SubMenu);

  connected.isSubMenu = true;

  var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

  var MENUITEM_OVERFLOWED_CLASSNAME = 'menuitem-overflowed';

  // Fix ssr
  if (canUseDOM) {
    require('mutationobserver-shim');
  }

  var DOMWrap = function (_React$Component) {
    _inherits$1(DOMWrap, _React$Component);

    function DOMWrap() {
      var _temp, _this, _ret;

      _classCallCheck$1(this, DOMWrap);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn$1(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
        lastVisibleIndex: undefined
      }, _this.getMenuItemNodes = function () {
        var prefixCls = _this.props.prefixCls;

        var ul = ReactDOM__default.findDOMNode(_this);
        if (!ul) {
          return [];
        }

        // filter out all overflowed indicator placeholder
        return [].slice.call(ul.children).filter(function (node) {
          return node.className.split(' ').indexOf(prefixCls + '-overflowed-submenu') < 0;
        });
      }, _this.getOverflowedSubMenuItem = function (keyPrefix, overflowedItems, renderPlaceholder) {
        var _this$props = _this.props,
            overflowedIndicator = _this$props.overflowedIndicator,
            level = _this$props.level,
            mode = _this$props.mode,
            prefixCls = _this$props.prefixCls,
            theme = _this$props.theme,
            propStyle = _this$props.style;

        if (level !== 1 || mode !== 'horizontal') {
          return null;
        }
        // put all the overflowed item inside a submenu
        // with a title of overflow indicator ('...')
        var copy = _this.props.children[0];

        var _copy$props = copy.props,
            throwAway = _copy$props.children,
            title = _copy$props.title,
            eventKey = _copy$props.eventKey,
            rest = _objectWithoutProperties$1(_copy$props, ['children', 'title', 'eventKey']);

        var style = _extends$2({}, propStyle);
        var key = keyPrefix + '-overflowed-indicator';

        if (overflowedItems.length === 0 && renderPlaceholder !== true) {
          style = _extends$2({}, style, {
            display: 'none'
          });
        } else if (renderPlaceholder) {
          style = _extends$2({}, style, {
            visibility: 'hidden',
            // prevent from taking normal dom space
            position: 'absolute'
          });
          key = key + '-placeholder';
        }

        var popupClassName = theme ? prefixCls + '-' + theme : '';
        var props = {};
        menuAllProps.forEach(function (k) {
          if (rest[k] !== undefined) {
            props[k] = rest[k];
          }
        });

        return React$1__default.createElement(
          connected,
          _extends$2({
            title: overflowedIndicator,
            className: prefixCls + '-overflowed-submenu',
            popupClassName: popupClassName
          }, props, {
            key: key,
            eventKey: keyPrefix + '-overflowed-indicator',
            disabled: false,
            style: style
          }),
          overflowedItems
        );
      }, _this.setChildrenWidthAndResize = function () {
        if (_this.props.mode !== 'horizontal') {
          return;
        }
        var ul = ReactDOM__default.findDOMNode(_this);

        if (!ul) {
          return;
        }

        var ulChildrenNodes = ul.children;

        if (!ulChildrenNodes || ulChildrenNodes.length === 0) {
          return;
        }

        var lastOverflowedIndicatorPlaceholder = ul.children[ulChildrenNodes.length - 1];

        // need last overflowed indicator for calculating length;
        setStyle(lastOverflowedIndicatorPlaceholder, 'display', 'inline-block');

        var menuItemNodes = _this.getMenuItemNodes();

        // reset display attribute for all hidden elements caused by overflow to calculate updated width
        // and then reset to original state after width calculation

        var overflowedItems = menuItemNodes.filter(function (c) {
          return c.className.split(' ').indexOf(MENUITEM_OVERFLOWED_CLASSNAME) >= 0;
        });

        overflowedItems.forEach(function (c) {
          setStyle(c, 'display', 'inline-block');
        });

        _this.menuItemSizes = menuItemNodes.map(function (c) {
          return getWidth(c);
        });

        overflowedItems.forEach(function (c) {
          setStyle(c, 'display', 'none');
        });
        _this.overflowedIndicatorWidth = getWidth(ul.children[ul.children.length - 1]);
        _this.originalTotalWidth = _this.menuItemSizes.reduce(function (acc, cur) {
          return acc + cur;
        }, 0);
        _this.handleResize();
        // prevent the overflowed indicator from taking space;
        setStyle(lastOverflowedIndicatorPlaceholder, 'display', 'none');
      }, _this.resizeObserver = null, _this.mutationObserver = null, _this.originalTotalWidth = 0, _this.overflowedItems = [], _this.menuItemSizes = [], _this.handleResize = function () {
        if (_this.props.mode !== 'horizontal') {
          return;
        }

        var ul = ReactDOM__default.findDOMNode(_this);
        if (!ul) {
          return;
        }
        var width = getWidth(ul);

        _this.overflowedItems = [];
        var currentSumWidth = 0;

        // index for last visible child in horizontal mode
        var lastVisibleIndex = undefined;

        if (_this.originalTotalWidth > width) {
          lastVisibleIndex = -1;

          _this.menuItemSizes.forEach(function (liWidth) {
            currentSumWidth += liWidth;
            if (currentSumWidth + _this.overflowedIndicatorWidth <= width) {
              lastVisibleIndex++;
            }
          });
        }

        _this.setState({ lastVisibleIndex: lastVisibleIndex });
      }, _temp), _possibleConstructorReturn$1(_this, _ret);
    }

    DOMWrap.prototype.componentDidMount = function componentDidMount() {
      var _this2 = this;

      this.setChildrenWidthAndResize();
      if (this.props.level === 1 && this.props.mode === 'horizontal') {
        var menuUl = ReactDOM__default.findDOMNode(this);
        if (!menuUl) {
          return;
        }
        this.resizeObserver = new index$3(function (entries) {
          entries.forEach(_this2.setChildrenWidthAndResize);
        });

        [].slice.call(menuUl.children).concat(menuUl).forEach(function (el) {
          _this2.resizeObserver.observe(el);
        });

        if (typeof MutationObserver !== 'undefined') {
          this.mutationObserver = new MutationObserver(function () {
            _this2.resizeObserver.disconnect();
            [].slice.call(menuUl.children).concat(menuUl).forEach(function (el) {
              _this2.resizeObserver.observe(el);
            });
            _this2.setChildrenWidthAndResize();
          });
          this.mutationObserver.observe(menuUl, { attributes: false, childList: true, subTree: false });
        }
      }
    };

    DOMWrap.prototype.componentWillUnmount = function componentWillUnmount() {
      if (this.resizeObserver) {
        this.resizeObserver.disconnect();
      }
      if (this.mutationObserver) {
        this.resizeObserver.disconnect();
      }
    };

    // get all valid menuItem nodes


    // memorize rendered menuSize


    // original scroll size of the list


    // copy of overflowed items


    // cache item of the original items (so we can track the size and order)


    DOMWrap.prototype.renderChildren = function renderChildren(children) {
      var _this3 = this;

      // need to take care of overflowed items in horizontal mode
      var lastVisibleIndex = this.state.lastVisibleIndex;

      return (children || []).reduce(function (acc, childNode, index) {
        var item = childNode;
        if (_this3.props.mode === 'horizontal') {
          var overflowed = _this3.getOverflowedSubMenuItem(childNode.props.eventKey, []);
          if (lastVisibleIndex !== undefined && _this3.props.className.indexOf(_this3.props.prefixCls + '-root') !== -1) {
            if (index > lastVisibleIndex) {
              item = React$1__default.cloneElement(childNode,
              // 这里修改 eventKey 是为了防止隐藏状态下还会触发 openkeys 事件
              {
                style: { display: 'none' },
                eventKey: childNode.props.eventKey + '-hidden',
                className: childNode.className + ' ' + MENUITEM_OVERFLOWED_CLASSNAME
              });
            }
            if (index === lastVisibleIndex + 1) {
              _this3.overflowedItems = children.slice(lastVisibleIndex + 1).map(function (c) {
                return React$1__default.cloneElement(c,
                // children[index].key will become '.$key' in clone by default,
                // we have to overwrite with the correct key explicitly
                { key: c.props.eventKey, mode: 'vertical-left' });
              });

              overflowed = _this3.getOverflowedSubMenuItem(childNode.props.eventKey, _this3.overflowedItems);
            }
          }

          var ret = [].concat(acc, [overflowed, item]);

          if (index === children.length - 1) {
            // need a placeholder for calculating overflowed indicator width
            ret.push(_this3.getOverflowedSubMenuItem(childNode.props.eventKey, [], true));
          }
          return ret;
        }
        return [].concat(acc, [item]);
      }, []);
    };

    DOMWrap.prototype.render = function render() {
      var _props = this.props,
          hiddenClassName = _props.hiddenClassName,
          visible = _props.visible,
          prefixCls = _props.prefixCls,
          overflowedIndicator = _props.overflowedIndicator,
          mode = _props.mode,
          level = _props.level,
          Tag = _props.tag,
          children = _props.children,
          theme = _props.theme,
          rest = _objectWithoutProperties$1(_props, ['hiddenClassName', 'visible', 'prefixCls', 'overflowedIndicator', 'mode', 'level', 'tag', 'children', 'theme']);

      if (!visible) {
        rest.className += ' ' + hiddenClassName;
      }

      return React$1__default.createElement(
        Tag,
        rest,
        this.renderChildren(this.props.children)
      );
    };

    return DOMWrap;
  }(React$1__default.Component);

  DOMWrap.propTypes = {
    className: PropTypes.string,
    children: PropTypes.node,
    mode: PropTypes.oneOf(['horizontal', 'vertical', 'vertical-left', 'vertical-right', 'inline']),
    prefixCls: PropTypes.string,
    level: PropTypes.number,
    theme: PropTypes.string,
    overflowedIndicator: PropTypes.node,
    visible: PropTypes.bool,
    hiddenClassName: PropTypes.string,
    tag: PropTypes.string,
    style: PropTypes.object
  };

  DOMWrap.defaultProps = {
    tag: 'div',
    className: ''
  };

  function allDisabled(arr) {
    if (!arr.length) {
      return true;
    }
    return arr.every(function (c) {
      return !!c.props.disabled;
    });
  }

  function updateActiveKey(store, menuId, activeKey) {
    var _extends2;

    var state = store.getState();
    store.setState({
      activeKey: _extends$2({}, state.activeKey, (_extends2 = {}, _extends2[menuId] = activeKey, _extends2))
    });
  }

  function getEventKey(props) {
    // when eventKey not available ,it's menu and return menu id '0-menu-'
    return props.eventKey || '0-menu-';
  }

  function getActiveKey(props, originalActiveKey) {
    var activeKey = originalActiveKey;
    var children = props.children,
        eventKey = props.eventKey;

    if (activeKey) {
      var found = void 0;
      loopMenuItem(children, function (c, i) {
        if (c && !c.props.disabled && activeKey === getKeyFromChildrenIndex(c, eventKey, i)) {
          found = true;
        }
      });
      if (found) {
        return activeKey;
      }
    }
    activeKey = null;
    if (props.defaultActiveFirst) {
      loopMenuItem(children, function (c, i) {
        if (!activeKey && c && !c.props.disabled) {
          activeKey = getKeyFromChildrenIndex(c, eventKey, i);
        }
      });
      return activeKey;
    }
    return activeKey;
  }

  function saveRef$1(c) {
    if (c) {
      var index = this.instanceArray.indexOf(c);
      if (index !== -1) {
        // update component if it's already inside instanceArray
        this.instanceArray[index] = c;
      } else {
        // add component if it's not in instanceArray yet;
        this.instanceArray.push(c);
      }
    }
  }

  var SubPopupMenu = function (_React$Component) {
    _inherits$1(SubPopupMenu, _React$Component);

    function SubPopupMenu(props) {
      var _extends3;

      _classCallCheck$1(this, SubPopupMenu);

      var _this = _possibleConstructorReturn$1(this, _React$Component.call(this, props));

      _initialiseProps$4.call(_this);

      props.store.setState({
        activeKey: _extends$2({}, props.store.getState().activeKey, (_extends3 = {}, _extends3[props.eventKey] = getActiveKey(props, props.activeKey), _extends3))
      });

      _this.instanceArray = [];
      return _this;
    }

    SubPopupMenu.prototype.componentDidMount = function componentDidMount() {
      // invoke customized ref to expose component to mixin
      if (this.props.manualRef) {
        this.props.manualRef(this);
      }
    };

    SubPopupMenu.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      return this.props.visible || nextProps.visible;
    };

    SubPopupMenu.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
      var props = this.props;
      var originalActiveKey = 'activeKey' in props ? props.activeKey : props.store.getState().activeKey[getEventKey(props)];
      var activeKey = getActiveKey(props, originalActiveKey);
      if (activeKey !== originalActiveKey) {
        updateActiveKey(props.store, getEventKey(props), activeKey);
      } else if ('activeKey' in prevProps) {
        // If prev activeKey is not same as current activeKey,
        // we should set it.
        var prevActiveKey = getActiveKey(prevProps, prevProps.activeKey);
        if (activeKey !== prevActiveKey) {
          updateActiveKey(props.store, getEventKey(props), activeKey);
        }
      }
    };

    // all keyboard events callbacks run from here at first


    SubPopupMenu.prototype.render = function render() {
      var _this2 = this;

      var props = _objectWithoutProperties$1(this.props, []);

      this.instanceArray = [];
      var className = classnames(props.prefixCls, props.className, props.prefixCls + '-' + props.mode);
      var domProps = {
        className: className,
        // role could be 'select' and by default set to menu
        role: props.role || 'menu'
      };
      if (props.id) {
        domProps.id = props.id;
      }
      if (props.focusable) {
        domProps.tabIndex = '0';
        domProps.onKeyDown = this.onKeyDown;
      }
      var prefixCls = props.prefixCls,
          eventKey = props.eventKey,
          visible = props.visible,
          level = props.level,
          mode = props.mode,
          overflowedIndicator = props.overflowedIndicator,
          theme = props.theme;

      menuAllProps.forEach(function (key) {
        return delete props[key];
      });

      // Otherwise, the propagated click event will trigger another onClick
      delete props.onClick;

      return (
        // ESLint is not smart enough to know that the type of `children` was checked.
        /* eslint-disable */
        React$1__default.createElement(
          DOMWrap,
          _extends$2({}, props, {
            prefixCls: prefixCls,
            mode: mode,
            tag: 'ul',
            level: level,
            theme: theme,
            hiddenClassName: prefixCls + '-hidden',
            visible: visible,
            overflowedIndicator: overflowedIndicator
          }, domProps),
          React$1__default.Children.map(props.children, function (c, i) {
            return _this2.renderMenuItem(c, i, eventKey || '0-menu-');
          })
        )
        /*eslint-enable */

      );
    };

    return SubPopupMenu;
  }(React$1__default.Component);
  SubPopupMenu.propTypes = {
    onSelect: PropTypes.func,
    onClick: PropTypes.func,
    onDeselect: PropTypes.func,
    onOpenChange: PropTypes.func,
    onDestroy: PropTypes.func,
    openTransitionName: PropTypes.string,
    openAnimation: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
    openKeys: PropTypes.arrayOf(PropTypes.string),
    visible: PropTypes.bool,
    children: PropTypes.any,
    parentMenu: PropTypes.object,
    eventKey: PropTypes.string,
    store: PropTypes.shape({
      getState: PropTypes.func,
      setState: PropTypes.func
    }),

    // adding in refactor
    focusable: PropTypes.bool,
    multiple: PropTypes.bool,
    style: PropTypes.object,
    defaultActiveFirst: PropTypes.bool,
    activeKey: PropTypes.string,
    selectedKeys: PropTypes.arrayOf(PropTypes.string),
    defaultSelectedKeys: PropTypes.arrayOf(PropTypes.string),
    defaultOpenKeys: PropTypes.arrayOf(PropTypes.string),
    level: PropTypes.number,
    mode: PropTypes.oneOf(['horizontal', 'vertical', 'vertical-left', 'vertical-right', 'inline']),
    triggerSubMenuAction: PropTypes.oneOf(['click', 'hover']),
    inlineIndent: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    manualRef: PropTypes.func,
    itemIcon: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),
    expandIcon: PropTypes.oneOfType([PropTypes.func, PropTypes.node])
  };
  SubPopupMenu.defaultProps = {
    prefixCls: 'rc-menu',
    className: '',
    mode: 'vertical',
    level: 1,
    inlineIndent: 24,
    visible: true,
    focusable: true,
    style: {},
    manualRef: noop$1
  };

  var _initialiseProps$4 = function _initialiseProps() {
    var _this3 = this;

    this.onKeyDown = function (e, callback) {
      var keyCode = e.keyCode;
      var handled = void 0;
      _this3.getFlatInstanceArray().forEach(function (obj) {
        if (obj && obj.props.active && obj.onKeyDown) {
          handled = obj.onKeyDown(e);
        }
      });
      if (handled) {
        return 1;
      }
      var activeItem = null;
      if (keyCode === KeyCode.UP || keyCode === KeyCode.DOWN) {
        activeItem = _this3.step(keyCode === KeyCode.UP ? -1 : 1);
      }
      if (activeItem) {
        e.preventDefault();
        updateActiveKey(_this3.props.store, getEventKey(_this3.props), activeItem.props.eventKey);

        if (typeof callback === 'function') {
          callback(activeItem);
        }

        return 1;
      }
    };

    this.onItemHover = function (e) {
      var key = e.key,
          hover = e.hover;

      updateActiveKey(_this3.props.store, getEventKey(_this3.props), hover ? key : null);
    };

    this.onDeselect = function (selectInfo) {
      _this3.props.onDeselect(selectInfo);
    };

    this.onSelect = function (selectInfo) {
      _this3.props.onSelect(selectInfo);
    };

    this.onClick = function (e) {
      _this3.props.onClick(e);
    };

    this.onOpenChange = function (e) {
      _this3.props.onOpenChange(e);
    };

    this.onDestroy = function (key) {
      /* istanbul ignore next */
      _this3.props.onDestroy(key);
    };

    this.getFlatInstanceArray = function () {
      return _this3.instanceArray;
    };

    this.getOpenTransitionName = function () {
      return _this3.props.openTransitionName;
    };

    this.step = function (direction) {
      var children = _this3.getFlatInstanceArray();
      var activeKey = _this3.props.store.getState().activeKey[getEventKey(_this3.props)];
      var len = children.length;
      if (!len) {
        return null;
      }
      if (direction < 0) {
        children = children.concat().reverse();
      }
      // find current activeIndex
      var activeIndex = -1;
      children.every(function (c, ci) {
        if (c && c.props.eventKey === activeKey) {
          activeIndex = ci;
          return false;
        }
        return true;
      });
      if (!_this3.props.defaultActiveFirst && activeIndex !== -1 && allDisabled(children.slice(activeIndex, len - 1))) {
        return undefined;
      }
      var start = (activeIndex + 1) % len;
      var i = start;

      do {
        var child = children[i];
        if (!child || child.props.disabled) {
          i = (i + 1) % len;
        } else {
          return child;
        }
      } while (i !== start);

      return null;
    };

    this.renderCommonMenuItem = function (child, i, extraProps) {
      var state = _this3.props.store.getState();
      var props = _this3.props;
      var key = getKeyFromChildrenIndex(child, props.eventKey, i);
      var childProps = child.props;
      var isActive = key === state.activeKey;
      var newChildProps = _extends$2({
        mode: childProps.mode || props.mode,
        level: props.level,
        inlineIndent: props.inlineIndent,
        renderMenuItem: _this3.renderMenuItem,
        rootPrefixCls: props.prefixCls,
        index: i,
        parentMenu: props.parentMenu,
        // customized ref function, need to be invoked manually in child's componentDidMount
        manualRef: childProps.disabled ? undefined : createChainedFunction(child.ref, saveRef$1.bind(_this3)),
        eventKey: key,
        active: !childProps.disabled && isActive,
        multiple: props.multiple,
        onClick: function onClick(e) {
          (childProps.onClick || noop$1)(e);
          _this3.onClick(e);
        },
        onItemHover: _this3.onItemHover,
        openTransitionName: _this3.getOpenTransitionName(),
        openAnimation: props.openAnimation,
        subMenuOpenDelay: props.subMenuOpenDelay,
        subMenuCloseDelay: props.subMenuCloseDelay,
        forceSubMenuRender: props.forceSubMenuRender,
        onOpenChange: _this3.onOpenChange,
        onDeselect: _this3.onDeselect,
        onSelect: _this3.onSelect,
        builtinPlacements: props.builtinPlacements,
        itemIcon: childProps.itemIcon || _this3.props.itemIcon,
        expandIcon: childProps.expandIcon || _this3.props.expandIcon
      }, extraProps);
      if (props.mode === 'inline') {
        newChildProps.triggerSubMenuAction = 'click';
      }
      return React$1__default.cloneElement(child, newChildProps);
    };

    this.renderMenuItem = function (c, i, subMenuKey) {
      /* istanbul ignore if */
      if (!c) {
        return null;
      }
      var state = _this3.props.store.getState();
      var extraProps = {
        openKeys: state.openKeys,
        selectedKeys: state.selectedKeys,
        triggerSubMenuAction: _this3.props.triggerSubMenuAction,
        subMenuKey: subMenuKey
      };
      return _this3.renderCommonMenuItem(c, i, extraProps);
    };
  };

  var connected$1 = lib_2()(SubPopupMenu);

  var Menu = function (_React$Component) {
    _inherits$1(Menu, _React$Component);

    function Menu(props) {
      _classCallCheck$1(this, Menu);

      var _this = _possibleConstructorReturn$1(this, _React$Component.call(this, props));

      _initialiseProps$5.call(_this);

      _this.isRootMenu = true;

      var selectedKeys = props.defaultSelectedKeys;
      var openKeys = props.defaultOpenKeys;
      if ('selectedKeys' in props) {
        selectedKeys = props.selectedKeys || [];
      }
      if ('openKeys' in props) {
        openKeys = props.openKeys || [];
      }

      _this.store = lib_1({
        selectedKeys: selectedKeys,
        openKeys: openKeys,
        activeKey: { '0-menu-': getActiveKey(props, props.activeKey) }
      });
      return _this;
    }

    Menu.prototype.componentDidMount = function componentDidMount() {
      this.updateMiniStore();
    };

    Menu.prototype.componentDidUpdate = function componentDidUpdate() {
      this.updateMiniStore();
    };

    // onKeyDown needs to be exposed as a instance method
    // e.g., in rc-select, we need to navigate menu item while
    // current active item is rc-select input box rather than the menu itself


    Menu.prototype.updateMiniStore = function updateMiniStore() {
      if ('selectedKeys' in this.props) {
        this.store.setState({
          selectedKeys: this.props.selectedKeys || []
        });
      }
      if ('openKeys' in this.props) {
        this.store.setState({
          openKeys: this.props.openKeys || []
        });
      }
    };

    Menu.prototype.render = function render() {
      var _this2 = this;

      var props = _objectWithoutProperties$1(this.props, []);

      props.className += ' ' + props.prefixCls + '-root';
      props = _extends$2({}, props, {
        onClick: this.onClick,
        onOpenChange: this.onOpenChange,
        onDeselect: this.onDeselect,
        onSelect: this.onSelect,
        openTransitionName: this.getOpenTransitionName(),
        parentMenu: this
      });
      return React$1__default.createElement(
        lib_3,
        { store: this.store },
        React$1__default.createElement(
          connected$1,
          _extends$2({}, props, { ref: function ref(c) {
              return _this2.innerMenu = c;
            } }),
          this.props.children
        )
      );
    };

    return Menu;
  }(React$1__default.Component);

  Menu.propTypes = {
    defaultSelectedKeys: PropTypes.arrayOf(PropTypes.string),
    defaultActiveFirst: PropTypes.bool,
    selectedKeys: PropTypes.arrayOf(PropTypes.string),
    defaultOpenKeys: PropTypes.arrayOf(PropTypes.string),
    openKeys: PropTypes.arrayOf(PropTypes.string),
    mode: PropTypes.oneOf(['horizontal', 'vertical', 'vertical-left', 'vertical-right', 'inline']),
    getPopupContainer: PropTypes.func,
    onClick: PropTypes.func,
    onSelect: PropTypes.func,
    onDeselect: PropTypes.func,
    onDestroy: PropTypes.func,
    openTransitionName: PropTypes.string,
    openAnimation: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
    subMenuOpenDelay: PropTypes.number,
    subMenuCloseDelay: PropTypes.number,
    forceSubMenuRender: PropTypes.bool,
    triggerSubMenuAction: PropTypes.string,
    level: PropTypes.number,
    selectable: PropTypes.bool,
    multiple: PropTypes.bool,
    children: PropTypes.any,
    className: PropTypes.string,
    style: PropTypes.object,
    activeKey: PropTypes.string,
    prefixCls: PropTypes.string,
    builtinPlacements: PropTypes.object,
    itemIcon: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),
    expandIcon: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),
    overflowedIndicator: PropTypes.node
  };
  Menu.defaultProps = {
    selectable: true,
    onClick: noop$1,
    onSelect: noop$1,
    onOpenChange: noop$1,
    onDeselect: noop$1,
    defaultSelectedKeys: [],
    defaultOpenKeys: [],
    subMenuOpenDelay: 0.1,
    subMenuCloseDelay: 0.1,
    triggerSubMenuAction: 'hover',
    prefixCls: 'rc-menu',
    className: '',
    mode: 'vertical',
    style: {},
    builtinPlacements: {},
    overflowedIndicator: React$1__default.createElement(
      'span',
      null,
      '\xB7\xB7\xB7'
    )
  };

  var _initialiseProps$5 = function _initialiseProps() {
    var _this3 = this;

    this.onSelect = function (selectInfo) {
      var props = _this3.props;
      if (props.selectable) {
        // root menu
        var selectedKeys = _this3.store.getState().selectedKeys;
        var selectedKey = selectInfo.key;
        if (props.multiple) {
          selectedKeys = selectedKeys.concat([selectedKey]);
        } else {
          selectedKeys = [selectedKey];
        }
        if (!('selectedKeys' in props)) {
          _this3.store.setState({
            selectedKeys: selectedKeys
          });
        }
        props.onSelect(_extends$2({}, selectInfo, {
          selectedKeys: selectedKeys
        }));
      }
    };

    this.onClick = function (e) {
      _this3.props.onClick(e);
    };

    this.onKeyDown = function (e, callback) {
      _this3.innerMenu.getWrappedInstance().onKeyDown(e, callback);
    };

    this.onOpenChange = function (event) {
      var props = _this3.props;
      var openKeys = _this3.store.getState().openKeys.concat();
      var changed = false;
      var processSingle = function processSingle(e) {
        var oneChanged = false;
        if (e.open) {
          oneChanged = openKeys.indexOf(e.key) === -1;
          if (oneChanged) {
            openKeys.push(e.key);
          }
        } else {
          var index = openKeys.indexOf(e.key);
          oneChanged = index !== -1;
          if (oneChanged) {
            openKeys.splice(index, 1);
          }
        }
        changed = changed || oneChanged;
      };
      if (Array.isArray(event)) {
        // batch change call
        event.forEach(processSingle);
      } else {
        processSingle(event);
      }
      if (changed) {
        if (!('openKeys' in _this3.props)) {
          _this3.store.setState({ openKeys: openKeys });
        }
        props.onOpenChange(openKeys);
      }
    };

    this.onDeselect = function (selectInfo) {
      var props = _this3.props;
      if (props.selectable) {
        var selectedKeys = _this3.store.getState().selectedKeys.concat();
        var selectedKey = selectInfo.key;
        var index = selectedKeys.indexOf(selectedKey);
        if (index !== -1) {
          selectedKeys.splice(index, 1);
        }
        if (!('selectedKeys' in props)) {
          _this3.store.setState({
            selectedKeys: selectedKeys
          });
        }
        props.onDeselect(_extends$2({}, selectInfo, {
          selectedKeys: selectedKeys
        }));
      }
    };

    this.getOpenTransitionName = function () {
      var props = _this3.props;
      var transitionName = props.openTransitionName;
      var animationName = props.openAnimation;
      if (!transitionName && typeof animationName === 'string') {
        transitionName = props.prefixCls + '-open-' + animationName;
      }
      return transitionName;
    };
  };

  /* eslint react/no-is-mounted:0 */

  var MenuItem = function (_React$Component) {
    _inherits$1(MenuItem, _React$Component);

    function MenuItem(props) {
      _classCallCheck$1(this, MenuItem);

      var _this = _possibleConstructorReturn$1(this, _React$Component.call(this, props));

      _this.onKeyDown = function (e) {
        var keyCode = e.keyCode;
        if (keyCode === KeyCode.ENTER) {
          _this.onClick(e);
          return true;
        }
      };

      _this.onMouseLeave = function (e) {
        var _this$props = _this.props,
            eventKey = _this$props.eventKey,
            onItemHover = _this$props.onItemHover,
            onMouseLeave = _this$props.onMouseLeave;

        onItemHover({
          key: eventKey,
          hover: false
        });
        onMouseLeave({
          key: eventKey,
          domEvent: e
        });
      };

      _this.onMouseEnter = function (e) {
        var _this$props2 = _this.props,
            eventKey = _this$props2.eventKey,
            onItemHover = _this$props2.onItemHover,
            onMouseEnter = _this$props2.onMouseEnter;

        onItemHover({
          key: eventKey,
          hover: true
        });
        onMouseEnter({
          key: eventKey,
          domEvent: e
        });
      };

      _this.onClick = function (e) {
        var _this$props3 = _this.props,
            eventKey = _this$props3.eventKey,
            multiple = _this$props3.multiple,
            onClick = _this$props3.onClick,
            onSelect = _this$props3.onSelect,
            onDeselect = _this$props3.onDeselect,
            isSelected = _this$props3.isSelected;

        var info = {
          key: eventKey,
          keyPath: [eventKey],
          item: _this,
          domEvent: e
        };
        onClick(info);
        if (multiple) {
          if (isSelected) {
            onDeselect(info);
          } else {
            onSelect(info);
          }
        } else if (!isSelected) {
          onSelect(info);
        }
      };

      return _this;
    }

    MenuItem.prototype.componentDidMount = function componentDidMount() {
      // invoke customized ref to expose component to mixin
      this.callRef();
    };

    MenuItem.prototype.componentDidUpdate = function componentDidUpdate() {
      if (this.props.active) {
        lib(ReactDOM__default.findDOMNode(this), ReactDOM__default.findDOMNode(this.props.parentMenu), {
          onlyScrollIfNeeded: true
        });
      }
      this.callRef();
    };

    MenuItem.prototype.componentWillUnmount = function componentWillUnmount() {
      var props = this.props;
      if (props.onDestroy) {
        props.onDestroy(props.eventKey);
      }
    };

    MenuItem.prototype.getPrefixCls = function getPrefixCls() {
      return this.props.rootPrefixCls + '-item';
    };

    MenuItem.prototype.getActiveClassName = function getActiveClassName() {
      return this.getPrefixCls() + '-active';
    };

    MenuItem.prototype.getSelectedClassName = function getSelectedClassName() {
      return this.getPrefixCls() + '-selected';
    };

    MenuItem.prototype.getDisabledClassName = function getDisabledClassName() {
      return this.getPrefixCls() + '-disabled';
    };

    MenuItem.prototype.callRef = function callRef() {
      if (this.props.manualRef) {
        this.props.manualRef(this);
      }
    };

    MenuItem.prototype.render = function render() {
      var _classNames;

      var props = _extends$2({}, this.props);
      var className = classnames(this.getPrefixCls(), props.className, (_classNames = {}, _classNames[this.getActiveClassName()] = !props.disabled && props.active, _classNames[this.getSelectedClassName()] = props.isSelected, _classNames[this.getDisabledClassName()] = props.disabled, _classNames));
      var attrs = _extends$2({}, props.attribute, {
        title: props.title,
        className: className,
        // set to menuitem by default
        role: props.role || 'menuitem',
        'aria-disabled': props.disabled
      });

      if (props.role === 'option') {
        // overwrite to option
        attrs = _extends$2({}, attrs, {
          role: 'option',
          'aria-selected': props.isSelected
        });
      } else if (props.role === null || props.role === 'none') {
        // sometimes we want to specify role inside <li/> element
        // <li><a role='menuitem'>Link</a></li> would be a good example
        // in this case the role on <li/> should be "none" to
        // remove the implied listitem role.
        // https://www.w3.org/TR/wai-aria-practices-1.1/examples/menubar/menubar-1/menubar-1.html
        attrs.role = 'none';
      }
      // In case that onClick/onMouseLeave/onMouseEnter is passed down from owner
      var mouseEvent = {
        onClick: props.disabled ? null : this.onClick,
        onMouseLeave: props.disabled ? null : this.onMouseLeave,
        onMouseEnter: props.disabled ? null : this.onMouseEnter
      };
      var style = _extends$2({}, props.style);
      if (props.mode === 'inline') {
        style.paddingLeft = props.inlineIndent * props.level;
      }
      menuAllProps.forEach(function (key) {
        return delete props[key];
      });
      var icon = this.props.itemIcon;
      if (typeof this.props.itemIcon === 'function') {
        icon = React$1__default.createElement(this.props.itemIcon, this.props);
      }
      return React$1__default.createElement(
        'li',
        _extends$2({}, props, attrs, mouseEvent, {
          style: style
        }),
        props.children,
        icon
      );
    };

    return MenuItem;
  }(React$1__default.Component);

  MenuItem.propTypes = {
    attribute: PropTypes.object,
    rootPrefixCls: PropTypes.string,
    eventKey: PropTypes.string,
    active: PropTypes.bool,
    children: PropTypes.any,
    selectedKeys: PropTypes.array,
    disabled: PropTypes.bool,
    title: PropTypes.string,
    onItemHover: PropTypes.func,
    onSelect: PropTypes.func,
    onClick: PropTypes.func,
    onDeselect: PropTypes.func,
    parentMenu: PropTypes.object,
    onDestroy: PropTypes.func,
    onMouseEnter: PropTypes.func,
    onMouseLeave: PropTypes.func,
    multiple: PropTypes.bool,
    isSelected: PropTypes.bool,
    manualRef: PropTypes.func,
    itemIcon: PropTypes.oneOfType([PropTypes.func, PropTypes.node])
  };
  MenuItem.defaultProps = {
    onSelect: noop$1,
    onMouseEnter: noop$1,
    onMouseLeave: noop$1,
    manualRef: noop$1
  };
  MenuItem.isMenuItem = true;

  var connected$2 = lib_2(function (_ref, _ref2) {
    var activeKey = _ref.activeKey,
        selectedKeys = _ref.selectedKeys;
    var eventKey = _ref2.eventKey,
        subMenuKey = _ref2.subMenuKey;
    return {
      active: activeKey[subMenuKey] === eventKey,
      isSelected: selectedKeys.indexOf(eventKey) !== -1
    };
  })(MenuItem);

  var MenuItemGroup = function (_React$Component) {
    _inherits$1(MenuItemGroup, _React$Component);

    function MenuItemGroup() {
      var _temp, _this, _ret;

      _classCallCheck$1(this, MenuItemGroup);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn$1(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.renderInnerMenuItem = function (item) {
        var _this$props = _this.props,
            renderMenuItem = _this$props.renderMenuItem,
            index = _this$props.index;

        return renderMenuItem(item, index, _this.props.subMenuKey);
      }, _temp), _possibleConstructorReturn$1(_this, _ret);
    }

    MenuItemGroup.prototype.render = function render() {
      var props = _objectWithoutProperties$1(this.props, []);

      var _props$className = props.className,
          className = _props$className === undefined ? '' : _props$className,
          rootPrefixCls = props.rootPrefixCls;

      var titleClassName = rootPrefixCls + '-item-group-title';
      var listClassName = rootPrefixCls + '-item-group-list';
      var title = props.title,
          children = props.children;

      menuAllProps.forEach(function (key) {
        return delete props[key];
      });

      // Set onClick to null, to ignore propagated onClick event
      delete props.onClick;

      return React$1__default.createElement(
        'li',
        _extends$2({}, props, { className: className + ' ' + rootPrefixCls + '-item-group' }),
        React$1__default.createElement(
          'div',
          {
            className: titleClassName,
            title: typeof title === 'string' ? title : undefined
          },
          title
        ),
        React$1__default.createElement(
          'ul',
          { className: listClassName },
          React$1__default.Children.map(children, this.renderInnerMenuItem)
        )
      );
    };

    return MenuItemGroup;
  }(React$1__default.Component);

  MenuItemGroup.propTypes = {
    renderMenuItem: PropTypes.func,
    index: PropTypes.number,
    className: PropTypes.string,
    subMenuKey: PropTypes.string,
    rootPrefixCls: PropTypes.string
  };
  MenuItemGroup.defaultProps = {
    disabled: true
  };


  MenuItemGroup.isMenuItemGroup = true;

  var Divider = function (_React$Component) {
    _inherits$1(Divider, _React$Component);

    function Divider() {
      _classCallCheck$1(this, Divider);

      return _possibleConstructorReturn$1(this, _React$Component.apply(this, arguments));
    }

    Divider.prototype.render = function render() {
      var _props = this.props,
          className = _props.className,
          rootPrefixCls = _props.rootPrefixCls,
          style = _props.style;

      return React$1__default.createElement('li', {
        className: className + ' ' + rootPrefixCls + '-item-divider',
        style: style
      });
    };

    return Divider;
  }(React$1__default.Component);

  Divider.propTypes = {
    className: PropTypes.string,
    rootPrefixCls: PropTypes.string,
    style: PropTypes.object
  };
  Divider.defaultProps = {
    // To fix keyboard UX.
    disabled: true,
    className: '',
    style: {}
  };

  var Option = function (_React$Component) {
    _inherits$1(Option, _React$Component);

    function Option() {
      _classCallCheck$1(this, Option);

      return _possibleConstructorReturn$1(this, _React$Component.apply(this, arguments));
    }

    return Option;
  }(React$1__default.Component);

  Option.propTypes = {
    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number])
  };
  Option.isSelectOption = true;

  function toTitle(title) {
    if (typeof title === 'string') {
      return title;
    }
    return null;
  }

  function getValuePropValue(child) {
    if (!child) {
      return null;
    }

    var props = child.props;
    if ('value' in props) {
      return props.value;
    }
    if (child.key) {
      return child.key;
    }
    if (child.type && child.type.isSelectOptGroup && props.label) {
      return props.label;
    }
    throw new Error('Need at least a key or a value or a label (only for OptGroup) for ' + child);
  }

  function getPropValue(child, prop) {
    if (prop === 'value') {
      return getValuePropValue(child);
    }
    return child.props[prop];
  }

  function isMultiple(props) {
    return props.multiple;
  }

  function isCombobox(props) {
    return props.combobox;
  }

  function isMultipleOrTags(props) {
    return props.multiple || props.tags;
  }

  function isMultipleOrTagsOrCombobox(props) {
    return isMultipleOrTags(props) || isCombobox(props);
  }

  function isSingleMode(props) {
    return !isMultipleOrTagsOrCombobox(props);
  }

  function toArray$1(value) {
    var ret = value;
    if (value === undefined) {
      ret = [];
    } else if (!Array.isArray(value)) {
      ret = [value];
    }
    return ret;
  }

  function getMapKey(value) {
    return typeof value + '-' + value;
  }

  function preventDefaultEvent(e) {
    e.preventDefault();
  }

  function findIndexInValueBySingleValue(value, singleValue) {
    var index = -1;
    for (var i = 0; i < value.length; i++) {
      if (value[i] === singleValue) {
        index = i;
        break;
      }
    }
    return index;
  }

  function getLabelFromPropsValue(value, key) {
    var label = void 0;
    value = toArray$1(value);
    for (var i = 0; i < value.length; i++) {
      if (value[i].key === key) {
        label = value[i].label;
        break;
      }
    }
    return label;
  }

  function getSelectKeys(menuItems, value) {
    if (value === null || value === undefined) {
      return [];
    }
    var selectedKeys = [];
    React$1__default.Children.forEach(menuItems, function (item) {
      if (item.type.isMenuItemGroup) {
        selectedKeys = selectedKeys.concat(getSelectKeys(item.props.children, value));
      } else {
        var itemValue = getValuePropValue(item);
        var itemKey = item.key;
        if (findIndexInValueBySingleValue(value, itemValue) !== -1 && itemKey) {
          selectedKeys.push(itemKey);
        }
      }
    });
    return selectedKeys;
  }

  var UNSELECTABLE_STYLE = {
    userSelect: 'none',
    WebkitUserSelect: 'none'
  };

  var UNSELECTABLE_ATTRIBUTE = {
    unselectable: 'on'
  };

  function findFirstMenuItem(children) {
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      if (child.type.isMenuItemGroup) {
        var found = findFirstMenuItem(child.props.children);
        if (found) {
          return found;
        }
      } else if (!child.props.disabled) {
        return child;
      }
    }
    return null;
  }

  function includesSeparators(string, separators) {
    for (var i = 0; i < separators.length; ++i) {
      if (string.lastIndexOf(separators[i]) > 0) {
        return true;
      }
    }
    return false;
  }

  function splitBySeparators(string, separators) {
    var reg = new RegExp('[' + separators.join() + ']');
    return string.split(reg).filter(function (token) {
      return token;
    });
  }

  function defaultFilterFn(input, child) {
    if (child.props.disabled) {
      return false;
    }
    var value = toArray$1(getPropValue(child, this.props.optionFilterProp)).join('');
    return value.toLowerCase().indexOf(input.toLowerCase()) > -1;
  }

  function validateOptionValue(value, props) {
    if (isSingleMode(props) || isMultiple(props)) {
      return;
    }
    if (typeof value !== 'string') {
      throw new Error('Invalid `value` of type `' + typeof value + '` supplied to Option, ' + 'expected `string` when `tags/combobox` is `true`.');
    }
  }

  function saveRef$2(instance, name) {
    return function (node) {
      instance[name] = node;
    };
  }

  var DropdownMenu = function (_React$Component) {
    _inherits$1(DropdownMenu, _React$Component);

    function DropdownMenu(props) {
      _classCallCheck$1(this, DropdownMenu);

      var _this = _possibleConstructorReturn$1(this, _React$Component.call(this, props));

      _initialiseProps$6.call(_this);

      _this.lastInputValue = props.inputValue;
      _this.saveMenuRef = saveRef$2(_this, 'menuRef');
      return _this;
    }

    DropdownMenu.prototype.componentDidMount = function componentDidMount() {
      this.scrollActiveItemToView();
      this.lastVisible = this.props.visible;
    };

    DropdownMenu.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      if (!nextProps.visible) {
        this.lastVisible = false;
      }
      // freeze when hide
      return nextProps.visible;
    };

    DropdownMenu.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
      var props = this.props;
      if (!prevProps.visible && props.visible) {
        this.scrollActiveItemToView();
      }
      this.lastVisible = props.visible;
      this.lastInputValue = props.inputValue;
    };

    DropdownMenu.prototype.renderMenu = function renderMenu() {
      var _this2 = this;

      var props = this.props;
      var menuItems = props.menuItems,
          defaultActiveFirstOption = props.defaultActiveFirstOption,
          value = props.value,
          prefixCls = props.prefixCls,
          multiple = props.multiple,
          onMenuSelect = props.onMenuSelect,
          inputValue = props.inputValue,
          firstActiveValue = props.firstActiveValue,
          backfillValue = props.backfillValue;

      if (menuItems && menuItems.length) {
        var menuProps = {};
        if (multiple) {
          menuProps.onDeselect = props.onMenuDeselect;
          menuProps.onSelect = onMenuSelect;
        } else {
          menuProps.onClick = onMenuSelect;
        }

        var selectedKeys = getSelectKeys(menuItems, value);
        var activeKeyProps = {};

        var clonedMenuItems = menuItems;
        if (selectedKeys.length || firstActiveValue) {
          if (props.visible && !this.lastVisible) {
            activeKeyProps.activeKey = selectedKeys[0] || firstActiveValue;
          }
          var foundFirst = false;
          // set firstActiveItem via cloning menus
          // for scroll into view
          var clone = function clone(item) {
            if (!foundFirst && selectedKeys.indexOf(item.key) !== -1 || !foundFirst && !selectedKeys.length && firstActiveValue.indexOf(item.key) !== -1) {
              foundFirst = true;
              return React$1.cloneElement(item, {
                ref: function ref(_ref) {
                  _this2.firstActiveItem = _ref;
                }
              });
            }
            return item;
          };

          clonedMenuItems = menuItems.map(function (item) {
            if (item.type.isMenuItemGroup) {
              var children = toArray(item.props.children).map(clone);
              return React$1.cloneElement(item, {}, children);
            }
            return clone(item);
          });
        } else {
          // Clear firstActiveItem when dropdown menu items was empty
          // Avoid `Unable to find node on an unmounted component`
          // https://github.com/ant-design/ant-design/issues/10774
          this.firstActiveItem = null;
        }

        // clear activeKey when inputValue change
        var lastValue = value && value[value.length - 1];
        if (inputValue !== this.lastInputValue && (!lastValue || lastValue !== backfillValue)) {
          activeKeyProps.activeKey = '';
        }
        return React$1__default.createElement(
          Menu,
          _extends$2({
            ref: this.saveMenuRef,
            style: this.props.dropdownMenuStyle,
            defaultActiveFirst: defaultActiveFirstOption,
            role: 'listbox'
          }, activeKeyProps, {
            multiple: multiple
          }, menuProps, {
            selectedKeys: selectedKeys,
            prefixCls: prefixCls + '-menu'
          }),
          clonedMenuItems
        );
      }
      return null;
    };

    DropdownMenu.prototype.render = function render() {
      var renderMenu = this.renderMenu();
      return renderMenu ? React$1__default.createElement(
        'div',
        {
          style: { overflow: 'auto' },
          onFocus: this.props.onPopupFocus,
          onMouseDown: preventDefaultEvent,
          onScroll: this.props.onPopupScroll
        },
        renderMenu
      ) : null;
    };

    return DropdownMenu;
  }(React$1__default.Component);

  DropdownMenu.propTypes = {
    defaultActiveFirstOption: PropTypes.bool,
    value: PropTypes.any,
    dropdownMenuStyle: PropTypes.object,
    multiple: PropTypes.bool,
    onPopupFocus: PropTypes.func,
    onPopupScroll: PropTypes.func,
    onMenuDeSelect: PropTypes.func,
    onMenuSelect: PropTypes.func,
    prefixCls: PropTypes.string,
    menuItems: PropTypes.any,
    inputValue: PropTypes.string,
    visible: PropTypes.bool
  };

  var _initialiseProps$6 = function _initialiseProps() {
    var _this3 = this;

    this.scrollActiveItemToView = function () {
      // scroll into view
      var itemComponent = ReactDOM.findDOMNode(_this3.firstActiveItem);
      var props = _this3.props;

      if (itemComponent) {
        var scrollIntoViewOpts = {
          onlyScrollIfNeeded: true
        };
        if ((!props.value || props.value.length === 0) && props.firstActiveValue) {
          scrollIntoViewOpts.alignWithTop = true;
        }

        lib(itemComponent, ReactDOM.findDOMNode(_this3.menuRef), scrollIntoViewOpts);
      }
    };
  };


  DropdownMenu.displayName = 'DropdownMenu';

  Trigger.displayName = 'Trigger';

  var BUILT_IN_PLACEMENTS = {
    bottomLeft: {
      points: ['tl', 'bl'],
      offset: [0, 4],
      overflow: {
        adjustX: 0,
        adjustY: 1
      }
    },
    topLeft: {
      points: ['bl', 'tl'],
      offset: [0, -4],
      overflow: {
        adjustX: 0,
        adjustY: 1
      }
    }
  };

  var SelectTrigger = function (_React$Component) {
    _inherits$1(SelectTrigger, _React$Component);

    function SelectTrigger(props) {
      _classCallCheck$1(this, SelectTrigger);

      var _this = _possibleConstructorReturn$1(this, _React$Component.call(this, props));

      _initialiseProps$7.call(_this);

      _this.saveDropdownMenuRef = saveRef$2(_this, 'dropdownMenuRef');
      _this.saveTriggerRef = saveRef$2(_this, 'triggerRef');

      _this.state = {
        dropdownWidth: null
      };
      return _this;
    }

    SelectTrigger.prototype.componentDidMount = function componentDidMount() {
      this.setDropdownWidth();
    };

    SelectTrigger.prototype.componentDidUpdate = function componentDidUpdate() {
      this.setDropdownWidth();
    };

    SelectTrigger.prototype.render = function render() {
      var _popupClassName;

      var _props = this.props,
          onPopupFocus = _props.onPopupFocus,
          props = _objectWithoutProperties$1(_props, ['onPopupFocus']);

      var multiple = props.multiple,
          visible = props.visible,
          inputValue = props.inputValue,
          dropdownAlign = props.dropdownAlign,
          disabled = props.disabled,
          showSearch = props.showSearch,
          dropdownClassName = props.dropdownClassName,
          dropdownStyle = props.dropdownStyle,
          dropdownMatchSelectWidth = props.dropdownMatchSelectWidth;

      var dropdownPrefixCls = this.getDropdownPrefixCls();
      var popupClassName = (_popupClassName = {}, _popupClassName[dropdownClassName] = !!dropdownClassName, _popupClassName[dropdownPrefixCls + '--' + (multiple ? 'multiple' : 'single')] = 1, _popupClassName);
      var popupElement = this.getDropdownElement({
        menuItems: props.options,
        onPopupFocus: onPopupFocus,
        multiple: multiple,
        inputValue: inputValue,
        visible: visible
      });
      var hideAction = void 0;
      if (disabled) {
        hideAction = [];
      } else if (isSingleMode(props) && !showSearch) {
        hideAction = ['click'];
      } else {
        hideAction = ['blur'];
      }
      var popupStyle = _extends$2({}, dropdownStyle);
      var widthProp = dropdownMatchSelectWidth ? 'width' : 'minWidth';
      if (this.state.dropdownWidth) {
        popupStyle[widthProp] = this.state.dropdownWidth + 'px';
      }

      return React$1__default.createElement(
        Trigger,
        _extends$2({}, props, {
          showAction: disabled ? [] : this.props.showAction,
          hideAction: hideAction,
          ref: this.saveTriggerRef,
          popupPlacement: 'bottomLeft',
          builtinPlacements: BUILT_IN_PLACEMENTS,
          prefixCls: dropdownPrefixCls,
          popupTransitionName: this.getDropdownTransitionName(),
          onPopupVisibleChange: props.onDropdownVisibleChange,
          popup: popupElement,
          popupAlign: dropdownAlign,
          popupVisible: visible,
          getPopupContainer: props.getPopupContainer,
          popupClassName: classnames(popupClassName),
          popupStyle: popupStyle
        }),
        props.children
      );
    };

    return SelectTrigger;
  }(React$1__default.Component);

  SelectTrigger.propTypes = {
    onPopupFocus: PropTypes.func,
    onPopupScroll: PropTypes.func,
    dropdownMatchSelectWidth: PropTypes.bool,
    dropdownAlign: PropTypes.object,
    visible: PropTypes.bool,
    disabled: PropTypes.bool,
    showSearch: PropTypes.bool,
    dropdownClassName: PropTypes.string,
    multiple: PropTypes.bool,
    inputValue: PropTypes.string,
    filterOption: PropTypes.any,
    options: PropTypes.any,
    prefixCls: PropTypes.string,
    popupClassName: PropTypes.string,
    children: PropTypes.any,
    showAction: PropTypes.arrayOf(PropTypes.string)
  };

  var _initialiseProps$7 = function _initialiseProps() {
    var _this2 = this;

    this.setDropdownWidth = function () {
      var width = ReactDOM__default.findDOMNode(_this2).offsetWidth;
      if (width !== _this2.state.dropdownWidth) {
        _this2.setState({ dropdownWidth: width });
      }
    };

    this.getInnerMenu = function () {
      return _this2.dropdownMenuRef && _this2.dropdownMenuRef.menuRef;
    };

    this.getPopupDOMNode = function () {
      return _this2.triggerRef.getPopupDomNode();
    };

    this.getDropdownElement = function (newProps) {
      var props = _this2.props;
      return React$1__default.createElement(DropdownMenu, _extends$2({
        ref: _this2.saveDropdownMenuRef
      }, newProps, {
        prefixCls: _this2.getDropdownPrefixCls(),
        onMenuSelect: props.onMenuSelect,
        onMenuDeselect: props.onMenuDeselect,
        onPopupScroll: props.onPopupScroll,
        value: props.value,
        backfillValue: props.backfillValue,
        firstActiveValue: props.firstActiveValue,
        defaultActiveFirstOption: props.defaultActiveFirstOption,
        dropdownMenuStyle: props.dropdownMenuStyle
      }));
    };

    this.getDropdownTransitionName = function () {
      var props = _this2.props;
      var transitionName = props.transitionName;
      if (!transitionName && props.animation) {
        transitionName = _this2.getDropdownPrefixCls() + '-' + props.animation;
      }
      return transitionName;
    };

    this.getDropdownPrefixCls = function () {
      return _this2.props.prefixCls + '-dropdown';
    };
  };


  SelectTrigger.displayName = 'SelectTrigger';

  function valueType(props, propName, componentName) {
    var basicType = PropTypes.oneOfType([PropTypes.string, PropTypes.number]);

    var labelInValueShape = PropTypes.shape({
      key: basicType.isRequired,
      label: PropTypes.node
    });
    if (props.labelInValue) {
      var validate = PropTypes.oneOfType([PropTypes.arrayOf(labelInValueShape), labelInValueShape]);
      var error = validate.apply(undefined, arguments);
      if (error) {
        return new Error('Invalid prop `' + propName + '` supplied to `' + componentName + '`, ' + ('when you set `labelInValue` to `true`, `' + propName + '` should in ') + 'shape of `{ key: string | number, label?: ReactNode }`.');
      }
    } else if ((props.mode === 'multiple' || props.mode === 'tags' || props.multiple || props.tags) && props[propName] === '') {
      return new Error('Invalid prop `' + propName + '` of type `string` supplied to `' + componentName + '`, ' + 'expected `array` when `multiple` or `tags` is `true`.');
    } else {
      var _validate = PropTypes.oneOfType([PropTypes.arrayOf(basicType), basicType]);
      return _validate.apply(undefined, arguments);
    }
  }

  var SelectPropTypes = {
    defaultActiveFirstOption: PropTypes.bool,
    multiple: PropTypes.bool,
    filterOption: PropTypes.any,
    children: PropTypes.any,
    showSearch: PropTypes.bool,
    disabled: PropTypes.bool,
    allowClear: PropTypes.bool,
    showArrow: PropTypes.bool,
    tags: PropTypes.bool,
    prefixCls: PropTypes.string,
    className: PropTypes.string,
    transitionName: PropTypes.string,
    optionLabelProp: PropTypes.string,
    optionFilterProp: PropTypes.string,
    animation: PropTypes.string,
    choiceTransitionName: PropTypes.string,
    onChange: PropTypes.func,
    onBlur: PropTypes.func,
    onFocus: PropTypes.func,
    onSelect: PropTypes.func,
    onSearch: PropTypes.func,
    onPopupScroll: PropTypes.func,
    onMouseEnter: PropTypes.func,
    onMouseLeave: PropTypes.func,
    onInputKeyDown: PropTypes.func,
    placeholder: PropTypes.any,
    onDeselect: PropTypes.func,
    labelInValue: PropTypes.bool,
    value: valueType,
    defaultValue: valueType,
    dropdownStyle: PropTypes.object,
    maxTagTextLength: PropTypes.number,
    maxTagCount: PropTypes.number,
    maxTagPlaceholder: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
    tokenSeparators: PropTypes.arrayOf(PropTypes.string),
    getInputElement: PropTypes.func,
    showAction: PropTypes.arrayOf(PropTypes.string)
  };

  function noop$3() {}

  function chaining() {
    for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {
      fns[_key] = arguments[_key];
    }

    return function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      // eslint-disable-line
      // eslint-disable-line
      for (var i = 0; i < fns.length; i++) {
        if (fns[i] && typeof fns[i] === 'function') {
          fns[i].apply(this, args);
        }
      }
    };
  }

  var Select = function (_React$Component) {
    _inherits$1(Select, _React$Component);

    function Select(props) {
      _classCallCheck$1(this, Select);

      var _this = _possibleConstructorReturn$1(this, _React$Component.call(this, props));

      _initialiseProps$8.call(_this);

      var optionsInfo = Select.getOptionsInfoFromProps(props);
      _this.state = {
        value: Select.getValueFromProps(props, true), // true: use default value
        inputValue: props.combobox ? Select.getInputValueForCombobox(props, optionsInfo, true // use default value
        ) : '',
        open: props.defaultOpen,
        optionsInfo: optionsInfo,
        // a flag for aviod redundant getOptionsInfoFromProps call
        skipBuildOptionsInfo: true
      };

      _this.saveInputRef = saveRef$2(_this, 'inputRef');
      _this.saveInputMirrorRef = saveRef$2(_this, 'inputMirrorRef');
      _this.saveTopCtrlRef = saveRef$2(_this, 'topCtrlRef');
      _this.saveSelectTriggerRef = saveRef$2(_this, 'selectTriggerRef');
      _this.saveRootRef = saveRef$2(_this, 'rootRef');
      _this.saveSelectionRef = saveRef$2(_this, 'selectionRef');
      return _this;
    }

    Select.prototype.componentDidMount = function componentDidMount() {
      if (this.props.autoFocus) {
        this.focus();
      }
    };

    Select.prototype.componentDidUpdate = function componentDidUpdate() {
      if (isMultipleOrTags(this.props)) {
        var inputNode = this.getInputDOMNode();
        var mirrorNode = this.getInputMirrorDOMNode();
        if (inputNode.value) {
          inputNode.style.width = '';
          inputNode.style.width = mirrorNode.clientWidth + 'px';
        } else {
          inputNode.style.width = '';
        }
      }
      this.forcePopupAlign();
    };

    Select.prototype.componentWillUnmount = function componentWillUnmount() {
      this.clearFocusTime();
      this.clearBlurTime();
      if (this.dropdownContainer) {
        ReactDOM__default.unmountComponentAtNode(this.dropdownContainer);
        document.body.removeChild(this.dropdownContainer);
        this.dropdownContainer = null;
      }
    };

    // combobox ignore


    Select.prototype.focus = function focus() {
      if (isSingleMode(this.props)) {
        this.selectionRef.focus();
      } else {
        this.getInputDOMNode().focus();
      }
    };

    Select.prototype.blur = function blur() {
      if (isSingleMode(this.props)) {
        this.selectionRef.blur();
      } else {
        this.getInputDOMNode().blur();
      }
    };

    Select.prototype.renderClear = function renderClear() {
      var _props = this.props,
          prefixCls = _props.prefixCls,
          allowClear = _props.allowClear;
      var _state = this.state,
          value = _state.value,
          inputValue = _state.inputValue;

      var clear = React$1__default.createElement('span', _extends$2({
        key: 'clear',
        onMouseDown: preventDefaultEvent,
        style: UNSELECTABLE_STYLE
      }, UNSELECTABLE_ATTRIBUTE, {
        className: prefixCls + '-selection__clear',
        onClick: this.onClearSelection
      }));
      if (!allowClear) {
        return null;
      }
      if (isCombobox(this.props)) {
        if (inputValue) {
          return clear;
        }
        return null;
      }
      if (inputValue || value.length) {
        return clear;
      }
      return null;
    };

    Select.prototype.render = function render() {
      var _rootCls;

      var props = this.props;
      var multiple = isMultipleOrTags(props);
      var state = this.state;
      var className = props.className,
          disabled = props.disabled,
          prefixCls = props.prefixCls;

      var ctrlNode = this.renderTopControlNode();
      var extraSelectionProps = {};
      var open = this.state.open;

      if (open) {
        this._options = this.renderFilterOptions();
      }
      var realOpen = this.getRealOpenState();
      var options = this._options || [];
      if (!isMultipleOrTagsOrCombobox(props)) {
        extraSelectionProps = {
          onKeyDown: this.onKeyDown,
          tabIndex: props.disabled ? -1 : 0
        };
      }
      var rootCls = (_rootCls = {}, _rootCls[className] = !!className, _rootCls[prefixCls] = 1, _rootCls[prefixCls + '-open'] = open, _rootCls[prefixCls + '-focused'] = open || !!this._focused, _rootCls[prefixCls + '-combobox'] = isCombobox(props), _rootCls[prefixCls + '-disabled'] = disabled, _rootCls[prefixCls + '-enabled'] = !disabled, _rootCls[prefixCls + '-allow-clear'] = !!props.allowClear, _rootCls[prefixCls + '-no-arrow'] = !props.showArrow, _rootCls);
      return React$1__default.createElement(
        SelectTrigger,
        {
          onPopupFocus: this.onPopupFocus,
          onMouseEnter: this.props.onMouseEnter,
          onMouseLeave: this.props.onMouseLeave,
          dropdownAlign: props.dropdownAlign,
          dropdownClassName: props.dropdownClassName,
          dropdownMatchSelectWidth: props.dropdownMatchSelectWidth,
          defaultActiveFirstOption: props.defaultActiveFirstOption,
          dropdownMenuStyle: props.dropdownMenuStyle,
          transitionName: props.transitionName,
          animation: props.animation,
          prefixCls: props.prefixCls,
          dropdownStyle: props.dropdownStyle,
          combobox: props.combobox,
          showSearch: props.showSearch,
          options: options,
          multiple: multiple,
          disabled: disabled,
          visible: realOpen,
          inputValue: state.inputValue,
          value: state.value,
          backfillValue: state.backfillValue,
          firstActiveValue: props.firstActiveValue,
          onDropdownVisibleChange: this.onDropdownVisibleChange,
          getPopupContainer: props.getPopupContainer,
          onMenuSelect: this.onMenuSelect,
          onMenuDeselect: this.onMenuDeselect,
          onPopupScroll: props.onPopupScroll,
          showAction: props.showAction,
          ref: this.saveSelectTriggerRef
        },
        React$1__default.createElement(
          'div',
          {
            style: props.style,
            ref: this.saveRootRef,
            onBlur: this.onOuterBlur,
            onFocus: this.onOuterFocus,
            className: classnames(rootCls)
          },
          React$1__default.createElement(
            'div',
            _extends$2({
              ref: this.saveSelectionRef,
              key: 'selection',
              className: prefixCls + '-selection\n            ' + prefixCls + '-selection--' + (multiple ? 'multiple' : 'single'),
              role: 'combobox',
              'aria-autocomplete': 'list',
              'aria-haspopup': 'true',
              'aria-expanded': realOpen
            }, extraSelectionProps),
            ctrlNode,
            this.renderClear(),
            multiple || !props.showArrow ? null : React$1__default.createElement(
              'span',
              _extends$2({
                key: 'arrow',
                className: prefixCls + '-arrow',
                style: UNSELECTABLE_STYLE
              }, UNSELECTABLE_ATTRIBUTE, {
                onClick: this.onArrowClick
              }),
              React$1__default.createElement('b', null)
            )
          )
        )
      );
    };

    return Select;
  }(React$1__default.Component);

  Select.propTypes = SelectPropTypes;
  Select.defaultProps = {
    prefixCls: 'rc-select',
    defaultOpen: false,
    labelInValue: false,
    defaultActiveFirstOption: true,
    showSearch: true,
    allowClear: false,
    placeholder: '',
    onChange: noop$3,
    onFocus: noop$3,
    onBlur: noop$3,
    onSelect: noop$3,
    onSearch: noop$3,
    onDeselect: noop$3,
    onInputKeyDown: noop$3,
    showArrow: true,
    dropdownMatchSelectWidth: true,
    dropdownStyle: {},
    dropdownMenuStyle: {},
    optionFilterProp: 'value',
    optionLabelProp: 'value',
    notFoundContent: 'Not Found',
    backfill: false,
    showAction: ['click'],
    tokenSeparators: [],
    autoClearSearchValue: true
  };

  Select.getDerivedStateFromProps = function (nextProps, prevState) {
    var optionsInfo = prevState.skipBuildOptionsInfo ? prevState.optionsInfo : Select.getOptionsInfoFromProps(nextProps, prevState);

    var newState = {
      optionsInfo: optionsInfo,
      skipBuildOptionsInfo: false
    };

    if ('open' in nextProps) {
      newState.open = nextProps.open;
    }

    if ('value' in nextProps) {
      var value = Select.getValueFromProps(nextProps);
      newState.value = value;
      if (nextProps.combobox) {
        newState.inputValue = Select.getInputValueForCombobox(nextProps, optionsInfo);
      }
    }
    return newState;
  };

  Select.getOptionsFromChildren = function (children) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    React$1__default.Children.forEach(children, function (child) {
      if (!child) {
        return;
      }
      if (child.type.isSelectOptGroup) {
        Select.getOptionsFromChildren(child.props.children, options);
      } else {
        options.push(child);
      }
    });
    return options;
  };

  Select.getInputValueForCombobox = function (props, optionsInfo, useDefaultValue) {
    var value = [];
    if ('value' in props && !useDefaultValue) {
      value = toArray$1(props.value);
    }
    if ('defaultValue' in props && useDefaultValue) {
      value = toArray$1(props.defaultValue);
    }
    if (value.length) {
      value = value[0];
    } else {
      return '';
    }
    var label = value;
    if (props.labelInValue) {
      label = value.label;
    } else if (optionsInfo[getMapKey(value)]) {
      label = optionsInfo[getMapKey(value)].label;
    }
    if (label === undefined) {
      label = '';
    }
    return label;
  };

  Select.getLabelFromOption = function (props, option) {
    return getPropValue(option, props.optionLabelProp);
  };

  Select.getOptionsInfoFromProps = function (props, preState) {
    var options = Select.getOptionsFromChildren(props.children);
    var optionsInfo = {};
    options.forEach(function (option) {
      var singleValue = getValuePropValue(option);
      optionsInfo[getMapKey(singleValue)] = {
        option: option,
        value: singleValue,
        label: Select.getLabelFromOption(props, option),
        title: option.props.title
      };
    });
    if (preState) {
      // keep option info in pre state value.
      var oldOptionsInfo = preState.optionsInfo;
      var value = preState.value;
      value.forEach(function (v) {
        var key = getMapKey(v);
        if (!optionsInfo[key] && oldOptionsInfo[key] !== undefined) {
          optionsInfo[key] = oldOptionsInfo[key];
        }
      });
    }
    return optionsInfo;
  };

  Select.getValueFromProps = function (props, useDefaultValue) {
    var value = [];
    if ('value' in props && !useDefaultValue) {
      value = toArray$1(props.value);
    }
    if ('defaultValue' in props && useDefaultValue) {
      value = toArray$1(props.defaultValue);
    }
    if (props.labelInValue) {
      value = value.map(function (v) {
        return v.key;
      });
    }
    return value;
  };

  var _initialiseProps$8 = function _initialiseProps() {
    var _this2 = this;

    this.onInputChange = function (event) {
      var tokenSeparators = _this2.props.tokenSeparators;

      var val = event.target.value;
      if (isMultipleOrTags(_this2.props) && tokenSeparators.length && includesSeparators(val, tokenSeparators)) {
        var nextValue = _this2.getValueByInput(val);
        if (nextValue !== undefined) {
          _this2.fireChange(nextValue);
        }
        _this2.setOpenState(false, true);
        _this2.setInputValue('', false);
        return;
      }
      _this2.setInputValue(val);
      _this2.setState({
        open: true
      });
      if (isCombobox(_this2.props)) {
        _this2.fireChange([val]);
      }
    };

    this.onDropdownVisibleChange = function (open) {
      if (open && !_this2._focused) {
        _this2.clearBlurTime();
        _this2.timeoutFocus();
        _this2._focused = true;
        _this2.updateFocusClassName();
      }
      _this2.setOpenState(open);
    };

    this.onKeyDown = function (event) {
      var props = _this2.props;
      if (props.disabled) {
        return;
      }
      var keyCode = event.keyCode;
      if (_this2.state.open && !_this2.getInputDOMNode()) {
        _this2.onInputKeyDown(event);
      } else if (keyCode === KeyCode.ENTER || keyCode === KeyCode.DOWN) {
        _this2.setOpenState(true);
        event.preventDefault();
      }
    };

    this.onInputKeyDown = function (event) {
      var props = _this2.props;
      if (props.disabled) {
        return;
      }
      var state = _this2.state;
      var keyCode = event.keyCode;
      if (isMultipleOrTags(props) && !event.target.value && keyCode === KeyCode.BACKSPACE) {
        event.preventDefault();
        var value = state.value;

        if (value.length) {
          _this2.removeSelected(value[value.length - 1]);
        }
        return;
      }
      if (keyCode === KeyCode.DOWN) {
        if (!state.open) {
          _this2.openIfHasChildren();
          event.preventDefault();
          event.stopPropagation();
          return;
        }
      } else if (keyCode === KeyCode.ENTER && state.open) {
        // Aviod trigger form submit when select item
        // https://github.com/ant-design/ant-design/issues/10861
        event.preventDefault();
      } else if (keyCode === KeyCode.ESC) {
        if (state.open) {
          _this2.setOpenState(false);
          event.preventDefault();
          event.stopPropagation();
        }
        return;
      }

      if (state.open) {
        var menu = _this2.selectTriggerRef.getInnerMenu();
        if (menu && menu.onKeyDown(event, _this2.handleBackfill)) {
          event.preventDefault();
          event.stopPropagation();
        }
      }
    };

    this.onMenuSelect = function (_ref) {
      var item = _ref.item;

      if (!item) {
        return;
      }
      var value = _this2.state.value;
      var props = _this2.props;
      var selectedValue = getValuePropValue(item);
      var lastValue = value[value.length - 1];
      _this2.fireSelect(selectedValue);
      if (isMultipleOrTags(props)) {
        if (findIndexInValueBySingleValue(value, selectedValue) !== -1) {
          return;
        }
        value = value.concat([selectedValue]);
      } else {
        if (lastValue && lastValue === selectedValue && selectedValue !== _this2.state.backfillValue) {
          _this2.setOpenState(false, true);
          return;
        }
        value = [selectedValue];
        _this2.setOpenState(false, true);
      }
      _this2.fireChange(value);
      var inputValue = void 0;
      if (isCombobox(props)) {
        inputValue = getPropValue(item, props.optionLabelProp);
      } else {
        inputValue = '';
      }
      if (props.autoClearSearchValue) {
        _this2.setInputValue(inputValue, false);
      }
    };

    this.onMenuDeselect = function (_ref2) {
      var item = _ref2.item,
          domEvent = _ref2.domEvent;

      if (domEvent.type === 'click') {
        _this2.removeSelected(getValuePropValue(item));
      }
      var props = _this2.props;

      if (props.autoClearSearchValue) {
        _this2.setInputValue('', false);
      }
    };

    this.onArrowClick = function (e) {
      e.stopPropagation();
      e.preventDefault();
      if (!_this2.props.disabled) {
        _this2.setOpenState(!_this2.state.open, !_this2.state.open);
      }
    };

    this.onPlaceholderClick = function () {
      if (_this2.getInputDOMNode()) {
        _this2.getInputDOMNode().focus();
      }
    };

    this.onOuterFocus = function (e) {
      if (_this2.props.disabled) {
        e.preventDefault();
        return;
      }
      _this2.clearBlurTime();
      if (!isMultipleOrTagsOrCombobox(_this2.props) && e.target === _this2.getInputDOMNode()) {
        return;
      }
      if (_this2._focused) {
        return;
      }
      _this2._focused = true;
      _this2.updateFocusClassName();
      _this2.timeoutFocus();
    };

    this.onPopupFocus = function () {
      // fix ie scrollbar, focus element again
      _this2.maybeFocus(true, true);
    };

    this.onOuterBlur = function (e) {
      if (_this2.props.disabled) {
        e.preventDefault();
        return;
      }
      _this2.blurTimer = setTimeout(function () {
        _this2._focused = false;
        _this2.updateFocusClassName();
        var props = _this2.props;
        var value = _this2.state.value;
        var inputValue = _this2.state.inputValue;

        if (isSingleMode(props) && props.showSearch && inputValue && props.defaultActiveFirstOption) {
          var options = _this2._options || [];
          if (options.length) {
            var firstOption = findFirstMenuItem(options);
            if (firstOption) {
              value = [getValuePropValue(firstOption)];
              _this2.fireChange(value);
            }
          }
        } else if (isMultipleOrTags(props) && inputValue) {
          // why not use setState?
          _this2.state.inputValue = _this2.getInputDOMNode().value = '';

          value = _this2.getValueByInput(inputValue);
          if (value !== undefined) {
            _this2.fireChange(value);
          }
        }
        props.onBlur(_this2.getVLForOnChange(value));
        _this2.setOpenState(false);
      }, 10);
    };

    this.onClearSelection = function (event) {
      var props = _this2.props;
      var state = _this2.state;
      if (props.disabled) {
        return;
      }
      var inputValue = state.inputValue,
          value = state.value;

      event.stopPropagation();
      if (inputValue || value.length) {
        if (value.length) {
          _this2.fireChange([]);
        }
        _this2.setOpenState(false, true);
        if (inputValue) {
          _this2.setInputValue('');
        }
      }
    };

    this.onChoiceAnimationLeave = function () {
      _this2.forcePopupAlign();
    };

    this.getOptionInfoBySingleValue = function (value, optionsInfo) {
      var info = void 0;
      optionsInfo = optionsInfo || _this2.state.optionsInfo;
      if (optionsInfo[getMapKey(value)]) {
        info = optionsInfo[getMapKey(value)];
      }
      if (info) {
        return info;
      }
      var defaultLabel = value;
      if (_this2.props.labelInValue) {
        var label = getLabelFromPropsValue(_this2.props.value, value);
        if (label !== undefined) {
          defaultLabel = label;
        }
      }
      var defaultInfo = {
        option: React$1__default.createElement(
          Option,
          { value: value, key: value },
          value
        ),
        value: value,
        label: defaultLabel
      };
      return defaultInfo;
    };

    this.getOptionBySingleValue = function (value) {
      var _getOptionInfoBySingl = _this2.getOptionInfoBySingleValue(value),
          option = _getOptionInfoBySingl.option;

      return option;
    };

    this.getOptionsBySingleValue = function (values) {
      return values.map(function (value) {
        return _this2.getOptionBySingleValue(value);
      });
    };

    this.getValueByLabel = function (label) {
      if (label === undefined) {
        return null;
      }
      var value = null;
      Object.keys(_this2.state.optionsInfo).forEach(function (key) {
        var info = _this2.state.optionsInfo[key];
        if (toArray$1(info.label).join('') === label) {
          value = info.value;
        }
      });
      return value;
    };

    this.getVLBySingleValue = function (value) {
      if (_this2.props.labelInValue) {
        return {
          key: value,
          label: _this2.getLabelBySingleValue(value)
        };
      }
      return value;
    };

    this.getVLForOnChange = function (vls_) {
      var vls = vls_;
      if (vls !== undefined) {
        if (!_this2.props.labelInValue) {
          vls = vls.map(function (v) {
            return v;
          });
        } else {
          vls = vls.map(function (vl) {
            return {
              key: vl,
              label: _this2.getLabelBySingleValue(vl)
            };
          });
        }
        return isMultipleOrTags(_this2.props) ? vls : vls[0];
      }
      return vls;
    };

    this.getLabelBySingleValue = function (value, optionsInfo) {
      var _getOptionInfoBySingl2 = _this2.getOptionInfoBySingleValue(value, optionsInfo),
          label = _getOptionInfoBySingl2.label;

      return label;
    };

    this.getDropdownContainer = function () {
      if (!_this2.dropdownContainer) {
        _this2.dropdownContainer = document.createElement('div');
        document.body.appendChild(_this2.dropdownContainer);
      }
      return _this2.dropdownContainer;
    };

    this.getPlaceholderElement = function () {
      var props = _this2.props,
          state = _this2.state;

      var hidden = false;
      if (state.inputValue) {
        hidden = true;
      }
      if (state.value.length) {
        hidden = true;
      }
      if (isCombobox(props) && state.value.length === 1 && !state.value[0]) {
        hidden = false;
      }
      var placeholder = props.placeholder;
      if (placeholder) {
        return React$1__default.createElement(
          'div',
          _extends$2({
            onMouseDown: preventDefaultEvent,
            style: _extends$2({
              display: hidden ? 'none' : 'block'
            }, UNSELECTABLE_STYLE)
          }, UNSELECTABLE_ATTRIBUTE, {
            onClick: _this2.onPlaceholderClick,
            className: props.prefixCls + '-selection__placeholder'
          }),
          placeholder
        );
      }
      return null;
    };

    this.getInputElement = function () {
      var _classnames;

      var props = _this2.props;
      var inputElement = props.getInputElement ? props.getInputElement() : React$1__default.createElement('input', { id: props.id, autoComplete: 'off' });
      var inputCls = classnames(inputElement.props.className, (_classnames = {}, _classnames[props.prefixCls + '-search__field'] = true, _classnames));
      // https://github.com/ant-design/ant-design/issues/4992#issuecomment-281542159
      // Add space to the end of the inputValue as the width measurement tolerance
      return React$1__default.createElement(
        'div',
        { className: props.prefixCls + '-search__field__wrap' },
        React$1__default.cloneElement(inputElement, {
          ref: _this2.saveInputRef,
          onChange: _this2.onInputChange,
          onKeyDown: chaining(_this2.onInputKeyDown, inputElement.props.onKeyDown, _this2.props.onInputKeyDown),
          value: _this2.state.inputValue,
          disabled: props.disabled,
          className: inputCls
        }),
        React$1__default.createElement(
          'span',
          {
            ref: _this2.saveInputMirrorRef,
            className: props.prefixCls + '-search__field__mirror'
          },
          _this2.state.inputValue,
          '\xA0'
        )
      );
    };

    this.getInputDOMNode = function () {
      return _this2.topCtrlRef ? _this2.topCtrlRef.querySelector('input,textarea,div[contentEditable]') : _this2.inputRef;
    };

    this.getInputMirrorDOMNode = function () {
      return _this2.inputMirrorRef;
    };

    this.getPopupDOMNode = function () {
      return _this2.selectTriggerRef.getPopupDOMNode();
    };

    this.getPopupMenuComponent = function () {
      return _this2.selectTriggerRef.getInnerMenu();
    };

    this.setOpenState = function (open, needFocus) {
      var props = _this2.props,
          state = _this2.state;

      if (state.open === open) {
        _this2.maybeFocus(open, needFocus);
        return;
      }
      var nextState = {
        open: open,
        backfillValue: undefined
      };
      // clear search input value when open is false in singleMode.
      if (!open && isSingleMode(props) && props.showSearch) {
        _this2.setInputValue('', false);
      }
      if (!open) {
        _this2.maybeFocus(open, needFocus);
      }
      _this2.setState(nextState, function () {
        if (open) {
          _this2.maybeFocus(open, needFocus);
        }
      });
    };

    this.setInputValue = function (inputValue) {
      var fireSearch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (inputValue !== _this2.state.inputValue) {
        _this2.setState({
          inputValue: inputValue
        }, _this2.forcePopupAlign);
        if (fireSearch) {
          _this2.props.onSearch(inputValue);
        }
      }
    };

    this.getValueByInput = function (string) {
      var _props2 = _this2.props,
          multiple = _props2.multiple,
          tokenSeparators = _props2.tokenSeparators;

      var nextValue = _this2.state.value;
      var hasNewValue = false;
      splitBySeparators(string, tokenSeparators).forEach(function (label) {
        var selectedValue = [label];
        if (multiple) {
          var value = _this2.getValueByLabel(label);
          if (value && findIndexInValueBySingleValue(nextValue, value) === -1) {
            nextValue = nextValue.concat(value);
            hasNewValue = true;
            _this2.fireSelect(value);
          }
        } else {
          // tag
          if (findIndexInValueBySingleValue(nextValue, label) === -1) {
            nextValue = nextValue.concat(selectedValue);
            hasNewValue = true;
            _this2.fireSelect(label);
          }
        }
      });
      return hasNewValue ? nextValue : undefined;
    };

    this.getRealOpenState = function () {
      var open = _this2.state.open;
      var options = _this2._options || [];
      if (isMultipleOrTagsOrCombobox(_this2.props) || !_this2.props.showSearch) {
        if (open && !options.length) {
          open = false;
        }
      }
      return open;
    };

    this.handleBackfill = function (item) {
      if (!_this2.props.backfill || !(isSingleMode(_this2.props) || isCombobox(_this2.props))) {
        return;
      }

      var key = getValuePropValue(item);

      if (isCombobox(_this2.props)) {
        _this2.setInputValue(key, false);
      }

      _this2.setState({
        value: [key],
        backfillValue: key
      });
    };

    this.filterOption = function (input, child) {
      var defaultFilter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultFilterFn;
      var value = _this2.state.value;

      var lastValue = value[value.length - 1];
      if (!input || lastValue && lastValue === _this2.state.backfillValue) {
        return true;
      }
      var filterFn = _this2.props.filterOption;
      if ('filterOption' in _this2.props) {
        if (_this2.props.filterOption === true) {
          filterFn = defaultFilter;
        }
      } else {
        filterFn = defaultFilter;
      }

      if (!filterFn) {
        return true;
      } else if (typeof filterFn === 'function') {
        return filterFn.call(_this2, input, child);
      } else if (child.props.disabled) {
        return false;
      }
      return true;
    };

    this.timeoutFocus = function () {
      if (_this2.focusTimer) {
        _this2.clearFocusTime();
      }
      _this2.focusTimer = setTimeout(function () {
        _this2.props.onFocus();
      }, 10);
    };

    this.clearFocusTime = function () {
      if (_this2.focusTimer) {
        clearTimeout(_this2.focusTimer);
        _this2.focusTimer = null;
      }
    };

    this.clearBlurTime = function () {
      if (_this2.blurTimer) {
        clearTimeout(_this2.blurTimer);
        _this2.blurTimer = null;
      }
    };

    this.updateFocusClassName = function () {
      var rootRef = _this2.rootRef,
          props = _this2.props;
      // avoid setState and its side effect

      if (_this2._focused) {
        componentClasses(rootRef).add(props.prefixCls + '-focused');
      } else {
        componentClasses(rootRef).remove(props.prefixCls + '-focused');
      }
    };

    this.maybeFocus = function (open, needFocus) {
      if (needFocus || open) {
        var input = _this2.getInputDOMNode();
        var _document = document,
            activeElement = _document.activeElement;

        if (input && (open || isMultipleOrTagsOrCombobox(_this2.props))) {
          if (activeElement !== input) {
            input.focus();
            _this2._focused = true;
          }
        } else {
          if (activeElement !== _this2.selectionRef) {
            _this2.selectionRef.focus();
            _this2._focused = true;
          }
        }
      }
    };

    this.removeSelected = function (selectedKey, e) {
      var props = _this2.props;
      if (props.disabled || _this2.isChildDisabled(selectedKey)) {
        return;
      }

      // Do not trigger Trigger popup
      if (e && e.stopPropagation) {
        e.stopPropagation();
      }

      var value = _this2.state.value.filter(function (singleValue) {
        return singleValue !== selectedKey;
      });
      var canMultiple = isMultipleOrTags(props);

      if (canMultiple) {
        var event = selectedKey;
        if (props.labelInValue) {
          event = {
            key: selectedKey,
            label: _this2.getLabelBySingleValue(selectedKey)
          };
        }
        props.onDeselect(event, _this2.getOptionBySingleValue(selectedKey));
      }
      _this2.fireChange(value);
    };

    this.openIfHasChildren = function () {
      var props = _this2.props;
      if (React$1__default.Children.count(props.children) || isSingleMode(props)) {
        _this2.setOpenState(true);
      }
    };

    this.fireSelect = function (value) {
      _this2.props.onSelect(_this2.getVLBySingleValue(value), _this2.getOptionBySingleValue(value));
    };

    this.fireChange = function (value) {
      var props = _this2.props;
      if (!('value' in props)) {
        _this2.setState({
          value: value
        }, _this2.forcePopupAlign);
      }
      var vls = _this2.getVLForOnChange(value);
      var options = _this2.getOptionsBySingleValue(value);
      props.onChange(vls, isMultipleOrTags(_this2.props) ? options : options[0]);
    };

    this.isChildDisabled = function (key) {
      return toArray(_this2.props.children).some(function (child) {
        var childValue = getValuePropValue(child);
        return childValue === key && child.props && child.props.disabled;
      });
    };

    this.forcePopupAlign = function () {
      _this2.selectTriggerRef.triggerRef.forcePopupAlign();
    };

    this.renderFilterOptions = function () {
      var inputValue = _this2.state.inputValue;
      var _props3 = _this2.props,
          children = _props3.children,
          tags = _props3.tags,
          filterOption = _props3.filterOption,
          notFoundContent = _props3.notFoundContent;

      var menuItems = [];
      var childrenKeys = [];
      var options = _this2.renderFilterOptionsFromChildren(children, childrenKeys, menuItems);
      if (tags) {
        // tags value must be string
        var value = _this2.state.value;
        value = value.filter(function (singleValue) {
          return childrenKeys.indexOf(singleValue) === -1 && (!inputValue || String(singleValue).indexOf(String(inputValue)) > -1);
        });
        value.forEach(function (singleValue) {
          var key = singleValue;
          var menuItem = React$1__default.createElement(
            connected$2,
            {
              style: UNSELECTABLE_STYLE,
              role: 'option',
              attribute: UNSELECTABLE_ATTRIBUTE,
              value: key,
              key: key
            },
            key
          );
          options.push(menuItem);
          menuItems.push(menuItem);
        });
        if (inputValue) {
          var notFindInputItem = menuItems.every(function (option) {
            // this.filterOption return true has two meaning,
            // 1, some one exists after filtering
            // 2, filterOption is set to false
            // condition 2 does not mean the option has same value with inputValue
            var filterFn = function filterFn() {
              return getValuePropValue(option) === inputValue;
            };
            if (filterOption !== false) {
              return !_this2.filterOption.call(_this2, inputValue, option, filterFn);
            }
            return !filterFn();
          });
          if (notFindInputItem) {
            options.unshift(React$1__default.createElement(
              connected$2,
              {
                style: UNSELECTABLE_STYLE,
                role: 'option',
                attribute: UNSELECTABLE_ATTRIBUTE,
                value: inputValue,
                key: inputValue
              },
              inputValue
            ));
          }
        }
      }

      if (!options.length && notFoundContent) {
        options = [React$1__default.createElement(
          connected$2,
          {
            style: UNSELECTABLE_STYLE,
            attribute: UNSELECTABLE_ATTRIBUTE,
            disabled: true,
            role: 'option',
            value: 'NOT_FOUND',
            key: 'NOT_FOUND'
          },
          notFoundContent
        )];
      }
      return options;
    };

    this.renderFilterOptionsFromChildren = function (children, childrenKeys, menuItems) {
      var sel = [];
      var props = _this2.props;
      var inputValue = _this2.state.inputValue;

      var tags = props.tags;
      React$1__default.Children.forEach(children, function (child) {
        if (!child) {
          return;
        }
        if (child.type.isSelectOptGroup) {
          var innerItems = _this2.renderFilterOptionsFromChildren(child.props.children, childrenKeys, menuItems);
          if (innerItems.length) {
            var label = child.props.label;
            var key = child.key;
            if (!key && typeof label === 'string') {
              key = label;
            } else if (!label && key) {
              label = key;
            }
            sel.push(React$1__default.createElement(
              MenuItemGroup,
              { key: key, title: label },
              innerItems
            ));
          }
          return;
        }

        warning_1$1(child.type.isSelectOption, 'the children of `Select` should be `Select.Option` or `Select.OptGroup`, ' + ('instead of `' + (child.type.name || child.type.displayName || child.type) + '`.'));

        var childValue = getValuePropValue(child);

        validateOptionValue(childValue, _this2.props);

        if (_this2.filterOption(inputValue, child)) {
          var menuItem = React$1__default.createElement(connected$2, _extends$2({
            style: UNSELECTABLE_STYLE,
            attribute: UNSELECTABLE_ATTRIBUTE,
            value: childValue,
            key: childValue,
            role: 'option'
          }, child.props));
          sel.push(menuItem);
          menuItems.push(menuItem);
        }

        if (tags) {
          childrenKeys.push(childValue);
        }
      });

      return sel;
    };

    this.renderTopControlNode = function () {
      var _state2 = _this2.state,
          value = _state2.value,
          open = _state2.open,
          inputValue = _state2.inputValue;

      var props = _this2.props;
      var choiceTransitionName = props.choiceTransitionName,
          prefixCls = props.prefixCls,
          maxTagTextLength = props.maxTagTextLength,
          maxTagCount = props.maxTagCount,
          maxTagPlaceholder = props.maxTagPlaceholder,
          showSearch = props.showSearch;

      var className = prefixCls + '-selection__rendered';
      // search input is inside topControlNode in single, multiple & combobox. 2016/04/13
      var innerNode = null;
      if (isSingleMode(props)) {
        var selectedValue = null;
        if (value.length) {
          var showSelectedValue = false;
          var opacity = 1;
          if (!showSearch) {
            showSelectedValue = true;
          } else {
            if (open) {
              showSelectedValue = !inputValue;
              if (showSelectedValue) {
                opacity = 0.4;
              }
            } else {
              showSelectedValue = true;
            }
          }
          var singleValue = value[0];

          var _getOptionInfoBySingl3 = _this2.getOptionInfoBySingleValue(singleValue),
              label = _getOptionInfoBySingl3.label,
              title = _getOptionInfoBySingl3.title;

          selectedValue = React$1__default.createElement(
            'div',
            {
              key: 'value',
              className: prefixCls + '-selection-selected-value',
              title: toTitle(title || label),
              style: {
                display: showSelectedValue ? 'block' : 'none',
                opacity: opacity
              }
            },
            label
          );
        }
        if (!showSearch) {
          innerNode = [selectedValue];
        } else {
          innerNode = [selectedValue, React$1__default.createElement(
            'div',
            {
              className: prefixCls + '-search ' + prefixCls + '-search--inline',
              key: 'input',
              style: {
                display: open ? 'block' : 'none'
              }
            },
            _this2.getInputElement()
          )];
        }
      } else {
        var selectedValueNodes = [];
        var limitedCountValue = value;
        var maxTagPlaceholderEl = void 0;
        if (maxTagCount !== undefined && value.length > maxTagCount) {
          limitedCountValue = limitedCountValue.slice(0, maxTagCount);
          var omittedValues = _this2.getVLForOnChange(value.slice(maxTagCount, value.length));
          var content = '+ ' + (value.length - maxTagCount) + ' ...';
          if (maxTagPlaceholder) {
            content = typeof maxTagPlaceholder === 'function' ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
          }
          maxTagPlaceholderEl = React$1__default.createElement(
            'li',
            _extends$2({
              style: UNSELECTABLE_STYLE
            }, UNSELECTABLE_ATTRIBUTE, {
              onMouseDown: preventDefaultEvent,
              className: prefixCls + '-selection__choice ' + prefixCls + '-selection__choice__disabled',
              key: 'maxTagPlaceholder',
              title: toTitle(content)
            }),
            React$1__default.createElement(
              'div',
              { className: prefixCls + '-selection__choice__content' },
              content
            )
          );
        }
        if (isMultipleOrTags(props)) {
          selectedValueNodes = limitedCountValue.map(function (singleValue) {
            var info = _this2.getOptionInfoBySingleValue(singleValue);
            var content = info.label;
            var title = info.title || content;
            if (maxTagTextLength && typeof content === 'string' && content.length > maxTagTextLength) {
              content = content.slice(0, maxTagTextLength) + '...';
            }
            var disabled = _this2.isChildDisabled(singleValue);
            var choiceClassName = disabled ? prefixCls + '-selection__choice ' + prefixCls + '-selection__choice__disabled' : prefixCls + '-selection__choice';
            return React$1__default.createElement(
              'li',
              _extends$2({
                style: UNSELECTABLE_STYLE
              }, UNSELECTABLE_ATTRIBUTE, {
                onMouseDown: preventDefaultEvent,
                className: choiceClassName,
                key: singleValue,
                title: toTitle(title)
              }),
              React$1__default.createElement(
                'div',
                { className: prefixCls + '-selection__choice__content' },
                content
              ),
              disabled ? null : React$1__default.createElement('span', {
                className: prefixCls + '-selection__choice__remove',
                onClick: function onClick(event) {
                  _this2.removeSelected(singleValue, event);
                }
              })
            );
          });
        }
        if (maxTagPlaceholderEl) {
          selectedValueNodes.push(maxTagPlaceholderEl);
        }
        selectedValueNodes.push(React$1__default.createElement(
          'li',
          {
            className: prefixCls + '-search ' + prefixCls + '-search--inline',
            key: '__input'
          },
          _this2.getInputElement()
        ));

        if (isMultipleOrTags(props) && choiceTransitionName) {
          innerNode = React$1__default.createElement(
            Animate,
            {
              onLeave: _this2.onChoiceAnimationLeave,
              component: 'ul',
              transitionName: choiceTransitionName
            },
            selectedValueNodes
          );
        } else {
          innerNode = React$1__default.createElement(
            'ul',
            null,
            selectedValueNodes
          );
        }
      }
      return React$1__default.createElement(
        'div',
        { className: className, ref: _this2.saveTopCtrlRef },
        _this2.getPlaceholderElement(),
        innerNode
      );
    };
  };

  Select.displayName = 'Select';

  polyfill(Select);

  var OptGroup = function (_React$Component) {
    _inherits$1(OptGroup, _React$Component);

    function OptGroup() {
      _classCallCheck$1(this, OptGroup);

      return _possibleConstructorReturn$1(this, _React$Component.apply(this, arguments));
    }

    return OptGroup;
  }(React$1__default.Component);

  OptGroup.isSelectOptGroup = true;

  Select.Option = Option;
  Select.OptGroup = OptGroup;

  var es$4 = /*#__PURE__*/Object.freeze({
    Option: Option,
    OptGroup: OptGroup,
    SelectPropTypes: SelectPropTypes,
    default: Select
  });

  var en_US = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports['default'] = {
    // Options.jsx
    items_per_page: '/ page',
    jump_to: 'Goto',
    jump_to_confirm: 'confirm',
    page: '',

    // Pagination.jsx
    prev_page: 'Previous Page',
    next_page: 'Next Page',
    prev_5: 'Previous 5 Pages',
    next_5: 'Next 5 Pages',
    prev_3: 'Previous 3 Pages',
    next_3: 'Next 3 Pages'
  };
  module.exports = exports['default'];
  });

  unwrapExports(en_US);

  var en_US$2 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports['default'] = {
    today: 'Today',
    now: 'Now',
    backToToday: 'Back to today',
    ok: 'Ok',
    clear: 'Clear',
    month: 'Month',
    year: 'Year',
    timeSelect: 'select time',
    dateSelect: 'select date',
    weekSelect: 'Choose a week',
    monthSelect: 'Choose a month',
    yearSelect: 'Choose a year',
    decadeSelect: 'Choose a decade',
    yearFormat: 'YYYY',
    dateFormat: 'M/D/YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'M/D/YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Previous month (PageUp)',
    nextMonth: 'Next month (PageDown)',
    previousYear: 'Last year (Control + left)',
    nextYear: 'Next year (Control + right)',
    previousDecade: 'Last decade',
    nextDecade: 'Next decade',
    previousCentury: 'Last century',
    nextCentury: 'Next century'
  };
  module.exports = exports['default'];
  });

  unwrapExports(en_US$2);

  var en_US$4 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  var locale = {
      placeholder: 'Select time'
  };
  exports['default'] = locale;
  module.exports = exports['default'];
  });

  unwrapExports(en_US$4);

  var en_US$6 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _en_US2 = _interopRequireDefault(en_US$2);



  var _en_US4 = _interopRequireDefault(en_US$4);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  // Merge into a locale object
  var locale = {
      lang: (0, _extends3['default'])({ placeholder: 'Select date', rangePlaceholder: ['Start date', 'End date'] }, _en_US2['default']),
      timePickerLocale: (0, _extends3['default'])({}, _en_US4['default'])
  };
  // All settings at:
  // https://github.com/ant-design/ant-design/blob/master/components/date-picker/locale/example.json
  exports['default'] = locale;
  module.exports = exports['default'];
  });

  unwrapExports(en_US$6);

  var en_US$8 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _en_US2 = _interopRequireDefault(en_US$6);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  exports['default'] = _en_US2['default'];
  module.exports = exports['default'];
  });

  unwrapExports(en_US$8);

  var _default = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _en_US2 = _interopRequireDefault(en_US);



  var _en_US4 = _interopRequireDefault(en_US$6);



  var _en_US6 = _interopRequireDefault(en_US$4);



  var _en_US8 = _interopRequireDefault(en_US$8);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  exports['default'] = {
      locale: 'en',
      Pagination: _en_US2['default'],
      DatePicker: _en_US4['default'],
      TimePicker: _en_US6['default'],
      Calendar: _en_US8['default'],
      Table: {
          filterTitle: 'Filter menu',
          filterConfirm: 'OK',
          filterReset: 'Reset',
          emptyText: 'No data',
          selectAll: 'Select current page',
          selectInvert: 'Invert current page'
      },
      Modal: {
          okText: 'OK',
          cancelText: 'Cancel',
          justOkText: 'OK'
      },
      Popconfirm: {
          okText: 'OK',
          cancelText: 'Cancel'
      },
      Transfer: {
          titles: ['', ''],
          notFoundContent: 'Not Found',
          searchPlaceholder: 'Search here',
          itemUnit: 'item',
          itemsUnit: 'items'
      },
      Select: {
          notFoundContent: 'Not Found'
      },
      Upload: {
          uploading: 'Uploading...',
          removeFile: 'Remove file',
          uploadError: 'Upload error',
          previewFile: 'Preview file'
      }
  };
  module.exports = exports['default'];
  });

  unwrapExports(_default);

  var _rcSelect = getCjsExportFromNamespace(es$4);

  var select = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _rcSelect2 = _interopRequireDefault(_rcSelect);



  var _classnames2 = _interopRequireDefault(classnames);



  var _LocaleReceiver2 = _interopRequireDefault(LocaleReceiver_1);



  var _default2 = _interopRequireDefault(_default);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var __rest = function (s, e) {
      var t = {};
      for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      }if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
      }return t;
  };

  var SelectPropTypes = {
      prefixCls: _propTypes2['default'].string,
      className: _propTypes2['default'].string,
      size: _propTypes2['default'].oneOf(['default', 'large', 'small']),
      combobox: _propTypes2['default'].bool,
      notFoundContent: _propTypes2['default'].any,
      showSearch: _propTypes2['default'].bool,
      optionLabelProp: _propTypes2['default'].string,
      transitionName: _propTypes2['default'].string,
      choiceTransitionName: _propTypes2['default'].string
  };
  // => It is needless to export the declaration of below two inner components.
  // export { Option, OptGroup };

  var Select = function (_React$Component) {
      (0, _inherits3['default'])(Select, _React$Component);

      function Select() {
          (0, _classCallCheck3['default'])(this, Select);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (Select.__proto__ || Object.getPrototypeOf(Select)).apply(this, arguments));

          _this.saveSelect = function (node) {
              _this.rcSelect = node;
          };
          _this.renderSelect = function (locale) {
              var _classNames;

              var _a = _this.props,
                  prefixCls = _a.prefixCls,
                  _a$className = _a.className,
                  className = _a$className === undefined ? '' : _a$className,
                  size = _a.size,
                  mode = _a.mode,
                  restProps = __rest(_a, ["prefixCls", "className", "size", "mode"]);
              var cls = (0, _classnames2['default'])((_classNames = {}, (0, _defineProperty3['default'])(_classNames, prefixCls + '-lg', size === 'large'), (0, _defineProperty3['default'])(_classNames, prefixCls + '-sm', size === 'small'), _classNames), className);
              var optionLabelProp = _this.props.optionLabelProp;

              var isCombobox = mode === 'combobox';
              if (isCombobox) {
                  // children 带 dom 结构时，无法填入输入框
                  optionLabelProp = optionLabelProp || 'value';
              }
              var modeConfig = {
                  multiple: mode === 'multiple',
                  tags: mode === 'tags',
                  combobox: isCombobox
              };
              return React.createElement(_rcSelect2['default'], (0, _extends3['default'])({}, restProps, modeConfig, { prefixCls: prefixCls, className: cls, optionLabelProp: optionLabelProp || 'children', notFoundContent: _this.getNotFoundContent(locale), ref: _this.saveSelect }));
          };
          return _this;
      }

      (0, _createClass3['default'])(Select, [{
          key: 'focus',
          value: function focus() {
              this.rcSelect.focus();
          }
      }, {
          key: 'blur',
          value: function blur() {
              this.rcSelect.blur();
          }
      }, {
          key: 'getNotFoundContent',
          value: function getNotFoundContent(locale) {
              var _props = this.props,
                  notFoundContent = _props.notFoundContent,
                  mode = _props.mode;

              var isCombobox = mode === 'combobox';
              if (isCombobox) {
                  // AutoComplete don't have notFoundContent defaultly
                  return notFoundContent === undefined ? null : notFoundContent;
              }
              return notFoundContent === undefined ? locale.notFoundContent : notFoundContent;
          }
      }, {
          key: 'render',
          value: function render() {
              return React.createElement(
                  _LocaleReceiver2['default'],
                  { componentName: 'Select', defaultLocale: _default2['default'].Select },
                  this.renderSelect
              );
          }
      }]);
      return Select;
  }(React.Component);

  exports['default'] = Select;

  Select.Option = _rcSelect.Option;
  Select.OptGroup = _rcSelect.OptGroup;
  Select.defaultProps = {
      prefixCls: 'ant-select',
      showSearch: false,
      transitionName: 'slide-up',
      choiceTransitionName: 'zoom'
  };
  Select.propTypes = SelectPropTypes;
  module.exports = exports['default'];
  });

  var Select$1 = unwrapExports(select);

  var Input_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _classnames2 = _interopRequireDefault(classnames);



  var _omit2 = _interopRequireDefault(_omit);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function fixControlledValue(value) {
      if (typeof value === 'undefined' || value === null) {
          return '';
      }
      return value;
  }

  var Input = function (_React$Component) {
      (0, _inherits3['default'])(Input, _React$Component);

      function Input() {
          (0, _classCallCheck3['default'])(this, Input);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (Input.__proto__ || Object.getPrototypeOf(Input)).apply(this, arguments));

          _this.handleKeyDown = function (e) {
              var _this$props = _this.props,
                  onPressEnter = _this$props.onPressEnter,
                  onKeyDown = _this$props.onKeyDown;

              if (e.keyCode === 13 && onPressEnter) {
                  onPressEnter(e);
              }
              if (onKeyDown) {
                  onKeyDown(e);
              }
          };
          _this.saveInput = function (node) {
              _this.input = node;
          };
          return _this;
      }

      (0, _createClass3['default'])(Input, [{
          key: 'focus',
          value: function focus() {
              this.input.focus();
          }
      }, {
          key: 'blur',
          value: function blur() {
              this.input.blur();
          }
      }, {
          key: 'getInputClassName',
          value: function getInputClassName() {
              var _classNames;

              var _props = this.props,
                  prefixCls = _props.prefixCls,
                  size = _props.size,
                  disabled = _props.disabled;

              return (0, _classnames2['default'])(prefixCls, (_classNames = {}, (0, _defineProperty3['default'])(_classNames, prefixCls + '-sm', size === 'small'), (0, _defineProperty3['default'])(_classNames, prefixCls + '-lg', size === 'large'), (0, _defineProperty3['default'])(_classNames, prefixCls + '-disabled', disabled), _classNames));
          }
      }, {
          key: 'renderLabeledInput',
          value: function renderLabeledInput(children) {
              var _classNames3;

              var props = this.props;
              // Not wrap when there is not addons
              if (!props.addonBefore && !props.addonAfter) {
                  return children;
              }
              var wrapperClassName = props.prefixCls + '-group';
              var addonClassName = wrapperClassName + '-addon';
              var addonBefore = props.addonBefore ? React.createElement(
                  'span',
                  { className: addonClassName },
                  props.addonBefore
              ) : null;
              var addonAfter = props.addonAfter ? React.createElement(
                  'span',
                  { className: addonClassName },
                  props.addonAfter
              ) : null;
              var className = (0, _classnames2['default'])(props.prefixCls + '-wrapper', (0, _defineProperty3['default'])({}, wrapperClassName, addonBefore || addonAfter));
              var groupClassName = (0, _classnames2['default'])(props.prefixCls + '-group-wrapper', (_classNames3 = {}, (0, _defineProperty3['default'])(_classNames3, props.prefixCls + '-group-wrapper-sm', props.size === 'small'), (0, _defineProperty3['default'])(_classNames3, props.prefixCls + '-group-wrapper-lg', props.size === 'large'), _classNames3));
              // Need another wrapper for changing display:table to display:inline-block
              // and put style prop in wrapper
              if (addonBefore || addonAfter) {
                  return React.createElement(
                      'span',
                      { className: groupClassName, style: props.style },
                      React.createElement(
                          'span',
                          { className: className },
                          addonBefore,
                          React.cloneElement(children, { style: null }),
                          addonAfter
                      )
                  );
              }
              return React.createElement(
                  'span',
                  { className: className },
                  addonBefore,
                  children,
                  addonAfter
              );
          }
      }, {
          key: 'renderLabeledIcon',
          value: function renderLabeledIcon(children) {
              var _classNames4;

              var props = this.props;

              if (!('prefix' in props || 'suffix' in props)) {
                  return children;
              }
              var prefix = props.prefix ? React.createElement(
                  'span',
                  { className: props.prefixCls + '-prefix' },
                  props.prefix
              ) : null;
              var suffix = props.suffix ? React.createElement(
                  'span',
                  { className: props.prefixCls + '-suffix' },
                  props.suffix
              ) : null;
              var affixWrapperCls = (0, _classnames2['default'])(props.className, props.prefixCls + '-affix-wrapper', (_classNames4 = {}, (0, _defineProperty3['default'])(_classNames4, props.prefixCls + '-affix-wrapper-sm', props.size === 'small'), (0, _defineProperty3['default'])(_classNames4, props.prefixCls + '-affix-wrapper-lg', props.size === 'large'), _classNames4));
              return React.createElement(
                  'span',
                  { className: affixWrapperCls, style: props.style },
                  prefix,
                  React.cloneElement(children, { style: null, className: this.getInputClassName() }),
                  suffix
              );
          }
      }, {
          key: 'renderInput',
          value: function renderInput() {
              var _props2 = this.props,
                  value = _props2.value,
                  className = _props2.className;
              // Fix https://fb.me/react-unknown-prop

              var otherProps = (0, _omit2['default'])(this.props, ['prefixCls', 'onPressEnter', 'addonBefore', 'addonAfter', 'prefix', 'suffix']);
              if ('value' in this.props) {
                  otherProps.value = fixControlledValue(value);
                  // Input elements must be either controlled or uncontrolled,
                  // specify either the value prop, or the defaultValue prop, but not both.
                  delete otherProps.defaultValue;
              }
              return this.renderLabeledIcon(React.createElement('input', (0, _extends3['default'])({}, otherProps, { className: (0, _classnames2['default'])(this.getInputClassName(), className), onKeyDown: this.handleKeyDown, ref: this.saveInput })));
          }
      }, {
          key: 'render',
          value: function render() {
              return this.renderLabeledInput(this.renderInput());
          }
      }]);
      return Input;
  }(React.Component);

  exports['default'] = Input;

  Input.defaultProps = {
      prefixCls: 'ant-input',
      type: 'text',
      disabled: false
  };
  Input.propTypes = {
      type: _propTypes2['default'].string,
      id: _propTypes2['default'].oneOfType([_propTypes2['default'].string, _propTypes2['default'].number]),
      size: _propTypes2['default'].oneOf(['small', 'default', 'large']),
      maxLength: _propTypes2['default'].oneOfType([_propTypes2['default'].string, _propTypes2['default'].number]),
      disabled: _propTypes2['default'].bool,
      value: _propTypes2['default'].any,
      defaultValue: _propTypes2['default'].any,
      className: _propTypes2['default'].string,
      addonBefore: _propTypes2['default'].node,
      addonAfter: _propTypes2['default'].node,
      prefixCls: _propTypes2['default'].string,
      autosize: _propTypes2['default'].oneOfType([_propTypes2['default'].bool, _propTypes2['default'].object]),
      onPressEnter: _propTypes2['default'].func,
      onKeyDown: _propTypes2['default'].func,
      onKeyUp: _propTypes2['default'].func,
      onFocus: _propTypes2['default'].func,
      onBlur: _propTypes2['default'].func,
      prefix: _propTypes2['default'].node,
      suffix: _propTypes2['default'].node
  };
  module.exports = exports['default'];
  });

  unwrapExports(Input_1);

  var Group_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var React = _interopRequireWildcard(React$1__default);



  var _classnames2 = _interopRequireDefault(classnames);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var Group = function Group(props) {
      var _classNames;

      var _props$prefixCls = props.prefixCls,
          prefixCls = _props$prefixCls === undefined ? 'ant-input-group' : _props$prefixCls,
          _props$className = props.className,
          className = _props$className === undefined ? '' : _props$className;

      var cls = (0, _classnames2['default'])(prefixCls, (_classNames = {}, (0, _defineProperty3['default'])(_classNames, prefixCls + '-lg', props.size === 'large'), (0, _defineProperty3['default'])(_classNames, prefixCls + '-sm', props.size === 'small'), (0, _defineProperty3['default'])(_classNames, prefixCls + '-compact', props.compact), _classNames), className);
      return React.createElement(
          'span',
          { className: cls, style: props.style },
          props.children
      );
  };
  exports['default'] = Group;
  module.exports = exports['default'];
  });

  unwrapExports(Group_1);

  var Search_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var _classnames2 = _interopRequireDefault(classnames);



  var _Input2 = _interopRequireDefault(Input_1);



  var _icon2 = _interopRequireDefault(icon);



  var _button2 = _interopRequireDefault(button$2);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var __rest = function (s, e) {
      var t = {};
      for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      }if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
      }return t;
  };

  var Search = function (_React$Component) {
      (0, _inherits3['default'])(Search, _React$Component);

      function Search() {
          (0, _classCallCheck3['default'])(this, Search);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (Search.__proto__ || Object.getPrototypeOf(Search)).apply(this, arguments));

          _this.onSearch = function () {
              var onSearch = _this.props.onSearch;

              if (onSearch) {
                  onSearch(_this.input.input.value);
              }
              _this.input.focus();
          };
          _this.saveInput = function (node) {
              _this.input = node;
          };
          return _this;
      }

      (0, _createClass3['default'])(Search, [{
          key: 'focus',
          value: function focus() {
              this.input.focus();
          }
      }, {
          key: 'blur',
          value: function blur() {
              this.input.blur();
          }
      }, {
          key: 'getButtonOrIcon',
          value: function getButtonOrIcon() {
              var _props = this.props,
                  enterButton = _props.enterButton,
                  prefixCls = _props.prefixCls,
                  size = _props.size,
                  disabled = _props.disabled;

              if (!enterButton) {
                  return React.createElement(_icon2['default'], { className: prefixCls + '-icon', type: 'search', key: 'searchIcon' });
              }
              var enterButtonAsElement = enterButton;
              if (enterButtonAsElement.type === _button2['default'] || enterButtonAsElement.type === 'button') {
                  return React.cloneElement(enterButtonAsElement, enterButtonAsElement.type === _button2['default'] ? {
                      className: prefixCls + '-button',
                      size: size,
                      onClick: this.onSearch
                  } : {
                      onClick: this.onSearch
                  });
              }
              return React.createElement(
                  _button2['default'],
                  { className: prefixCls + '-button', type: 'primary', size: size, disabled: disabled, onClick: this.onSearch, key: 'enterButton' },
                  enterButton === true ? React.createElement(_icon2['default'], { type: 'search' }) : enterButton
              );
          }
      }, {
          key: 'render',
          value: function render() {
              var _classNames;

              var _a = this.props,
                  className = _a.className,
                  prefixCls = _a.prefixCls,
                  inputPrefixCls = _a.inputPrefixCls,
                  size = _a.size,
                  suffix = _a.suffix,
                  enterButton = _a.enterButton,
                  others = __rest(_a, ["className", "prefixCls", "inputPrefixCls", "size", "suffix", "enterButton"]);
              delete others.onSearch;
              var buttonOrIcon = this.getButtonOrIcon();
              var searchSuffix = suffix ? [suffix, buttonOrIcon] : buttonOrIcon;
              var inputClassName = (0, _classnames2['default'])(prefixCls, className, (_classNames = {}, (0, _defineProperty3['default'])(_classNames, prefixCls + '-enter-button', !!enterButton), (0, _defineProperty3['default'])(_classNames, prefixCls + '-' + size, !!size), _classNames));
              return React.createElement(_Input2['default'], (0, _extends3['default'])({ onPressEnter: this.onSearch }, others, { size: size, className: inputClassName, prefixCls: inputPrefixCls, suffix: searchSuffix, ref: this.saveInput }));
          }
      }]);
      return Search;
  }(React.Component);

  exports['default'] = Search;

  Search.defaultProps = {
      inputPrefixCls: 'ant-input',
      prefixCls: 'ant-input-search',
      enterButton: false
  };
  module.exports = exports['default'];
  });

  unwrapExports(Search_1);

  var calculateNodeHeight_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports['default'] = calculateNodeHeight;
  // Thanks to https://github.com/andreypopp/react-textarea-autosize/
  /**
   * calculateNodeHeight(uiTextNode, useCache = false)
   */
  var HIDDEN_TEXTAREA_STYLE = '\n  min-height:0 !important;\n  max-height:none !important;\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important\n';
  var SIZING_STYLE = ['letter-spacing', 'line-height', 'padding-top', 'padding-bottom', 'font-family', 'font-weight', 'font-size', 'text-rendering', 'text-transform', 'width', 'text-indent', 'padding-left', 'padding-right', 'border-width', 'box-sizing'];
  var computedStyleCache = {};
  var hiddenTextarea = void 0;
  function calculateNodeStyling(node) {
      var useCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var nodeRef = node.getAttribute('id') || node.getAttribute('data-reactid') || node.getAttribute('name');
      if (useCache && computedStyleCache[nodeRef]) {
          return computedStyleCache[nodeRef];
      }
      var style = window.getComputedStyle(node);
      var boxSizing = style.getPropertyValue('box-sizing') || style.getPropertyValue('-moz-box-sizing') || style.getPropertyValue('-webkit-box-sizing');
      var paddingSize = parseFloat(style.getPropertyValue('padding-bottom')) + parseFloat(style.getPropertyValue('padding-top'));
      var borderSize = parseFloat(style.getPropertyValue('border-bottom-width')) + parseFloat(style.getPropertyValue('border-top-width'));
      var sizingStyle = SIZING_STYLE.map(function (name) {
          return name + ':' + style.getPropertyValue(name);
      }).join(';');
      var nodeInfo = {
          sizingStyle: sizingStyle,
          paddingSize: paddingSize,
          borderSize: borderSize,
          boxSizing: boxSizing
      };
      if (useCache && nodeRef) {
          computedStyleCache[nodeRef] = nodeInfo;
      }
      return nodeInfo;
  }
  function calculateNodeHeight(uiTextNode) {
      var useCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var minRows = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var maxRows = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      if (!hiddenTextarea) {
          hiddenTextarea = document.createElement('textarea');
          document.body.appendChild(hiddenTextarea);
      }
      // Fix wrap="off" issue
      // https://github.com/ant-design/ant-design/issues/6577
      if (uiTextNode.getAttribute('wrap')) {
          hiddenTextarea.setAttribute('wrap', uiTextNode.getAttribute('wrap'));
      } else {
          hiddenTextarea.removeAttribute('wrap');
      }
      // Copy all CSS properties that have an impact on the height of the content in
      // the textbox

      var _calculateNodeStyling = calculateNodeStyling(uiTextNode, useCache),
          paddingSize = _calculateNodeStyling.paddingSize,
          borderSize = _calculateNodeStyling.borderSize,
          boxSizing = _calculateNodeStyling.boxSizing,
          sizingStyle = _calculateNodeStyling.sizingStyle;
      // Need to have the overflow attribute to hide the scrollbar otherwise
      // text-lines will not calculated properly as the shadow will technically be
      // narrower for content


      hiddenTextarea.setAttribute('style', sizingStyle + ';' + HIDDEN_TEXTAREA_STYLE);
      hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || '';
      var minHeight = Number.MIN_SAFE_INTEGER;
      var maxHeight = Number.MAX_SAFE_INTEGER;
      var height = hiddenTextarea.scrollHeight;
      var overflowY = void 0;
      if (boxSizing === 'border-box') {
          // border-box: add border, since height = content + padding + border
          height = height + borderSize;
      } else if (boxSizing === 'content-box') {
          // remove padding, since height = content
          height = height - paddingSize;
      }
      if (minRows !== null || maxRows !== null) {
          // measure height of a textarea with a single row
          hiddenTextarea.value = ' ';
          var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
          if (minRows !== null) {
              minHeight = singleRowHeight * minRows;
              if (boxSizing === 'border-box') {
                  minHeight = minHeight + paddingSize + borderSize;
              }
              height = Math.max(minHeight, height);
          }
          if (maxRows !== null) {
              maxHeight = singleRowHeight * maxRows;
              if (boxSizing === 'border-box') {
                  maxHeight = maxHeight + paddingSize + borderSize;
              }
              overflowY = height > maxHeight ? '' : 'hidden';
              height = Math.min(maxHeight, height);
          }
      }
      // Remove scroll bar flash when autosize without maxRows
      if (!maxRows) {
          overflowY = 'hidden';
      }
      return { height: height, minHeight: minHeight, maxHeight: maxHeight, overflowY: overflowY };
  }
  module.exports = exports['default'];
  });

  unwrapExports(calculateNodeHeight_1);

  var TextArea_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var _omit2 = _interopRequireDefault(_omit);



  var _classnames2 = _interopRequireDefault(classnames);



  var _calculateNodeHeight2 = _interopRequireDefault(calculateNodeHeight_1);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function onNextFrame(cb) {
      if (window.requestAnimationFrame) {
          return window.requestAnimationFrame(cb);
      }
      return window.setTimeout(cb, 1);
  }
  function clearNextFrameAction(nextFrameId) {
      if (window.cancelAnimationFrame) {
          window.cancelAnimationFrame(nextFrameId);
      } else {
          window.clearTimeout(nextFrameId);
      }
  }

  var TextArea = function (_React$Component) {
      (0, _inherits3['default'])(TextArea, _React$Component);

      function TextArea() {
          (0, _classCallCheck3['default'])(this, TextArea);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (TextArea.__proto__ || Object.getPrototypeOf(TextArea)).apply(this, arguments));

          _this.state = {
              textareaStyles: {}
          };
          _this.resizeTextarea = function () {
              var autosize = _this.props.autosize;

              if (!autosize || !_this.textAreaRef) {
                  return;
              }
              var minRows = autosize ? autosize.minRows : null;
              var maxRows = autosize ? autosize.maxRows : null;
              var textareaStyles = (0, _calculateNodeHeight2['default'])(_this.textAreaRef, false, minRows, maxRows);
              _this.setState({ textareaStyles: textareaStyles });
          };
          _this.handleTextareaChange = function (e) {
              if (!('value' in _this.props)) {
                  _this.resizeTextarea();
              }
              var onChange = _this.props.onChange;

              if (onChange) {
                  onChange(e);
              }
          };
          _this.handleKeyDown = function (e) {
              var _this$props = _this.props,
                  onPressEnter = _this$props.onPressEnter,
                  onKeyDown = _this$props.onKeyDown;

              if (e.keyCode === 13 && onPressEnter) {
                  onPressEnter(e);
              }
              if (onKeyDown) {
                  onKeyDown(e);
              }
          };
          _this.saveTextAreaRef = function (textArea) {
              _this.textAreaRef = textArea;
          };
          return _this;
      }

      (0, _createClass3['default'])(TextArea, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              this.resizeTextarea();
          }
      }, {
          key: 'componentWillReceiveProps',
          value: function componentWillReceiveProps(nextProps) {
              // Re-render with the new content then recalculate the height as required.
              if (this.props.value !== nextProps.value) {
                  if (this.nextFrameActionId) {
                      clearNextFrameAction(this.nextFrameActionId);
                  }
                  this.nextFrameActionId = onNextFrame(this.resizeTextarea);
              }
          }
      }, {
          key: 'focus',
          value: function focus() {
              this.textAreaRef.focus();
          }
      }, {
          key: 'blur',
          value: function blur() {
              this.textAreaRef.blur();
          }
      }, {
          key: 'getTextAreaClassName',
          value: function getTextAreaClassName() {
              var _props = this.props,
                  prefixCls = _props.prefixCls,
                  className = _props.className,
                  disabled = _props.disabled;

              return (0, _classnames2['default'])(prefixCls, className, (0, _defineProperty3['default'])({}, prefixCls + '-disabled', disabled));
          }
      }, {
          key: 'render',
          value: function render() {
              var props = this.props;
              var otherProps = (0, _omit2['default'])(props, ['prefixCls', 'onPressEnter', 'autosize']);
              var style = (0, _extends3['default'])({}, props.style, this.state.textareaStyles);
              // Fix https://github.com/ant-design/ant-design/issues/6776
              // Make sure it could be reset when using form.getFieldDecorator
              if ('value' in otherProps) {
                  otherProps.value = otherProps.value || '';
              }
              return React.createElement('textarea', (0, _extends3['default'])({}, otherProps, { className: this.getTextAreaClassName(), style: style, onKeyDown: this.handleKeyDown, onChange: this.handleTextareaChange, ref: this.saveTextAreaRef }));
          }
      }]);
      return TextArea;
  }(React.Component);

  exports['default'] = TextArea;

  TextArea.defaultProps = {
      prefixCls: 'ant-input'
  };
  module.exports = exports['default'];
  });

  unwrapExports(TextArea_1);

  var input = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _Input2 = _interopRequireDefault(Input_1);



  var _Group2 = _interopRequireDefault(Group_1);



  var _Search2 = _interopRequireDefault(Search_1);



  var _TextArea2 = _interopRequireDefault(TextArea_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  _Input2['default'].Group = _Group2['default'];
  _Input2['default'].Search = _Search2['default'];
  _Input2['default'].TextArea = _TextArea2['default'];
  exports['default'] = _Input2['default'];
  module.exports = exports['default'];
  });

  var Input$1 = unwrapExports(input);

  var DateConstants = {
    DATE_ROW_COUNT: 6,
    DATE_COL_COUNT: 7
  };

  var DateTHead = function (_React$Component) {
    _inherits$1(DateTHead, _React$Component);

    function DateTHead() {
      _classCallCheck$1(this, DateTHead);

      return _possibleConstructorReturn$1(this, _React$Component.apply(this, arguments));
    }

    DateTHead.prototype.render = function render() {
      var props = this.props;
      var value = props.value;
      var localeData = value.localeData();
      var prefixCls = props.prefixCls;
      var veryShortWeekdays = [];
      var weekDays = [];
      var firstDayOfWeek = localeData.firstDayOfWeek();
      var showWeekNumberEl = void 0;
      var now = moment();
      for (var dateColIndex = 0; dateColIndex < DateConstants.DATE_COL_COUNT; dateColIndex++) {
        var index = (firstDayOfWeek + dateColIndex) % DateConstants.DATE_COL_COUNT;
        now.day(index);
        veryShortWeekdays[dateColIndex] = localeData.weekdaysMin(now);
        weekDays[dateColIndex] = localeData.weekdaysShort(now);
      }

      if (props.showWeekNumber) {
        showWeekNumberEl = React$1__default.createElement(
          'th',
          {
            role: 'columnheader',
            className: prefixCls + '-column-header ' + prefixCls + '-week-number-header'
          },
          React$1__default.createElement(
            'span',
            { className: prefixCls + '-column-header-inner' },
            'x'
          )
        );
      }
      var weekDaysEls = weekDays.map(function (day, xindex) {
        return React$1__default.createElement(
          'th',
          {
            key: xindex,
            role: 'columnheader',
            title: day,
            className: prefixCls + '-column-header'
          },
          React$1__default.createElement(
            'span',
            { className: prefixCls + '-column-header-inner' },
            veryShortWeekdays[xindex]
          )
        );
      });
      return React$1__default.createElement(
        'thead',
        null,
        React$1__default.createElement(
          'tr',
          { role: 'row' },
          showWeekNumberEl,
          weekDaysEls
        )
      );
    };

    return DateTHead;
  }(React$1__default.Component);

  var defaultDisabledTime = {
    disabledHours: function disabledHours() {
      return [];
    },
    disabledMinutes: function disabledMinutes() {
      return [];
    },
    disabledSeconds: function disabledSeconds() {
      return [];
    }
  };

  function getTodayTime(value) {
    var today = moment();
    today.locale(value.locale()).utcOffset(value.utcOffset());
    return today;
  }

  function getTitleString(value) {
    return value.format('LL');
  }

  function getTodayTimeStr(value) {
    var today = getTodayTime(value);
    return getTitleString(today);
  }

  function getMonthName(month) {
    var locale = month.locale();
    var localeData = month.localeData();
    return localeData[locale === 'zh-cn' ? 'months' : 'monthsShort'](month);
  }

  function syncTime(from, to) {
    if (!moment.isMoment(from) || !moment.isMoment(to)) return;
    to.hour(from.hour());
    to.minute(from.minute());
    to.second(from.second());
  }

  function getTimeConfig(value, disabledTime) {
    var disabledTimeConfig = disabledTime ? disabledTime(value) : {};
    disabledTimeConfig = _extends$2({}, defaultDisabledTime, disabledTimeConfig);
    return disabledTimeConfig;
  }

  function isTimeValidByConfig(value, disabledTimeConfig) {
    var invalidTime = false;
    if (value) {
      var hour = value.hour();
      var minutes = value.minute();
      var seconds = value.second();
      var disabledHours = disabledTimeConfig.disabledHours();
      if (disabledHours.indexOf(hour) === -1) {
        var disabledMinutes = disabledTimeConfig.disabledMinutes(hour);
        if (disabledMinutes.indexOf(minutes) === -1) {
          var disabledSeconds = disabledTimeConfig.disabledSeconds(hour, minutes);
          invalidTime = disabledSeconds.indexOf(seconds) !== -1;
        } else {
          invalidTime = true;
        }
      } else {
        invalidTime = true;
      }
    }
    return !invalidTime;
  }

  function isTimeValid(value, disabledTime) {
    var disabledTimeConfig = getTimeConfig(value, disabledTime);
    return isTimeValidByConfig(value, disabledTimeConfig);
  }

  function isAllowedDate(value, disabledDate, disabledTime) {
    if (disabledDate) {
      if (disabledDate(value)) {
        return false;
      }
    }
    if (disabledTime) {
      if (!isTimeValid(value, disabledTime)) {
        return false;
      }
    }
    return true;
  }

  function isSameDay(one, two) {
    return one && two && one.isSame(two, 'day');
  }

  function beforeCurrentMonthYear(current, today) {
    if (current.year() < today.year()) {
      return 1;
    }
    return current.year() === today.year() && current.month() < today.month();
  }

  function afterCurrentMonthYear(current, today) {
    if (current.year() > today.year()) {
      return 1;
    }
    return current.year() === today.year() && current.month() > today.month();
  }

  function getIdFromDate(date) {
    return 'rc-calendar-' + date.year() + '-' + date.month() + '-' + date.date();
  }

  var DateTBody = createReactClass({
    displayName: 'DateTBody',

    propTypes: {
      contentRender: PropTypes.func,
      dateRender: PropTypes.func,
      disabledDate: PropTypes.func,
      prefixCls: PropTypes.string,
      selectedValue: PropTypes.oneOfType([PropTypes.object, PropTypes.arrayOf(PropTypes.object)]),
      value: PropTypes.object,
      hoverValue: PropTypes.any,
      showWeekNumber: PropTypes.bool
    },

    getDefaultProps: function getDefaultProps() {
      return {
        hoverValue: []
      };
    },
    render: function render() {
      var props = this.props;
      var contentRender = props.contentRender,
          prefixCls = props.prefixCls,
          selectedValue = props.selectedValue,
          value = props.value,
          showWeekNumber = props.showWeekNumber,
          dateRender = props.dateRender,
          disabledDate = props.disabledDate,
          hoverValue = props.hoverValue;

      var iIndex = void 0;
      var jIndex = void 0;
      var current = void 0;
      var dateTable = [];
      var today = getTodayTime(value);
      var cellClass = prefixCls + '-cell';
      var weekNumberCellClass = prefixCls + '-week-number-cell';
      var dateClass = prefixCls + '-date';
      var todayClass = prefixCls + '-today';
      var selectedClass = prefixCls + '-selected-day';
      var selectedDateClass = prefixCls + '-selected-date'; // do not move with mouse operation
      var selectedStartDateClass = prefixCls + '-selected-start-date';
      var selectedEndDateClass = prefixCls + '-selected-end-date';
      var inRangeClass = prefixCls + '-in-range-cell';
      var lastMonthDayClass = prefixCls + '-last-month-cell';
      var nextMonthDayClass = prefixCls + '-next-month-btn-day';
      var disabledClass = prefixCls + '-disabled-cell';
      var firstDisableClass = prefixCls + '-disabled-cell-first-of-row';
      var lastDisableClass = prefixCls + '-disabled-cell-last-of-row';
      var lastDayOfMonthClass = prefixCls + '-last-day-of-month';
      var month1 = value.clone();
      month1.date(1);
      var day = month1.day();
      var lastMonthDiffDay = (day + 7 - value.localeData().firstDayOfWeek()) % 7;
      // calculate last month
      var lastMonth1 = month1.clone();
      lastMonth1.add(0 - lastMonthDiffDay, 'days');
      var passed = 0;

      for (iIndex = 0; iIndex < DateConstants.DATE_ROW_COUNT; iIndex++) {
        for (jIndex = 0; jIndex < DateConstants.DATE_COL_COUNT; jIndex++) {
          current = lastMonth1;
          if (passed) {
            current = current.clone();
            current.add(passed, 'days');
          }
          dateTable.push(current);
          passed++;
        }
      }
      var tableHtml = [];
      passed = 0;

      for (iIndex = 0; iIndex < DateConstants.DATE_ROW_COUNT; iIndex++) {
        var _cx;

        var isCurrentWeek = void 0;
        var weekNumberCell = void 0;
        var isActiveWeek = false;
        var dateCells = [];
        if (showWeekNumber) {
          weekNumberCell = React$1__default.createElement(
            'td',
            {
              key: dateTable[passed].week(),
              role: 'gridcell',
              className: weekNumberCellClass
            },
            dateTable[passed].week()
          );
        }
        for (jIndex = 0; jIndex < DateConstants.DATE_COL_COUNT; jIndex++) {
          var next = null;
          var last = null;
          current = dateTable[passed];
          if (jIndex < DateConstants.DATE_COL_COUNT - 1) {
            next = dateTable[passed + 1];
          }
          if (jIndex > 0) {
            last = dateTable[passed - 1];
          }
          var cls = cellClass;
          var disabled = false;
          var selected = false;

          if (isSameDay(current, today)) {
            cls += ' ' + todayClass;
            isCurrentWeek = true;
          }

          var isBeforeCurrentMonthYear = beforeCurrentMonthYear(current, value);
          var isAfterCurrentMonthYear = afterCurrentMonthYear(current, value);

          if (selectedValue && Array.isArray(selectedValue)) {
            var rangeValue = hoverValue.length ? hoverValue : selectedValue;
            if (!isBeforeCurrentMonthYear && !isAfterCurrentMonthYear) {
              var startValue = rangeValue[0];
              var endValue = rangeValue[1];
              if (startValue) {
                if (isSameDay(current, startValue)) {
                  selected = true;
                  isActiveWeek = true;
                  cls += ' ' + selectedStartDateClass;
                }
              }
              if (startValue && endValue) {
                if (isSameDay(current, endValue)) {
                  selected = true;
                  isActiveWeek = true;
                  cls += ' ' + selectedEndDateClass;
                } else if (current.isAfter(startValue, 'day') && current.isBefore(endValue, 'day')) {
                  cls += ' ' + inRangeClass;
                }
              }
            }
          } else if (isSameDay(current, value)) {
            // keyboard change value, highlight works
            selected = true;
            isActiveWeek = true;
          }

          if (isSameDay(current, selectedValue)) {
            cls += ' ' + selectedDateClass;
          }

          if (isBeforeCurrentMonthYear) {
            cls += ' ' + lastMonthDayClass;
          }

          if (isAfterCurrentMonthYear) {
            cls += ' ' + nextMonthDayClass;
          }

          if (current.clone().endOf('month').date() === current.date()) {
            cls += ' ' + lastDayOfMonthClass;
          }

          if (disabledDate) {
            if (disabledDate(current, value)) {
              disabled = true;

              if (!last || !disabledDate(last, value)) {
                cls += ' ' + firstDisableClass;
              }

              if (!next || !disabledDate(next, value)) {
                cls += ' ' + lastDisableClass;
              }
            }
          }

          if (selected) {
            cls += ' ' + selectedClass;
          }

          if (disabled) {
            cls += ' ' + disabledClass;
          }

          var dateHtml = void 0;
          if (dateRender) {
            dateHtml = dateRender(current, value);
          } else {
            var content = contentRender ? contentRender(current, value) : current.date();
            dateHtml = React$1__default.createElement(
              'div',
              {
                key: getIdFromDate(current),
                className: dateClass,
                'aria-selected': selected,
                'aria-disabled': disabled
              },
              content
            );
          }

          dateCells.push(React$1__default.createElement(
            'td',
            {
              key: passed,
              onClick: disabled ? undefined : props.onSelect.bind(null, current),
              onMouseEnter: disabled ? undefined : props.onDayHover && props.onDayHover.bind(null, current) || undefined,
              role: 'gridcell',
              title: getTitleString(current),
              className: cls
            },
            dateHtml
          ));

          passed++;
        }

        tableHtml.push(React$1__default.createElement(
          'tr',
          {
            key: iIndex,
            role: 'row',
            className: classnames((_cx = {}, _cx[prefixCls + '-current-week'] = isCurrentWeek, _cx[prefixCls + '-active-week'] = isActiveWeek, _cx))
          },
          weekNumberCell,
          dateCells
        ));
      }
      return React$1__default.createElement(
        'tbody',
        { className: prefixCls + '-tbody' },
        tableHtml
      );
    }
  });

  var DateTable = function (_React$Component) {
    _inherits$1(DateTable, _React$Component);

    function DateTable() {
      _classCallCheck$1(this, DateTable);

      return _possibleConstructorReturn$1(this, _React$Component.apply(this, arguments));
    }

    DateTable.prototype.render = function render() {
      var props = this.props;
      var prefixCls = props.prefixCls;
      return React$1__default.createElement(
        'table',
        { className: prefixCls + '-table', cellSpacing: '0', role: 'grid' },
        React$1__default.createElement(DateTHead, props),
        React$1__default.createElement(DateTBody, props)
      );
    };

    return DateTable;
  }(React$1__default.Component);

  function mirror(o) {
    return o;
  }

  function mapSelf(children) {
    // return ReactFragment
    return React$1__default.Children.map(children, mirror);
  }

  var ROW = 4;
  var COL = 3;

  function chooseMonth(month) {
    var next = this.state.value.clone();
    next.month(month);
    this.setAndSelectValue(next);
  }

  function noop$4() {}

  var MonthTable = function (_Component) {
    _inherits$1(MonthTable, _Component);

    function MonthTable(props) {
      _classCallCheck$1(this, MonthTable);

      var _this = _possibleConstructorReturn$1(this, _Component.call(this, props));

      _this.state = {
        value: props.value
      };
      return _this;
    }

    MonthTable.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if ('value' in nextProps) {
        this.setState({
          value: nextProps.value
        });
      }
    };

    MonthTable.prototype.setAndSelectValue = function setAndSelectValue(value) {
      this.setState({
        value: value
      });
      this.props.onSelect(value);
    };

    MonthTable.prototype.months = function months() {
      var value = this.state.value;
      var current = value.clone();
      var months = [];
      var index = 0;
      for (var rowIndex = 0; rowIndex < ROW; rowIndex++) {
        months[rowIndex] = [];
        for (var colIndex = 0; colIndex < COL; colIndex++) {
          current.month(index);
          var content = getMonthName(current);
          months[rowIndex][colIndex] = {
            value: index,
            content: content,
            title: content
          };
          index++;
        }
      }
      return months;
    };

    MonthTable.prototype.render = function render() {
      var _this2 = this;

      var props = this.props;
      var value = this.state.value;
      var today = getTodayTime(value);
      var months = this.months();
      var currentMonth = value.month();
      var prefixCls = props.prefixCls,
          locale = props.locale,
          contentRender = props.contentRender,
          cellRender = props.cellRender;

      var monthsEls = months.map(function (month, index) {
        var tds = month.map(function (monthData) {
          var _classNameMap;

          var disabled = false;
          if (props.disabledDate) {
            var testValue = value.clone();
            testValue.month(monthData.value);
            disabled = props.disabledDate(testValue);
          }
          var classNameMap = (_classNameMap = {}, _classNameMap[prefixCls + '-cell'] = 1, _classNameMap[prefixCls + '-cell-disabled'] = disabled, _classNameMap[prefixCls + '-selected-cell'] = monthData.value === currentMonth, _classNameMap[prefixCls + '-current-cell'] = today.year() === value.year() && monthData.value === today.month(), _classNameMap);
          var cellEl = void 0;
          if (cellRender) {
            var currentValue = value.clone();
            currentValue.month(monthData.value);
            cellEl = cellRender(currentValue, locale);
          } else {
            var content = void 0;
            if (contentRender) {
              var _currentValue = value.clone();
              _currentValue.month(monthData.value);
              content = contentRender(_currentValue, locale);
            } else {
              content = monthData.content;
            }
            cellEl = React$1__default.createElement(
              'a',
              { className: prefixCls + '-month' },
              content
            );
          }
          return React$1__default.createElement(
            'td',
            {
              role: 'gridcell',
              key: monthData.value,
              onClick: disabled ? null : chooseMonth.bind(_this2, monthData.value),
              title: monthData.title,
              className: classnames(classNameMap)
            },
            cellEl
          );
        });
        return React$1__default.createElement(
          'tr',
          { key: index, role: 'row' },
          tds
        );
      });

      return React$1__default.createElement(
        'table',
        { className: prefixCls + '-table', cellSpacing: '0', role: 'grid' },
        React$1__default.createElement(
          'tbody',
          { className: prefixCls + '-tbody' },
          monthsEls
        )
      );
    };

    return MonthTable;
  }(React$1.Component);

  MonthTable.defaultProps = {
    onSelect: noop$4
  };
  MonthTable.propTypes = {
    onSelect: PropTypes.func,
    cellRender: PropTypes.func,
    prefixCls: PropTypes.string,
    value: PropTypes.object
  };

  function goYear(direction) {
    var next = this.state.value.clone();
    next.add(direction, 'year');
    this.setAndChangeValue(next);
  }

  function noop$5() {}

  var MonthPanel = createReactClass({
    displayName: 'MonthPanel',

    propTypes: {
      onChange: PropTypes.func,
      disabledDate: PropTypes.func,
      onSelect: PropTypes.func
    },

    getDefaultProps: function getDefaultProps() {
      return {
        onChange: noop$5,
        onSelect: noop$5
      };
    },
    getInitialState: function getInitialState() {
      var props = this.props;
      // bind methods
      this.nextYear = goYear.bind(this, 1);
      this.previousYear = goYear.bind(this, -1);
      this.prefixCls = props.rootPrefixCls + '-month-panel';
      return {
        value: props.value || props.defaultValue
      };
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
      if ('value' in nextProps) {
        this.setState({
          value: nextProps.value
        });
      }
    },
    setAndChangeValue: function setAndChangeValue(value) {
      this.setValue(value);
      this.props.onChange(value);
    },
    setAndSelectValue: function setAndSelectValue(value) {
      this.setValue(value);
      this.props.onSelect(value);
    },
    setValue: function setValue(value) {
      if (!('value' in this.props)) {
        this.setState({
          value: value
        });
      }
    },
    render: function render() {
      var props = this.props;
      var value = this.state.value;
      var cellRender = props.cellRender;
      var contentRender = props.contentRender;
      var locale = props.locale;
      var year = value.year();
      var prefixCls = this.prefixCls;
      return React$1__default.createElement(
        'div',
        { className: prefixCls, style: props.style },
        React$1__default.createElement(
          'div',
          null,
          React$1__default.createElement(
            'div',
            { className: prefixCls + '-header' },
            React$1__default.createElement('a', {
              className: prefixCls + '-prev-year-btn',
              role: 'button',
              onClick: this.previousYear,
              title: locale.previousYear
            }),
            React$1__default.createElement(
              'a',
              {
                className: prefixCls + '-year-select',
                role: 'button',
                onClick: props.onYearPanelShow,
                title: locale.yearSelect
              },
              React$1__default.createElement(
                'span',
                { className: prefixCls + '-year-select-content' },
                year
              ),
              React$1__default.createElement(
                'span',
                { className: prefixCls + '-year-select-arrow' },
                'x'
              )
            ),
            React$1__default.createElement('a', {
              className: prefixCls + '-next-year-btn',
              role: 'button',
              onClick: this.nextYear,
              title: locale.nextYear
            })
          ),
          React$1__default.createElement(
            'div',
            { className: prefixCls + '-body' },
            React$1__default.createElement(MonthTable, {
              disabledDate: props.disabledDate,
              onSelect: this.setAndSelectValue,
              locale: locale,
              value: value,
              cellRender: cellRender,
              contentRender: contentRender,
              prefixCls: prefixCls
            })
          )
        )
      );
    }
  });

  var ROW$1 = 4;
  var COL$1 = 3;

  function goYear$1(direction) {
    var value = this.state.value.clone();
    value.add(direction, 'year');
    this.setState({
      value: value
    });
  }

  function chooseYear(year) {
    var value = this.state.value.clone();
    value.year(year);
    value.month(this.state.value.month());
    this.props.onSelect(value);
  }

  var YearPanel = function (_React$Component) {
    _inherits$1(YearPanel, _React$Component);

    function YearPanel(props) {
      _classCallCheck$1(this, YearPanel);

      var _this = _possibleConstructorReturn$1(this, _React$Component.call(this, props));

      _this.prefixCls = props.rootPrefixCls + '-year-panel';
      _this.state = {
        value: props.value || props.defaultValue
      };
      _this.nextDecade = goYear$1.bind(_this, 10);
      _this.previousDecade = goYear$1.bind(_this, -10);
      return _this;
    }

    YearPanel.prototype.years = function years() {
      var value = this.state.value;
      var currentYear = value.year();
      var startYear = parseInt(currentYear / 10, 10) * 10;
      var previousYear = startYear - 1;
      var years = [];
      var index = 0;
      for (var rowIndex = 0; rowIndex < ROW$1; rowIndex++) {
        years[rowIndex] = [];
        for (var colIndex = 0; colIndex < COL$1; colIndex++) {
          var year = previousYear + index;
          var content = String(year);
          years[rowIndex][colIndex] = {
            content: content,
            year: year,
            title: content
          };
          index++;
        }
      }
      return years;
    };

    YearPanel.prototype.render = function render() {
      var _this2 = this;

      var props = this.props;
      var value = this.state.value;
      var locale = props.locale;
      var years = this.years();
      var currentYear = value.year();
      var startYear = parseInt(currentYear / 10, 10) * 10;
      var endYear = startYear + 9;
      var prefixCls = this.prefixCls;

      var yeasEls = years.map(function (row, index) {
        var tds = row.map(function (yearData) {
          var _classNameMap;

          var classNameMap = (_classNameMap = {}, _classNameMap[prefixCls + '-cell'] = 1, _classNameMap[prefixCls + '-selected-cell'] = yearData.year === currentYear, _classNameMap[prefixCls + '-last-decade-cell'] = yearData.year < startYear, _classNameMap[prefixCls + '-next-decade-cell'] = yearData.year > endYear, _classNameMap);
          var clickHandler = void 0;
          if (yearData.year < startYear) {
            clickHandler = _this2.previousDecade;
          } else if (yearData.year > endYear) {
            clickHandler = _this2.nextDecade;
          } else {
            clickHandler = chooseYear.bind(_this2, yearData.year);
          }
          return React$1__default.createElement(
            'td',
            {
              role: 'gridcell',
              title: yearData.title,
              key: yearData.content,
              onClick: clickHandler,
              className: classnames(classNameMap)
            },
            React$1__default.createElement(
              'a',
              {
                className: prefixCls + '-year'
              },
              yearData.content
            )
          );
        });
        return React$1__default.createElement(
          'tr',
          { key: index, role: 'row' },
          tds
        );
      });

      return React$1__default.createElement(
        'div',
        { className: this.prefixCls },
        React$1__default.createElement(
          'div',
          null,
          React$1__default.createElement(
            'div',
            { className: prefixCls + '-header' },
            React$1__default.createElement('a', {
              className: prefixCls + '-prev-decade-btn',
              role: 'button',
              onClick: this.previousDecade,
              title: locale.previousDecade
            }),
            React$1__default.createElement(
              'a',
              {
                className: prefixCls + '-decade-select',
                role: 'button',
                onClick: props.onDecadePanelShow,
                title: locale.decadeSelect
              },
              React$1__default.createElement(
                'span',
                { className: prefixCls + '-decade-select-content' },
                startYear,
                '-',
                endYear
              ),
              React$1__default.createElement(
                'span',
                { className: prefixCls + '-decade-select-arrow' },
                'x'
              )
            ),
            React$1__default.createElement('a', {
              className: prefixCls + '-next-decade-btn',
              role: 'button',
              onClick: this.nextDecade,
              title: locale.nextDecade
            })
          ),
          React$1__default.createElement(
            'div',
            { className: prefixCls + '-body' },
            React$1__default.createElement(
              'table',
              { className: prefixCls + '-table', cellSpacing: '0', role: 'grid' },
              React$1__default.createElement(
                'tbody',
                { className: prefixCls + '-tbody' },
                yeasEls
              )
            )
          )
        )
      );
    };

    return YearPanel;
  }(React$1__default.Component);


  YearPanel.propTypes = {
    rootPrefixCls: PropTypes.string,
    value: PropTypes.object,
    defaultValue: PropTypes.object
  };

  YearPanel.defaultProps = {
    onSelect: function onSelect() {}
  };

  var ROW$2 = 4;
  var COL$2 = 3;

  function goYear$2(direction) {
    var next = this.state.value.clone();
    next.add(direction, 'years');
    this.setState({
      value: next
    });
  }

  function chooseDecade(year, event) {
    var next = this.state.value.clone();
    next.year(year);
    next.month(this.state.value.month());
    this.props.onSelect(next);
    event.preventDefault();
  }

  var DecadePanel = function (_React$Component) {
    _inherits$1(DecadePanel, _React$Component);

    function DecadePanel(props) {
      _classCallCheck$1(this, DecadePanel);

      var _this = _possibleConstructorReturn$1(this, _React$Component.call(this, props));

      _this.state = {
        value: props.value || props.defaultValue
      };

      // bind methods
      _this.prefixCls = props.rootPrefixCls + '-decade-panel';
      _this.nextCentury = goYear$2.bind(_this, 100);
      _this.previousCentury = goYear$2.bind(_this, -100);
      return _this;
    }

    DecadePanel.prototype.render = function render() {
      var _this2 = this;

      var value = this.state.value;
      var locale = this.props.locale;
      var currentYear = value.year();
      var startYear = parseInt(currentYear / 100, 10) * 100;
      var preYear = startYear - 10;
      var endYear = startYear + 99;
      var decades = [];
      var index = 0;
      var prefixCls = this.prefixCls;

      for (var rowIndex = 0; rowIndex < ROW$2; rowIndex++) {
        decades[rowIndex] = [];
        for (var colIndex = 0; colIndex < COL$2; colIndex++) {
          var startDecade = preYear + index * 10;
          var endDecade = preYear + index * 10 + 9;
          decades[rowIndex][colIndex] = {
            startDecade: startDecade,
            endDecade: endDecade
          };
          index++;
        }
      }

      var decadesEls = decades.map(function (row, decadeIndex) {
        var tds = row.map(function (decadeData) {
          var _classNameMap;

          var dStartDecade = decadeData.startDecade;
          var dEndDecade = decadeData.endDecade;
          var isLast = dStartDecade < startYear;
          var isNext = dEndDecade > endYear;
          var classNameMap = (_classNameMap = {}, _classNameMap[prefixCls + '-cell'] = 1, _classNameMap[prefixCls + '-selected-cell'] = dStartDecade <= currentYear && currentYear <= dEndDecade, _classNameMap[prefixCls + '-last-century-cell'] = isLast, _classNameMap[prefixCls + '-next-century-cell'] = isNext, _classNameMap);
          var content = dStartDecade + '-' + dEndDecade;
          var clickHandler = void 0;
          if (isLast) {
            clickHandler = _this2.previousCentury;
          } else if (isNext) {
            clickHandler = _this2.nextCentury;
          } else {
            clickHandler = chooseDecade.bind(_this2, dStartDecade);
          }
          return React$1__default.createElement(
            'td',
            {
              key: dStartDecade,
              onClick: clickHandler,
              role: 'gridcell',
              className: classnames(classNameMap)
            },
            React$1__default.createElement(
              'a',
              {
                className: prefixCls + '-decade'
              },
              content
            )
          );
        });
        return React$1__default.createElement(
          'tr',
          { key: decadeIndex, role: 'row' },
          tds
        );
      });

      return React$1__default.createElement(
        'div',
        { className: this.prefixCls },
        React$1__default.createElement(
          'div',
          { className: prefixCls + '-header' },
          React$1__default.createElement('a', {
            className: prefixCls + '-prev-century-btn',
            role: 'button',
            onClick: this.previousCentury,
            title: locale.previousCentury
          }),
          React$1__default.createElement(
            'div',
            { className: prefixCls + '-century' },
            startYear,
            '-',
            endYear
          ),
          React$1__default.createElement('a', {
            className: prefixCls + '-next-century-btn',
            role: 'button',
            onClick: this.nextCentury,
            title: locale.nextCentury
          })
        ),
        React$1__default.createElement(
          'div',
          { className: prefixCls + '-body' },
          React$1__default.createElement(
            'table',
            { className: prefixCls + '-table', cellSpacing: '0', role: 'grid' },
            React$1__default.createElement(
              'tbody',
              { className: prefixCls + '-tbody' },
              decadesEls
            )
          )
        )
      );
    };

    return DecadePanel;
  }(React$1__default.Component);


  DecadePanel.propTypes = {
    locale: PropTypes.object,
    value: PropTypes.object,
    defaultValue: PropTypes.object,
    rootPrefixCls: PropTypes.string
  };

  DecadePanel.defaultProps = {
    onSelect: function onSelect() {}
  };

  function goMonth(direction) {
    var next = this.props.value.clone();
    next.add(direction, 'months');
    this.props.onValueChange(next);
  }

  function goYear$3(direction) {
    var next = this.props.value.clone();
    next.add(direction, 'years');
    this.props.onValueChange(next);
  }

  function showIf(condition, el) {
    return condition ? el : null;
  }

  var CalendarHeader = createReactClass({
    displayName: 'CalendarHeader',

    propTypes: {
      prefixCls: PropTypes.string,
      value: PropTypes.object,
      onValueChange: PropTypes.func,
      showTimePicker: PropTypes.bool,
      onPanelChange: PropTypes.func,
      locale: PropTypes.object,
      enablePrev: PropTypes.any,
      enableNext: PropTypes.any,
      disabledMonth: PropTypes.func
    },

    getDefaultProps: function getDefaultProps() {
      return {
        enableNext: 1,
        enablePrev: 1,
        onPanelChange: function onPanelChange() {},
        onValueChange: function onValueChange() {}
      };
    },
    getInitialState: function getInitialState() {
      this.nextMonth = goMonth.bind(this, 1);
      this.previousMonth = goMonth.bind(this, -1);
      this.nextYear = goYear$3.bind(this, 1);
      this.previousYear = goYear$3.bind(this, -1);
      return { yearPanelReferer: null };
    },
    onMonthSelect: function onMonthSelect(value) {
      this.props.onPanelChange(value, 'date');
      if (this.props.onMonthSelect) {
        this.props.onMonthSelect(value);
      } else {
        this.props.onValueChange(value);
      }
    },
    onYearSelect: function onYearSelect(value) {
      var referer = this.state.yearPanelReferer;
      this.setState({ yearPanelReferer: null });
      this.props.onPanelChange(value, referer);
      this.props.onValueChange(value);
    },
    onDecadeSelect: function onDecadeSelect(value) {
      this.props.onPanelChange(value, 'year');
      this.props.onValueChange(value);
    },
    monthYearElement: function monthYearElement(showTimePicker) {
      var _this = this;

      var props = this.props;
      var prefixCls = props.prefixCls;
      var locale = props.locale;
      var value = props.value;
      var localeData = value.localeData();
      var monthBeforeYear = locale.monthBeforeYear;
      var selectClassName = prefixCls + '-' + (monthBeforeYear ? 'my-select' : 'ym-select');
      var year = React$1__default.createElement(
        'a',
        {
          className: prefixCls + '-year-select',
          role: 'button',
          onClick: showTimePicker ? null : function () {
            return _this.showYearPanel('date');
          },
          title: locale.yearSelect
        },
        value.format(locale.yearFormat)
      );
      var month = React$1__default.createElement(
        'a',
        {
          className: prefixCls + '-month-select',
          role: 'button',
          onClick: showTimePicker ? null : this.showMonthPanel,
          title: locale.monthSelect
        },
        locale.monthFormat ? value.format(locale.monthFormat) : localeData.monthsShort(value)
      );
      var day = void 0;
      if (showTimePicker) {
        day = React$1__default.createElement(
          'a',
          {
            className: prefixCls + '-day-select',
            role: 'button'
          },
          value.format(locale.dayFormat)
        );
      }
      var my = [];
      if (monthBeforeYear) {
        my = [month, day, year];
      } else {
        my = [year, month, day];
      }
      return React$1__default.createElement(
        'span',
        { className: selectClassName },
        mapSelf(my)
      );
    },
    showMonthPanel: function showMonthPanel() {
      // null means that users' interaction doesn't change value
      this.props.onPanelChange(null, 'month');
    },
    showYearPanel: function showYearPanel(referer) {
      this.setState({ yearPanelReferer: referer });
      this.props.onPanelChange(null, 'year');
    },
    showDecadePanel: function showDecadePanel() {
      this.props.onPanelChange(null, 'decade');
    },
    render: function render() {
      var _this2 = this;

      var props = this.props;
      var prefixCls = props.prefixCls,
          locale = props.locale,
          mode = props.mode,
          value = props.value,
          showTimePicker = props.showTimePicker,
          enableNext = props.enableNext,
          enablePrev = props.enablePrev,
          disabledMonth = props.disabledMonth;


      var panel = null;
      if (mode === 'month') {
        panel = React$1__default.createElement(MonthPanel, {
          locale: locale,
          defaultValue: value,
          rootPrefixCls: prefixCls,
          onSelect: this.onMonthSelect,
          onYearPanelShow: function onYearPanelShow() {
            return _this2.showYearPanel('month');
          },
          disabledDate: disabledMonth,
          cellRender: props.monthCellRender,
          contentRender: props.monthCellContentRender
        });
      }
      if (mode === 'year') {
        panel = React$1__default.createElement(YearPanel, {
          locale: locale,
          defaultValue: value,
          rootPrefixCls: prefixCls,
          onSelect: this.onYearSelect,
          onDecadePanelShow: this.showDecadePanel
        });
      }
      if (mode === 'decade') {
        panel = React$1__default.createElement(DecadePanel, {
          locale: locale,
          defaultValue: value,
          rootPrefixCls: prefixCls,
          onSelect: this.onDecadeSelect
        });
      }

      return React$1__default.createElement(
        'div',
        { className: prefixCls + '-header' },
        React$1__default.createElement(
          'div',
          { style: { position: 'relative' } },
          showIf(enablePrev && !showTimePicker, React$1__default.createElement('a', {
            className: prefixCls + '-prev-year-btn',
            role: 'button',
            onClick: this.previousYear,
            title: locale.previousYear
          })),
          showIf(enablePrev && !showTimePicker, React$1__default.createElement('a', {
            className: prefixCls + '-prev-month-btn',
            role: 'button',
            onClick: this.previousMonth,
            title: locale.previousMonth
          })),
          this.monthYearElement(showTimePicker),
          showIf(enableNext && !showTimePicker, React$1__default.createElement('a', {
            className: prefixCls + '-next-month-btn',
            onClick: this.nextMonth,
            title: locale.nextMonth
          })),
          showIf(enableNext && !showTimePicker, React$1__default.createElement('a', {
            className: prefixCls + '-next-year-btn',
            onClick: this.nextYear,
            title: locale.nextYear
          }))
        ),
        panel
      );
    }
  });

  function TodayButton(_ref) {
    var prefixCls = _ref.prefixCls,
        locale = _ref.locale,
        value = _ref.value,
        timePicker = _ref.timePicker,
        disabled = _ref.disabled,
        disabledDate = _ref.disabledDate,
        onToday = _ref.onToday,
        text = _ref.text;

    var localeNow = (!text && timePicker ? locale.now : text) || locale.today;
    var disabledToday = disabledDate && !isAllowedDate(getTodayTime(value), disabledDate);
    var isDisabled = disabledToday || disabled;
    var disabledTodayClass = isDisabled ? prefixCls + '-today-btn-disabled' : '';
    return React$1__default.createElement(
      'a',
      {
        className: prefixCls + '-today-btn ' + disabledTodayClass,
        role: 'button',
        onClick: isDisabled ? null : onToday,
        title: getTodayTimeStr(value)
      },
      localeNow
    );
  }

  function OkButton(_ref) {
    var prefixCls = _ref.prefixCls,
        locale = _ref.locale,
        okDisabled = _ref.okDisabled,
        onOk = _ref.onOk;

    var className = prefixCls + "-ok-btn";
    if (okDisabled) {
      className += " " + prefixCls + "-ok-btn-disabled";
    }
    return React$1__default.createElement(
      "a",
      {
        className: className,
        role: "button",
        onClick: okDisabled ? null : onOk
      },
      locale.ok
    );
  }

  function TimePickerButton(_ref) {
    var _classnames;

    var prefixCls = _ref.prefixCls,
        locale = _ref.locale,
        showTimePicker = _ref.showTimePicker,
        onOpenTimePicker = _ref.onOpenTimePicker,
        onCloseTimePicker = _ref.onCloseTimePicker,
        timePickerDisabled = _ref.timePickerDisabled;

    var className = classnames((_classnames = {}, _classnames[prefixCls + '-time-picker-btn'] = true, _classnames[prefixCls + '-time-picker-btn-disabled'] = timePickerDisabled, _classnames));
    var onClick = null;
    if (!timePickerDisabled) {
      onClick = showTimePicker ? onCloseTimePicker : onOpenTimePicker;
    }
    return React$1__default.createElement(
      'a',
      {
        className: className,
        role: 'button',
        onClick: onClick
      },
      showTimePicker ? locale.dateSelect : locale.timeSelect
    );
  }

  var CalendarFooter = createReactClass({
    displayName: 'CalendarFooter',

    propTypes: {
      prefixCls: PropTypes.string,
      showDateInput: PropTypes.bool,
      disabledTime: PropTypes.any,
      timePicker: PropTypes.element,
      selectedValue: PropTypes.any,
      showOk: PropTypes.bool,
      onSelect: PropTypes.func,
      value: PropTypes.object,
      renderFooter: PropTypes.func,
      defaultValue: PropTypes.object
    },

    onSelect: function onSelect(value) {
      this.props.onSelect(value);
    },
    getRootDOMNode: function getRootDOMNode() {
      return ReactDOM__default.findDOMNode(this);
    },
    render: function render() {
      var props = this.props;
      var value = props.value,
          prefixCls = props.prefixCls,
          showOk = props.showOk,
          timePicker = props.timePicker,
          renderFooter = props.renderFooter;

      var footerEl = null;
      var extraFooter = renderFooter();
      if (props.showToday || timePicker || extraFooter) {
        var _cx;

        var nowEl = void 0;
        if (props.showToday) {
          nowEl = React$1__default.createElement(TodayButton, _extends$2({}, props, { value: value }));
        }
        var okBtn = void 0;
        if (showOk === true || showOk !== false && !!props.timePicker) {
          okBtn = React$1__default.createElement(OkButton, props);
        }
        var timePickerBtn = void 0;
        if (!!props.timePicker) {
          timePickerBtn = React$1__default.createElement(TimePickerButton, props);
        }

        var footerBtn = void 0;
        if (nowEl || timePickerBtn || okBtn) {
          footerBtn = React$1__default.createElement(
            'span',
            { className: prefixCls + '-footer-btn' },
            mapSelf([nowEl, timePickerBtn, okBtn])
          );
        }
        var cls = classnames((_cx = {}, _cx[prefixCls + '-footer'] = true, _cx[prefixCls + '-footer-show-ok'] = okBtn, _cx));
        footerEl = React$1__default.createElement(
          'div',
          { className: cls },
          extraFooter,
          footerBtn
        );
      }
      return footerEl;
    }
  });

  function noop$6() {}

  function getNow() {
    return moment();
  }

  function getNowByCurrentStateValue(value) {
    var ret = void 0;
    if (value) {
      ret = getTodayTime(value);
    } else {
      ret = getNow();
    }
    return ret;
  }

  var CalendarMixin = {
    propTypes: {
      value: PropTypes.object,
      defaultValue: PropTypes.object,
      onKeyDown: PropTypes.func
    },

    getDefaultProps: function getDefaultProps() {
      return {
        onKeyDown: noop$6
      };
    },
    getInitialState: function getInitialState() {
      var props = this.props;
      var value = props.value || props.defaultValue || getNow();
      return {
        value: value,
        selectedValue: props.selectedValue || props.defaultSelectedValue
      };
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
      var value = nextProps.value;
      var selectedValue = nextProps.selectedValue;

      if ('value' in nextProps) {
        value = value || nextProps.defaultValue || getNowByCurrentStateValue(this.state.value);
        this.setState({
          value: value
        });
      }
      if ('selectedValue' in nextProps) {
        this.setState({
          selectedValue: selectedValue
        });
      }
    },
    onSelect: function onSelect(value, cause) {
      if (value) {
        this.setValue(value);
      }
      this.setSelectedValue(value, cause);
    },
    renderRoot: function renderRoot(newProps) {
      var _className;

      var props = this.props;
      var prefixCls = props.prefixCls;

      var className = (_className = {}, _className[prefixCls] = 1, _className[prefixCls + '-hidden'] = !props.visible, _className[props.className] = !!props.className, _className[newProps.className] = !!newProps.className, _className);

      return React$1__default.createElement(
        'div',
        {
          ref: this.saveRoot,
          className: '' + classnames(className),
          style: this.props.style,
          tabIndex: '0',
          onKeyDown: this.onKeyDown
        },
        newProps.children
      );
    },
    setSelectedValue: function setSelectedValue(selectedValue, cause) {
      // if (this.isAllowedDate(selectedValue)) {
      if (!('selectedValue' in this.props)) {
        this.setState({
          selectedValue: selectedValue
        });
      }
      this.props.onSelect(selectedValue, cause);
      // }
    },
    setValue: function setValue(value) {
      var originalValue = this.state.value;
      if (!('value' in this.props)) {
        this.setState({
          value: value
        });
      }
      if (originalValue && value && !originalValue.isSame(value) || !originalValue && value || originalValue && !value) {
        this.props.onChange(value);
      }
    },
    isAllowedDate: function isAllowedDate$$1(value) {
      var disabledDate = this.props.disabledDate;
      var disabledTime = this.props.disabledTime;
      return isAllowedDate(value, disabledDate, disabledTime);
    }
  };

  var enUs = {
    today: 'Today',
    now: 'Now',
    backToToday: 'Back to today',
    ok: 'Ok',
    clear: 'Clear',
    month: 'Month',
    year: 'Year',
    timeSelect: 'select time',
    dateSelect: 'select date',
    weekSelect: 'Choose a week',
    monthSelect: 'Choose a month',
    yearSelect: 'Choose a year',
    decadeSelect: 'Choose a decade',
    yearFormat: 'YYYY',
    dateFormat: 'M/D/YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'M/D/YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Previous month (PageUp)',
    nextMonth: 'Next month (PageDown)',
    previousYear: 'Last year (Control + left)',
    nextYear: 'Next year (Control + right)',
    previousDecade: 'Last decade',
    nextDecade: 'Next decade',
    previousCentury: 'Last century',
    nextCentury: 'Next century'
  };

  function noop$7() {}

  var CommonMixin = {
    propTypes: {
      className: PropTypes.string,
      locale: PropTypes.object,
      style: PropTypes.object,
      visible: PropTypes.bool,
      onSelect: PropTypes.func,
      prefixCls: PropTypes.string,
      onChange: PropTypes.func,
      onOk: PropTypes.func
    },

    getDefaultProps: function getDefaultProps() {
      return {
        locale: enUs,
        style: {},
        visible: true,
        prefixCls: 'rc-calendar',
        className: '',
        onSelect: noop$7,
        onChange: noop$7,
        onClear: noop$7,
        renderFooter: function renderFooter() {
          return null;
        },
        renderSidebar: function renderSidebar() {
          return null;
        }
      };
    },
    shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
      return this.props.visible || nextProps.visible;
    },
    getFormat: function getFormat() {
      var format = this.props.format;
      var _props = this.props,
          locale = _props.locale,
          timePicker = _props.timePicker;

      if (!format) {
        if (timePicker) {
          format = locale.dateTimeFormat;
        } else {
          format = locale.dateFormat;
        }
      }
      return format;
    },
    focus: function focus() {
      if (this.rootInstance) {
        this.rootInstance.focus();
      }
    },
    saveRoot: function saveRoot(root) {
      this.rootInstance = root;
    }
  };

  var DateInput = createReactClass({
    displayName: 'DateInput',

    propTypes: {
      prefixCls: PropTypes.string,
      timePicker: PropTypes.object,
      value: PropTypes.object,
      disabledTime: PropTypes.any,
      format: PropTypes.string,
      locale: PropTypes.object,
      disabledDate: PropTypes.func,
      onChange: PropTypes.func,
      onClear: PropTypes.func,
      placeholder: PropTypes.string,
      onSelect: PropTypes.func,
      selectedValue: PropTypes.object
    },

    getInitialState: function getInitialState() {
      var selectedValue = this.props.selectedValue;
      return {
        str: selectedValue && selectedValue.format(this.props.format) || '',
        invalid: false
      };
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
      this.cachedSelectionStart = this.dateInputInstance.selectionStart;
      this.cachedSelectionEnd = this.dateInputInstance.selectionEnd;
      // when popup show, click body will call this, bug!
      var selectedValue = nextProps.selectedValue;
      this.setState({
        str: selectedValue && selectedValue.format(nextProps.format) || '',
        invalid: false
      });
    },
    componentDidUpdate: function componentDidUpdate() {
      if (!this.state.invalid) {
        this.dateInputInstance.setSelectionRange(this.cachedSelectionStart, this.cachedSelectionEnd);
      }
    },
    onInputChange: function onInputChange(event) {
      var str = event.target.value;
      this.setState({
        str: str
      });
      var value = void 0;
      var _props = this.props,
          disabledDate = _props.disabledDate,
          format = _props.format,
          onChange = _props.onChange;

      if (str) {
        var parsed = moment(str, format, true);
        if (!parsed.isValid()) {
          this.setState({
            invalid: true
          });
          return;
        }
        value = this.props.value.clone();
        value.year(parsed.year()).month(parsed.month()).date(parsed.date()).hour(parsed.hour()).minute(parsed.minute()).second(parsed.second());

        if (value && (!disabledDate || !disabledDate(value))) {
          var originalValue = this.props.selectedValue;
          if (originalValue && value) {
            if (!originalValue.isSame(value)) {
              onChange(value);
            }
          } else if (originalValue !== value) {
            onChange(value);
          }
        } else {
          this.setState({
            invalid: true
          });
          return;
        }
      } else {
        onChange(null);
      }
      this.setState({
        invalid: false
      });
    },
    onClear: function onClear() {
      this.setState({
        str: ''
      });
      this.props.onClear(null);
    },
    getRootDOMNode: function getRootDOMNode() {
      return ReactDOM__default.findDOMNode(this);
    },
    focus: function focus() {
      if (this.dateInputInstance) {
        this.dateInputInstance.focus();
      }
    },
    saveDateInput: function saveDateInput(dateInput) {
      this.dateInputInstance = dateInput;
    },
    render: function render() {
      var props = this.props;
      var _state = this.state,
          invalid = _state.invalid,
          str = _state.str;
      var locale = props.locale,
          prefixCls = props.prefixCls,
          placeholder = props.placeholder;

      var invalidClass = invalid ? prefixCls + '-input-invalid' : '';
      return React$1__default.createElement(
        'div',
        { className: prefixCls + '-input-wrap' },
        React$1__default.createElement(
          'div',
          { className: prefixCls + '-date-input-wrap' },
          React$1__default.createElement('input', {
            ref: this.saveDateInput,
            className: prefixCls + '-input ' + invalidClass,
            value: str,
            disabled: props.disabled,
            placeholder: placeholder,
            onChange: this.onInputChange
          })
        ),
        props.showClear ? React$1__default.createElement('a', {
          className: prefixCls + '-clear-btn',
          role: 'button',
          title: locale.clear,
          onClick: this.onClear
        }) : null
      );
    }
  });

  function goStartMonth(time) {
    return time.clone().startOf('month');
  }

  function goEndMonth(time) {
    return time.clone().endOf('month');
  }

  function goTime(time, direction, unit) {
    return time.clone().add(direction, unit);
  }

  function noop$8() {}

  var Calendar = createReactClass({
    displayName: 'Calendar',

    propTypes: {
      prefixCls: PropTypes.string,
      className: PropTypes.string,
      style: PropTypes.object,
      defaultValue: PropTypes.object,
      value: PropTypes.object,
      selectedValue: PropTypes.object,
      mode: PropTypes.oneOf(['time', 'date', 'month', 'year', 'decade']),
      locale: PropTypes.object,
      showDateInput: PropTypes.bool,
      showWeekNumber: PropTypes.bool,
      showToday: PropTypes.bool,
      showOk: PropTypes.bool,
      onSelect: PropTypes.func,
      onOk: PropTypes.func,
      onKeyDown: PropTypes.func,
      timePicker: PropTypes.element,
      dateInputPlaceholder: PropTypes.any,
      onClear: PropTypes.func,
      onChange: PropTypes.func,
      onPanelChange: PropTypes.func,
      disabledDate: PropTypes.func,
      disabledTime: PropTypes.any,
      renderFooter: PropTypes.func,
      renderSidebar: PropTypes.func
    },

    mixins: [CommonMixin, CalendarMixin],

    getDefaultProps: function getDefaultProps() {
      return {
        showToday: true,
        showDateInput: true,
        timePicker: null,
        onOk: noop$8,
        onPanelChange: noop$8
      };
    },
    getInitialState: function getInitialState() {
      return {
        mode: this.props.mode || 'date'
      };
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
      if ('mode' in nextProps && this.state.mode !== nextProps.mode) {
        this.setState({ mode: nextProps.mode });
      }
    },
    onKeyDown: function onKeyDown(event) {
      if (event.target.nodeName.toLowerCase() === 'input') {
        return undefined;
      }
      var keyCode = event.keyCode;
      // mac
      var ctrlKey = event.ctrlKey || event.metaKey;
      var disabledDate = this.props.disabledDate;
      var value = this.state.value;

      switch (keyCode) {
        case KeyCode.DOWN:
          this.goTime(1, 'weeks');
          event.preventDefault();
          return 1;
        case KeyCode.UP:
          this.goTime(-1, 'weeks');
          event.preventDefault();
          return 1;
        case KeyCode.LEFT:
          if (ctrlKey) {
            this.goTime(-1, 'years');
          } else {
            this.goTime(-1, 'days');
          }
          event.preventDefault();
          return 1;
        case KeyCode.RIGHT:
          if (ctrlKey) {
            this.goTime(1, 'years');
          } else {
            this.goTime(1, 'days');
          }
          event.preventDefault();
          return 1;
        case KeyCode.HOME:
          this.setValue(goStartMonth(this.state.value));
          event.preventDefault();
          return 1;
        case KeyCode.END:
          this.setValue(goEndMonth(this.state.value));
          event.preventDefault();
          return 1;
        case KeyCode.PAGE_DOWN:
          this.goTime(1, 'month');
          event.preventDefault();
          return 1;
        case KeyCode.PAGE_UP:
          this.goTime(-1, 'month');
          event.preventDefault();
          return 1;
        case KeyCode.ENTER:
          if (!disabledDate || !disabledDate(value)) {
            this.onSelect(value, {
              source: 'keyboard'
            });
          }
          event.preventDefault();
          return 1;
        default:
          this.props.onKeyDown(event);
          return 1;
      }
    },
    onClear: function onClear() {
      this.onSelect(null);
      this.props.onClear();
    },
    onOk: function onOk() {
      var selectedValue = this.state.selectedValue;

      if (this.isAllowedDate(selectedValue)) {
        this.props.onOk(selectedValue);
      }
    },
    onDateInputChange: function onDateInputChange(value) {
      this.onSelect(value, {
        source: 'dateInput'
      });
    },
    onDateTableSelect: function onDateTableSelect(value) {
      var timePicker = this.props.timePicker;
      var selectedValue = this.state.selectedValue;

      if (!selectedValue && timePicker) {
        var timePickerDefaultValue = timePicker.props.defaultValue;
        if (timePickerDefaultValue) {
          syncTime(timePickerDefaultValue, value);
        }
      }
      this.onSelect(value);
    },
    onToday: function onToday() {
      var value = this.state.value;

      var now = getTodayTime(value);
      this.onSelect(now, {
        source: 'todayButton'
      });
    },
    onPanelChange: function onPanelChange(value, mode) {
      var props = this.props,
          state = this.state;

      if (!('mode' in props)) {
        this.setState({ mode: mode });
      }
      props.onPanelChange(value || state.value, mode);
    },
    getRootDOMNode: function getRootDOMNode() {
      return ReactDOM__default.findDOMNode(this);
    },
    openTimePicker: function openTimePicker() {
      this.onPanelChange(null, 'time');
    },
    closeTimePicker: function closeTimePicker() {
      this.onPanelChange(null, 'date');
    },
    goTime: function goTime$$1(direction, unit) {
      this.setValue(goTime(this.state.value, direction, unit));
    },
    render: function render() {
      var props = this.props,
          state = this.state;
      var locale = props.locale,
          prefixCls = props.prefixCls,
          disabledDate = props.disabledDate,
          dateInputPlaceholder = props.dateInputPlaceholder,
          timePicker = props.timePicker,
          disabledTime = props.disabledTime;
      var value = state.value,
          selectedValue = state.selectedValue,
          mode = state.mode;

      var showTimePicker = mode === 'time';
      var disabledTimeConfig = showTimePicker && disabledTime && timePicker ? getTimeConfig(selectedValue, disabledTime) : null;

      var timePickerEle = null;

      if (timePicker && showTimePicker) {
        var timePickerProps = _extends$2({
          showHour: true,
          showSecond: true,
          showMinute: true
        }, timePicker.props, disabledTimeConfig, {
          onChange: this.onDateInputChange,
          value: selectedValue,
          disabledTime: disabledTime
        });

        if (timePicker.props.defaultValue !== undefined) {
          timePickerProps.defaultOpenValue = timePicker.props.defaultValue;
        }

        timePickerEle = React$1__default.cloneElement(timePicker, timePickerProps);
      }

      var dateInputElement = props.showDateInput ? React$1__default.createElement(DateInput, {
        format: this.getFormat(),
        key: 'date-input',
        value: value,
        locale: locale,
        placeholder: dateInputPlaceholder,
        showClear: true,
        disabledTime: disabledTime,
        disabledDate: disabledDate,
        onClear: this.onClear,
        prefixCls: prefixCls,
        selectedValue: selectedValue,
        onChange: this.onDateInputChange
      }) : null;
      var children = [props.renderSidebar(), React$1__default.createElement(
        'div',
        { className: prefixCls + '-panel', key: 'panel' },
        dateInputElement,
        React$1__default.createElement(
          'div',
          { className: prefixCls + '-date-panel' },
          React$1__default.createElement(CalendarHeader, {
            locale: locale,
            mode: mode,
            value: value,
            onValueChange: this.setValue,
            onPanelChange: this.onPanelChange,
            showTimePicker: showTimePicker,
            prefixCls: prefixCls
          }),
          timePicker && showTimePicker ? React$1__default.createElement(
            'div',
            { className: prefixCls + '-time-picker' },
            React$1__default.createElement(
              'div',
              { className: prefixCls + '-time-picker-panel' },
              timePickerEle
            )
          ) : null,
          React$1__default.createElement(
            'div',
            { className: prefixCls + '-body' },
            React$1__default.createElement(DateTable, {
              locale: locale,
              value: value,
              selectedValue: selectedValue,
              prefixCls: prefixCls,
              dateRender: props.dateRender,
              onSelect: this.onDateTableSelect,
              disabledDate: disabledDate,
              showWeekNumber: props.showWeekNumber
            })
          ),
          React$1__default.createElement(CalendarFooter, {
            showOk: props.showOk,
            renderFooter: props.renderFooter,
            locale: locale,
            prefixCls: prefixCls,
            showToday: props.showToday,
            disabledTime: disabledTime,
            showTimePicker: showTimePicker,
            showDateInput: props.showDateInput,
            timePicker: timePicker,
            selectedValue: selectedValue,
            value: value,
            disabledDate: disabledDate,
            okDisabled: !this.isAllowedDate(selectedValue),
            onOk: this.onOk,
            onSelect: this.onSelect,
            onToday: this.onToday,
            onOpenTimePicker: this.openTimePicker,
            onCloseTimePicker: this.closeTimePicker
          })
        )
      )];

      return this.renderRoot({
        children: children,
        className: props.showWeekNumber ? prefixCls + '-week-number' : ''
      });
    }
  });



  var es$5 = /*#__PURE__*/Object.freeze({
    default: Calendar
  });

  var KeyCode_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /**
   * @ignore
   * some key-codes definition and utils from closure-library
   * @author yiminghe@gmail.com
   */

  var KeyCode = {
    /**
     * MAC_ENTER
     */
    MAC_ENTER: 3,
    /**
     * BACKSPACE
     */
    BACKSPACE: 8,
    /**
     * TAB
     */
    TAB: 9,
    /**
     * NUMLOCK on FF/Safari Mac
     */
    NUM_CENTER: 12, // NUMLOCK on FF/Safari Mac
    /**
     * ENTER
     */
    ENTER: 13,
    /**
     * SHIFT
     */
    SHIFT: 16,
    /**
     * CTRL
     */
    CTRL: 17,
    /**
     * ALT
     */
    ALT: 18,
    /**
     * PAUSE
     */
    PAUSE: 19,
    /**
     * CAPS_LOCK
     */
    CAPS_LOCK: 20,
    /**
     * ESC
     */
    ESC: 27,
    /**
     * SPACE
     */
    SPACE: 32,
    /**
     * PAGE_UP
     */
    PAGE_UP: 33, // also NUM_NORTH_EAST
    /**
     * PAGE_DOWN
     */
    PAGE_DOWN: 34, // also NUM_SOUTH_EAST
    /**
     * END
     */
    END: 35, // also NUM_SOUTH_WEST
    /**
     * HOME
     */
    HOME: 36, // also NUM_NORTH_WEST
    /**
     * LEFT
     */
    LEFT: 37, // also NUM_WEST
    /**
     * UP
     */
    UP: 38, // also NUM_NORTH
    /**
     * RIGHT
     */
    RIGHT: 39, // also NUM_EAST
    /**
     * DOWN
     */
    DOWN: 40, // also NUM_SOUTH
    /**
     * PRINT_SCREEN
     */
    PRINT_SCREEN: 44,
    /**
     * INSERT
     */
    INSERT: 45, // also NUM_INSERT
    /**
     * DELETE
     */
    DELETE: 46, // also NUM_DELETE
    /**
     * ZERO
     */
    ZERO: 48,
    /**
     * ONE
     */
    ONE: 49,
    /**
     * TWO
     */
    TWO: 50,
    /**
     * THREE
     */
    THREE: 51,
    /**
     * FOUR
     */
    FOUR: 52,
    /**
     * FIVE
     */
    FIVE: 53,
    /**
     * SIX
     */
    SIX: 54,
    /**
     * SEVEN
     */
    SEVEN: 55,
    /**
     * EIGHT
     */
    EIGHT: 56,
    /**
     * NINE
     */
    NINE: 57,
    /**
     * QUESTION_MARK
     */
    QUESTION_MARK: 63, // needs localization
    /**
     * A
     */
    A: 65,
    /**
     * B
     */
    B: 66,
    /**
     * C
     */
    C: 67,
    /**
     * D
     */
    D: 68,
    /**
     * E
     */
    E: 69,
    /**
     * F
     */
    F: 70,
    /**
     * G
     */
    G: 71,
    /**
     * H
     */
    H: 72,
    /**
     * I
     */
    I: 73,
    /**
     * J
     */
    J: 74,
    /**
     * K
     */
    K: 75,
    /**
     * L
     */
    L: 76,
    /**
     * M
     */
    M: 77,
    /**
     * N
     */
    N: 78,
    /**
     * O
     */
    O: 79,
    /**
     * P
     */
    P: 80,
    /**
     * Q
     */
    Q: 81,
    /**
     * R
     */
    R: 82,
    /**
     * S
     */
    S: 83,
    /**
     * T
     */
    T: 84,
    /**
     * U
     */
    U: 85,
    /**
     * V
     */
    V: 86,
    /**
     * W
     */
    W: 87,
    /**
     * X
     */
    X: 88,
    /**
     * Y
     */
    Y: 89,
    /**
     * Z
     */
    Z: 90,
    /**
     * META
     */
    META: 91, // WIN_KEY_LEFT
    /**
     * WIN_KEY_RIGHT
     */
    WIN_KEY_RIGHT: 92,
    /**
     * CONTEXT_MENU
     */
    CONTEXT_MENU: 93,
    /**
     * NUM_ZERO
     */
    NUM_ZERO: 96,
    /**
     * NUM_ONE
     */
    NUM_ONE: 97,
    /**
     * NUM_TWO
     */
    NUM_TWO: 98,
    /**
     * NUM_THREE
     */
    NUM_THREE: 99,
    /**
     * NUM_FOUR
     */
    NUM_FOUR: 100,
    /**
     * NUM_FIVE
     */
    NUM_FIVE: 101,
    /**
     * NUM_SIX
     */
    NUM_SIX: 102,
    /**
     * NUM_SEVEN
     */
    NUM_SEVEN: 103,
    /**
     * NUM_EIGHT
     */
    NUM_EIGHT: 104,
    /**
     * NUM_NINE
     */
    NUM_NINE: 105,
    /**
     * NUM_MULTIPLY
     */
    NUM_MULTIPLY: 106,
    /**
     * NUM_PLUS
     */
    NUM_PLUS: 107,
    /**
     * NUM_MINUS
     */
    NUM_MINUS: 109,
    /**
     * NUM_PERIOD
     */
    NUM_PERIOD: 110,
    /**
     * NUM_DIVISION
     */
    NUM_DIVISION: 111,
    /**
     * F1
     */
    F1: 112,
    /**
     * F2
     */
    F2: 113,
    /**
     * F3
     */
    F3: 114,
    /**
     * F4
     */
    F4: 115,
    /**
     * F5
     */
    F5: 116,
    /**
     * F6
     */
    F6: 117,
    /**
     * F7
     */
    F7: 118,
    /**
     * F8
     */
    F8: 119,
    /**
     * F9
     */
    F9: 120,
    /**
     * F10
     */
    F10: 121,
    /**
     * F11
     */
    F11: 122,
    /**
     * F12
     */
    F12: 123,
    /**
     * NUMLOCK
     */
    NUMLOCK: 144,
    /**
     * SEMICOLON
     */
    SEMICOLON: 186, // needs localization
    /**
     * DASH
     */
    DASH: 189, // needs localization
    /**
     * EQUALS
     */
    EQUALS: 187, // needs localization
    /**
     * COMMA
     */
    COMMA: 188, // needs localization
    /**
     * PERIOD
     */
    PERIOD: 190, // needs localization
    /**
     * SLASH
     */
    SLASH: 191, // needs localization
    /**
     * APOSTROPHE
     */
    APOSTROPHE: 192, // needs localization
    /**
     * SINGLE_QUOTE
     */
    SINGLE_QUOTE: 222, // needs localization
    /**
     * OPEN_SQUARE_BRACKET
     */
    OPEN_SQUARE_BRACKET: 219, // needs localization
    /**
     * BACKSLASH
     */
    BACKSLASH: 220, // needs localization
    /**
     * CLOSE_SQUARE_BRACKET
     */
    CLOSE_SQUARE_BRACKET: 221, // needs localization
    /**
     * WIN_KEY
     */
    WIN_KEY: 224,
    /**
     * MAC_FF_META
     */
    MAC_FF_META: 224, // Firefox (Gecko) fires this for the meta key instead of 91
    /**
     * WIN_IME
     */
    WIN_IME: 229
  };

  /*
   whether text and modified key is entered at the same time.
   */
  KeyCode.isTextModifyingKeyEvent = function isTextModifyingKeyEvent(e) {
    var keyCode = e.keyCode;
    if (e.altKey && !e.ctrlKey || e.metaKey ||
    // Function keys don't generate text
    keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
      return false;
    }

    // The following keys are quite harmless, even in combination with
    // CTRL, ALT or SHIFT.
    switch (keyCode) {
      case KeyCode.ALT:
      case KeyCode.CAPS_LOCK:
      case KeyCode.CONTEXT_MENU:
      case KeyCode.CTRL:
      case KeyCode.DOWN:
      case KeyCode.END:
      case KeyCode.ESC:
      case KeyCode.HOME:
      case KeyCode.INSERT:
      case KeyCode.LEFT:
      case KeyCode.MAC_FF_META:
      case KeyCode.META:
      case KeyCode.NUMLOCK:
      case KeyCode.NUM_CENTER:
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
      case KeyCode.PAUSE:
      case KeyCode.PRINT_SCREEN:
      case KeyCode.RIGHT:
      case KeyCode.SHIFT:
      case KeyCode.UP:
      case KeyCode.WIN_KEY:
      case KeyCode.WIN_KEY_RIGHT:
        return false;
      default:
        return true;
    }
  };

  /*
   whether character is entered.
   */
  KeyCode.isCharacterKey = function isCharacterKey(keyCode) {
    if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
      return true;
    }

    if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
      return true;
    }

    if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
      return true;
    }

    // Safari sends zero key code for non-latin characters.
    if (window.navigation.userAgent.indexOf('WebKit') !== -1 && keyCode === 0) {
      return true;
    }

    switch (keyCode) {
      case KeyCode.SPACE:
      case KeyCode.QUESTION_MARK:
      case KeyCode.NUM_PLUS:
      case KeyCode.NUM_MINUS:
      case KeyCode.NUM_PERIOD:
      case KeyCode.NUM_DIVISION:
      case KeyCode.SEMICOLON:
      case KeyCode.DASH:
      case KeyCode.EQUALS:
      case KeyCode.COMMA:
      case KeyCode.PERIOD:
      case KeyCode.SLASH:
      case KeyCode.APOSTROPHE:
      case KeyCode.SINGLE_QUOTE:
      case KeyCode.OPEN_SQUARE_BRACKET:
      case KeyCode.BACKSLASH:
      case KeyCode.CLOSE_SQUARE_BRACKET:
        return true;
      default:
        return false;
    }
  };

  exports['default'] = KeyCode;
  module.exports = exports['default'];
  });

  unwrapExports(KeyCode_1);

  var mapSelf_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports['default'] = mapSelf;



  var _react2 = _interopRequireDefault(React$1__default);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function mirror(o) {
    return o;
  }

  function mapSelf(children) {
    // return ReactFragment
    return _react2['default'].Children.map(children, mirror);
  }
  module.exports = exports['default'];
  });

  unwrapExports(mapSelf_1);

  var util$2 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _extends3 = _interopRequireDefault(_extends$1);

  exports.getTodayTime = getTodayTime;
  exports.getTitleString = getTitleString;
  exports.getTodayTimeStr = getTodayTimeStr;
  exports.getMonthName = getMonthName;
  exports.syncTime = syncTime;
  exports.getTimeConfig = getTimeConfig;
  exports.isTimeValidByConfig = isTimeValidByConfig;
  exports.isTimeValid = isTimeValid;
  exports.isAllowedDate = isAllowedDate;



  var _moment2 = _interopRequireDefault(moment);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var defaultDisabledTime = {
    disabledHours: function disabledHours() {
      return [];
    },
    disabledMinutes: function disabledMinutes() {
      return [];
    },
    disabledSeconds: function disabledSeconds() {
      return [];
    }
  };

  function getTodayTime(value) {
    var today = (0, _moment2['default'])();
    today.locale(value.locale()).utcOffset(value.utcOffset());
    return today;
  }

  function getTitleString(value) {
    return value.format('LL');
  }

  function getTodayTimeStr(value) {
    var today = getTodayTime(value);
    return getTitleString(today);
  }

  function getMonthName(month) {
    var locale = month.locale();
    var localeData = month.localeData();
    return localeData[locale === 'zh-cn' ? 'months' : 'monthsShort'](month);
  }

  function syncTime(from, to) {
    if (!_moment2['default'].isMoment(from) || !_moment2['default'].isMoment(to)) return;
    to.hour(from.hour());
    to.minute(from.minute());
    to.second(from.second());
  }

  function getTimeConfig(value, disabledTime) {
    var disabledTimeConfig = disabledTime ? disabledTime(value) : {};
    disabledTimeConfig = (0, _extends3['default'])({}, defaultDisabledTime, disabledTimeConfig);
    return disabledTimeConfig;
  }

  function isTimeValidByConfig(value, disabledTimeConfig) {
    var invalidTime = false;
    if (value) {
      var hour = value.hour();
      var minutes = value.minute();
      var seconds = value.second();
      var disabledHours = disabledTimeConfig.disabledHours();
      if (disabledHours.indexOf(hour) === -1) {
        var disabledMinutes = disabledTimeConfig.disabledMinutes(hour);
        if (disabledMinutes.indexOf(minutes) === -1) {
          var disabledSeconds = disabledTimeConfig.disabledSeconds(hour, minutes);
          invalidTime = disabledSeconds.indexOf(seconds) !== -1;
        } else {
          invalidTime = true;
        }
      } else {
        invalidTime = true;
      }
    }
    return !invalidTime;
  }

  function isTimeValid(value, disabledTime) {
    var disabledTimeConfig = getTimeConfig(value, disabledTime);
    return isTimeValidByConfig(value, disabledTimeConfig);
  }

  function isAllowedDate(value, disabledDate, disabledTime) {
    if (disabledDate) {
      if (disabledDate(value)) {
        return false;
      }
    }
    if (disabledTime) {
      if (!isTimeValid(value, disabledTime)) {
        return false;
      }
    }
    return true;
  }
  });

  unwrapExports(util$2);
  var util_1 = util$2.getTodayTime;
  var util_2 = util$2.getTitleString;
  var util_3 = util$2.getTodayTimeStr;
  var util_4 = util$2.getMonthName;
  var util_5 = util$2.syncTime;
  var util_6 = util$2.getTimeConfig;
  var util_7 = util$2.isTimeValidByConfig;
  var util_8 = util$2.isTimeValid;
  var util_9 = util$2.isAllowedDate;

  var MonthTable_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var _react2 = _interopRequireDefault(React$1__default);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _classnames2 = _interopRequireDefault(classnames);



  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var ROW = 4;
  var COL = 3;

  function chooseMonth(month) {
    var next = this.state.value.clone();
    next.month(month);
    this.setAndSelectValue(next);
  }

  function noop() {}

  var MonthTable = function (_Component) {
    (0, _inherits3['default'])(MonthTable, _Component);

    function MonthTable(props) {
      (0, _classCallCheck3['default'])(this, MonthTable);

      var _this = (0, _possibleConstructorReturn3['default'])(this, _Component.call(this, props));

      _this.state = {
        value: props.value
      };
      return _this;
    }

    MonthTable.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if ('value' in nextProps) {
        this.setState({
          value: nextProps.value
        });
      }
    };

    MonthTable.prototype.setAndSelectValue = function setAndSelectValue(value) {
      this.setState({
        value: value
      });
      this.props.onSelect(value);
    };

    MonthTable.prototype.months = function months() {
      var value = this.state.value;
      var current = value.clone();
      var months = [];
      var index = 0;
      for (var rowIndex = 0; rowIndex < ROW; rowIndex++) {
        months[rowIndex] = [];
        for (var colIndex = 0; colIndex < COL; colIndex++) {
          current.month(index);
          var content = (0, util$2.getMonthName)(current);
          months[rowIndex][colIndex] = {
            value: index,
            content: content,
            title: content
          };
          index++;
        }
      }
      return months;
    };

    MonthTable.prototype.render = function render() {
      var _this2 = this;

      var props = this.props;
      var value = this.state.value;
      var today = (0, util$2.getTodayTime)(value);
      var months = this.months();
      var currentMonth = value.month();
      var prefixCls = props.prefixCls,
          locale = props.locale,
          contentRender = props.contentRender,
          cellRender = props.cellRender;

      var monthsEls = months.map(function (month, index) {
        var tds = month.map(function (monthData) {
          var _classNameMap;

          var disabled = false;
          if (props.disabledDate) {
            var testValue = value.clone();
            testValue.month(monthData.value);
            disabled = props.disabledDate(testValue);
          }
          var classNameMap = (_classNameMap = {}, _classNameMap[prefixCls + '-cell'] = 1, _classNameMap[prefixCls + '-cell-disabled'] = disabled, _classNameMap[prefixCls + '-selected-cell'] = monthData.value === currentMonth, _classNameMap[prefixCls + '-current-cell'] = today.year() === value.year() && monthData.value === today.month(), _classNameMap);
          var cellEl = void 0;
          if (cellRender) {
            var currentValue = value.clone();
            currentValue.month(monthData.value);
            cellEl = cellRender(currentValue, locale);
          } else {
            var content = void 0;
            if (contentRender) {
              var _currentValue = value.clone();
              _currentValue.month(monthData.value);
              content = contentRender(_currentValue, locale);
            } else {
              content = monthData.content;
            }
            cellEl = _react2['default'].createElement(
              'a',
              { className: prefixCls + '-month' },
              content
            );
          }
          return _react2['default'].createElement(
            'td',
            {
              role: 'gridcell',
              key: monthData.value,
              onClick: disabled ? null : chooseMonth.bind(_this2, monthData.value),
              title: monthData.title,
              className: (0, _classnames2['default'])(classNameMap)
            },
            cellEl
          );
        });
        return _react2['default'].createElement(
          'tr',
          { key: index, role: 'row' },
          tds
        );
      });

      return _react2['default'].createElement(
        'table',
        { className: prefixCls + '-table', cellSpacing: '0', role: 'grid' },
        _react2['default'].createElement(
          'tbody',
          { className: prefixCls + '-tbody' },
          monthsEls
        )
      );
    };

    return MonthTable;
  }(React$1__default.Component);

  MonthTable.defaultProps = {
    onSelect: noop
  };
  MonthTable.propTypes = {
    onSelect: _propTypes2['default'].func,
    cellRender: _propTypes2['default'].func,
    prefixCls: _propTypes2['default'].string,
    value: _propTypes2['default'].object
  };
  exports['default'] = MonthTable;
  module.exports = exports['default'];
  });

  unwrapExports(MonthTable_1);

  var MonthPanel_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _react2 = _interopRequireDefault(React$1__default);



  var _createReactClass2 = _interopRequireDefault(createReactClass);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _MonthTable2 = _interopRequireDefault(MonthTable_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function goYear(direction) {
    var next = this.state.value.clone();
    next.add(direction, 'year');
    this.setAndChangeValue(next);
  }

  function noop() {}

  var MonthPanel = (0, _createReactClass2['default'])({
    displayName: 'MonthPanel',

    propTypes: {
      onChange: _propTypes2['default'].func,
      disabledDate: _propTypes2['default'].func,
      onSelect: _propTypes2['default'].func
    },

    getDefaultProps: function getDefaultProps() {
      return {
        onChange: noop,
        onSelect: noop
      };
    },
    getInitialState: function getInitialState() {
      var props = this.props;
      // bind methods
      this.nextYear = goYear.bind(this, 1);
      this.previousYear = goYear.bind(this, -1);
      this.prefixCls = props.rootPrefixCls + '-month-panel';
      return {
        value: props.value || props.defaultValue
      };
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
      if ('value' in nextProps) {
        this.setState({
          value: nextProps.value
        });
      }
    },
    setAndChangeValue: function setAndChangeValue(value) {
      this.setValue(value);
      this.props.onChange(value);
    },
    setAndSelectValue: function setAndSelectValue(value) {
      this.setValue(value);
      this.props.onSelect(value);
    },
    setValue: function setValue(value) {
      if (!('value' in this.props)) {
        this.setState({
          value: value
        });
      }
    },
    render: function render() {
      var props = this.props;
      var value = this.state.value;
      var cellRender = props.cellRender;
      var contentRender = props.contentRender;
      var locale = props.locale;
      var year = value.year();
      var prefixCls = this.prefixCls;
      return _react2['default'].createElement(
        'div',
        { className: prefixCls, style: props.style },
        _react2['default'].createElement(
          'div',
          null,
          _react2['default'].createElement(
            'div',
            { className: prefixCls + '-header' },
            _react2['default'].createElement('a', {
              className: prefixCls + '-prev-year-btn',
              role: 'button',
              onClick: this.previousYear,
              title: locale.previousYear
            }),
            _react2['default'].createElement(
              'a',
              {
                className: prefixCls + '-year-select',
                role: 'button',
                onClick: props.onYearPanelShow,
                title: locale.yearSelect
              },
              _react2['default'].createElement(
                'span',
                { className: prefixCls + '-year-select-content' },
                year
              ),
              _react2['default'].createElement(
                'span',
                { className: prefixCls + '-year-select-arrow' },
                'x'
              )
            ),
            _react2['default'].createElement('a', {
              className: prefixCls + '-next-year-btn',
              role: 'button',
              onClick: this.nextYear,
              title: locale.nextYear
            })
          ),
          _react2['default'].createElement(
            'div',
            { className: prefixCls + '-body' },
            _react2['default'].createElement(_MonthTable2['default'], {
              disabledDate: props.disabledDate,
              onSelect: this.setAndSelectValue,
              locale: locale,
              value: value,
              cellRender: cellRender,
              contentRender: contentRender,
              prefixCls: prefixCls
            })
          )
        )
      );
    }
  });

  exports['default'] = MonthPanel;
  module.exports = exports['default'];
  });

  unwrapExports(MonthPanel_1);

  var YearPanel_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var _react2 = _interopRequireDefault(React$1__default);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _classnames2 = _interopRequireDefault(classnames);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var ROW = 4;
  var COL = 3;

  function goYear(direction) {
    var value = this.state.value.clone();
    value.add(direction, 'year');
    this.setState({
      value: value
    });
  }

  function chooseYear(year) {
    var value = this.state.value.clone();
    value.year(year);
    value.month(this.state.value.month());
    this.props.onSelect(value);
  }

  var YearPanel = function (_React$Component) {
    (0, _inherits3['default'])(YearPanel, _React$Component);

    function YearPanel(props) {
      (0, _classCallCheck3['default'])(this, YearPanel);

      var _this = (0, _possibleConstructorReturn3['default'])(this, _React$Component.call(this, props));

      _this.prefixCls = props.rootPrefixCls + '-year-panel';
      _this.state = {
        value: props.value || props.defaultValue
      };
      _this.nextDecade = goYear.bind(_this, 10);
      _this.previousDecade = goYear.bind(_this, -10);
      return _this;
    }

    YearPanel.prototype.years = function years() {
      var value = this.state.value;
      var currentYear = value.year();
      var startYear = parseInt(currentYear / 10, 10) * 10;
      var previousYear = startYear - 1;
      var years = [];
      var index = 0;
      for (var rowIndex = 0; rowIndex < ROW; rowIndex++) {
        years[rowIndex] = [];
        for (var colIndex = 0; colIndex < COL; colIndex++) {
          var year = previousYear + index;
          var content = String(year);
          years[rowIndex][colIndex] = {
            content: content,
            year: year,
            title: content
          };
          index++;
        }
      }
      return years;
    };

    YearPanel.prototype.render = function render() {
      var _this2 = this;

      var props = this.props;
      var value = this.state.value;
      var locale = props.locale;
      var years = this.years();
      var currentYear = value.year();
      var startYear = parseInt(currentYear / 10, 10) * 10;
      var endYear = startYear + 9;
      var prefixCls = this.prefixCls;

      var yeasEls = years.map(function (row, index) {
        var tds = row.map(function (yearData) {
          var _classNameMap;

          var classNameMap = (_classNameMap = {}, _classNameMap[prefixCls + '-cell'] = 1, _classNameMap[prefixCls + '-selected-cell'] = yearData.year === currentYear, _classNameMap[prefixCls + '-last-decade-cell'] = yearData.year < startYear, _classNameMap[prefixCls + '-next-decade-cell'] = yearData.year > endYear, _classNameMap);
          var clickHandler = void 0;
          if (yearData.year < startYear) {
            clickHandler = _this2.previousDecade;
          } else if (yearData.year > endYear) {
            clickHandler = _this2.nextDecade;
          } else {
            clickHandler = chooseYear.bind(_this2, yearData.year);
          }
          return _react2['default'].createElement(
            'td',
            {
              role: 'gridcell',
              title: yearData.title,
              key: yearData.content,
              onClick: clickHandler,
              className: (0, _classnames2['default'])(classNameMap)
            },
            _react2['default'].createElement(
              'a',
              {
                className: prefixCls + '-year'
              },
              yearData.content
            )
          );
        });
        return _react2['default'].createElement(
          'tr',
          { key: index, role: 'row' },
          tds
        );
      });

      return _react2['default'].createElement(
        'div',
        { className: this.prefixCls },
        _react2['default'].createElement(
          'div',
          null,
          _react2['default'].createElement(
            'div',
            { className: prefixCls + '-header' },
            _react2['default'].createElement('a', {
              className: prefixCls + '-prev-decade-btn',
              role: 'button',
              onClick: this.previousDecade,
              title: locale.previousDecade
            }),
            _react2['default'].createElement(
              'a',
              {
                className: prefixCls + '-decade-select',
                role: 'button',
                onClick: props.onDecadePanelShow,
                title: locale.decadeSelect
              },
              _react2['default'].createElement(
                'span',
                { className: prefixCls + '-decade-select-content' },
                startYear,
                '-',
                endYear
              ),
              _react2['default'].createElement(
                'span',
                { className: prefixCls + '-decade-select-arrow' },
                'x'
              )
            ),
            _react2['default'].createElement('a', {
              className: prefixCls + '-next-decade-btn',
              role: 'button',
              onClick: this.nextDecade,
              title: locale.nextDecade
            })
          ),
          _react2['default'].createElement(
            'div',
            { className: prefixCls + '-body' },
            _react2['default'].createElement(
              'table',
              { className: prefixCls + '-table', cellSpacing: '0', role: 'grid' },
              _react2['default'].createElement(
                'tbody',
                { className: prefixCls + '-tbody' },
                yeasEls
              )
            )
          )
        )
      );
    };

    return YearPanel;
  }(_react2['default'].Component);

  exports['default'] = YearPanel;


  YearPanel.propTypes = {
    rootPrefixCls: _propTypes2['default'].string,
    value: _propTypes2['default'].object,
    defaultValue: _propTypes2['default'].object
  };

  YearPanel.defaultProps = {
    onSelect: function onSelect() {}
  };
  module.exports = exports['default'];
  });

  unwrapExports(YearPanel_1);

  var DecadePanel_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var _react2 = _interopRequireDefault(React$1__default);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _classnames2 = _interopRequireDefault(classnames);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var ROW = 4;
  var COL = 3;


  function goYear(direction) {
    var next = this.state.value.clone();
    next.add(direction, 'years');
    this.setState({
      value: next
    });
  }

  function chooseDecade(year, event) {
    var next = this.state.value.clone();
    next.year(year);
    next.month(this.state.value.month());
    this.props.onSelect(next);
    event.preventDefault();
  }

  var DecadePanel = function (_React$Component) {
    (0, _inherits3['default'])(DecadePanel, _React$Component);

    function DecadePanel(props) {
      (0, _classCallCheck3['default'])(this, DecadePanel);

      var _this = (0, _possibleConstructorReturn3['default'])(this, _React$Component.call(this, props));

      _this.state = {
        value: props.value || props.defaultValue
      };

      // bind methods
      _this.prefixCls = props.rootPrefixCls + '-decade-panel';
      _this.nextCentury = goYear.bind(_this, 100);
      _this.previousCentury = goYear.bind(_this, -100);
      return _this;
    }

    DecadePanel.prototype.render = function render() {
      var _this2 = this;

      var value = this.state.value;
      var locale = this.props.locale;
      var currentYear = value.year();
      var startYear = parseInt(currentYear / 100, 10) * 100;
      var preYear = startYear - 10;
      var endYear = startYear + 99;
      var decades = [];
      var index = 0;
      var prefixCls = this.prefixCls;

      for (var rowIndex = 0; rowIndex < ROW; rowIndex++) {
        decades[rowIndex] = [];
        for (var colIndex = 0; colIndex < COL; colIndex++) {
          var startDecade = preYear + index * 10;
          var endDecade = preYear + index * 10 + 9;
          decades[rowIndex][colIndex] = {
            startDecade: startDecade,
            endDecade: endDecade
          };
          index++;
        }
      }

      var decadesEls = decades.map(function (row, decadeIndex) {
        var tds = row.map(function (decadeData) {
          var _classNameMap;

          var dStartDecade = decadeData.startDecade;
          var dEndDecade = decadeData.endDecade;
          var isLast = dStartDecade < startYear;
          var isNext = dEndDecade > endYear;
          var classNameMap = (_classNameMap = {}, _classNameMap[prefixCls + '-cell'] = 1, _classNameMap[prefixCls + '-selected-cell'] = dStartDecade <= currentYear && currentYear <= dEndDecade, _classNameMap[prefixCls + '-last-century-cell'] = isLast, _classNameMap[prefixCls + '-next-century-cell'] = isNext, _classNameMap);
          var content = dStartDecade + '-' + dEndDecade;
          var clickHandler = void 0;
          if (isLast) {
            clickHandler = _this2.previousCentury;
          } else if (isNext) {
            clickHandler = _this2.nextCentury;
          } else {
            clickHandler = chooseDecade.bind(_this2, dStartDecade);
          }
          return _react2['default'].createElement(
            'td',
            {
              key: dStartDecade,
              onClick: clickHandler,
              role: 'gridcell',
              className: (0, _classnames2['default'])(classNameMap)
            },
            _react2['default'].createElement(
              'a',
              {
                className: prefixCls + '-decade'
              },
              content
            )
          );
        });
        return _react2['default'].createElement(
          'tr',
          { key: decadeIndex, role: 'row' },
          tds
        );
      });

      return _react2['default'].createElement(
        'div',
        { className: this.prefixCls },
        _react2['default'].createElement(
          'div',
          { className: prefixCls + '-header' },
          _react2['default'].createElement('a', {
            className: prefixCls + '-prev-century-btn',
            role: 'button',
            onClick: this.previousCentury,
            title: locale.previousCentury
          }),
          _react2['default'].createElement(
            'div',
            { className: prefixCls + '-century' },
            startYear,
            '-',
            endYear
          ),
          _react2['default'].createElement('a', {
            className: prefixCls + '-next-century-btn',
            role: 'button',
            onClick: this.nextCentury,
            title: locale.nextCentury
          })
        ),
        _react2['default'].createElement(
          'div',
          { className: prefixCls + '-body' },
          _react2['default'].createElement(
            'table',
            { className: prefixCls + '-table', cellSpacing: '0', role: 'grid' },
            _react2['default'].createElement(
              'tbody',
              { className: prefixCls + '-tbody' },
              decadesEls
            )
          )
        )
      );
    };

    return DecadePanel;
  }(_react2['default'].Component);

  exports['default'] = DecadePanel;


  DecadePanel.propTypes = {
    locale: _propTypes2['default'].object,
    value: _propTypes2['default'].object,
    defaultValue: _propTypes2['default'].object,
    rootPrefixCls: _propTypes2['default'].string
  };

  DecadePanel.defaultProps = {
    onSelect: function onSelect() {}
  };
  module.exports = exports['default'];
  });

  unwrapExports(DecadePanel_1);

  var CalendarHeader_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _react2 = _interopRequireDefault(React$1__default);



  var _createReactClass2 = _interopRequireDefault(createReactClass);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _mapSelf2 = _interopRequireDefault(mapSelf_1);



  var _MonthPanel2 = _interopRequireDefault(MonthPanel_1);



  var _YearPanel2 = _interopRequireDefault(YearPanel_1);



  var _DecadePanel2 = _interopRequireDefault(DecadePanel_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function goMonth(direction) {
    var next = this.props.value.clone();
    next.add(direction, 'months');
    this.props.onValueChange(next);
  }

  function goYear(direction) {
    var next = this.props.value.clone();
    next.add(direction, 'years');
    this.props.onValueChange(next);
  }

  function showIf(condition, el) {
    return condition ? el : null;
  }

  var CalendarHeader = (0, _createReactClass2['default'])({
    displayName: 'CalendarHeader',

    propTypes: {
      prefixCls: _propTypes2['default'].string,
      value: _propTypes2['default'].object,
      onValueChange: _propTypes2['default'].func,
      showTimePicker: _propTypes2['default'].bool,
      onPanelChange: _propTypes2['default'].func,
      locale: _propTypes2['default'].object,
      enablePrev: _propTypes2['default'].any,
      enableNext: _propTypes2['default'].any,
      disabledMonth: _propTypes2['default'].func
    },

    getDefaultProps: function getDefaultProps() {
      return {
        enableNext: 1,
        enablePrev: 1,
        onPanelChange: function onPanelChange() {},
        onValueChange: function onValueChange() {}
      };
    },
    getInitialState: function getInitialState() {
      this.nextMonth = goMonth.bind(this, 1);
      this.previousMonth = goMonth.bind(this, -1);
      this.nextYear = goYear.bind(this, 1);
      this.previousYear = goYear.bind(this, -1);
      return { yearPanelReferer: null };
    },
    onMonthSelect: function onMonthSelect(value) {
      this.props.onPanelChange(value, 'date');
      if (this.props.onMonthSelect) {
        this.props.onMonthSelect(value);
      } else {
        this.props.onValueChange(value);
      }
    },
    onYearSelect: function onYearSelect(value) {
      var referer = this.state.yearPanelReferer;
      this.setState({ yearPanelReferer: null });
      this.props.onPanelChange(value, referer);
      this.props.onValueChange(value);
    },
    onDecadeSelect: function onDecadeSelect(value) {
      this.props.onPanelChange(value, 'year');
      this.props.onValueChange(value);
    },
    monthYearElement: function monthYearElement(showTimePicker) {
      var _this = this;

      var props = this.props;
      var prefixCls = props.prefixCls;
      var locale = props.locale;
      var value = props.value;
      var localeData = value.localeData();
      var monthBeforeYear = locale.monthBeforeYear;
      var selectClassName = prefixCls + '-' + (monthBeforeYear ? 'my-select' : 'ym-select');
      var year = _react2['default'].createElement(
        'a',
        {
          className: prefixCls + '-year-select',
          role: 'button',
          onClick: showTimePicker ? null : function () {
            return _this.showYearPanel('date');
          },
          title: locale.yearSelect
        },
        value.format(locale.yearFormat)
      );
      var month = _react2['default'].createElement(
        'a',
        {
          className: prefixCls + '-month-select',
          role: 'button',
          onClick: showTimePicker ? null : this.showMonthPanel,
          title: locale.monthSelect
        },
        locale.monthFormat ? value.format(locale.monthFormat) : localeData.monthsShort(value)
      );
      var day = void 0;
      if (showTimePicker) {
        day = _react2['default'].createElement(
          'a',
          {
            className: prefixCls + '-day-select',
            role: 'button'
          },
          value.format(locale.dayFormat)
        );
      }
      var my = [];
      if (monthBeforeYear) {
        my = [month, day, year];
      } else {
        my = [year, month, day];
      }
      return _react2['default'].createElement(
        'span',
        { className: selectClassName },
        (0, _mapSelf2['default'])(my)
      );
    },
    showMonthPanel: function showMonthPanel() {
      // null means that users' interaction doesn't change value
      this.props.onPanelChange(null, 'month');
    },
    showYearPanel: function showYearPanel(referer) {
      this.setState({ yearPanelReferer: referer });
      this.props.onPanelChange(null, 'year');
    },
    showDecadePanel: function showDecadePanel() {
      this.props.onPanelChange(null, 'decade');
    },
    render: function render() {
      var _this2 = this;

      var props = this.props;
      var prefixCls = props.prefixCls,
          locale = props.locale,
          mode = props.mode,
          value = props.value,
          showTimePicker = props.showTimePicker,
          enableNext = props.enableNext,
          enablePrev = props.enablePrev,
          disabledMonth = props.disabledMonth;


      var panel = null;
      if (mode === 'month') {
        panel = _react2['default'].createElement(_MonthPanel2['default'], {
          locale: locale,
          defaultValue: value,
          rootPrefixCls: prefixCls,
          onSelect: this.onMonthSelect,
          onYearPanelShow: function onYearPanelShow() {
            return _this2.showYearPanel('month');
          },
          disabledDate: disabledMonth,
          cellRender: props.monthCellRender,
          contentRender: props.monthCellContentRender
        });
      }
      if (mode === 'year') {
        panel = _react2['default'].createElement(_YearPanel2['default'], {
          locale: locale,
          defaultValue: value,
          rootPrefixCls: prefixCls,
          onSelect: this.onYearSelect,
          onDecadePanelShow: this.showDecadePanel
        });
      }
      if (mode === 'decade') {
        panel = _react2['default'].createElement(_DecadePanel2['default'], {
          locale: locale,
          defaultValue: value,
          rootPrefixCls: prefixCls,
          onSelect: this.onDecadeSelect
        });
      }

      return _react2['default'].createElement(
        'div',
        { className: prefixCls + '-header' },
        _react2['default'].createElement(
          'div',
          { style: { position: 'relative' } },
          showIf(enablePrev && !showTimePicker, _react2['default'].createElement('a', {
            className: prefixCls + '-prev-year-btn',
            role: 'button',
            onClick: this.previousYear,
            title: locale.previousYear
          })),
          showIf(enablePrev && !showTimePicker, _react2['default'].createElement('a', {
            className: prefixCls + '-prev-month-btn',
            role: 'button',
            onClick: this.previousMonth,
            title: locale.previousMonth
          })),
          this.monthYearElement(showTimePicker),
          showIf(enableNext && !showTimePicker, _react2['default'].createElement('a', {
            className: prefixCls + '-next-month-btn',
            onClick: this.nextMonth,
            title: locale.nextMonth
          })),
          showIf(enableNext && !showTimePicker, _react2['default'].createElement('a', {
            className: prefixCls + '-next-year-btn',
            onClick: this.nextYear,
            title: locale.nextYear
          }))
        ),
        panel
      );
    }
  });

  exports['default'] = CalendarHeader;
  module.exports = exports['default'];
  });

  unwrapExports(CalendarHeader_1);

  var TodayButton_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports['default'] = TodayButton;



  var _react2 = _interopRequireDefault(React$1__default);



  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function TodayButton(_ref) {
    var prefixCls = _ref.prefixCls,
        locale = _ref.locale,
        value = _ref.value,
        timePicker = _ref.timePicker,
        disabled = _ref.disabled,
        disabledDate = _ref.disabledDate,
        onToday = _ref.onToday,
        text = _ref.text;

    var localeNow = (!text && timePicker ? locale.now : text) || locale.today;
    var disabledToday = disabledDate && !(0, util$2.isAllowedDate)((0, util$2.getTodayTime)(value), disabledDate);
    var isDisabled = disabledToday || disabled;
    var disabledTodayClass = isDisabled ? prefixCls + '-today-btn-disabled' : '';
    return _react2['default'].createElement(
      'a',
      {
        className: prefixCls + '-today-btn ' + disabledTodayClass,
        role: 'button',
        onClick: isDisabled ? null : onToday,
        title: (0, util$2.getTodayTimeStr)(value)
      },
      localeNow
    );
  }
  module.exports = exports['default'];
  });

  unwrapExports(TodayButton_1);

  var OkButton_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = OkButton;



  var _react2 = _interopRequireDefault(React$1__default);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function OkButton(_ref) {
    var prefixCls = _ref.prefixCls,
        locale = _ref.locale,
        okDisabled = _ref.okDisabled,
        onOk = _ref.onOk;

    var className = prefixCls + "-ok-btn";
    if (okDisabled) {
      className += " " + prefixCls + "-ok-btn-disabled";
    }
    return _react2["default"].createElement(
      "a",
      {
        className: className,
        role: "button",
        onClick: okDisabled ? null : onOk
      },
      locale.ok
    );
  }
  module.exports = exports['default'];
  });

  unwrapExports(OkButton_1);

  var TimePickerButton_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports['default'] = TimePickerButton;



  var _react2 = _interopRequireDefault(React$1__default);



  var _classnames3 = _interopRequireDefault(classnames);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function TimePickerButton(_ref) {
    var _classnames;

    var prefixCls = _ref.prefixCls,
        locale = _ref.locale,
        showTimePicker = _ref.showTimePicker,
        onOpenTimePicker = _ref.onOpenTimePicker,
        onCloseTimePicker = _ref.onCloseTimePicker,
        timePickerDisabled = _ref.timePickerDisabled;

    var className = (0, _classnames3['default'])((_classnames = {}, _classnames[prefixCls + '-time-picker-btn'] = true, _classnames[prefixCls + '-time-picker-btn-disabled'] = timePickerDisabled, _classnames));
    var onClick = null;
    if (!timePickerDisabled) {
      onClick = showTimePicker ? onCloseTimePicker : onOpenTimePicker;
    }
    return _react2['default'].createElement(
      'a',
      {
        className: className,
        role: 'button',
        onClick: onClick
      },
      showTimePicker ? locale.dateSelect : locale.timeSelect
    );
  }
  module.exports = exports['default'];
  });

  unwrapExports(TimePickerButton_1);

  var CalendarFooter_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _extends3 = _interopRequireDefault(_extends$1);



  var _react2 = _interopRequireDefault(React$1__default);



  var _reactDom2 = _interopRequireDefault(ReactDOM__default);



  var _createReactClass2 = _interopRequireDefault(createReactClass);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _mapSelf2 = _interopRequireDefault(mapSelf_1);



  var _classnames2 = _interopRequireDefault(classnames);



  var _TodayButton2 = _interopRequireDefault(TodayButton_1);



  var _OkButton2 = _interopRequireDefault(OkButton_1);



  var _TimePickerButton2 = _interopRequireDefault(TimePickerButton_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var CalendarFooter = (0, _createReactClass2['default'])({
    displayName: 'CalendarFooter',

    propTypes: {
      prefixCls: _propTypes2['default'].string,
      showDateInput: _propTypes2['default'].bool,
      disabledTime: _propTypes2['default'].any,
      timePicker: _propTypes2['default'].element,
      selectedValue: _propTypes2['default'].any,
      showOk: _propTypes2['default'].bool,
      onSelect: _propTypes2['default'].func,
      value: _propTypes2['default'].object,
      renderFooter: _propTypes2['default'].func,
      defaultValue: _propTypes2['default'].object
    },

    onSelect: function onSelect(value) {
      this.props.onSelect(value);
    },
    getRootDOMNode: function getRootDOMNode() {
      return _reactDom2['default'].findDOMNode(this);
    },
    render: function render() {
      var props = this.props;
      var value = props.value,
          prefixCls = props.prefixCls,
          showOk = props.showOk,
          timePicker = props.timePicker,
          renderFooter = props.renderFooter;

      var footerEl = null;
      var extraFooter = renderFooter();
      if (props.showToday || timePicker || extraFooter) {
        var _cx;

        var nowEl = void 0;
        if (props.showToday) {
          nowEl = _react2['default'].createElement(_TodayButton2['default'], (0, _extends3['default'])({}, props, { value: value }));
        }
        var okBtn = void 0;
        if (showOk === true || showOk !== false && !!props.timePicker) {
          okBtn = _react2['default'].createElement(_OkButton2['default'], props);
        }
        var timePickerBtn = void 0;
        if (!!props.timePicker) {
          timePickerBtn = _react2['default'].createElement(_TimePickerButton2['default'], props);
        }

        var footerBtn = void 0;
        if (nowEl || timePickerBtn || okBtn) {
          footerBtn = _react2['default'].createElement(
            'span',
            { className: prefixCls + '-footer-btn' },
            (0, _mapSelf2['default'])([nowEl, timePickerBtn, okBtn])
          );
        }
        var cls = (0, _classnames2['default'])((_cx = {}, _cx[prefixCls + '-footer'] = true, _cx[prefixCls + '-footer-show-ok'] = okBtn, _cx));
        footerEl = _react2['default'].createElement(
          'div',
          { className: cls },
          extraFooter,
          footerBtn
        );
      }
      return footerEl;
    }
  });

  exports['default'] = CalendarFooter;
  module.exports = exports['default'];
  });

  unwrapExports(CalendarFooter_1);

  var CalendarMixin_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _react2 = _interopRequireDefault(React$1__default);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _classnames2 = _interopRequireDefault(classnames);



  var _moment2 = _interopRequireDefault(moment);



  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function noop() {}

  function getNow() {
    return (0, _moment2['default'])();
  }

  function getNowByCurrentStateValue(value) {
    var ret = void 0;
    if (value) {
      ret = (0, util$2.getTodayTime)(value);
    } else {
      ret = getNow();
    }
    return ret;
  }

  var CalendarMixin = {
    propTypes: {
      value: _propTypes2['default'].object,
      defaultValue: _propTypes2['default'].object,
      onKeyDown: _propTypes2['default'].func
    },

    getDefaultProps: function getDefaultProps() {
      return {
        onKeyDown: noop
      };
    },
    getInitialState: function getInitialState() {
      var props = this.props;
      var value = props.value || props.defaultValue || getNow();
      return {
        value: value,
        selectedValue: props.selectedValue || props.defaultSelectedValue
      };
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
      var value = nextProps.value;
      var selectedValue = nextProps.selectedValue;

      if ('value' in nextProps) {
        value = value || nextProps.defaultValue || getNowByCurrentStateValue(this.state.value);
        this.setState({
          value: value
        });
      }
      if ('selectedValue' in nextProps) {
        this.setState({
          selectedValue: selectedValue
        });
      }
    },
    onSelect: function onSelect(value, cause) {
      if (value) {
        this.setValue(value);
      }
      this.setSelectedValue(value, cause);
    },
    renderRoot: function renderRoot(newProps) {
      var _className;

      var props = this.props;
      var prefixCls = props.prefixCls;

      var className = (_className = {}, _className[prefixCls] = 1, _className[prefixCls + '-hidden'] = !props.visible, _className[props.className] = !!props.className, _className[newProps.className] = !!newProps.className, _className);

      return _react2['default'].createElement(
        'div',
        {
          ref: this.saveRoot,
          className: '' + (0, _classnames2['default'])(className),
          style: this.props.style,
          tabIndex: '0',
          onKeyDown: this.onKeyDown
        },
        newProps.children
      );
    },
    setSelectedValue: function setSelectedValue(selectedValue, cause) {
      // if (this.isAllowedDate(selectedValue)) {
      if (!('selectedValue' in this.props)) {
        this.setState({
          selectedValue: selectedValue
        });
      }
      this.props.onSelect(selectedValue, cause);
      // }
    },
    setValue: function setValue(value) {
      var originalValue = this.state.value;
      if (!('value' in this.props)) {
        this.setState({
          value: value
        });
      }
      if (originalValue && value && !originalValue.isSame(value) || !originalValue && value || originalValue && !value) {
        this.props.onChange(value);
      }
    },
    isAllowedDate: function isAllowedDate(value) {
      var disabledDate = this.props.disabledDate;
      var disabledTime = this.props.disabledTime;
      return (0, util$2.isAllowedDate)(value, disabledDate, disabledTime);
    }
  };

  exports['default'] = CalendarMixin;
  module.exports = exports['default'];
  });

  unwrapExports(CalendarMixin_1);

  var CommonMixin$1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _en_US2 = _interopRequireDefault(en_US$2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function noop() {}

  exports['default'] = {
    propTypes: {
      className: _propTypes2['default'].string,
      locale: _propTypes2['default'].object,
      style: _propTypes2['default'].object,
      visible: _propTypes2['default'].bool,
      onSelect: _propTypes2['default'].func,
      prefixCls: _propTypes2['default'].string,
      onChange: _propTypes2['default'].func,
      onOk: _propTypes2['default'].func
    },

    getDefaultProps: function getDefaultProps() {
      return {
        locale: _en_US2['default'],
        style: {},
        visible: true,
        prefixCls: 'rc-calendar',
        className: '',
        onSelect: noop,
        onChange: noop,
        onClear: noop,
        renderFooter: function renderFooter() {
          return null;
        },
        renderSidebar: function renderSidebar() {
          return null;
        }
      };
    },
    shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
      return this.props.visible || nextProps.visible;
    },
    getFormat: function getFormat() {
      var format = this.props.format;
      var _props = this.props,
          locale = _props.locale,
          timePicker = _props.timePicker;

      if (!format) {
        if (timePicker) {
          format = locale.dateTimeFormat;
        } else {
          format = locale.dateFormat;
        }
      }
      return format;
    },
    focus: function focus() {
      if (this.rootInstance) {
        this.rootInstance.focus();
      }
    },
    saveRoot: function saveRoot(root) {
      this.rootInstance = root;
    }
  };
  module.exports = exports['default'];
  });

  unwrapExports(CommonMixin$1);

  var MonthCalendar_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _react2 = _interopRequireDefault(React$1__default);



  var _createReactClass2 = _interopRequireDefault(createReactClass);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _KeyCode2 = _interopRequireDefault(KeyCode_1);



  var _CalendarHeader2 = _interopRequireDefault(CalendarHeader_1);



  var _CalendarFooter2 = _interopRequireDefault(CalendarFooter_1);



  var _CalendarMixin2 = _interopRequireDefault(CalendarMixin_1);



  var _CommonMixin2 = _interopRequireDefault(CommonMixin$1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var MonthCalendar = (0, _createReactClass2['default'])({
    displayName: 'MonthCalendar',

    propTypes: {
      monthCellRender: _propTypes2['default'].func,
      dateCellRender: _propTypes2['default'].func
    },
    mixins: [_CommonMixin2['default'], _CalendarMixin2['default']],

    getInitialState: function getInitialState() {
      return { mode: 'month' };
    },
    onKeyDown: function onKeyDown(event) {
      var keyCode = event.keyCode;
      var ctrlKey = event.ctrlKey || event.metaKey;
      var stateValue = this.state.value;
      var disabledDate = this.props.disabledDate;

      var value = stateValue;
      switch (keyCode) {
        case _KeyCode2['default'].DOWN:
          value = stateValue.clone();
          value.add(3, 'months');
          break;
        case _KeyCode2['default'].UP:
          value = stateValue.clone();
          value.add(-3, 'months');
          break;
        case _KeyCode2['default'].LEFT:
          value = stateValue.clone();
          if (ctrlKey) {
            value.add(-1, 'years');
          } else {
            value.add(-1, 'months');
          }
          break;
        case _KeyCode2['default'].RIGHT:
          value = stateValue.clone();
          if (ctrlKey) {
            value.add(1, 'years');
          } else {
            value.add(1, 'months');
          }
          break;
        case _KeyCode2['default'].ENTER:
          if (!disabledDate || !disabledDate(stateValue)) {
            this.onSelect(stateValue);
          }
          event.preventDefault();
          return 1;
        default:
          return undefined;
      }
      if (value !== stateValue) {
        this.setValue(value);
        event.preventDefault();
        return 1;
      }
    },
    handlePanelChange: function handlePanelChange(_, mode) {
      if (mode !== 'date') {
        this.setState({ mode: mode });
      }
    },
    render: function render() {
      var props = this.props,
          state = this.state;
      var mode = state.mode,
          value = state.value;

      var children = _react2['default'].createElement(
        'div',
        { className: props.prefixCls + '-month-calendar-content' },
        _react2['default'].createElement(
          'div',
          { className: props.prefixCls + '-month-header-wrap' },
          _react2['default'].createElement(_CalendarHeader2['default'], {
            prefixCls: props.prefixCls,
            mode: mode,
            value: value,
            locale: props.locale,
            disabledMonth: props.disabledDate,
            monthCellRender: props.monthCellRender,
            monthCellContentRender: props.monthCellContentRender,
            onMonthSelect: this.onSelect,
            onValueChange: this.setValue,
            onPanelChange: this.handlePanelChange
          })
        ),
        _react2['default'].createElement(_CalendarFooter2['default'], {
          prefixCls: props.prefixCls,
          renderFooter: props.renderFooter
        })
      );
      return this.renderRoot({
        className: props.prefixCls + '-month-calendar',
        children: children
      });
    }
  });

  exports['default'] = MonthCalendar;
  module.exports = exports['default'];
  });

  unwrapExports(MonthCalendar_1);

  var createChainedFunction_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = createChainedFunction;
  /**
   * Safe chained function
   *
   * Will only create a new function if needed,
   * otherwise will pass back existing functions or null.
   *
   * @returns {function|null}
   */
  function createChainedFunction() {
    var args = [].slice.call(arguments, 0);
    if (args.length === 1) {
      return args[0];
    }

    return function chainedFunction() {
      for (var i = 0; i < args.length; i++) {
        if (args[i] && args[i].apply) {
          args[i].apply(this, arguments);
        }
      }
    };
  }
  module.exports = exports['default'];
  });

  unwrapExports(createChainedFunction_1);

  var placements_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  var autoAdjustOverflow = {
    adjustX: 1,
    adjustY: 1
  };

  var targetOffset = [0, 0];

  var placements = {
    bottomLeft: {
      points: ['tl', 'tl'],
      overflow: autoAdjustOverflow,
      offset: [0, -3],
      targetOffset: targetOffset
    },
    bottomRight: {
      points: ['tr', 'tr'],
      overflow: autoAdjustOverflow,
      offset: [0, -3],
      targetOffset: targetOffset
    },
    topRight: {
      points: ['br', 'br'],
      overflow: autoAdjustOverflow,
      offset: [0, 3],
      targetOffset: targetOffset
    },
    topLeft: {
      points: ['bl', 'bl'],
      overflow: autoAdjustOverflow,
      offset: [0, 3],
      targetOffset: targetOffset
    }
  };

  exports['default'] = placements;
  module.exports = exports['default'];
  });

  unwrapExports(placements_1);

  var _rcTrigger = getCjsExportFromNamespace(es$3);

  var Picker_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _react2 = _interopRequireDefault(React$1__default);



  var _reactDom2 = _interopRequireDefault(ReactDOM__default);



  var _createReactClass2 = _interopRequireDefault(createReactClass);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _createChainedFunction2 = _interopRequireDefault(createChainedFunction_1);



  var _KeyCode2 = _interopRequireDefault(KeyCode_1);



  var _placements2 = _interopRequireDefault(placements_1);



  var _rcTrigger2 = _interopRequireDefault(_rcTrigger);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function noop() {}

  function refFn(field, component) {
    this[field] = component;
  }

  var Picker = (0, _createReactClass2['default'])({
    displayName: 'Picker',

    propTypes: {
      animation: _propTypes2['default'].oneOfType([_propTypes2['default'].func, _propTypes2['default'].string]),
      disabled: _propTypes2['default'].bool,
      transitionName: _propTypes2['default'].string,
      onChange: _propTypes2['default'].func,
      onOpenChange: _propTypes2['default'].func,
      children: _propTypes2['default'].func,
      getCalendarContainer: _propTypes2['default'].func,
      calendar: _propTypes2['default'].element,
      style: _propTypes2['default'].object,
      open: _propTypes2['default'].bool,
      defaultOpen: _propTypes2['default'].bool,
      prefixCls: _propTypes2['default'].string,
      placement: _propTypes2['default'].any,
      value: _propTypes2['default'].oneOfType([_propTypes2['default'].object, _propTypes2['default'].array]),
      defaultValue: _propTypes2['default'].oneOfType([_propTypes2['default'].object, _propTypes2['default'].array]),
      align: _propTypes2['default'].object
    },

    getDefaultProps: function getDefaultProps() {
      return {
        prefixCls: 'rc-calendar-picker',
        style: {},
        align: {},
        placement: 'bottomLeft',
        defaultOpen: false,
        onChange: noop,
        onOpenChange: noop
      };
    },
    getInitialState: function getInitialState() {
      var props = this.props;
      var open = void 0;
      if ('open' in props) {
        open = props.open;
      } else {
        open = props.defaultOpen;
      }
      var value = props.value || props.defaultValue;
      this.saveCalendarRef = refFn.bind(this, 'calendarInstance');
      return {
        open: open,
        value: value
      };
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
      var value = nextProps.value,
          open = nextProps.open;

      if ('value' in nextProps) {
        this.setState({
          value: value
        });
      }
      if (open !== undefined) {
        this.setState({
          open: open
        });
      }
    },
    componentDidUpdate: function componentDidUpdate(_, prevState) {
      if (!prevState.open && this.state.open) {
        // setTimeout is for making sure saveCalendarRef happen before focusCalendar
        this.focusTimeout = setTimeout(this.focusCalendar, 0, this);
      }
    },
    componentWillUnmount: function componentWillUnmount() {
      clearTimeout(this.focusTimeout);
    },
    onCalendarKeyDown: function onCalendarKeyDown(event) {
      if (event.keyCode === _KeyCode2['default'].ESC) {
        event.stopPropagation();
        this.close(this.focus);
      }
    },
    onCalendarSelect: function onCalendarSelect(value) {
      var cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var props = this.props;
      if (!('value' in props)) {
        this.setState({
          value: value
        });
      }
      if (cause.source === 'keyboard' || !props.calendar.props.timePicker && cause.source !== 'dateInput' || cause.source === 'todayButton') {
        this.close(this.focus);
      }
      props.onChange(value);
    },
    onKeyDown: function onKeyDown(event) {
      if (event.keyCode === _KeyCode2['default'].DOWN && !this.state.open) {
        this.open();
        event.preventDefault();
      }
    },
    onCalendarOk: function onCalendarOk() {
      this.close(this.focus);
    },
    onCalendarClear: function onCalendarClear() {
      this.close(this.focus);
    },
    onVisibleChange: function onVisibleChange(open) {
      this.setOpen(open);
    },
    getCalendarElement: function getCalendarElement() {
      var props = this.props;
      var state = this.state;
      var calendarProps = props.calendar.props;
      var value = state.value;

      var defaultValue = value;
      var extraProps = {
        ref: this.saveCalendarRef,
        defaultValue: defaultValue || calendarProps.defaultValue,
        selectedValue: value,
        onKeyDown: this.onCalendarKeyDown,
        onOk: (0, _createChainedFunction2['default'])(calendarProps.onOk, this.onCalendarOk),
        onSelect: (0, _createChainedFunction2['default'])(calendarProps.onSelect, this.onCalendarSelect),
        onClear: (0, _createChainedFunction2['default'])(calendarProps.onClear, this.onCalendarClear)
      };

      return _react2['default'].cloneElement(props.calendar, extraProps);
    },
    setOpen: function setOpen(open, callback) {
      var onOpenChange = this.props.onOpenChange;

      if (this.state.open !== open) {
        if (!('open' in this.props)) {
          this.setState({
            open: open
          }, callback);
        }
        onOpenChange(open);
      }
    },
    open: function open(callback) {
      this.setOpen(true, callback);
    },
    close: function close(callback) {
      this.setOpen(false, callback);
    },
    focus: function focus() {
      if (!this.state.open) {
        _reactDom2['default'].findDOMNode(this).focus();
      }
    },
    focusCalendar: function focusCalendar() {
      if (this.state.open && !!this.calendarInstance) {
        this.calendarInstance.focus();
      }
    },
    render: function render() {
      var props = this.props;
      var prefixCls = props.prefixCls,
          placement = props.placement,
          style = props.style,
          getCalendarContainer = props.getCalendarContainer,
          align = props.align,
          animation = props.animation,
          disabled = props.disabled,
          dropdownClassName = props.dropdownClassName,
          transitionName = props.transitionName,
          children = props.children;

      var state = this.state;
      return _react2['default'].createElement(
        _rcTrigger2['default'],
        {
          popup: this.getCalendarElement(),
          popupAlign: align,
          builtinPlacements: _placements2['default'],
          popupPlacement: placement,
          action: disabled && !state.open ? [] : ['click'],
          destroyPopupOnHide: true,
          getPopupContainer: getCalendarContainer,
          popupStyle: style,
          popupAnimation: animation,
          popupTransitionName: transitionName,
          popupVisible: state.open,
          onPopupVisibleChange: this.onVisibleChange,
          prefixCls: prefixCls,
          popupClassName: dropdownClassName
        },
        _react2['default'].cloneElement(children(state, props), { onKeyDown: this.onKeyDown })
      );
    }
  });

  exports['default'] = Picker;
  module.exports = exports['default'];
  });

  unwrapExports(Picker_1);

  var interopDefault_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports["default"] = interopDefault;
  // https://github.com/moment/moment/issues/3650
  function interopDefault(m) {
      return m["default"] || m;
  }
  module.exports = exports["default"];
  });

  unwrapExports(interopDefault_1);

  var createPicker_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);

  exports['default'] = createPicker;



  var React = _interopRequireWildcard(React$1__default);



  var moment$$1 = _interopRequireWildcard(moment);



  var _MonthCalendar2 = _interopRequireDefault(MonthCalendar_1);



  var _Picker2 = _interopRequireDefault(Picker_1);



  var _classnames2 = _interopRequireDefault(classnames);



  var _omit2 = _interopRequireDefault(_omit);



  var _icon2 = _interopRequireDefault(icon);



  var _warning2 = _interopRequireDefault(warning$4);



  var _interopDefault2 = _interopRequireDefault(interopDefault_1);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function createPicker(TheCalendar) {
      return _a = function (_React$Component) {
          (0, _inherits3['default'])(CalenderWrapper, _React$Component);

          function CalenderWrapper(props) {
              (0, _classCallCheck3['default'])(this, CalenderWrapper);

              var _this = (0, _possibleConstructorReturn3['default'])(this, (CalenderWrapper.__proto__ || Object.getPrototypeOf(CalenderWrapper)).call(this, props));

              _this.renderFooter = function () {
                  var _this$props = _this.props,
                      prefixCls = _this$props.prefixCls,
                      renderExtraFooter = _this$props.renderExtraFooter;

                  return renderExtraFooter ? React.createElement(
                      'div',
                      { className: prefixCls + '-footer-extra' },
                      renderExtraFooter.apply(undefined, arguments)
                  ) : null;
              };
              _this.clearSelection = function (e) {
                  e.preventDefault();
                  e.stopPropagation();
                  _this.handleChange(null);
              };
              _this.handleChange = function (value) {
                  var props = _this.props;
                  if (!('value' in props)) {
                      _this.setState({
                          value: value,
                          showDate: value
                      });
                  }
                  props.onChange(value, value && value.format(props.format) || '');
              };
              _this.handleCalendarChange = function (value) {
                  _this.setState({ showDate: value });
              };
              _this.saveInput = function (node) {
                  _this.input = node;
              };
              var value = props.value || props.defaultValue;
              if (value && !(0, _interopDefault2['default'])(moment$$1).isMoment(value)) {
                  throw new Error('The value/defaultValue of DatePicker or MonthPicker must be ' + 'a moment object after `antd@2.0`, see: https://u.ant.design/date-picker-value');
              }
              _this.state = {
                  value: value,
                  showDate: value
              };
              return _this;
          }

          (0, _createClass3['default'])(CalenderWrapper, [{
              key: 'componentWillReceiveProps',
              value: function componentWillReceiveProps(nextProps) {
                  if ('value' in nextProps) {
                      this.setState({
                          value: nextProps.value,
                          showDate: nextProps.value
                      });
                  }
              }
          }, {
              key: 'focus',
              value: function focus() {
                  this.input.focus();
              }
          }, {
              key: 'blur',
              value: function blur() {
                  this.input.blur();
              }
          }, {
              key: 'render',
              value: function render() {
                  var _classNames,
                      _this2 = this;

                  var _state = this.state,
                      value = _state.value,
                      showDate = _state.showDate;

                  var props = (0, _omit2['default'])(this.props, ['onChange']);
                  var prefixCls = props.prefixCls,
                      locale = props.locale,
                      localeCode = props.localeCode;

                  var placeholder = 'placeholder' in props ? props.placeholder : locale.lang.placeholder;
                  var disabledTime = props.showTime ? props.disabledTime : null;
                  var calendarClassName = (0, _classnames2['default'])((_classNames = {}, (0, _defineProperty3['default'])(_classNames, prefixCls + '-time', props.showTime), (0, _defineProperty3['default'])(_classNames, prefixCls + '-month', _MonthCalendar2['default'] === TheCalendar), _classNames));
                  if (value && localeCode) {
                      value.locale(localeCode);
                  }
                  var pickerProps = {};
                  var calendarProps = {};
                  if (props.showTime) {
                      calendarProps = {
                          // fix https://github.com/ant-design/ant-design/issues/1902
                          onSelect: this.handleChange
                      };
                  } else {
                      pickerProps = {
                          onChange: this.handleChange
                      };
                  }
                  if ('mode' in props) {
                      calendarProps.mode = props.mode;
                  }
                  (0, _warning2['default'])(!('onOK' in props), 'It should be `DatePicker[onOk]` or `MonthPicker[onOk]`, instead of `onOK`!');
                  var calendar = React.createElement(TheCalendar, (0, _extends3['default'])({}, calendarProps, { disabledDate: props.disabledDate, disabledTime: disabledTime, locale: locale.lang, timePicker: props.timePicker, defaultValue: props.defaultPickerValue || (0, _interopDefault2['default'])(moment$$1)(), dateInputPlaceholder: placeholder, prefixCls: prefixCls, className: calendarClassName, onOk: props.onOk, dateRender: props.dateRender, format: props.format, showToday: props.showToday, monthCellContentRender: props.monthCellContentRender, renderFooter: this.renderFooter, onPanelChange: props.onPanelChange, onChange: this.handleCalendarChange, value: showDate }));
                  var clearIcon = !props.disabled && props.allowClear && value ? React.createElement(_icon2['default'], { type: 'cross-circle', className: prefixCls + '-picker-clear', onClick: this.clearSelection }) : null;
                  var input = function input(_ref) {
                      var inputValue = _ref.value;
                      return React.createElement(
                          'div',
                          null,
                          React.createElement('input', { ref: _this2.saveInput, disabled: props.disabled, readOnly: true, value: inputValue && inputValue.format(props.format) || '', placeholder: placeholder, className: props.pickerInputClass }),
                          clearIcon,
                          React.createElement('span', { className: prefixCls + '-picker-icon' })
                      );
                  };
                  return React.createElement(
                      'span',
                      { id: props.id, className: (0, _classnames2['default'])(props.className, props.pickerClass), style: props.style, onFocus: props.onFocus, onBlur: props.onBlur },
                      React.createElement(
                          _Picker2['default'],
                          (0, _extends3['default'])({}, props, pickerProps, { calendar: calendar, value: value, prefixCls: prefixCls + '-picker-container', style: props.popupStyle }),
                          input
                      )
                  );
              }
          }]);
          return CalenderWrapper;
      }(React.Component), _a.defaultProps = {
          prefixCls: 'ant-calendar',
          allowClear: true,
          showToday: true
      }, _a;
      var _a;
  }
  module.exports = exports['default'];
  });

  unwrapExports(createPicker_1);

  var Header_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var _react2 = _interopRequireDefault(React$1__default);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _moment2 = _interopRequireDefault(moment);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var Header = function (_Component) {
    (0, _inherits3['default'])(Header, _Component);

    function Header(props) {
      (0, _classCallCheck3['default'])(this, Header);

      var _this = (0, _possibleConstructorReturn3['default'])(this, (Header.__proto__ || Object.getPrototypeOf(Header)).call(this, props));

      _initialiseProps.call(_this);

      var value = props.value,
          format = props.format;

      _this.state = {
        str: value && value.format(format) || '',
        invalid: false
      };
      return _this;
    }

    (0, _createClass3['default'])(Header, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        var _this2 = this;

        if (this.props.focusOnOpen) {
          // Wait one frame for the panel to be positioned before focusing
          var requestAnimationFrame = window.requestAnimationFrame || window.setTimeout;
          requestAnimationFrame(function () {
            _this2.refs.input.focus();
            _this2.refs.input.select();
          });
        }
      }
    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        var value = nextProps.value,
            format = nextProps.format;

        this.setState({
          str: value && value.format(format) || '',
          invalid: false
        });
      }
    }, {
      key: 'getClearButton',
      value: function getClearButton() {
        var _props = this.props,
            prefixCls = _props.prefixCls,
            allowEmpty = _props.allowEmpty;

        if (!allowEmpty) {
          return null;
        }
        return _react2['default'].createElement('a', {
          className: prefixCls + '-clear-btn',
          role: 'button',
          title: this.props.clearText,
          onMouseDown: this.onClear
        });
      }
    }, {
      key: 'getProtoValue',
      value: function getProtoValue() {
        return this.props.value || this.props.defaultOpenValue;
      }
    }, {
      key: 'getInput',
      value: function getInput() {
        var _props2 = this.props,
            prefixCls = _props2.prefixCls,
            placeholder = _props2.placeholder,
            inputReadOnly = _props2.inputReadOnly;
        var _state = this.state,
            invalid = _state.invalid,
            str = _state.str;

        var invalidClass = invalid ? prefixCls + '-input-invalid' : '';
        return _react2['default'].createElement('input', {
          className: prefixCls + '-input  ' + invalidClass,
          ref: 'input',
          onKeyDown: this.onKeyDown,
          value: str,
          placeholder: placeholder,
          onChange: this.onInputChange,
          readOnly: !!inputReadOnly
        });
      }
    }, {
      key: 'render',
      value: function render() {
        var prefixCls = this.props.prefixCls;

        return _react2['default'].createElement(
          'div',
          { className: prefixCls + '-input-wrap' },
          this.getInput(),
          this.getClearButton()
        );
      }
    }]);
    return Header;
  }(React$1__default.Component);

  Header.propTypes = {
    format: _propTypes2['default'].string,
    prefixCls: _propTypes2['default'].string,
    disabledDate: _propTypes2['default'].func,
    placeholder: _propTypes2['default'].string,
    clearText: _propTypes2['default'].string,
    value: _propTypes2['default'].object,
    inputReadOnly: _propTypes2['default'].bool,
    hourOptions: _propTypes2['default'].array,
    minuteOptions: _propTypes2['default'].array,
    secondOptions: _propTypes2['default'].array,
    disabledHours: _propTypes2['default'].func,
    disabledMinutes: _propTypes2['default'].func,
    disabledSeconds: _propTypes2['default'].func,
    onChange: _propTypes2['default'].func,
    onClear: _propTypes2['default'].func,
    onEsc: _propTypes2['default'].func,
    allowEmpty: _propTypes2['default'].bool,
    defaultOpenValue: _propTypes2['default'].object,
    currentSelectPanel: _propTypes2['default'].string,
    focusOnOpen: _propTypes2['default'].bool,
    onKeyDown: _propTypes2['default'].func
  };
  Header.defaultProps = {
    inputReadOnly: false
  };

  var _initialiseProps = function _initialiseProps() {
    var _this3 = this;

    this.onInputChange = function (event) {
      var str = event.target.value;
      _this3.setState({
        str: str
      });
      var _props3 = _this3.props,
          format = _props3.format,
          hourOptions = _props3.hourOptions,
          minuteOptions = _props3.minuteOptions,
          secondOptions = _props3.secondOptions,
          disabledHours = _props3.disabledHours,
          disabledMinutes = _props3.disabledMinutes,
          disabledSeconds = _props3.disabledSeconds,
          onChange = _props3.onChange,
          allowEmpty = _props3.allowEmpty;


      if (str) {
        var originalValue = _this3.props.value;
        var value = _this3.getProtoValue().clone();
        var parsed = (0, _moment2['default'])(str, format, true);
        if (!parsed.isValid()) {
          _this3.setState({
            invalid: true
          });
          return;
        }
        value.hour(parsed.hour()).minute(parsed.minute()).second(parsed.second());

        // if time value not allowed, response warning.
        if (hourOptions.indexOf(value.hour()) < 0 || minuteOptions.indexOf(value.minute()) < 0 || secondOptions.indexOf(value.second()) < 0) {
          _this3.setState({
            invalid: true
          });
          return;
        }

        // if time value is disabled, response warning.
        var disabledHourOptions = disabledHours();
        var disabledMinuteOptions = disabledMinutes(value.hour());
        var disabledSecondOptions = disabledSeconds(value.hour(), value.minute());
        if (disabledHourOptions && disabledHourOptions.indexOf(value.hour()) >= 0 || disabledMinuteOptions && disabledMinuteOptions.indexOf(value.minute()) >= 0 || disabledSecondOptions && disabledSecondOptions.indexOf(value.second()) >= 0) {
          _this3.setState({
            invalid: true
          });
          return;
        }

        if (originalValue) {
          if (originalValue.hour() !== value.hour() || originalValue.minute() !== value.minute() || originalValue.second() !== value.second()) {
            // keep other fields for rc-calendar
            var changedValue = originalValue.clone();
            changedValue.hour(value.hour());
            changedValue.minute(value.minute());
            changedValue.second(value.second());
            onChange(changedValue);
          }
        } else if (originalValue !== value) {
          onChange(value);
        }
      } else if (allowEmpty) {
        onChange(null);
      } else {
        _this3.setState({
          invalid: true
        });
        return;
      }

      _this3.setState({
        invalid: false
      });
    };

    this.onKeyDown = function (e) {
      var _props4 = _this3.props,
          onEsc = _props4.onEsc,
          onKeyDown = _props4.onKeyDown;

      if (e.keyCode === 27) {
        onEsc();
      }

      onKeyDown(e);
    };

    this.onClear = function () {
      _this3.setState({ str: '' });
      _this3.props.onClear();
    };
  };

  exports['default'] = Header;
  module.exports = exports['default'];
  });

  unwrapExports(Header_1);

  var Select_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var _react2 = _interopRequireDefault(React$1__default);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _reactDom2 = _interopRequireDefault(ReactDOM__default);



  var _classnames4 = _interopRequireDefault(classnames);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var scrollTo = function scrollTo(element, to, duration) {
    var requestAnimationFrame = window.requestAnimationFrame || function requestAnimationFrameTimeout() {
      return setTimeout(arguments[0], 10);
    };
    // jump to target if duration zero
    if (duration <= 0) {
      element.scrollTop = to;
      return;
    }
    var difference = to - element.scrollTop;
    var perTick = difference / duration * 10;

    requestAnimationFrame(function () {
      element.scrollTop = element.scrollTop + perTick;
      if (element.scrollTop === to) return;
      scrollTo(element, to, duration - 10);
    });
  };

  var Select = function (_Component) {
    (0, _inherits3['default'])(Select, _Component);

    function Select() {
      var _ref;

      var _temp, _this, _ret;

      (0, _classCallCheck3['default'])(this, Select);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = (0, _possibleConstructorReturn3['default'])(this, (_ref = Select.__proto__ || Object.getPrototypeOf(Select)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        active: false
      }, _this.onSelect = function (value) {
        var _this$props = _this.props,
            onSelect = _this$props.onSelect,
            type = _this$props.type;

        onSelect(type, value);
      }, _this.handleMouseEnter = function (e) {
        _this.setState({ active: true });
        _this.props.onMouseEnter(e);
      }, _this.handleMouseLeave = function () {
        _this.setState({ active: false });
      }, _this.saveList = function (node) {
        _this.list = node;
      }, _temp), (0, _possibleConstructorReturn3['default'])(_this, _ret);
    }

    (0, _createClass3['default'])(Select, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        // jump to selected option
        this.scrollToSelected(0);
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate(prevProps) {
        // smooth scroll to selected option
        if (prevProps.selectedIndex !== this.props.selectedIndex) {
          this.scrollToSelected(120);
        }
      }
    }, {
      key: 'getOptions',
      value: function getOptions() {
        var _this2 = this;

        var _props = this.props,
            options = _props.options,
            selectedIndex = _props.selectedIndex,
            prefixCls = _props.prefixCls;

        return options.map(function (item, index) {
          var _classnames;

          var cls = (0, _classnames4['default'])((_classnames = {}, (0, _defineProperty3['default'])(_classnames, prefixCls + '-select-option-selected', selectedIndex === index), (0, _defineProperty3['default'])(_classnames, prefixCls + '-select-option-disabled', item.disabled), _classnames));
          var onclick = null;
          if (!item.disabled) {
            onclick = _this2.onSelect.bind(_this2, item.value);
          }
          return _react2['default'].createElement(
            'li',
            {
              className: cls,
              key: index,
              onClick: onclick,
              disabled: item.disabled
            },
            item.value
          );
        });
      }
    }, {
      key: 'scrollToSelected',
      value: function scrollToSelected(duration) {
        // move to selected item
        var select = _reactDom2['default'].findDOMNode(this);
        var list = _reactDom2['default'].findDOMNode(this.list);
        if (!list) {
          return;
        }
        var index = this.props.selectedIndex;
        if (index < 0) {
          index = 0;
        }
        var topOption = list.children[index];
        var to = topOption.offsetTop;
        scrollTo(select, to, duration);
      }
    }, {
      key: 'render',
      value: function render() {
        var _classnames2;

        if (this.props.options.length === 0) {
          return null;
        }

        var prefixCls = this.props.prefixCls;

        var cls = (0, _classnames4['default'])((_classnames2 = {}, (0, _defineProperty3['default'])(_classnames2, prefixCls + '-select', 1), (0, _defineProperty3['default'])(_classnames2, prefixCls + '-select-active', this.state.active), _classnames2));

        return _react2['default'].createElement(
          'div',
          {
            className: cls,
            onMouseEnter: this.handleMouseEnter,
            onMouseLeave: this.handleMouseLeave
          },
          _react2['default'].createElement(
            'ul',
            { ref: this.saveList },
            this.getOptions()
          )
        );
      }
    }]);
    return Select;
  }(React$1__default.Component);

  Select.propTypes = {
    prefixCls: _propTypes2['default'].string,
    options: _propTypes2['default'].array,
    selectedIndex: _propTypes2['default'].number,
    type: _propTypes2['default'].string,
    onSelect: _propTypes2['default'].func,
    onMouseEnter: _propTypes2['default'].func
  };
  exports['default'] = Select;
  module.exports = exports['default'];
  });

  unwrapExports(Select_1);

  var Combobox_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var _react2 = _interopRequireDefault(React$1__default);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _Select2 = _interopRequireDefault(Select_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var formatOption = function formatOption(option, disabledOptions) {
    var value = '' + option;
    if (option < 10) {
      value = '0' + option;
    }

    var disabled = false;
    if (disabledOptions && disabledOptions.indexOf(option) >= 0) {
      disabled = true;
    }

    return {
      value: value,
      disabled: disabled
    };
  };

  var Combobox = function (_Component) {
    (0, _inherits3['default'])(Combobox, _Component);

    function Combobox() {
      var _ref;

      var _temp, _this, _ret;

      (0, _classCallCheck3['default'])(this, Combobox);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = (0, _possibleConstructorReturn3['default'])(this, (_ref = Combobox.__proto__ || Object.getPrototypeOf(Combobox)).call.apply(_ref, [this].concat(args))), _this), _this.onItemChange = function (type, itemValue) {
        var _this$props = _this.props,
            onChange = _this$props.onChange,
            defaultOpenValue = _this$props.defaultOpenValue,
            use12Hours = _this$props.use12Hours;

        var value = (_this.props.value || defaultOpenValue).clone();

        if (type === 'hour') {
          if (use12Hours) {
            if (_this.props.isAM) {
              value.hour(+itemValue % 12);
            } else {
              value.hour(+itemValue % 12 + 12);
            }
          } else {
            value.hour(+itemValue);
          }
        } else if (type === 'minute') {
          value.minute(+itemValue);
        } else if (type === 'ampm') {
          var ampm = itemValue.toUpperCase();
          if (use12Hours) {
            if (ampm === 'PM' && value.hour() < 12) {
              value.hour(value.hour() % 12 + 12);
            }

            if (ampm === 'AM') {
              if (value.hour() >= 12) {
                value.hour(value.hour() - 12);
              }
            }
          }
        } else {
          value.second(+itemValue);
        }
        onChange(value);
      }, _this.onEnterSelectPanel = function (range) {
        _this.props.onCurrentSelectPanelChange(range);
      }, _temp), (0, _possibleConstructorReturn3['default'])(_this, _ret);
    }

    (0, _createClass3['default'])(Combobox, [{
      key: 'getHourSelect',
      value: function getHourSelect(hour) {
        var _props = this.props,
            prefixCls = _props.prefixCls,
            hourOptions = _props.hourOptions,
            disabledHours = _props.disabledHours,
            showHour = _props.showHour,
            use12Hours = _props.use12Hours;

        if (!showHour) {
          return null;
        }
        var disabledOptions = disabledHours();
        var hourOptionsAdj = void 0;
        var hourAdj = void 0;
        if (use12Hours) {
          hourOptionsAdj = [12].concat(hourOptions.filter(function (h) {
            return h < 12 && h > 0;
          }));
          hourAdj = hour % 12 || 12;
        } else {
          hourOptionsAdj = hourOptions;
          hourAdj = hour;
        }

        return _react2['default'].createElement(_Select2['default'], {
          prefixCls: prefixCls,
          options: hourOptionsAdj.map(function (option) {
            return formatOption(option, disabledOptions);
          }),
          selectedIndex: hourOptionsAdj.indexOf(hourAdj),
          type: 'hour',
          onSelect: this.onItemChange,
          onMouseEnter: this.onEnterSelectPanel.bind(this, 'hour')
        });
      }
    }, {
      key: 'getMinuteSelect',
      value: function getMinuteSelect(minute) {
        var _props2 = this.props,
            prefixCls = _props2.prefixCls,
            minuteOptions = _props2.minuteOptions,
            disabledMinutes = _props2.disabledMinutes,
            defaultOpenValue = _props2.defaultOpenValue,
            showMinute = _props2.showMinute;

        if (!showMinute) {
          return null;
        }
        var value = this.props.value || defaultOpenValue;
        var disabledOptions = disabledMinutes(value.hour());

        return _react2['default'].createElement(_Select2['default'], {
          prefixCls: prefixCls,
          options: minuteOptions.map(function (option) {
            return formatOption(option, disabledOptions);
          }),
          selectedIndex: minuteOptions.indexOf(minute),
          type: 'minute',
          onSelect: this.onItemChange,
          onMouseEnter: this.onEnterSelectPanel.bind(this, 'minute')
        });
      }
    }, {
      key: 'getSecondSelect',
      value: function getSecondSelect(second) {
        var _props3 = this.props,
            prefixCls = _props3.prefixCls,
            secondOptions = _props3.secondOptions,
            disabledSeconds = _props3.disabledSeconds,
            showSecond = _props3.showSecond,
            defaultOpenValue = _props3.defaultOpenValue;

        if (!showSecond) {
          return null;
        }
        var value = this.props.value || defaultOpenValue;
        var disabledOptions = disabledSeconds(value.hour(), value.minute());

        return _react2['default'].createElement(_Select2['default'], {
          prefixCls: prefixCls,
          options: secondOptions.map(function (option) {
            return formatOption(option, disabledOptions);
          }),
          selectedIndex: secondOptions.indexOf(second),
          type: 'second',
          onSelect: this.onItemChange,
          onMouseEnter: this.onEnterSelectPanel.bind(this, 'second')
        });
      }
    }, {
      key: 'getAMPMSelect',
      value: function getAMPMSelect() {
        var _props4 = this.props,
            prefixCls = _props4.prefixCls,
            use12Hours = _props4.use12Hours,
            format = _props4.format;

        if (!use12Hours) {
          return null;
        }

        var AMPMOptions = ['am', 'pm'] // If format has A char, then we should uppercase AM/PM
        .map(function (c) {
          return format.match(/\sA/) ? c.toUpperCase() : c;
        }).map(function (c) {
          return { value: c };
        });

        var selected = this.props.isAM ? 0 : 1;

        return _react2['default'].createElement(_Select2['default'], {
          prefixCls: prefixCls,
          options: AMPMOptions,
          selectedIndex: selected,
          type: 'ampm',
          onSelect: this.onItemChange,
          onMouseEnter: this.onEnterSelectPanel.bind(this, 'ampm')
        });
      }
    }, {
      key: 'render',
      value: function render() {
        var _props5 = this.props,
            prefixCls = _props5.prefixCls,
            defaultOpenValue = _props5.defaultOpenValue;

        var value = this.props.value || defaultOpenValue;
        return _react2['default'].createElement(
          'div',
          { className: prefixCls + '-combobox' },
          this.getHourSelect(value.hour()),
          this.getMinuteSelect(value.minute()),
          this.getSecondSelect(value.second()),
          this.getAMPMSelect(value.hour())
        );
      }
    }]);
    return Combobox;
  }(React$1__default.Component);

  Combobox.propTypes = {
    format: _propTypes2['default'].string,
    defaultOpenValue: _propTypes2['default'].object,
    prefixCls: _propTypes2['default'].string,
    value: _propTypes2['default'].object,
    onChange: _propTypes2['default'].func,
    showHour: _propTypes2['default'].bool,
    showMinute: _propTypes2['default'].bool,
    showSecond: _propTypes2['default'].bool,
    hourOptions: _propTypes2['default'].array,
    minuteOptions: _propTypes2['default'].array,
    secondOptions: _propTypes2['default'].array,
    disabledHours: _propTypes2['default'].func,
    disabledMinutes: _propTypes2['default'].func,
    disabledSeconds: _propTypes2['default'].func,
    onCurrentSelectPanelChange: _propTypes2['default'].func,
    use12Hours: _propTypes2['default'].bool,
    isAM: _propTypes2['default'].bool
  };
  exports['default'] = Combobox;
  module.exports = exports['default'];
  });

  unwrapExports(Combobox_1);

  var Panel_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var _react2 = _interopRequireDefault(React$1__default);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _Header2 = _interopRequireDefault(Header_1);



  var _Combobox2 = _interopRequireDefault(Combobox_1);



  var _moment2 = _interopRequireDefault(moment);



  var _classnames2 = _interopRequireDefault(classnames);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function noop() {}

  function generateOptions(length, disabledOptions, hideDisabledOptions) {
    var step = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

    var arr = [];
    for (var value = 0; value < length; value += step) {
      if (!disabledOptions || disabledOptions.indexOf(value) < 0 || !hideDisabledOptions) {
        arr.push(value);
      }
    }
    return arr;
  }

  var Panel = function (_Component) {
    (0, _inherits3['default'])(Panel, _Component);

    function Panel(props) {
      (0, _classCallCheck3['default'])(this, Panel);

      var _this = (0, _possibleConstructorReturn3['default'])(this, (Panel.__proto__ || Object.getPrototypeOf(Panel)).call(this, props));

      _this.onChange = function (newValue) {
        _this.setState({ value: newValue });
        _this.props.onChange(newValue);
      };

      _this.onCurrentSelectPanelChange = function (currentSelectPanel) {
        _this.setState({ currentSelectPanel: currentSelectPanel });
      };

      _this.disabledHours = function () {
        var _this$props = _this.props,
            use12Hours = _this$props.use12Hours,
            disabledHours = _this$props.disabledHours;

        var disabledOptions = disabledHours();
        if (use12Hours && Array.isArray(disabledOptions)) {
          if (_this.isAM()) {
            disabledOptions = disabledOptions.filter(function (h) {
              return h < 12;
            }).map(function (h) {
              return h === 0 ? 12 : h;
            });
          } else {
            disabledOptions = disabledOptions.map(function (h) {
              return h === 12 ? 12 : h - 12;
            });
          }
        }
        return disabledOptions;
      };

      _this.state = {
        value: props.value,
        selectionRange: []
      };
      return _this;
    }

    (0, _createClass3['default'])(Panel, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        var value = nextProps.value;
        if (value) {
          this.setState({
            value: value
          });
        }
      }
    }, {
      key: 'close',


      // https://github.com/ant-design/ant-design/issues/5829
      value: function close() {
        this.props.onEsc();
      }
    }, {
      key: 'isAM',
      value: function isAM() {
        var value = this.state.value || this.props.defaultOpenValue;
        return value.hour() >= 0 && value.hour() < 12;
      }
    }, {
      key: 'render',
      value: function render() {
        var _classNames;

        var _props = this.props,
            prefixCls = _props.prefixCls,
            className = _props.className,
            placeholder = _props.placeholder,
            disabledMinutes = _props.disabledMinutes,
            disabledSeconds = _props.disabledSeconds,
            hideDisabledOptions = _props.hideDisabledOptions,
            allowEmpty = _props.allowEmpty,
            showHour = _props.showHour,
            showMinute = _props.showMinute,
            showSecond = _props.showSecond,
            format = _props.format,
            defaultOpenValue = _props.defaultOpenValue,
            clearText = _props.clearText,
            onEsc = _props.onEsc,
            addon = _props.addon,
            use12Hours = _props.use12Hours,
            onClear = _props.onClear,
            focusOnOpen = _props.focusOnOpen,
            onKeyDown = _props.onKeyDown,
            hourStep = _props.hourStep,
            minuteStep = _props.minuteStep,
            secondStep = _props.secondStep,
            inputReadOnly = _props.inputReadOnly;
        var _state = this.state,
            value = _state.value,
            currentSelectPanel = _state.currentSelectPanel;

        var disabledHourOptions = this.disabledHours();
        var disabledMinuteOptions = disabledMinutes(value ? value.hour() : null);
        var disabledSecondOptions = disabledSeconds(value ? value.hour() : null, value ? value.minute() : null);
        var hourOptions = generateOptions(24, disabledHourOptions, hideDisabledOptions, hourStep);
        var minuteOptions = generateOptions(60, disabledMinuteOptions, hideDisabledOptions, minuteStep);
        var secondOptions = generateOptions(60, disabledSecondOptions, hideDisabledOptions, secondStep);

        return _react2['default'].createElement(
          'div',
          { className: (0, _classnames2['default'])((_classNames = {}, (0, _defineProperty3['default'])(_classNames, prefixCls + '-inner', true), (0, _defineProperty3['default'])(_classNames, className, !!className), _classNames)) },
          _react2['default'].createElement(_Header2['default'], {
            clearText: clearText,
            prefixCls: prefixCls,
            defaultOpenValue: defaultOpenValue,
            value: value,
            currentSelectPanel: currentSelectPanel,
            onEsc: onEsc,
            format: format,
            placeholder: placeholder,
            hourOptions: hourOptions,
            minuteOptions: minuteOptions,
            secondOptions: secondOptions,
            disabledHours: this.disabledHours,
            disabledMinutes: disabledMinutes,
            disabledSeconds: disabledSeconds,
            onChange: this.onChange,
            onClear: onClear,
            allowEmpty: allowEmpty,
            focusOnOpen: focusOnOpen,
            onKeyDown: onKeyDown,
            inputReadOnly: inputReadOnly
          }),
          _react2['default'].createElement(_Combobox2['default'], {
            prefixCls: prefixCls,
            value: value,
            defaultOpenValue: defaultOpenValue,
            format: format,
            onChange: this.onChange,
            showHour: showHour,
            showMinute: showMinute,
            showSecond: showSecond,
            hourOptions: hourOptions,
            minuteOptions: minuteOptions,
            secondOptions: secondOptions,
            disabledHours: this.disabledHours,
            disabledMinutes: disabledMinutes,
            disabledSeconds: disabledSeconds,
            onCurrentSelectPanelChange: this.onCurrentSelectPanelChange,
            use12Hours: use12Hours,
            isAM: this.isAM()
          }),
          addon(this)
        );
      }
    }]);
    return Panel;
  }(React$1__default.Component);

  Panel.propTypes = {
    clearText: _propTypes2['default'].string,
    prefixCls: _propTypes2['default'].string,
    className: _propTypes2['default'].string,
    defaultOpenValue: _propTypes2['default'].object,
    value: _propTypes2['default'].object,
    placeholder: _propTypes2['default'].string,
    format: _propTypes2['default'].string,
    inputReadOnly: _propTypes2['default'].bool,
    disabledHours: _propTypes2['default'].func,
    disabledMinutes: _propTypes2['default'].func,
    disabledSeconds: _propTypes2['default'].func,
    hideDisabledOptions: _propTypes2['default'].bool,
    onChange: _propTypes2['default'].func,
    onEsc: _propTypes2['default'].func,
    allowEmpty: _propTypes2['default'].bool,
    showHour: _propTypes2['default'].bool,
    showMinute: _propTypes2['default'].bool,
    showSecond: _propTypes2['default'].bool,
    onClear: _propTypes2['default'].func,
    use12Hours: _propTypes2['default'].bool,
    hourStep: _propTypes2['default'].number,
    minuteStep: _propTypes2['default'].number,
    secondStep: _propTypes2['default'].number,
    addon: _propTypes2['default'].func,
    focusOnOpen: _propTypes2['default'].bool,
    onKeyDown: _propTypes2['default'].func
  };
  Panel.defaultProps = {
    prefixCls: 'rc-time-picker-panel',
    onChange: noop,
    onClear: noop,
    disabledHours: noop,
    disabledMinutes: noop,
    disabledSeconds: noop,
    defaultOpenValue: (0, _moment2['default'])(),
    use12Hours: false,
    addon: noop,
    onKeyDown: noop,
    inputReadOnly: false
  };
  exports['default'] = Panel;
  module.exports = exports['default'];
  });

  unwrapExports(Panel_1);

  var placements_1$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var autoAdjustOverflow = {
    adjustX: 1,
    adjustY: 1
  };

  var targetOffset = [0, 0];

  var placements = {
    bottomLeft: {
      points: ['tl', 'tl'],
      overflow: autoAdjustOverflow,
      offset: [0, -3],
      targetOffset: targetOffset
    },
    bottomRight: {
      points: ['tr', 'tr'],
      overflow: autoAdjustOverflow,
      offset: [0, -3],
      targetOffset: targetOffset
    },
    topRight: {
      points: ['br', 'br'],
      overflow: autoAdjustOverflow,
      offset: [0, 3],
      targetOffset: targetOffset
    },
    topLeft: {
      points: ['bl', 'bl'],
      overflow: autoAdjustOverflow,
      offset: [0, 3],
      targetOffset: targetOffset
    }
  };

  exports['default'] = placements;
  module.exports = exports['default'];
  });

  unwrapExports(placements_1$1);

  var TimePicker = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var _react2 = _interopRequireDefault(React$1__default);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _rcTrigger2 = _interopRequireDefault(_rcTrigger);



  var _Panel2 = _interopRequireDefault(Panel_1);



  var _placements2 = _interopRequireDefault(placements_1$1);



  var _moment2 = _interopRequireDefault(moment);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function noop() {}

  function refFn(field, component) {
    this[field] = component;
  }

  var Picker = function (_Component) {
    (0, _inherits3['default'])(Picker, _Component);

    function Picker(props) {
      (0, _classCallCheck3['default'])(this, Picker);

      var _this = (0, _possibleConstructorReturn3['default'])(this, (Picker.__proto__ || Object.getPrototypeOf(Picker)).call(this, props));

      _initialiseProps.call(_this);

      _this.saveInputRef = refFn.bind(_this, 'picker');
      _this.savePanelRef = refFn.bind(_this, 'panelInstance');
      var defaultOpen = props.defaultOpen,
          defaultValue = props.defaultValue,
          _props$open = props.open,
          open = _props$open === undefined ? defaultOpen : _props$open,
          _props$value = props.value,
          value = _props$value === undefined ? defaultValue : _props$value;

      _this.state = {
        open: open,
        value: value
      };
      return _this;
    }

    (0, _createClass3['default'])(Picker, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        var value = nextProps.value,
            open = nextProps.open;

        if ('value' in nextProps) {
          this.setState({
            value: value
          });
        }
        if (open !== undefined) {
          this.setState({ open: open });
        }
      }
    }, {
      key: 'setValue',
      value: function setValue(value) {
        if (!('value' in this.props)) {
          this.setState({
            value: value
          });
        }
        this.props.onChange(value);
      }
    }, {
      key: 'getFormat',
      value: function getFormat() {
        var _props = this.props,
            format = _props.format,
            showHour = _props.showHour,
            showMinute = _props.showMinute,
            showSecond = _props.showSecond,
            use12Hours = _props.use12Hours;

        if (format) {
          return format;
        }

        if (use12Hours) {
          var fmtString = [showHour ? 'h' : '', showMinute ? 'mm' : '', showSecond ? 'ss' : ''].filter(function (item) {
            return !!item;
          }).join(':');

          return fmtString.concat(' a');
        }

        return [showHour ? 'HH' : '', showMinute ? 'mm' : '', showSecond ? 'ss' : ''].filter(function (item) {
          return !!item;
        }).join(':');
      }
    }, {
      key: 'getPanelElement',
      value: function getPanelElement() {
        var _props2 = this.props,
            prefixCls = _props2.prefixCls,
            placeholder = _props2.placeholder,
            disabledHours = _props2.disabledHours,
            disabledMinutes = _props2.disabledMinutes,
            disabledSeconds = _props2.disabledSeconds,
            hideDisabledOptions = _props2.hideDisabledOptions,
            inputReadOnly = _props2.inputReadOnly,
            allowEmpty = _props2.allowEmpty,
            showHour = _props2.showHour,
            showMinute = _props2.showMinute,
            showSecond = _props2.showSecond,
            defaultOpenValue = _props2.defaultOpenValue,
            clearText = _props2.clearText,
            addon = _props2.addon,
            use12Hours = _props2.use12Hours,
            focusOnOpen = _props2.focusOnOpen,
            onKeyDown = _props2.onKeyDown,
            hourStep = _props2.hourStep,
            minuteStep = _props2.minuteStep,
            secondStep = _props2.secondStep;

        return _react2['default'].createElement(_Panel2['default'], {
          clearText: clearText,
          prefixCls: prefixCls + '-panel',
          ref: this.savePanelRef,
          value: this.state.value,
          inputReadOnly: inputReadOnly,
          onChange: this.onPanelChange,
          onClear: this.onPanelClear,
          defaultOpenValue: defaultOpenValue,
          showHour: showHour,
          showMinute: showMinute,
          showSecond: showSecond,
          onEsc: this.onEsc,
          allowEmpty: allowEmpty,
          format: this.getFormat(),
          placeholder: placeholder,
          disabledHours: disabledHours,
          disabledMinutes: disabledMinutes,
          disabledSeconds: disabledSeconds,
          hideDisabledOptions: hideDisabledOptions,
          use12Hours: use12Hours,
          hourStep: hourStep,
          minuteStep: minuteStep,
          secondStep: secondStep,
          addon: addon,
          focusOnOpen: focusOnOpen,
          onKeyDown: onKeyDown
        });
      }
    }, {
      key: 'getPopupClassName',
      value: function getPopupClassName() {
        var _props3 = this.props,
            showHour = _props3.showHour,
            showMinute = _props3.showMinute,
            showSecond = _props3.showSecond,
            use12Hours = _props3.use12Hours,
            prefixCls = _props3.prefixCls;

        var popupClassName = this.props.popupClassName;
        // Keep it for old compatibility
        if ((!showHour || !showMinute || !showSecond) && !use12Hours) {
          popupClassName += ' ' + prefixCls + '-panel-narrow';
        }
        var selectColumnCount = 0;
        if (showHour) {
          selectColumnCount += 1;
        }
        if (showMinute) {
          selectColumnCount += 1;
        }
        if (showSecond) {
          selectColumnCount += 1;
        }
        if (use12Hours) {
          selectColumnCount += 1;
        }
        popupClassName += ' ' + prefixCls + '-panel-column-' + selectColumnCount;
        return popupClassName;
      }
    }, {
      key: 'setOpen',
      value: function setOpen(open) {
        var _props4 = this.props,
            onOpen = _props4.onOpen,
            onClose = _props4.onClose;

        if (this.state.open !== open) {
          if (!('open' in this.props)) {
            this.setState({ open: open });
          }
          if (open) {
            onOpen({ open: open });
          } else {
            onClose({ open: open });
          }
        }
      }
    }, {
      key: 'focus',
      value: function focus() {
        this.picker.focus();
      }
    }, {
      key: 'blur',
      value: function blur() {
        this.picker.blur();
      }
    }, {
      key: 'render',
      value: function render() {
        var _props5 = this.props,
            prefixCls = _props5.prefixCls,
            placeholder = _props5.placeholder,
            placement = _props5.placement,
            align = _props5.align,
            disabled = _props5.disabled,
            transitionName = _props5.transitionName,
            style = _props5.style,
            className = _props5.className,
            getPopupContainer = _props5.getPopupContainer,
            name = _props5.name,
            autoComplete = _props5.autoComplete,
            onFocus = _props5.onFocus,
            onBlur = _props5.onBlur,
            autoFocus = _props5.autoFocus,
            inputReadOnly = _props5.inputReadOnly;
        var _state = this.state,
            open = _state.open,
            value = _state.value;

        var popupClassName = this.getPopupClassName();
        return _react2['default'].createElement(
          _rcTrigger2['default'],
          {
            prefixCls: prefixCls + '-panel',
            popupClassName: popupClassName,
            popup: this.getPanelElement(),
            popupAlign: align,
            builtinPlacements: _placements2['default'],
            popupPlacement: placement,
            action: disabled ? [] : ['click'],
            destroyPopupOnHide: true,
            getPopupContainer: getPopupContainer,
            popupTransitionName: transitionName,
            popupVisible: open,
            onPopupVisibleChange: this.onVisibleChange
          },
          _react2['default'].createElement(
            'span',
            { className: prefixCls + ' ' + className, style: style },
            _react2['default'].createElement('input', {
              className: prefixCls + '-input',
              ref: this.saveInputRef,
              type: 'text',
              placeholder: placeholder,
              name: name,
              onKeyDown: this.onKeyDown,
              disabled: disabled,
              value: value && value.format(this.getFormat()) || '',
              autoComplete: autoComplete,
              onFocus: onFocus,
              onBlur: onBlur,
              autoFocus: autoFocus,
              onChange: noop,
              readOnly: !!inputReadOnly
            }),
            _react2['default'].createElement('span', { className: prefixCls + '-icon' })
          )
        );
      }
    }]);
    return Picker;
  }(React$1__default.Component);

  Picker.propTypes = {
    prefixCls: _propTypes2['default'].string,
    clearText: _propTypes2['default'].string,
    value: _propTypes2['default'].object,
    defaultOpenValue: _propTypes2['default'].object,
    inputReadOnly: _propTypes2['default'].bool,
    disabled: _propTypes2['default'].bool,
    allowEmpty: _propTypes2['default'].bool,
    defaultValue: _propTypes2['default'].object,
    open: _propTypes2['default'].bool,
    defaultOpen: _propTypes2['default'].bool,
    align: _propTypes2['default'].object,
    placement: _propTypes2['default'].any,
    transitionName: _propTypes2['default'].string,
    getPopupContainer: _propTypes2['default'].func,
    placeholder: _propTypes2['default'].string,
    format: _propTypes2['default'].string,
    showHour: _propTypes2['default'].bool,
    showMinute: _propTypes2['default'].bool,
    showSecond: _propTypes2['default'].bool,
    style: _propTypes2['default'].object,
    className: _propTypes2['default'].string,
    popupClassName: _propTypes2['default'].string,
    disabledHours: _propTypes2['default'].func,
    disabledMinutes: _propTypes2['default'].func,
    disabledSeconds: _propTypes2['default'].func,
    hideDisabledOptions: _propTypes2['default'].bool,
    onChange: _propTypes2['default'].func,
    onOpen: _propTypes2['default'].func,
    onClose: _propTypes2['default'].func,
    onFocus: _propTypes2['default'].func,
    onBlur: _propTypes2['default'].func,
    addon: _propTypes2['default'].func,
    name: _propTypes2['default'].string,
    autoComplete: _propTypes2['default'].string,
    use12Hours: _propTypes2['default'].bool,
    hourStep: _propTypes2['default'].number,
    minuteStep: _propTypes2['default'].number,
    secondStep: _propTypes2['default'].number,
    focusOnOpen: _propTypes2['default'].bool,
    onKeyDown: _propTypes2['default'].func,
    autoFocus: _propTypes2['default'].bool
  };
  Picker.defaultProps = {
    clearText: 'clear',
    prefixCls: 'rc-time-picker',
    defaultOpen: false,
    inputReadOnly: false,
    style: {},
    className: '',
    popupClassName: '',
    align: {},
    defaultOpenValue: (0, _moment2['default'])(),
    allowEmpty: true,
    showHour: true,
    showMinute: true,
    showSecond: true,
    disabledHours: noop,
    disabledMinutes: noop,
    disabledSeconds: noop,
    hideDisabledOptions: false,
    placement: 'bottomLeft',
    onChange: noop,
    onOpen: noop,
    onClose: noop,
    onFocus: noop,
    onBlur: noop,
    addon: noop,
    use12Hours: false,
    focusOnOpen: false,
    onKeyDown: noop
  };

  var _initialiseProps = function _initialiseProps() {
    var _this2 = this;

    this.onPanelChange = function (value) {
      _this2.setValue(value);
    };

    this.onPanelClear = function () {
      _this2.setValue(null);
      _this2.setOpen(false);
    };

    this.onVisibleChange = function (open) {
      _this2.setOpen(open);
    };

    this.onEsc = function () {
      _this2.setOpen(false);
      _this2.focus();
    };

    this.onKeyDown = function (e) {
      if (e.keyCode === 40) {
        _this2.setOpen(true);
      }
    };
  };

  exports['default'] = Picker;
  module.exports = exports['default'];
  });

  unwrapExports(TimePicker);

  var timePicker = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _extends3 = _interopRequireDefault(_extends$1);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);

  exports.generateShowHourMinuteSecond = generateShowHourMinuteSecond;



  var React = _interopRequireWildcard(React$1__default);



  var moment$$1 = _interopRequireWildcard(moment);



  var _TimePicker2 = _interopRequireDefault(TimePicker);



  var _classnames2 = _interopRequireDefault(classnames);



  var _LocaleReceiver2 = _interopRequireDefault(LocaleReceiver_1);



  var _en_US2 = _interopRequireDefault(en_US$4);



  var _interopDefault2 = _interopRequireDefault(interopDefault_1);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function generateShowHourMinuteSecond(format) {
      // Ref: http://momentjs.com/docs/#/parsing/string-format/
      return {
          showHour: format.indexOf('H') > -1 || format.indexOf('h') > -1 || format.indexOf('k') > -1,
          showMinute: format.indexOf('m') > -1,
          showSecond: format.indexOf('s') > -1
      };
  }

  var TimePicker$$1 = function (_React$Component) {
      (0, _inherits3['default'])(TimePicker$$1, _React$Component);

      function TimePicker$$1(props) {
          (0, _classCallCheck3['default'])(this, TimePicker$$1);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (TimePicker$$1.__proto__ || Object.getPrototypeOf(TimePicker$$1)).call(this, props));

          _this.handleChange = function (value) {
              if (!('value' in _this.props)) {
                  _this.setState({ value: value });
              }
              var _this$props = _this.props,
                  onChange = _this$props.onChange,
                  _this$props$format = _this$props.format,
                  format = _this$props$format === undefined ? 'HH:mm:ss' : _this$props$format;

              if (onChange) {
                  onChange(value, value && value.format(format) || '');
              }
          };
          _this.handleOpenClose = function (_ref) {
              var open = _ref.open;
              var onOpenChange = _this.props.onOpenChange;

              if (onOpenChange) {
                  onOpenChange(open);
              }
          };
          _this.saveTimePicker = function (timePickerRef) {
              _this.timePickerRef = timePickerRef;
          };
          _this.renderTimePicker = function (locale) {
              var props = (0, _extends3['default'])({}, _this.props);
              delete props.defaultValue;
              var format = _this.getDefaultFormat();
              var className = (0, _classnames2['default'])(props.className, (0, _defineProperty3['default'])({}, props.prefixCls + '-' + props.size, !!props.size));
              var addon = function addon(panel) {
                  return props.addon ? React.createElement(
                      'div',
                      { className: props.prefixCls + '-panel-addon' },
                      props.addon(panel)
                  ) : null;
              };
              return React.createElement(_TimePicker2['default'], (0, _extends3['default'])({}, generateShowHourMinuteSecond(format), props, { ref: _this.saveTimePicker, format: format, className: className, value: _this.state.value, placeholder: props.placeholder === undefined ? locale.placeholder : props.placeholder, onChange: _this.handleChange, onOpen: _this.handleOpenClose, onClose: _this.handleOpenClose, addon: addon }));
          };
          var value = props.value || props.defaultValue;
          if (value && !(0, _interopDefault2['default'])(moment$$1).isMoment(value)) {
              throw new Error('The value/defaultValue of TimePicker must be a moment object after `antd@2.0`, ' + 'see: https://u.ant.design/time-picker-value');
          }
          _this.state = {
              value: value
          };
          return _this;
      }

      (0, _createClass3['default'])(TimePicker$$1, [{
          key: 'componentWillReceiveProps',
          value: function componentWillReceiveProps(nextProps) {
              if ('value' in nextProps) {
                  this.setState({ value: nextProps.value });
              }
          }
      }, {
          key: 'focus',
          value: function focus() {
              this.timePickerRef.focus();
          }
      }, {
          key: 'blur',
          value: function blur() {
              this.timePickerRef.blur();
          }
      }, {
          key: 'getDefaultFormat',
          value: function getDefaultFormat() {
              var _props = this.props,
                  format = _props.format,
                  use12Hours = _props.use12Hours;

              if (format) {
                  return format;
              } else if (use12Hours) {
                  return 'h:mm:ss a';
              }
              return 'HH:mm:ss';
          }
      }, {
          key: 'render',
          value: function render() {
              return React.createElement(
                  _LocaleReceiver2['default'],
                  { componentName: 'TimePicker', defaultLocale: _en_US2['default'] },
                  this.renderTimePicker
              );
          }
      }]);
      return TimePicker$$1;
  }(React.Component);

  exports['default'] = TimePicker$$1;

  TimePicker$$1.defaultProps = {
      prefixCls: 'ant-time-picker',
      align: {
          offset: [0, -2]
      },
      disabled: false,
      disabledHours: undefined,
      disabledMinutes: undefined,
      disabledSeconds: undefined,
      hideDisabledOptions: false,
      placement: 'bottomLeft',
      transitionName: 'slide-up',
      focusOnOpen: true
  };
  });

  unwrapExports(timePicker);
  var timePicker_1 = timePicker.generateShowHourMinuteSecond;

  var wrapPicker_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _extends3 = _interopRequireDefault(_extends$1);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);

  exports['default'] = wrapPicker;



  var React = _interopRequireWildcard(React$1__default);



  var _Panel2 = _interopRequireDefault(Panel_1);



  var _classnames2 = _interopRequireDefault(classnames);



  var _LocaleReceiver2 = _interopRequireDefault(LocaleReceiver_1);





  var _en_US2 = _interopRequireDefault(en_US$6);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function getColumns(_ref) {
      var showHour = _ref.showHour,
          showMinute = _ref.showMinute,
          showSecond = _ref.showSecond,
          use12Hours = _ref.use12Hours;

      var column = 0;
      if (showHour) {
          column += 1;
      }
      if (showMinute) {
          column += 1;
      }
      if (showSecond) {
          column += 1;
      }
      if (use12Hours) {
          column += 1;
      }
      return column;
  }
  function wrapPicker(Picker, defaultFormat) {
      return _a = function (_React$Component) {
          (0, _inherits3['default'])(PickerWrapper, _React$Component);

          function PickerWrapper() {
              (0, _classCallCheck3['default'])(this, PickerWrapper);

              var _this = (0, _possibleConstructorReturn3['default'])(this, (PickerWrapper.__proto__ || Object.getPrototypeOf(PickerWrapper)).apply(this, arguments));

              _this.handleOpenChange = function (open) {
                  var onOpenChange = _this.props.onOpenChange;

                  onOpenChange(open);
              };
              _this.handleFocus = function (e) {
                  var onFocus = _this.props.onFocus;

                  if (onFocus) {
                      onFocus(e);
                  }
              };
              _this.handleBlur = function (e) {
                  var onBlur = _this.props.onBlur;

                  if (onBlur) {
                      onBlur(e);
                  }
              };
              _this.savePicker = function (node) {
                  _this.picker = node;
              };
              _this.getDefaultLocale = function () {
                  var result = (0, _extends3['default'])({}, _en_US2['default'], _this.props.locale);
                  result.lang = (0, _extends3['default'])({}, result.lang, (_this.props.locale || {}).lang);
                  return result;
              };
              _this.renderPicker = function (locale, localeCode) {
                  var _classNames2;

                  var props = _this.props;
                  var prefixCls = props.prefixCls,
                      inputPrefixCls = props.inputPrefixCls;

                  var pickerClass = (0, _classnames2['default'])(prefixCls + '-picker', (0, _defineProperty3['default'])({}, prefixCls + '-picker-' + props.size, !!props.size));
                  var pickerInputClass = (0, _classnames2['default'])(prefixCls + '-picker-input', inputPrefixCls, (_classNames2 = {}, (0, _defineProperty3['default'])(_classNames2, inputPrefixCls + '-lg', props.size === 'large'), (0, _defineProperty3['default'])(_classNames2, inputPrefixCls + '-sm', props.size === 'small'), (0, _defineProperty3['default'])(_classNames2, inputPrefixCls + '-disabled', props.disabled), _classNames2));
                  var timeFormat = props.showTime && props.showTime.format || 'HH:mm:ss';
                  var rcTimePickerProps = (0, _extends3['default'])({}, (0, timePicker.generateShowHourMinuteSecond)(timeFormat), { format: timeFormat, use12Hours: props.showTime && props.showTime.use12Hours });
                  var columns = getColumns(rcTimePickerProps);
                  var timePickerCls = prefixCls + '-time-picker-column-' + columns;
                  var timePicker$$1 = props.showTime ? React.createElement(_Panel2['default'], (0, _extends3['default'])({}, rcTimePickerProps, props.showTime, { prefixCls: prefixCls + '-time-picker', className: timePickerCls, placeholder: locale.timePickerLocale.placeholder, transitionName: 'slide-up' })) : null;
                  return React.createElement(Picker, (0, _extends3['default'])({}, props, { ref: _this.savePicker, pickerClass: pickerClass, pickerInputClass: pickerInputClass, locale: locale, localeCode: localeCode, timePicker: timePicker$$1, onOpenChange: _this.handleOpenChange, onFocus: _this.handleFocus, onBlur: _this.handleBlur }));
              };
              return _this;
          }

          (0, _createClass3['default'])(PickerWrapper, [{
              key: 'componentDidMount',
              value: function componentDidMount() {
                  var _props = this.props,
                      autoFocus = _props.autoFocus,
                      disabled = _props.disabled;

                  if (autoFocus && !disabled) {
                      this.focus();
                  }
              }
          }, {
              key: 'focus',
              value: function focus() {
                  this.picker.focus();
              }
          }, {
              key: 'blur',
              value: function blur() {
                  this.picker.blur();
              }
          }, {
              key: 'render',
              value: function render() {
                  return React.createElement(
                      _LocaleReceiver2['default'],
                      { componentName: 'DatePicker', defaultLocale: this.getDefaultLocale },
                      this.renderPicker
                  );
              }
          }]);
          return PickerWrapper;
      }(React.Component), _a.defaultProps = {
          format: defaultFormat || 'YYYY-MM-DD',
          transitionName: 'slide-up',
          popupStyle: {},
          onChange: function onChange() {},
          onOk: function onOk() {},
          onOpenChange: function onOpenChange() {},

          locale: {},
          prefixCls: 'ant-calendar',
          inputPrefixCls: 'ant-input'
      }, _a;
      var _a;
  }
  module.exports = exports['default'];
  });

  unwrapExports(wrapPicker_1);

  var ITERATOR$4 = _wks('iterator');

  var core_isIterable = _core.isIterable = function (it) {
    var O = Object(it);
    return O[ITERATOR$4] !== undefined
      || '@@iterator' in O
      // eslint-disable-next-line no-prototype-builtins
      || _iterators.hasOwnProperty(_classof(O));
  };

  var isIterable = core_isIterable;

  var isIterable$1 = createCommonjsModule(function (module) {
  module.exports = { "default": isIterable, __esModule: true };
  });

  unwrapExports(isIterable$1);

  var core_getIterator = _core.getIterator = function (it) {
    var iterFn = core_getIteratorMethod(it);
    if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
    return _anObject(iterFn.call(it));
  };

  var getIterator = core_getIterator;

  var getIterator$1 = createCommonjsModule(function (module) {
  module.exports = { "default": getIterator, __esModule: true };
  });

  unwrapExports(getIterator$1);

  var slicedToArray = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _isIterable3 = _interopRequireDefault(isIterable$1);



  var _getIterator3 = _interopRequireDefault(getIterator$1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if ((0, _isIterable3.default)(Object(arr))) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  });

  unwrapExports(slicedToArray);

  var DateConstants$1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = {
    DATE_ROW_COUNT: 6,
    DATE_COL_COUNT: 7
  };
  module.exports = exports['default'];
  });

  unwrapExports(DateConstants$1);

  var DateTHead_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var _react2 = _interopRequireDefault(React$1__default);



  var _DateConstants2 = _interopRequireDefault(DateConstants$1);



  var _moment2 = _interopRequireDefault(moment);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var DateTHead = function (_React$Component) {
    (0, _inherits3['default'])(DateTHead, _React$Component);

    function DateTHead() {
      (0, _classCallCheck3['default'])(this, DateTHead);
      return (0, _possibleConstructorReturn3['default'])(this, _React$Component.apply(this, arguments));
    }

    DateTHead.prototype.render = function render() {
      var props = this.props;
      var value = props.value;
      var localeData = value.localeData();
      var prefixCls = props.prefixCls;
      var veryShortWeekdays = [];
      var weekDays = [];
      var firstDayOfWeek = localeData.firstDayOfWeek();
      var showWeekNumberEl = void 0;
      var now = (0, _moment2['default'])();
      for (var dateColIndex = 0; dateColIndex < _DateConstants2['default'].DATE_COL_COUNT; dateColIndex++) {
        var index = (firstDayOfWeek + dateColIndex) % _DateConstants2['default'].DATE_COL_COUNT;
        now.day(index);
        veryShortWeekdays[dateColIndex] = localeData.weekdaysMin(now);
        weekDays[dateColIndex] = localeData.weekdaysShort(now);
      }

      if (props.showWeekNumber) {
        showWeekNumberEl = _react2['default'].createElement(
          'th',
          {
            role: 'columnheader',
            className: prefixCls + '-column-header ' + prefixCls + '-week-number-header'
          },
          _react2['default'].createElement(
            'span',
            { className: prefixCls + '-column-header-inner' },
            'x'
          )
        );
      }
      var weekDaysEls = weekDays.map(function (day, xindex) {
        return _react2['default'].createElement(
          'th',
          {
            key: xindex,
            role: 'columnheader',
            title: day,
            className: prefixCls + '-column-header'
          },
          _react2['default'].createElement(
            'span',
            { className: prefixCls + '-column-header-inner' },
            veryShortWeekdays[xindex]
          )
        );
      });
      return _react2['default'].createElement(
        'thead',
        null,
        _react2['default'].createElement(
          'tr',
          { role: 'row' },
          showWeekNumberEl,
          weekDaysEls
        )
      );
    };

    return DateTHead;
  }(_react2['default'].Component);

  exports['default'] = DateTHead;
  module.exports = exports['default'];
  });

  unwrapExports(DateTHead_1);

  var DateTBody_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _react2 = _interopRequireDefault(React$1__default);



  var _createReactClass2 = _interopRequireDefault(createReactClass);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _classnames2 = _interopRequireDefault(classnames);



  var _DateConstants2 = _interopRequireDefault(DateConstants$1);



  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function isSameDay(one, two) {
    return one && two && one.isSame(two, 'day');
  }

  function beforeCurrentMonthYear(current, today) {
    if (current.year() < today.year()) {
      return 1;
    }
    return current.year() === today.year() && current.month() < today.month();
  }

  function afterCurrentMonthYear(current, today) {
    if (current.year() > today.year()) {
      return 1;
    }
    return current.year() === today.year() && current.month() > today.month();
  }

  function getIdFromDate(date) {
    return 'rc-calendar-' + date.year() + '-' + date.month() + '-' + date.date();
  }

  var DateTBody = (0, _createReactClass2['default'])({
    displayName: 'DateTBody',

    propTypes: {
      contentRender: _propTypes2['default'].func,
      dateRender: _propTypes2['default'].func,
      disabledDate: _propTypes2['default'].func,
      prefixCls: _propTypes2['default'].string,
      selectedValue: _propTypes2['default'].oneOfType([_propTypes2['default'].object, _propTypes2['default'].arrayOf(_propTypes2['default'].object)]),
      value: _propTypes2['default'].object,
      hoverValue: _propTypes2['default'].any,
      showWeekNumber: _propTypes2['default'].bool
    },

    getDefaultProps: function getDefaultProps() {
      return {
        hoverValue: []
      };
    },
    render: function render() {
      var props = this.props;
      var contentRender = props.contentRender,
          prefixCls = props.prefixCls,
          selectedValue = props.selectedValue,
          value = props.value,
          showWeekNumber = props.showWeekNumber,
          dateRender = props.dateRender,
          disabledDate = props.disabledDate,
          hoverValue = props.hoverValue;

      var iIndex = void 0;
      var jIndex = void 0;
      var current = void 0;
      var dateTable = [];
      var today = (0, util$2.getTodayTime)(value);
      var cellClass = prefixCls + '-cell';
      var weekNumberCellClass = prefixCls + '-week-number-cell';
      var dateClass = prefixCls + '-date';
      var todayClass = prefixCls + '-today';
      var selectedClass = prefixCls + '-selected-day';
      var selectedDateClass = prefixCls + '-selected-date'; // do not move with mouse operation
      var selectedStartDateClass = prefixCls + '-selected-start-date';
      var selectedEndDateClass = prefixCls + '-selected-end-date';
      var inRangeClass = prefixCls + '-in-range-cell';
      var lastMonthDayClass = prefixCls + '-last-month-cell';
      var nextMonthDayClass = prefixCls + '-next-month-btn-day';
      var disabledClass = prefixCls + '-disabled-cell';
      var firstDisableClass = prefixCls + '-disabled-cell-first-of-row';
      var lastDisableClass = prefixCls + '-disabled-cell-last-of-row';
      var lastDayOfMonthClass = prefixCls + '-last-day-of-month';
      var month1 = value.clone();
      month1.date(1);
      var day = month1.day();
      var lastMonthDiffDay = (day + 7 - value.localeData().firstDayOfWeek()) % 7;
      // calculate last month
      var lastMonth1 = month1.clone();
      lastMonth1.add(0 - lastMonthDiffDay, 'days');
      var passed = 0;

      for (iIndex = 0; iIndex < _DateConstants2['default'].DATE_ROW_COUNT; iIndex++) {
        for (jIndex = 0; jIndex < _DateConstants2['default'].DATE_COL_COUNT; jIndex++) {
          current = lastMonth1;
          if (passed) {
            current = current.clone();
            current.add(passed, 'days');
          }
          dateTable.push(current);
          passed++;
        }
      }
      var tableHtml = [];
      passed = 0;

      for (iIndex = 0; iIndex < _DateConstants2['default'].DATE_ROW_COUNT; iIndex++) {
        var _cx;

        var isCurrentWeek = void 0;
        var weekNumberCell = void 0;
        var isActiveWeek = false;
        var dateCells = [];
        if (showWeekNumber) {
          weekNumberCell = _react2['default'].createElement(
            'td',
            {
              key: dateTable[passed].week(),
              role: 'gridcell',
              className: weekNumberCellClass
            },
            dateTable[passed].week()
          );
        }
        for (jIndex = 0; jIndex < _DateConstants2['default'].DATE_COL_COUNT; jIndex++) {
          var next = null;
          var last = null;
          current = dateTable[passed];
          if (jIndex < _DateConstants2['default'].DATE_COL_COUNT - 1) {
            next = dateTable[passed + 1];
          }
          if (jIndex > 0) {
            last = dateTable[passed - 1];
          }
          var cls = cellClass;
          var disabled = false;
          var selected = false;

          if (isSameDay(current, today)) {
            cls += ' ' + todayClass;
            isCurrentWeek = true;
          }

          var isBeforeCurrentMonthYear = beforeCurrentMonthYear(current, value);
          var isAfterCurrentMonthYear = afterCurrentMonthYear(current, value);

          if (selectedValue && Array.isArray(selectedValue)) {
            var rangeValue = hoverValue.length ? hoverValue : selectedValue;
            if (!isBeforeCurrentMonthYear && !isAfterCurrentMonthYear) {
              var startValue = rangeValue[0];
              var endValue = rangeValue[1];
              if (startValue) {
                if (isSameDay(current, startValue)) {
                  selected = true;
                  isActiveWeek = true;
                  cls += ' ' + selectedStartDateClass;
                }
              }
              if (startValue && endValue) {
                if (isSameDay(current, endValue)) {
                  selected = true;
                  isActiveWeek = true;
                  cls += ' ' + selectedEndDateClass;
                } else if (current.isAfter(startValue, 'day') && current.isBefore(endValue, 'day')) {
                  cls += ' ' + inRangeClass;
                }
              }
            }
          } else if (isSameDay(current, value)) {
            // keyboard change value, highlight works
            selected = true;
            isActiveWeek = true;
          }

          if (isSameDay(current, selectedValue)) {
            cls += ' ' + selectedDateClass;
          }

          if (isBeforeCurrentMonthYear) {
            cls += ' ' + lastMonthDayClass;
          }

          if (isAfterCurrentMonthYear) {
            cls += ' ' + nextMonthDayClass;
          }

          if (current.clone().endOf('month').date() === current.date()) {
            cls += ' ' + lastDayOfMonthClass;
          }

          if (disabledDate) {
            if (disabledDate(current, value)) {
              disabled = true;

              if (!last || !disabledDate(last, value)) {
                cls += ' ' + firstDisableClass;
              }

              if (!next || !disabledDate(next, value)) {
                cls += ' ' + lastDisableClass;
              }
            }
          }

          if (selected) {
            cls += ' ' + selectedClass;
          }

          if (disabled) {
            cls += ' ' + disabledClass;
          }

          var dateHtml = void 0;
          if (dateRender) {
            dateHtml = dateRender(current, value);
          } else {
            var content = contentRender ? contentRender(current, value) : current.date();
            dateHtml = _react2['default'].createElement(
              'div',
              {
                key: getIdFromDate(current),
                className: dateClass,
                'aria-selected': selected,
                'aria-disabled': disabled
              },
              content
            );
          }

          dateCells.push(_react2['default'].createElement(
            'td',
            {
              key: passed,
              onClick: disabled ? undefined : props.onSelect.bind(null, current),
              onMouseEnter: disabled ? undefined : props.onDayHover && props.onDayHover.bind(null, current) || undefined,
              role: 'gridcell',
              title: (0, util$2.getTitleString)(current),
              className: cls
            },
            dateHtml
          ));

          passed++;
        }

        tableHtml.push(_react2['default'].createElement(
          'tr',
          {
            key: iIndex,
            role: 'row',
            className: (0, _classnames2['default'])((_cx = {}, _cx[prefixCls + '-current-week'] = isCurrentWeek, _cx[prefixCls + '-active-week'] = isActiveWeek, _cx))
          },
          weekNumberCell,
          dateCells
        ));
      }
      return _react2['default'].createElement(
        'tbody',
        { className: prefixCls + '-tbody' },
        tableHtml
      );
    }
  });

  exports['default'] = DateTBody;
  module.exports = exports['default'];
  });

  unwrapExports(DateTBody_1);

  var DateTable_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var _react2 = _interopRequireDefault(React$1__default);



  var _DateTHead2 = _interopRequireDefault(DateTHead_1);



  var _DateTBody2 = _interopRequireDefault(DateTBody_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var DateTable = function (_React$Component) {
    (0, _inherits3['default'])(DateTable, _React$Component);

    function DateTable() {
      (0, _classCallCheck3['default'])(this, DateTable);
      return (0, _possibleConstructorReturn3['default'])(this, _React$Component.apply(this, arguments));
    }

    DateTable.prototype.render = function render() {
      var props = this.props;
      var prefixCls = props.prefixCls;
      return _react2['default'].createElement(
        'table',
        { className: prefixCls + '-table', cellSpacing: '0', role: 'grid' },
        _react2['default'].createElement(_DateTHead2['default'], props),
        _react2['default'].createElement(_DateTBody2['default'], props)
      );
    };

    return DateTable;
  }(_react2['default'].Component);

  exports['default'] = DateTable;
  module.exports = exports['default'];
  });

  unwrapExports(DateTable_1);

  var DateInput_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _react2 = _interopRequireDefault(React$1__default);



  var _reactDom2 = _interopRequireDefault(ReactDOM__default);



  var _createReactClass2 = _interopRequireDefault(createReactClass);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _moment2 = _interopRequireDefault(moment);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var DateInput = (0, _createReactClass2['default'])({
    displayName: 'DateInput',

    propTypes: {
      prefixCls: _propTypes2['default'].string,
      timePicker: _propTypes2['default'].object,
      value: _propTypes2['default'].object,
      disabledTime: _propTypes2['default'].any,
      format: _propTypes2['default'].string,
      locale: _propTypes2['default'].object,
      disabledDate: _propTypes2['default'].func,
      onChange: _propTypes2['default'].func,
      onClear: _propTypes2['default'].func,
      placeholder: _propTypes2['default'].string,
      onSelect: _propTypes2['default'].func,
      selectedValue: _propTypes2['default'].object
    },

    getInitialState: function getInitialState() {
      var selectedValue = this.props.selectedValue;
      return {
        str: selectedValue && selectedValue.format(this.props.format) || '',
        invalid: false
      };
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
      this.cachedSelectionStart = this.dateInputInstance.selectionStart;
      this.cachedSelectionEnd = this.dateInputInstance.selectionEnd;
      // when popup show, click body will call this, bug!
      var selectedValue = nextProps.selectedValue;
      this.setState({
        str: selectedValue && selectedValue.format(nextProps.format) || '',
        invalid: false
      });
    },
    componentDidUpdate: function componentDidUpdate() {
      if (!this.state.invalid) {
        this.dateInputInstance.setSelectionRange(this.cachedSelectionStart, this.cachedSelectionEnd);
      }
    },
    onInputChange: function onInputChange(event) {
      var str = event.target.value;
      this.setState({
        str: str
      });
      var value = void 0;
      var _props = this.props,
          disabledDate = _props.disabledDate,
          format = _props.format,
          onChange = _props.onChange;

      if (str) {
        var parsed = (0, _moment2['default'])(str, format, true);
        if (!parsed.isValid()) {
          this.setState({
            invalid: true
          });
          return;
        }
        value = this.props.value.clone();
        value.year(parsed.year()).month(parsed.month()).date(parsed.date()).hour(parsed.hour()).minute(parsed.minute()).second(parsed.second());

        if (value && (!disabledDate || !disabledDate(value))) {
          var originalValue = this.props.selectedValue;
          if (originalValue && value) {
            if (!originalValue.isSame(value)) {
              onChange(value);
            }
          } else if (originalValue !== value) {
            onChange(value);
          }
        } else {
          this.setState({
            invalid: true
          });
          return;
        }
      } else {
        onChange(null);
      }
      this.setState({
        invalid: false
      });
    },
    onClear: function onClear() {
      this.setState({
        str: ''
      });
      this.props.onClear(null);
    },
    getRootDOMNode: function getRootDOMNode() {
      return _reactDom2['default'].findDOMNode(this);
    },
    focus: function focus() {
      if (this.dateInputInstance) {
        this.dateInputInstance.focus();
      }
    },
    saveDateInput: function saveDateInput(dateInput) {
      this.dateInputInstance = dateInput;
    },
    render: function render() {
      var props = this.props;
      var _state = this.state,
          invalid = _state.invalid,
          str = _state.str;
      var locale = props.locale,
          prefixCls = props.prefixCls,
          placeholder = props.placeholder;

      var invalidClass = invalid ? prefixCls + '-input-invalid' : '';
      return _react2['default'].createElement(
        'div',
        { className: prefixCls + '-input-wrap' },
        _react2['default'].createElement(
          'div',
          { className: prefixCls + '-date-input-wrap' },
          _react2['default'].createElement('input', {
            ref: this.saveDateInput,
            className: prefixCls + '-input ' + invalidClass,
            value: str,
            disabled: props.disabled,
            placeholder: placeholder,
            onChange: this.onInputChange
          })
        ),
        props.showClear ? _react2['default'].createElement('a', {
          className: prefixCls + '-clear-btn',
          role: 'button',
          title: locale.clear,
          onClick: this.onClear
        }) : null
      );
    }
  });

  exports['default'] = DateInput;
  module.exports = exports['default'];
  });

  unwrapExports(DateInput_1);

  var CalendarPart_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _extends3 = _interopRequireDefault(_extends$1);



  var _react2 = _interopRequireDefault(React$1__default);



  var _createReactClass2 = _interopRequireDefault(createReactClass);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _CalendarHeader2 = _interopRequireDefault(CalendarHeader_1);



  var _DateTable2 = _interopRequireDefault(DateTable_1);



  var _DateInput2 = _interopRequireDefault(DateInput_1);



  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var CalendarPart = (0, _createReactClass2['default'])({
    displayName: 'CalendarPart',

    propTypes: {
      prefixCls: _propTypes2['default'].string,
      value: _propTypes2['default'].any,
      hoverValue: _propTypes2['default'].any,
      selectedValue: _propTypes2['default'].any,
      direction: _propTypes2['default'].any,
      locale: _propTypes2['default'].any,
      showDateInput: _propTypes2['default'].bool,
      showTimePicker: _propTypes2['default'].bool,
      format: _propTypes2['default'].any,
      placeholder: _propTypes2['default'].any,
      disabledDate: _propTypes2['default'].any,
      timePicker: _propTypes2['default'].any,
      disabledTime: _propTypes2['default'].any,
      onInputSelect: _propTypes2['default'].func,
      timePickerDisabledTime: _propTypes2['default'].object,
      enableNext: _propTypes2['default'].any,
      enablePrev: _propTypes2['default'].any
    },
    render: function render() {
      var props = this.props;
      var prefixCls = props.prefixCls,
          value = props.value,
          hoverValue = props.hoverValue,
          selectedValue = props.selectedValue,
          mode = props.mode,
          direction = props.direction,
          locale = props.locale,
          format = props.format,
          placeholder = props.placeholder,
          disabledDate = props.disabledDate,
          timePicker = props.timePicker,
          disabledTime = props.disabledTime,
          timePickerDisabledTime = props.timePickerDisabledTime,
          showTimePicker = props.showTimePicker,
          onInputSelect = props.onInputSelect,
          enablePrev = props.enablePrev,
          enableNext = props.enableNext;

      var shouldShowTimePicker = showTimePicker && timePicker;
      var disabledTimeConfig = shouldShowTimePicker && disabledTime ? (0, util$2.getTimeConfig)(selectedValue, disabledTime) : null;
      var rangeClassName = prefixCls + '-range';
      var newProps = {
        locale: locale,
        value: value,
        prefixCls: prefixCls,
        showTimePicker: showTimePicker
      };
      var index = direction === 'left' ? 0 : 1;
      var timePickerEle = shouldShowTimePicker && _react2['default'].cloneElement(timePicker, (0, _extends3['default'])({
        showHour: true,
        showMinute: true,
        showSecond: true
      }, timePicker.props, disabledTimeConfig, timePickerDisabledTime, {
        onChange: onInputSelect,
        defaultOpenValue: value,
        value: selectedValue[index]
      }));

      var dateInputElement = props.showDateInput && _react2['default'].createElement(_DateInput2['default'], {
        format: format,
        locale: locale,
        prefixCls: prefixCls,
        timePicker: timePicker,
        disabledDate: disabledDate,
        placeholder: placeholder,
        disabledTime: disabledTime,
        value: value,
        showClear: false,
        selectedValue: selectedValue[index],
        onChange: onInputSelect
      });

      return _react2['default'].createElement(
        'div',
        {
          className: rangeClassName + '-part ' + rangeClassName + '-' + direction
        },
        dateInputElement,
        _react2['default'].createElement(
          'div',
          { style: { outline: 'none' } },
          _react2['default'].createElement(_CalendarHeader2['default'], (0, _extends3['default'])({}, newProps, {
            mode: mode,
            enableNext: enableNext,
            enablePrev: enablePrev,
            onValueChange: props.onValueChange,
            onPanelChange: props.onPanelChange,
            disabledMonth: props.disabledMonth
          })),
          showTimePicker ? _react2['default'].createElement(
            'div',
            { className: prefixCls + '-time-picker' },
            _react2['default'].createElement(
              'div',
              { className: prefixCls + '-time-picker-panel' },
              timePickerEle
            )
          ) : null,
          _react2['default'].createElement(
            'div',
            { className: prefixCls + '-body' },
            _react2['default'].createElement(_DateTable2['default'], (0, _extends3['default'])({}, newProps, {
              hoverValue: hoverValue,
              selectedValue: selectedValue,
              dateRender: props.dateRender,
              onSelect: props.onSelect,
              onDayHover: props.onDayHover,
              disabledDate: disabledDate,
              showWeekNumber: props.showWeekNumber
            }))
          )
        )
      );
    }
  });

  exports['default'] = CalendarPart;
  module.exports = exports['default'];
  });

  unwrapExports(CalendarPart_1);

  var toTime = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.goStartMonth = goStartMonth;
  exports.goEndMonth = goEndMonth;
  exports.goTime = goTime;
  exports.includesTime = includesTime;
  function goStartMonth(time) {
    return time.clone().startOf('month');
  }

  function goEndMonth(time) {
    return time.clone().endOf('month');
  }

  function goTime(time, direction, unit) {
    return time.clone().add(direction, unit);
  }

  function includesTime() {
    var timeList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var time = arguments[1];
    var unit = arguments[2];

    return timeList.some(function (t) {
      return t.isSame(time, unit);
    });
  }
  });

  unwrapExports(toTime);
  var toTime_1 = toTime.goStartMonth;
  var toTime_2 = toTime.goEndMonth;
  var toTime_3 = toTime.goTime;
  var toTime_4 = toTime.includesTime;

  var RangeCalendar_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _extends3 = _interopRequireDefault(_extends$1);



  var _react2 = _interopRequireDefault(React$1__default);



  var _createReactClass2 = _interopRequireDefault(createReactClass);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _moment2 = _interopRequireDefault(moment);



  var _classnames3 = _interopRequireDefault(classnames);



  var _KeyCode2 = _interopRequireDefault(KeyCode_1);



  var _CalendarPart2 = _interopRequireDefault(CalendarPart_1);



  var _TodayButton2 = _interopRequireDefault(TodayButton_1);



  var _OkButton2 = _interopRequireDefault(OkButton_1);



  var _TimePickerButton2 = _interopRequireDefault(TimePickerButton_1);



  var _CommonMixin2 = _interopRequireDefault(CommonMixin$1);





  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function noop() {}

  function isEmptyArray(arr) {
    return Array.isArray(arr) && (arr.length === 0 || arr.every(function (i) {
      return !i;
    }));
  }

  function isArraysEqual(a, b) {
    if (a === b) return true;
    if (a === null || typeof a === 'undefined' || b === null || typeof b === 'undefined') {
      return false;
    }
    if (a.length !== b.length) return false;

    for (var i = 0; i < a.length; ++i) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }

  function getValueFromSelectedValue(selectedValue) {
    var start = selectedValue[0],
        end = selectedValue[1];

    var newEnd = end && end.isSame(start, 'month') ? end.clone().add(1, 'month') : end;
    return [start, newEnd];
  }

  function normalizeAnchor(props, init) {
    var selectedValue = props.selectedValue || init && props.defaultSelectedValue;
    var value = props.value || init && props.defaultValue;
    var normalizedValue = value ? getValueFromSelectedValue(value) : getValueFromSelectedValue(selectedValue);
    return !isEmptyArray(normalizedValue) ? normalizedValue : init && [(0, _moment2['default'])(), (0, _moment2['default'])().add(1, 'months')];
  }

  function generateOptions(length, extraOptionGen) {
    var arr = extraOptionGen ? extraOptionGen().concat() : [];
    for (var value = 0; value < length; value++) {
      if (arr.indexOf(value) === -1) {
        arr.push(value);
      }
    }
    return arr;
  }

  function onInputSelect(direction, value) {
    if (!value) {
      return;
    }
    var originalValue = this.state.selectedValue;
    var selectedValue = originalValue.concat();
    var index = direction === 'left' ? 0 : 1;
    selectedValue[index] = value;
    if (selectedValue[0] && this.compare(selectedValue[0], selectedValue[1]) > 0) {
      selectedValue[1 - index] = this.state.showTimePicker ? selectedValue[index] : undefined;
    }
    this.props.onInputSelect(selectedValue);
    this.fireSelectValueChange(selectedValue);
  }

  var RangeCalendar = (0, _createReactClass2['default'])({
    displayName: 'RangeCalendar',

    propTypes: {
      prefixCls: _propTypes2['default'].string,
      dateInputPlaceholder: _propTypes2['default'].any,
      defaultValue: _propTypes2['default'].any,
      value: _propTypes2['default'].any,
      hoverValue: _propTypes2['default'].any,
      mode: _propTypes2['default'].arrayOf(_propTypes2['default'].oneOf(['date', 'month', 'year', 'decade'])),
      showDateInput: _propTypes2['default'].bool,
      timePicker: _propTypes2['default'].any,
      showOk: _propTypes2['default'].bool,
      showToday: _propTypes2['default'].bool,
      defaultSelectedValue: _propTypes2['default'].array,
      selectedValue: _propTypes2['default'].array,
      onOk: _propTypes2['default'].func,
      showClear: _propTypes2['default'].bool,
      locale: _propTypes2['default'].object,
      onChange: _propTypes2['default'].func,
      onSelect: _propTypes2['default'].func,
      onValueChange: _propTypes2['default'].func,
      onHoverChange: _propTypes2['default'].func,
      onPanelChange: _propTypes2['default'].func,
      format: _propTypes2['default'].oneOfType([_propTypes2['default'].object, _propTypes2['default'].string]),
      onClear: _propTypes2['default'].func,
      type: _propTypes2['default'].any,
      disabledDate: _propTypes2['default'].func,
      disabledTime: _propTypes2['default'].func
    },

    mixins: [_CommonMixin2['default']],

    getDefaultProps: function getDefaultProps() {
      return {
        type: 'both',
        defaultSelectedValue: [],
        onValueChange: noop,
        onHoverChange: noop,
        onPanelChange: noop,
        disabledTime: noop,
        onInputSelect: noop,
        showToday: true,
        showDateInput: true
      };
    },
    getInitialState: function getInitialState() {
      var props = this.props;
      var selectedValue = props.selectedValue || props.defaultSelectedValue;
      var value = normalizeAnchor(props, 1);
      return {
        selectedValue: selectedValue,
        prevSelectedValue: selectedValue,
        firstSelectedValue: null,
        hoverValue: props.hoverValue || [],
        value: value,
        showTimePicker: false,
        mode: props.mode || ['date', 'date']
      };
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
      var state = this.state;

      var newState = {};
      if ('value' in nextProps) {
        newState.value = normalizeAnchor(nextProps, 0);
        this.setState(newState);
      }
      if ('hoverValue' in nextProps && !isArraysEqual(state.hoverValue, nextProps.hoverValue)) {
        this.setState({ hoverValue: nextProps.hoverValue });
      }
      if ('selectedValue' in nextProps) {
        newState.selectedValue = nextProps.selectedValue;
        newState.prevSelectedValue = nextProps.selectedValue;
        this.setState(newState);
      }
      if ('mode' in nextProps && !isArraysEqual(state.mode, nextProps.mode)) {
        this.setState({ mode: nextProps.mode });
      }
    },
    onDatePanelEnter: function onDatePanelEnter() {
      if (this.hasSelectedValue()) {
        this.fireHoverValueChange(this.state.selectedValue.concat());
      }
    },
    onDatePanelLeave: function onDatePanelLeave() {
      if (this.hasSelectedValue()) {
        this.fireHoverValueChange([]);
      }
    },
    onSelect: function onSelect(value) {
      var type = this.props.type;
      var _state = this.state,
          selectedValue = _state.selectedValue,
          prevSelectedValue = _state.prevSelectedValue,
          firstSelectedValue = _state.firstSelectedValue;

      var nextSelectedValue = void 0;
      if (type === 'both') {
        if (!firstSelectedValue) {
          (0, util$2.syncTime)(prevSelectedValue[0], value);
          nextSelectedValue = [value];
        } else if (this.compare(firstSelectedValue, value) < 0) {
          (0, util$2.syncTime)(prevSelectedValue[1], value);
          nextSelectedValue = [firstSelectedValue, value];
        } else {
          (0, util$2.syncTime)(prevSelectedValue[0], value);
          (0, util$2.syncTime)(prevSelectedValue[1], firstSelectedValue);
          nextSelectedValue = [value, firstSelectedValue];
        }
      } else if (type === 'start') {
        (0, util$2.syncTime)(prevSelectedValue[0], value);
        var endValue = selectedValue[1];
        nextSelectedValue = endValue && this.compare(endValue, value) > 0 ? [value, endValue] : [value];
      } else {
        // type === 'end'
        var startValue = selectedValue[0];
        if (startValue && this.compare(startValue, value) <= 0) {
          (0, util$2.syncTime)(prevSelectedValue[1], value);
          nextSelectedValue = [startValue, value];
        } else {
          (0, util$2.syncTime)(prevSelectedValue[0], value);
          nextSelectedValue = [value];
        }
      }

      this.fireSelectValueChange(nextSelectedValue);
    },
    onKeyDown: function onKeyDown(event) {
      var _this = this;

      if (event.target.nodeName.toLowerCase() === 'input') {
        return;
      }

      var keyCode = event.keyCode;

      var ctrlKey = event.ctrlKey || event.metaKey;

      var _state2 = this.state,
          selectedValue = _state2.selectedValue,
          hoverValue = _state2.hoverValue,
          firstSelectedValue = _state2.firstSelectedValue,
          value = _state2.value;
      var _props = this.props,
          onKeyDown = _props.onKeyDown,
          disabledDate = _props.disabledDate;

      // Update last time of the picker

      var updateHoverPoint = function updateHoverPoint(func) {
        // Change hover to make focus in UI
        var currentHoverTime = void 0;
        var nextHoverTime = void 0;
        var nextHoverValue = void 0;

        if (!firstSelectedValue) {
          currentHoverTime = hoverValue[0] || selectedValue[0] || value[0] || (0, _moment2['default'])();
          nextHoverTime = func(currentHoverTime);
          nextHoverValue = [nextHoverTime];
          _this.fireHoverValueChange(nextHoverValue);
        } else {
          if (hoverValue.length === 1) {
            currentHoverTime = hoverValue[0].clone();
            nextHoverTime = func(currentHoverTime);
            nextHoverValue = _this.onDayHover(nextHoverTime);
          } else {
            currentHoverTime = hoverValue[0].isSame(firstSelectedValue, 'day') ? hoverValue[1] : hoverValue[0];
            nextHoverTime = func(currentHoverTime);
            nextHoverValue = _this.onDayHover(nextHoverTime);
          }
        }

        // Find origin hover time on value index
        if (nextHoverValue.length >= 2) {
          var miss = nextHoverValue.some(function (ht) {
            return !(0, toTime.includesTime)(value, ht, 'month');
          });
          if (miss) {
            var newValue = nextHoverValue.slice().sort(function (t1, t2) {
              return t1.valueOf() - t2.valueOf();
            });
            if (newValue[0].isSame(newValue[1], 'month')) {
              newValue[1] = newValue[0].clone().add(1, 'month');
            }
            _this.fireValueChange(newValue);
          }
        } else if (nextHoverValue.length === 1) {
          // If only one value, let's keep the origin panel
          var oriValueIndex = value.findIndex(function (time) {
            return time.isSame(currentHoverTime, 'month');
          });
          if (oriValueIndex === -1) oriValueIndex = 0;

          if (value.every(function (time) {
            return !time.isSame(nextHoverTime, 'month');
          })) {
            var _newValue = value.slice();
            _newValue[oriValueIndex] = nextHoverTime.clone();
            _this.fireValueChange(_newValue);
          }
        }

        event.preventDefault();

        return nextHoverTime;
      };

      switch (keyCode) {
        case _KeyCode2['default'].DOWN:
          updateHoverPoint(function (time) {
            return (0, toTime.goTime)(time, 1, 'weeks');
          });
          return;
        case _KeyCode2['default'].UP:
          updateHoverPoint(function (time) {
            return (0, toTime.goTime)(time, -1, 'weeks');
          });
          return;
        case _KeyCode2['default'].LEFT:
          if (ctrlKey) {
            updateHoverPoint(function (time) {
              return (0, toTime.goTime)(time, -1, 'years');
            });
          } else {
            updateHoverPoint(function (time) {
              return (0, toTime.goTime)(time, -1, 'days');
            });
          }
          return;
        case _KeyCode2['default'].RIGHT:
          if (ctrlKey) {
            updateHoverPoint(function (time) {
              return (0, toTime.goTime)(time, 1, 'years');
            });
          } else {
            updateHoverPoint(function (time) {
              return (0, toTime.goTime)(time, 1, 'days');
            });
          }
          return;
        case _KeyCode2['default'].HOME:
          updateHoverPoint(function (time) {
            return (0, toTime.goStartMonth)(time);
          });
          return;
        case _KeyCode2['default'].END:
          updateHoverPoint(function (time) {
            return (0, toTime.goEndMonth)(time);
          });
          return;
        case _KeyCode2['default'].PAGE_DOWN:
          updateHoverPoint(function (time) {
            return (0, toTime.goTime)(time, 1, 'month');
          });
          return;
        case _KeyCode2['default'].PAGE_UP:
          updateHoverPoint(function (time) {
            return (0, toTime.goTime)(time, -1, 'month');
          });
          return;
        case _KeyCode2['default'].ENTER:
          {
            var lastValue = void 0;
            if (hoverValue.length === 0) {
              lastValue = updateHoverPoint(function (time) {
                return time;
              });
            } else if (hoverValue.length === 1) {
              lastValue = hoverValue[0];
            } else {
              lastValue = hoverValue[0].isSame(firstSelectedValue, 'day') ? hoverValue[1] : hoverValue[0];
            }
            if (lastValue && (!disabledDate || !disabledDate(lastValue))) {
              this.onSelect(lastValue);
            }
            event.preventDefault();
            return;
          }
        default:
          if (onKeyDown) {
            onKeyDown(event);
          }
      }
    },
    onDayHover: function onDayHover(value) {
      var hoverValue = [];
      var _state3 = this.state,
          selectedValue = _state3.selectedValue,
          firstSelectedValue = _state3.firstSelectedValue;
      var type = this.props.type;

      if (type === 'start' && selectedValue[1]) {
        hoverValue = this.compare(value, selectedValue[1]) < 0 ? [value, selectedValue[1]] : [value];
      } else if (type === 'end' && selectedValue[0]) {
        hoverValue = this.compare(value, selectedValue[0]) > 0 ? [selectedValue[0], value] : [];
      } else {
        if (!firstSelectedValue) {
          if (this.state.hoverValue.length) {
            this.setState({ hoverValue: [] });
          }
          return hoverValue;
        }
        hoverValue = this.compare(value, firstSelectedValue) < 0 ? [value, firstSelectedValue] : [firstSelectedValue, value];
      }
      this.fireHoverValueChange(hoverValue);

      return hoverValue;
    },
    onToday: function onToday() {
      var startValue = (0, util$2.getTodayTime)(this.state.value[0]);
      var endValue = startValue.clone().add(1, 'months');
      this.setState({ value: [startValue, endValue] });
    },
    onOpenTimePicker: function onOpenTimePicker() {
      this.setState({
        showTimePicker: true
      });
    },
    onCloseTimePicker: function onCloseTimePicker() {
      this.setState({
        showTimePicker: false
      });
    },
    onOk: function onOk() {
      var selectedValue = this.state.selectedValue;

      if (this.isAllowedDateAndTime(selectedValue)) {
        this.props.onOk(this.state.selectedValue);
      }
    },
    onStartInputSelect: function onStartInputSelect() {
      for (var _len = arguments.length, oargs = Array(_len), _key = 0; _key < _len; _key++) {
        oargs[_key] = arguments[_key];
      }

      var args = ['left'].concat(oargs);
      return onInputSelect.apply(this, args);
    },
    onEndInputSelect: function onEndInputSelect() {
      for (var _len2 = arguments.length, oargs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        oargs[_key2] = arguments[_key2];
      }

      var args = ['right'].concat(oargs);
      return onInputSelect.apply(this, args);
    },
    onStartValueChange: function onStartValueChange(leftValue) {
      var value = [].concat(this.state.value);
      value[0] = leftValue;
      return this.fireValueChange(value);
    },
    onEndValueChange: function onEndValueChange(rightValue) {
      var value = [].concat(this.state.value);
      value[1] = rightValue;
      return this.fireValueChange(value);
    },
    onStartPanelChange: function onStartPanelChange(value, mode) {
      var props = this.props,
          state = this.state;

      var newMode = [mode, state.mode[1]];
      if (!('mode' in props)) {
        this.setState({
          mode: newMode
        });
      }
      var newValue = [value || state.value[0], state.value[1]];
      props.onPanelChange(newValue, newMode);
    },
    onEndPanelChange: function onEndPanelChange(value, mode) {
      var props = this.props,
          state = this.state;

      var newMode = [state.mode[0], mode];
      if (!('mode' in props)) {
        this.setState({
          mode: newMode
        });
      }
      var newValue = [state.value[0], value || state.value[1]];
      props.onPanelChange(newValue, newMode);
    },
    getStartValue: function getStartValue() {
      var value = this.state.value[0];
      var selectedValue = this.state.selectedValue;
      // keep selectedTime when select date
      if (selectedValue[0] && this.props.timePicker) {
        value = value.clone();
        (0, util$2.syncTime)(selectedValue[0], value);
      }
      if (this.state.showTimePicker && selectedValue[0]) {
        return selectedValue[0];
      }
      return value;
    },
    getEndValue: function getEndValue() {
      var _state4 = this.state,
          value = _state4.value,
          selectedValue = _state4.selectedValue,
          showTimePicker = _state4.showTimePicker;

      var endValue = value[1] ? value[1].clone() : value[0].clone().add(1, 'month');
      // keep selectedTime when select date
      if (selectedValue[1] && this.props.timePicker) {
        (0, util$2.syncTime)(selectedValue[1], endValue);
      }
      if (showTimePicker) {
        return selectedValue[1] ? selectedValue[1] : this.getStartValue();
      }
      return endValue;
    },

    // get disabled hours for second picker
    getEndDisableTime: function getEndDisableTime() {
      var _state5 = this.state,
          selectedValue = _state5.selectedValue,
          value = _state5.value;
      var disabledTime = this.props.disabledTime;

      var userSettingDisabledTime = disabledTime(selectedValue, 'end') || {};
      var startValue = selectedValue && selectedValue[0] || value[0].clone();
      // if startTime and endTime is same day..
      // the second time picker will not able to pick time before first time picker
      if (!selectedValue[1] || startValue.isSame(selectedValue[1], 'day')) {
        var hours = startValue.hour();
        var minutes = startValue.minute();
        var second = startValue.second();
        var _disabledHours = userSettingDisabledTime.disabledHours,
            _disabledMinutes = userSettingDisabledTime.disabledMinutes,
            _disabledSeconds = userSettingDisabledTime.disabledSeconds;

        var oldDisabledMinutes = _disabledMinutes ? _disabledMinutes() : [];
        var olddisabledSeconds = _disabledSeconds ? _disabledSeconds() : [];
        _disabledHours = generateOptions(hours, _disabledHours);
        _disabledMinutes = generateOptions(minutes, _disabledMinutes);
        _disabledSeconds = generateOptions(second, _disabledSeconds);
        return {
          disabledHours: function disabledHours() {
            return _disabledHours;
          },
          disabledMinutes: function disabledMinutes(hour) {
            if (hour === hours) {
              return _disabledMinutes;
            }
            return oldDisabledMinutes;
          },
          disabledSeconds: function disabledSeconds(hour, minute) {
            if (hour === hours && minute === minutes) {
              return _disabledSeconds;
            }
            return olddisabledSeconds;
          }
        };
      }
      return userSettingDisabledTime;
    },
    isAllowedDateAndTime: function isAllowedDateAndTime(selectedValue) {
      return (0, util$2.isAllowedDate)(selectedValue[0], this.props.disabledDate, this.disabledStartTime) && (0, util$2.isAllowedDate)(selectedValue[1], this.props.disabledDate, this.disabledEndTime);
    },
    isMonthYearPanelShow: function isMonthYearPanelShow(mode) {
      return ['month', 'year', 'decade'].indexOf(mode) > -1;
    },
    hasSelectedValue: function hasSelectedValue() {
      var selectedValue = this.state.selectedValue;

      return !!selectedValue[1] && !!selectedValue[0];
    },
    compare: function compare(v1, v2) {
      if (this.props.timePicker) {
        return v1.diff(v2);
      }
      return v1.diff(v2, 'days');
    },
    fireSelectValueChange: function fireSelectValueChange(selectedValue, direct) {
      var timePicker = this.props.timePicker;
      var prevSelectedValue = this.state.prevSelectedValue;

      if (timePicker && timePicker.props.defaultValue) {
        var timePickerDefaultValue = timePicker.props.defaultValue;
        if (!prevSelectedValue[0] && selectedValue[0]) {
          (0, util$2.syncTime)(timePickerDefaultValue[0], selectedValue[0]);
        }
        if (!prevSelectedValue[1] && selectedValue[1]) {
          (0, util$2.syncTime)(timePickerDefaultValue[1], selectedValue[1]);
        }
      }

      if (!('selectedValue' in this.props)) {
        this.setState({
          selectedValue: selectedValue
        });
      }

      // 尚未选择过时间，直接输入的话
      if (!this.state.selectedValue[0] || !this.state.selectedValue[1]) {
        var startValue = selectedValue[0] || (0, _moment2['default'])();
        var endValue = selectedValue[1] || startValue.clone().add(1, 'months');
        this.setState({
          selectedValue: selectedValue,
          value: getValueFromSelectedValue([startValue, endValue])
        });
      }

      if (selectedValue[0] && !selectedValue[1]) {
        this.setState({ firstSelectedValue: selectedValue[0] });
        this.fireHoverValueChange(selectedValue.concat());
      }
      this.props.onChange(selectedValue);
      if (direct || selectedValue[0] && selectedValue[1]) {
        this.setState({
          prevSelectedValue: selectedValue,
          firstSelectedValue: null
        });
        this.fireHoverValueChange([]);
        this.props.onSelect(selectedValue);
      }
    },
    fireValueChange: function fireValueChange(value) {
      var props = this.props;
      if (!('value' in props)) {
        this.setState({
          value: value
        });
      }
      props.onValueChange(value);
    },
    fireHoverValueChange: function fireHoverValueChange(hoverValue) {
      var props = this.props;
      if (!('hoverValue' in props)) {
        this.setState({ hoverValue: hoverValue });
      }
      props.onHoverChange(hoverValue);
    },
    clear: function clear() {
      this.fireSelectValueChange([], true);
      this.props.onClear();
    },
    disabledStartTime: function disabledStartTime(time) {
      return this.props.disabledTime(time, 'start');
    },
    disabledEndTime: function disabledEndTime(time) {
      return this.props.disabledTime(time, 'end');
    },
    disabledStartMonth: function disabledStartMonth(month) {
      var value = this.state.value;

      return month.isSameOrAfter(value[1], 'month');
    },
    disabledEndMonth: function disabledEndMonth(month) {
      var value = this.state.value;

      return month.isSameOrBefore(value[0], 'month');
    },
    render: function render() {
      var _className, _classnames;

      var props = this.props,
          state = this.state;
      var prefixCls = props.prefixCls,
          dateInputPlaceholder = props.dateInputPlaceholder,
          timePicker = props.timePicker,
          showOk = props.showOk,
          locale = props.locale,
          showClear = props.showClear,
          showToday = props.showToday,
          type = props.type;
      var hoverValue = state.hoverValue,
          selectedValue = state.selectedValue,
          mode = state.mode,
          showTimePicker = state.showTimePicker;

      var className = (_className = {}, _className[props.className] = !!props.className, _className[prefixCls] = 1, _className[prefixCls + '-hidden'] = !props.visible, _className[prefixCls + '-range'] = 1, _className[prefixCls + '-show-time-picker'] = showTimePicker, _className[prefixCls + '-week-number'] = props.showWeekNumber, _className);
      var classes = (0, _classnames3['default'])(className);
      var newProps = {
        selectedValue: state.selectedValue,
        onSelect: this.onSelect,
        onDayHover: type === 'start' && selectedValue[1] || type === 'end' && selectedValue[0] || !!hoverValue.length ? this.onDayHover : undefined
      };

      var placeholder1 = void 0;
      var placeholder2 = void 0;

      if (dateInputPlaceholder) {
        if (Array.isArray(dateInputPlaceholder)) {
          placeholder1 = dateInputPlaceholder[0];
          placeholder2 = dateInputPlaceholder[1];
        } else {
          placeholder1 = placeholder2 = dateInputPlaceholder;
        }
      }
      var showOkButton = showOk === true || showOk !== false && !!timePicker;
      var cls = (0, _classnames3['default'])((_classnames = {}, _classnames[prefixCls + '-footer'] = true, _classnames[prefixCls + '-range-bottom'] = true, _classnames[prefixCls + '-footer-show-ok'] = showOkButton, _classnames));

      var startValue = this.getStartValue();
      var endValue = this.getEndValue();
      var todayTime = (0, util$2.getTodayTime)(startValue);
      var thisMonth = todayTime.month();
      var thisYear = todayTime.year();
      var isTodayInView = startValue.year() === thisYear && startValue.month() === thisMonth || endValue.year() === thisYear && endValue.month() === thisMonth;
      var nextMonthOfStart = startValue.clone().add(1, 'months');
      var isClosestMonths = nextMonthOfStart.year() === endValue.year() && nextMonthOfStart.month() === endValue.month();

      // console.warn('Render:', selectedValue.map(t => t.format('YYYY-MM-DD')).join(', '));
      // console.log('start:', startValue.format('YYYY-MM-DD'));
      // console.log('end:', endValue.format('YYYY-MM-DD'));

      return _react2['default'].createElement(
        'div',
        {
          ref: this.saveRoot,
          className: classes,
          style: props.style,
          tabIndex: '0',
          onKeyDown: this.onKeyDown
        },
        props.renderSidebar(),
        _react2['default'].createElement(
          'div',
          { className: prefixCls + '-panel' },
          showClear && selectedValue[0] && selectedValue[1] ? _react2['default'].createElement('a', {
            className: prefixCls + '-clear-btn',
            role: 'button',
            title: locale.clear,
            onClick: this.clear
          }) : null,
          _react2['default'].createElement(
            'div',
            {
              className: prefixCls + '-date-panel',
              onMouseLeave: type !== 'both' ? this.onDatePanelLeave : undefined,
              onMouseEnter: type !== 'both' ? this.onDatePanelEnter : undefined
            },
            _react2['default'].createElement(_CalendarPart2['default'], (0, _extends3['default'])({}, props, newProps, {
              hoverValue: hoverValue,
              direction: 'left',
              disabledTime: this.disabledStartTime,
              disabledMonth: this.disabledStartMonth,
              format: this.getFormat(),
              value: startValue,
              mode: mode[0],
              placeholder: placeholder1,
              onInputSelect: this.onStartInputSelect,
              onValueChange: this.onStartValueChange,
              onPanelChange: this.onStartPanelChange,
              showDateInput: this.props.showDateInput,
              timePicker: timePicker,
              showTimePicker: showTimePicker,
              enablePrev: true,
              enableNext: !isClosestMonths || this.isMonthYearPanelShow(mode[1])
            })),
            _react2['default'].createElement(
              'span',
              { className: prefixCls + '-range-middle' },
              '~'
            ),
            _react2['default'].createElement(_CalendarPart2['default'], (0, _extends3['default'])({}, props, newProps, {
              hoverValue: hoverValue,
              direction: 'right',
              format: this.getFormat(),
              timePickerDisabledTime: this.getEndDisableTime(),
              placeholder: placeholder2,
              value: endValue,
              mode: mode[1],
              onInputSelect: this.onEndInputSelect,
              onValueChange: this.onEndValueChange,
              onPanelChange: this.onEndPanelChange,
              showDateInput: this.props.showDateInput,
              timePicker: timePicker,
              showTimePicker: showTimePicker,
              disabledTime: this.disabledEndTime,
              disabledMonth: this.disabledEndMonth,
              enablePrev: !isClosestMonths || this.isMonthYearPanelShow(mode[0]),
              enableNext: true
            }))
          ),
          _react2['default'].createElement(
            'div',
            { className: cls },
            props.renderFooter(),
            showToday || props.timePicker || showOkButton ? _react2['default'].createElement(
              'div',
              { className: prefixCls + '-footer-btn' },
              showToday ? _react2['default'].createElement(_TodayButton2['default'], (0, _extends3['default'])({}, props, {
                disabled: isTodayInView,
                value: state.value[0],
                onToday: this.onToday,
                text: locale.backToToday
              })) : null,
              props.timePicker ? _react2['default'].createElement(_TimePickerButton2['default'], (0, _extends3['default'])({}, props, {
                showTimePicker: showTimePicker,
                onOpenTimePicker: this.onOpenTimePicker,
                onCloseTimePicker: this.onCloseTimePicker,
                timePickerDisabled: !this.hasSelectedValue() || hoverValue.length
              })) : null,
              showOkButton ? _react2['default'].createElement(_OkButton2['default'], (0, _extends3['default'])({}, props, {
                onOk: this.onOk,
                okDisabled: !this.isAllowedDateAndTime(selectedValue) || !this.hasSelectedValue() || hoverValue.length
              })) : null
            ) : null
          )
        )
      );
    }
  });

  exports['default'] = RangeCalendar;
  module.exports = exports['default'];
  });

  unwrapExports(RangeCalendar_1);

  var RangePicker_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var _slicedToArray3 = _interopRequireDefault(slicedToArray);



  var React = _interopRequireWildcard(React$1__default);



  var moment$$1 = _interopRequireWildcard(moment);



  var _RangeCalendar2 = _interopRequireDefault(RangeCalendar_1);



  var _Picker2 = _interopRequireDefault(Picker_1);



  var _classnames2 = _interopRequireDefault(classnames);



  var _icon2 = _interopRequireDefault(icon);



  var _warning2 = _interopRequireDefault(warning$4);



  var _interopDefault2 = _interopRequireDefault(interopDefault_1);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  /* tslint:disable jsx-no-multiline-js */
  function getShowDateFromValue(value) {
      var _value = (0, _slicedToArray3['default'])(value, 2),
          start = _value[0],
          end = _value[1];
      // value could be an empty array, then we should not reset showDate


      if (!start && !end) {
          return;
      }
      var newEnd = end && end.isSame(start, 'month') ? end.clone().add(1, 'month') : end;
      return [start, newEnd];
  }
  function formatValue(value, format) {
      return value && value.format(format) || '';
  }
  function pickerValueAdapter(value) {
      if (!value) {
          return;
      }
      if (Array.isArray(value)) {
          return value;
      }
      return [value, value.clone().add(1, 'month')];
  }
  function isEmptyArray(arr) {
      if (Array.isArray(arr)) {
          return arr.length === 0 || arr.every(function (i) {
              return !i;
          });
      }
      return false;
  }
  function fixLocale(value, localeCode) {
      if (!localeCode) {
          return;
      }
      if (!value || value.length === 0) {
          return;
      }
      if (value[0]) {
          value[0].locale(localeCode);
      }
      if (value[1]) {
          value[1].locale(localeCode);
      }
  }

  var RangePicker = function (_React$Component) {
      (0, _inherits3['default'])(RangePicker, _React$Component);

      function RangePicker(props) {
          (0, _classCallCheck3['default'])(this, RangePicker);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (RangePicker.__proto__ || Object.getPrototypeOf(RangePicker)).call(this, props));

          _this.clearSelection = function (e) {
              e.preventDefault();
              e.stopPropagation();
              _this.setState({ value: [] });
              _this.handleChange([]);
          };
          _this.clearHoverValue = function () {
              return _this.setState({ hoverValue: [] });
          };
          _this.handleChange = function (value) {
              var props = _this.props;
              if (!('value' in props)) {
                  _this.setState(function (_ref) {
                      var showDate = _ref.showDate;
                      return {
                          value: value,
                          showDate: getShowDateFromValue(value) || showDate
                      };
                  });
              }
              props.onChange(value, [formatValue(value[0], props.format), formatValue(value[1], props.format)]);
          };
          _this.handleOpenChange = function (open) {
              if (!('open' in _this.props)) {
                  _this.setState({ open: open });
              }
              if (open === false) {
                  _this.clearHoverValue();
              }
              var onOpenChange = _this.props.onOpenChange;

              if (onOpenChange) {
                  onOpenChange(open);
              }
          };
          _this.handleShowDateChange = function (showDate) {
              return _this.setState({ showDate: showDate });
          };
          _this.handleHoverChange = function (hoverValue) {
              return _this.setState({ hoverValue: hoverValue });
          };
          _this.handleRangeMouseLeave = function () {
              if (_this.state.open) {
                  _this.clearHoverValue();
              }
          };
          _this.handleCalendarInputSelect = function (value) {
              if (!value[0]) {
                  return;
              }
              _this.setState(function (_ref2) {
                  var showDate = _ref2.showDate;
                  return {
                      value: value,
                      showDate: getShowDateFromValue(value) || showDate
                  };
              });
          };
          _this.handleRangeClick = function (value) {
              if (typeof value === 'function') {
                  value = value();
              }
              _this.setValue(value, true);
              var onOk = _this.props.onOk;

              if (onOk) {
                  onOk(value);
              }
          };
          _this.savePicker = function (node) {
              _this.picker = node;
          };
          _this.renderFooter = function () {
              var _this$props = _this.props,
                  prefixCls = _this$props.prefixCls,
                  ranges = _this$props.ranges,
                  renderExtraFooter = _this$props.renderExtraFooter;

              if (!ranges && !renderExtraFooter) {
                  return null;
              }
              var customFooter = renderExtraFooter ? React.createElement(
                  'div',
                  { className: prefixCls + '-footer-extra', key: 'extra' },
                  renderExtraFooter.apply(undefined, arguments)
              ) : null;
              var operations = Object.keys(ranges || {}).map(function (range) {
                  var value = ranges[range];
                  return React.createElement(
                      'a',
                      { key: range, onClick: function onClick() {
                              return _this.handleRangeClick(value);
                          }, onMouseEnter: function onMouseEnter() {
                              return _this.setState({ hoverValue: value });
                          }, onMouseLeave: _this.handleRangeMouseLeave },
                      range
                  );
              });
              var rangeNode = React.createElement(
                  'div',
                  { className: prefixCls + '-footer-extra ' + prefixCls + '-range-quick-selector', key: 'range' },
                  operations
              );
              return [rangeNode, customFooter];
          };
          var value = props.value || props.defaultValue || [];
          if (value[0] && !(0, _interopDefault2['default'])(moment$$1).isMoment(value[0]) || value[1] && !(0, _interopDefault2['default'])(moment$$1).isMoment(value[1])) {
              throw new Error('The value/defaultValue of RangePicker must be a moment object array after `antd@2.0`, ' + 'see: https://u.ant.design/date-picker-value');
          }
          var pickerValue = !value || isEmptyArray(value) ? props.defaultPickerValue : value;
          _this.state = {
              value: value,
              showDate: pickerValueAdapter(pickerValue || (0, _interopDefault2['default'])(moment$$1)()),
              open: props.open,
              hoverValue: []
          };
          return _this;
      }

      (0, _createClass3['default'])(RangePicker, [{
          key: 'componentWillReceiveProps',
          value: function componentWillReceiveProps(nextProps) {
              if ('value' in nextProps) {
                  var state = this.state;
                  var value = nextProps.value || [];
                  this.setState({
                      value: value,
                      showDate: getShowDateFromValue(value) || state.showDate
                  });
              }
              if ('open' in nextProps) {
                  this.setState({
                      open: nextProps.open
                  });
              }
          }
      }, {
          key: 'setValue',
          value: function setValue(value, hidePanel) {
              this.handleChange(value);
              if ((hidePanel || !this.props.showTime) && !('open' in this.props)) {
                  this.setState({ open: false });
              }
          }
      }, {
          key: 'focus',
          value: function focus() {
              this.picker.focus();
          }
      }, {
          key: 'blur',
          value: function blur() {
              this.picker.blur();
          }
      }, {
          key: 'render',
          value: function render() {
              var _classNames,
                  _this2 = this;

              var state = this.state,
                  props = this.props;
              var value = state.value,
                  showDate = state.showDate,
                  hoverValue = state.hoverValue,
                  open = state.open;
              var prefixCls = props.prefixCls,
                  popupStyle = props.popupStyle,
                  style = props.style,
                  disabledDate = props.disabledDate,
                  disabledTime = props.disabledTime,
                  showTime = props.showTime,
                  showToday = props.showToday,
                  ranges = props.ranges,
                  onOk = props.onOk,
                  locale = props.locale,
                  localeCode = props.localeCode,
                  format = props.format,
                  dateRender = props.dateRender,
                  onCalendarChange = props.onCalendarChange;

              fixLocale(value, localeCode);
              fixLocale(showDate, localeCode);
              (0, _warning2['default'])(!('onOK' in props), 'It should be `RangePicker[onOk]`, instead of `onOK`!');
              var calendarClassName = (0, _classnames2['default'])((_classNames = {}, (0, _defineProperty3['default'])(_classNames, prefixCls + '-time', showTime), (0, _defineProperty3['default'])(_classNames, prefixCls + '-range-with-ranges', ranges), _classNames));
              // 需要选择时间时，点击 ok 时才触发 onChange
              var pickerChangeHandler = {
                  onChange: this.handleChange
              };
              var calendarProps = {
                  onOk: this.handleChange
              };
              if (props.timePicker) {
                  pickerChangeHandler.onChange = function (changedValue) {
                      return _this2.handleChange(changedValue);
                  };
              } else {
                  calendarProps = {};
              }
              if ('mode' in props) {
                  calendarProps.mode = props.mode;
              }
              var startPlaceholder = 'placeholder' in props ? props.placeholder[0] : locale.lang.rangePlaceholder[0];
              var endPlaceholder = 'placeholder' in props ? props.placeholder[1] : locale.lang.rangePlaceholder[1];
              var calendar = React.createElement(_RangeCalendar2['default'], (0, _extends3['default'])({}, calendarProps, { onChange: onCalendarChange, format: format, prefixCls: prefixCls, className: calendarClassName, renderFooter: this.renderFooter, timePicker: props.timePicker, disabledDate: disabledDate, disabledTime: disabledTime, dateInputPlaceholder: [startPlaceholder, endPlaceholder], locale: locale.lang, onOk: onOk, dateRender: dateRender, value: showDate, onValueChange: this.handleShowDateChange, hoverValue: hoverValue, onHoverChange: this.handleHoverChange, onPanelChange: props.onPanelChange, showToday: showToday, onInputSelect: this.handleCalendarInputSelect }));
              // default width for showTime
              var pickerStyle = {};
              if (props.showTime) {
                  pickerStyle.width = style && style.width || 350;
              }
              var clearIcon = !props.disabled && props.allowClear && value && (value[0] || value[1]) ? React.createElement(_icon2['default'], { type: 'cross-circle', className: prefixCls + '-picker-clear', onClick: this.clearSelection }) : null;
              var input = function input(_ref3) {
                  var inputValue = _ref3.value;

                  var start = inputValue[0];
                  var end = inputValue[1];
                  return React.createElement(
                      'span',
                      { className: props.pickerInputClass },
                      React.createElement('input', { disabled: props.disabled, readOnly: true, value: start && start.format(props.format) || '', placeholder: startPlaceholder, className: prefixCls + '-range-picker-input', tabIndex: -1 }),
                      React.createElement(
                          'span',
                          { className: prefixCls + '-range-picker-separator' },
                          ' ~ '
                      ),
                      React.createElement('input', { disabled: props.disabled, readOnly: true, value: end && end.format(props.format) || '', placeholder: endPlaceholder, className: prefixCls + '-range-picker-input', tabIndex: -1 }),
                      clearIcon,
                      React.createElement('span', { className: prefixCls + '-picker-icon' })
                  );
              };
              return React.createElement(
                  'span',
                  { ref: this.savePicker, id: props.id, className: (0, _classnames2['default'])(props.className, props.pickerClass), style: (0, _extends3['default'])({}, style, pickerStyle), tabIndex: props.disabled ? -1 : 0, onFocus: props.onFocus, onBlur: props.onBlur },
                  React.createElement(
                      _Picker2['default'],
                      (0, _extends3['default'])({}, props, pickerChangeHandler, { calendar: calendar, value: value, open: open, onOpenChange: this.handleOpenChange, prefixCls: prefixCls + '-picker-container', style: popupStyle }),
                      input
                  )
              );
          }
      }]);
      return RangePicker;
  }(React.Component);

  exports['default'] = RangePicker;

  RangePicker.defaultProps = {
      prefixCls: 'ant-calendar',
      allowClear: true,
      showToday: false
  };
  module.exports = exports['default'];
  });

  unwrapExports(RangePicker_1);

  var _rcCalendar = getCjsExportFromNamespace(es$5);

  var WeekPicker_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var moment$$1 = _interopRequireWildcard(moment);



  var _rcCalendar2 = _interopRequireDefault(_rcCalendar);



  var _Picker2 = _interopRequireDefault(Picker_1);



  var _classnames2 = _interopRequireDefault(classnames);



  var _icon2 = _interopRequireDefault(icon);



  var _interopDefault2 = _interopRequireDefault(interopDefault_1);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function formatValue(value, format) {
      return value && value.format(format) || '';
  }

  var WeekPicker = function (_React$Component) {
      (0, _inherits3['default'])(WeekPicker, _React$Component);

      function WeekPicker(props) {
          (0, _classCallCheck3['default'])(this, WeekPicker);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (WeekPicker.__proto__ || Object.getPrototypeOf(WeekPicker)).call(this, props));

          _this.weekDateRender = function (current) {
              var selectedValue = _this.state.value;
              var prefixCls = _this.props.prefixCls;

              if (selectedValue && current.year() === selectedValue.year() && current.week() === selectedValue.week()) {
                  return React.createElement(
                      'div',
                      { className: prefixCls + '-selected-day' },
                      React.createElement(
                          'div',
                          { className: prefixCls + '-date' },
                          current.date()
                      )
                  );
              }
              return React.createElement(
                  'div',
                  { className: prefixCls + '-date' },
                  current.date()
              );
          };
          _this.handleChange = function (value) {
              if (!('value' in _this.props)) {
                  _this.setState({ value: value });
              }
              _this.props.onChange(value, formatValue(value, _this.props.format));
          };
          _this.clearSelection = function (e) {
              e.preventDefault();
              e.stopPropagation();
              _this.handleChange(null);
          };
          _this.saveInput = function (node) {
              _this.input = node;
          };
          var value = props.value || props.defaultValue;
          if (value && !(0, _interopDefault2['default'])(moment$$1).isMoment(value)) {
              throw new Error('The value/defaultValue of DatePicker or MonthPicker must be ' + 'a moment object after `antd@2.0`, see: https://u.ant.design/date-picker-value');
          }
          _this.state = {
              value: value
          };
          return _this;
      }

      (0, _createClass3['default'])(WeekPicker, [{
          key: 'componentWillReceiveProps',
          value: function componentWillReceiveProps(nextProps) {
              if ('value' in nextProps) {
                  this.setState({ value: nextProps.value });
              }
          }
      }, {
          key: 'focus',
          value: function focus() {
              this.input.focus();
          }
      }, {
          key: 'blur',
          value: function blur() {
              this.input.blur();
          }
      }, {
          key: 'render',
          value: function render() {
              var _this2 = this;

              var _props = this.props,
                  prefixCls = _props.prefixCls,
                  className = _props.className,
                  disabled = _props.disabled,
                  pickerClass = _props.pickerClass,
                  popupStyle = _props.popupStyle,
                  pickerInputClass = _props.pickerInputClass,
                  format = _props.format,
                  allowClear = _props.allowClear,
                  locale = _props.locale,
                  localeCode = _props.localeCode,
                  disabledDate = _props.disabledDate,
                  style = _props.style,
                  onFocus = _props.onFocus,
                  onBlur = _props.onBlur;

              var pickerValue = this.state.value;
              if (pickerValue && localeCode) {
                  pickerValue.locale(localeCode);
              }
              var placeholder = 'placeholder' in this.props ? this.props.placeholder : locale.lang.placeholder;
              var calendar = React.createElement(_rcCalendar2['default'], { showWeekNumber: true, dateRender: this.weekDateRender, prefixCls: prefixCls, format: format, locale: locale.lang, showDateInput: false, showToday: false, disabledDate: disabledDate });
              var clearIcon = !disabled && allowClear && this.state.value ? React.createElement(_icon2['default'], { type: 'cross-circle', className: prefixCls + '-picker-clear', onClick: this.clearSelection }) : null;
              var input = function input(_ref) {
                  var value = _ref.value;

                  return React.createElement(
                      'span',
                      null,
                      React.createElement('input', { ref: _this2.saveInput, disabled: disabled, readOnly: true, value: value && value.format(format) || '', placeholder: placeholder, className: pickerInputClass, onFocus: onFocus, onBlur: onBlur, style: style }),
                      clearIcon,
                      React.createElement('span', { className: prefixCls + '-picker-icon' })
                  );
              };
              return React.createElement(
                  'span',
                  { className: (0, _classnames2['default'])(className, pickerClass), id: this.props.id },
                  React.createElement(
                      _Picker2['default'],
                      (0, _extends3['default'])({}, this.props, { calendar: calendar, prefixCls: prefixCls + '-picker-container', value: pickerValue, onChange: this.handleChange, style: popupStyle }),
                      input
                  )
              );
          }
      }]);
      return WeekPicker;
  }(React.Component);

  exports['default'] = WeekPicker;

  WeekPicker.defaultProps = {
      format: 'gggg-wo',
      allowClear: true
  };
  module.exports = exports['default'];
  });

  unwrapExports(WeekPicker_1);

  var datePicker = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _rcCalendar2 = _interopRequireDefault(_rcCalendar);



  var _MonthCalendar2 = _interopRequireDefault(MonthCalendar_1);



  var _createPicker2 = _interopRequireDefault(createPicker_1);



  var _wrapPicker2 = _interopRequireDefault(wrapPicker_1);



  var _RangePicker2 = _interopRequireDefault(RangePicker_1);



  var _WeekPicker2 = _interopRequireDefault(WeekPicker_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var DatePicker = (0, _wrapPicker2['default'])((0, _createPicker2['default'])(_rcCalendar2['default']));
  var MonthPicker = (0, _wrapPicker2['default'])((0, _createPicker2['default'])(_MonthCalendar2['default']), 'YYYY-MM');
  (0, _extends3['default'])(DatePicker, {
      RangePicker: (0, _wrapPicker2['default'])(_RangePicker2['default']),
      MonthPicker: MonthPicker,
      WeekPicker: (0, _wrapPicker2['default'])(_WeekPicker2['default'], 'gggg-wo')
  });
  exports['default'] = DatePicker;
  module.exports = exports['default'];
  });

  unwrapExports(datePicker);

  // Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js
  // (MIT licensed)

  const BUFFER = Symbol('buffer');
  const TYPE = Symbol('type');

  class Blob {
  	constructor() {
  		this[TYPE] = '';

  		const blobParts = arguments[0];
  		const options = arguments[1];

  		const buffers = [];

  		if (blobParts) {
  			const a = blobParts;
  			const length = Number(a.length);
  			for (let i = 0; i < length; i++) {
  				const element = a[i];
  				let buffer;
  				if (element instanceof Buffer) {
  					buffer = element;
  				} else if (ArrayBuffer.isView(element)) {
  					buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
  				} else if (element instanceof ArrayBuffer) {
  					buffer = Buffer.from(element);
  				} else if (element instanceof Blob) {
  					buffer = element[BUFFER];
  				} else {
  					buffer = Buffer.from(typeof element === 'string' ? element : String(element));
  				}
  				buffers.push(buffer);
  			}
  		}

  		this[BUFFER] = Buffer.concat(buffers);

  		let type = options && options.type !== undefined && String(options.type).toLowerCase();
  		if (type && !/[^\u0020-\u007E]/.test(type)) {
  			this[TYPE] = type;
  		}
  	}
  	get size() {
  		return this[BUFFER].length;
  	}
  	get type() {
  		return this[TYPE];
  	}
  	slice() {
  		const size = this.size;

  		const start = arguments[0];
  		const end = arguments[1];
  		let relativeStart, relativeEnd;
  		if (start === undefined) {
  			relativeStart = 0;
  		} else if (start < 0) {
  			relativeStart = Math.max(size + start, 0);
  		} else {
  			relativeStart = Math.min(start, size);
  		}
  		if (end === undefined) {
  			relativeEnd = size;
  		} else if (end < 0) {
  			relativeEnd = Math.max(size + end, 0);
  		} else {
  			relativeEnd = Math.min(end, size);
  		}
  		const span = Math.max(relativeEnd - relativeStart, 0);

  		const buffer = this[BUFFER];
  		const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
  		const blob = new Blob([], { type: arguments[2] });
  		blob[BUFFER] = slicedBuffer;
  		return blob;
  	}
  }

  Object.defineProperties(Blob.prototype, {
  	size: { enumerable: true },
  	type: { enumerable: true },
  	slice: { enumerable: true }
  });

  Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
  	value: 'Blob',
  	writable: false,
  	enumerable: false,
  	configurable: true
  });

  /**
   * fetch-error.js
   *
   * FetchError interface for operational errors
   */

  /**
   * Create FetchError instance
   *
   * @param   String      message      Error message for human
   * @param   String      type         Error type for machine
   * @param   String      systemError  For Node.js system error
   * @return  FetchError
   */
  function FetchError(message, type, systemError) {
    Error.call(this, message);

    this.message = message;
    this.type = type;

    // when err.type is `system`, err.code contains system error code
    if (systemError) {
      this.code = this.errno = systemError.code;
    }

    // hide custom error implementation details from end-users
    Error.captureStackTrace(this, this.constructor);
  }

  FetchError.prototype = Object.create(Error.prototype);
  FetchError.prototype.constructor = FetchError;
  FetchError.prototype.name = 'FetchError';

  /**
   * body.js
   *
   * Body interface provides common methods for Request and Response
   */

  const Stream = require('stream');

  var _require = require('stream');

  const PassThrough = _require.PassThrough;


  let convert;
  try {
  	convert = require('encoding').convert;
  } catch (e) {}

  const INTERNALS = Symbol('Body internals');

  /**
   * Body mixin
   *
   * Ref: https://fetch.spec.whatwg.org/#body
   *
   * @param   Stream  body  Readable stream
   * @param   Object  opts  Response options
   * @return  Void
   */
  function Body(body) {
  	var _this = this;

  	var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
  	    _ref$size = _ref.size;

  	let size = _ref$size === undefined ? 0 : _ref$size;
  	var _ref$timeout = _ref.timeout;
  	let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;

  	if (body == null) {
  		// body is undefined or null
  		body = null;
  	} else if (typeof body === 'string') ; else if (isURLSearchParams(body)) ; else if (body instanceof Blob) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') ; else if (body instanceof Stream) ; else {
  		// none of the above
  		// coerce to string
  		body = String(body);
  	}
  	this[INTERNALS] = {
  		body,
  		disturbed: false,
  		error: null
  	};
  	this.size = size;
  	this.timeout = timeout;

  	if (body instanceof Stream) {
  		body.on('error', function (err) {
  			_this[INTERNALS].error = new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);
  		});
  	}
  }

  Body.prototype = {
  	get body() {
  		return this[INTERNALS].body;
  	},

  	get bodyUsed() {
  		return this[INTERNALS].disturbed;
  	},

  	/**
    * Decode response as ArrayBuffer
    *
    * @return  Promise
    */
  	arrayBuffer() {
  		return consumeBody.call(this).then(function (buf) {
  			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
  		});
  	},

  	/**
    * Return raw response as Blob
    *
    * @return Promise
    */
  	blob() {
  		let ct = this.headers && this.headers.get('content-type') || '';
  		return consumeBody.call(this).then(function (buf) {
  			return Object.assign(
  			// Prevent copying
  			new Blob([], {
  				type: ct.toLowerCase()
  			}), {
  				[BUFFER]: buf
  			});
  		});
  	},

  	/**
    * Decode response as json
    *
    * @return  Promise
    */
  	json() {
  		var _this2 = this;

  		return consumeBody.call(this).then(function (buffer) {
  			try {
  				return JSON.parse(buffer.toString());
  			} catch (err) {
  				return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));
  			}
  		});
  	},

  	/**
    * Decode response as text
    *
    * @return  Promise
    */
  	text() {
  		return consumeBody.call(this).then(function (buffer) {
  			return buffer.toString();
  		});
  	},

  	/**
    * Decode response as buffer (non-spec api)
    *
    * @return  Promise
    */
  	buffer() {
  		return consumeBody.call(this);
  	},

  	/**
    * Decode response as text, while automatically detecting the encoding and
    * trying to decode to UTF-8 (non-spec api)
    *
    * @return  Promise
    */
  	textConverted() {
  		var _this3 = this;

  		return consumeBody.call(this).then(function (buffer) {
  			return convertBody(buffer, _this3.headers);
  		});
  	}

  };

  // In browsers, all properties are enumerable.
  Object.defineProperties(Body.prototype, {
  	body: { enumerable: true },
  	bodyUsed: { enumerable: true },
  	arrayBuffer: { enumerable: true },
  	blob: { enumerable: true },
  	json: { enumerable: true },
  	text: { enumerable: true }
  });

  Body.mixIn = function (proto) {
  	for (const name of Object.getOwnPropertyNames(Body.prototype)) {
  		// istanbul ignore else: future proof
  		if (!(name in proto)) {
  			const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
  			Object.defineProperty(proto, name, desc);
  		}
  	}
  };

  /**
   * Consume and convert an entire Body to a Buffer.
   *
   * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
   *
   * @return  Promise
   */
  function consumeBody() {
  	var _this4 = this;

  	if (this[INTERNALS].disturbed) {
  		return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
  	}

  	this[INTERNALS].disturbed = true;

  	if (this[INTERNALS].error) {
  		return Body.Promise.reject(this[INTERNALS].error);
  	}

  	// body is null
  	if (this.body === null) {
  		return Body.Promise.resolve(Buffer.alloc(0));
  	}

  	// body is string
  	if (typeof this.body === 'string') {
  		return Body.Promise.resolve(Buffer.from(this.body));
  	}

  	// body is blob
  	if (this.body instanceof Blob) {
  		return Body.Promise.resolve(this.body[BUFFER]);
  	}

  	// body is buffer
  	if (Buffer.isBuffer(this.body)) {
  		return Body.Promise.resolve(this.body);
  	}

  	// body is buffer
  	if (Object.prototype.toString.call(this.body) === '[object ArrayBuffer]') {
  		return Body.Promise.resolve(Buffer.from(this.body));
  	}

  	// istanbul ignore if: should never happen
  	if (!(this.body instanceof Stream)) {
  		return Body.Promise.resolve(Buffer.alloc(0));
  	}

  	// body is stream
  	// get ready to actually consume the body
  	let accum = [];
  	let accumBytes = 0;
  	let abort = false;

  	return new Body.Promise(function (resolve, reject) {
  		let resTimeout;

  		// allow timeout on slow response body
  		if (_this4.timeout) {
  			resTimeout = setTimeout(function () {
  				abort = true;
  				reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));
  			}, _this4.timeout);
  		}

  		// handle stream error, such as incorrect content-encoding
  		_this4.body.on('error', function (err) {
  			reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));
  		});

  		_this4.body.on('data', function (chunk) {
  			if (abort || chunk === null) {
  				return;
  			}

  			if (_this4.size && accumBytes + chunk.length > _this4.size) {
  				abort = true;
  				reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));
  				return;
  			}

  			accumBytes += chunk.length;
  			accum.push(chunk);
  		});

  		_this4.body.on('end', function () {
  			if (abort) {
  				return;
  			}

  			clearTimeout(resTimeout);

  			try {
  				resolve(Buffer.concat(accum));
  			} catch (err) {
  				// handle streams that have accumulated too much data (issue #414)
  				reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));
  			}
  		});
  	});
  }

  /**
   * Detect buffer encoding and convert to target encoding
   * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
   *
   * @param   Buffer  buffer    Incoming buffer
   * @param   String  encoding  Target encoding
   * @return  String
   */
  function convertBody(buffer, headers) {
  	if (typeof convert !== 'function') {
  		throw new Error('The package `encoding` must be installed to use the textConverted() function');
  	}

  	const ct = headers.get('content-type');
  	let charset = 'utf-8';
  	let res, str;

  	// header
  	if (ct) {
  		res = /charset=([^;]*)/i.exec(ct);
  	}

  	// no charset in content type, peek at response body for at most 1024 bytes
  	str = buffer.slice(0, 1024).toString();

  	// html5
  	if (!res && str) {
  		res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
  	}

  	// html4
  	if (!res && str) {
  		res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);

  		if (res) {
  			res = /charset=(.*)/i.exec(res.pop());
  		}
  	}

  	// xml
  	if (!res && str) {
  		res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
  	}

  	// found charset
  	if (res) {
  		charset = res.pop();

  		// prevent decode issues when sites use incorrect encoding
  		// ref: https://hsivonen.fi/encoding-menu/
  		if (charset === 'gb2312' || charset === 'gbk') {
  			charset = 'gb18030';
  		}
  	}

  	// turn raw buffers into a single utf-8 buffer
  	return convert(buffer, 'UTF-8', charset).toString();
  }

  /**
   * Detect a URLSearchParams object
   * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143
   *
   * @param   Object  obj     Object to detect by type or brand
   * @return  String
   */
  function isURLSearchParams(obj) {
  	// Duck-typing as a necessary condition.
  	if (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {
  		return false;
  	}

  	// Brand-checking and more duck-typing as optional condition.
  	return obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';
  }

  /**
   * Clone body given Res/Req instance
   *
   * @param   Mixed  instance  Response or Request instance
   * @return  Mixed
   */
  function clone(instance) {
  	let p1, p2;
  	let body = instance.body;

  	// don't allow cloning a used body
  	if (instance.bodyUsed) {
  		throw new Error('cannot clone body after it is used');
  	}

  	// check that body is a stream and not form-data object
  	// note: we can't clone the form-data object without having it as a dependency
  	if (body instanceof Stream && typeof body.getBoundary !== 'function') {
  		// tee instance body
  		p1 = new PassThrough();
  		p2 = new PassThrough();
  		body.pipe(p1);
  		body.pipe(p2);
  		// set instance body to teed body and return the other teed body
  		instance[INTERNALS].body = p1;
  		body = p2;
  	}

  	return body;
  }

  /**
   * Performs the operation "extract a `Content-Type` value from |object|" as
   * specified in the specification:
   * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
   *
   * This function assumes that instance.body is present.
   *
   * @param   Mixed  instance  Response or Request instance
   */
  function extractContentType(instance) {
  	const body = instance.body;

  	// istanbul ignore if: Currently, because of a guard in Request, body
  	// can never be null. Included here for completeness.

  	if (body === null) {
  		// body is null
  		return null;
  	} else if (typeof body === 'string') {
  		// body is string
  		return 'text/plain;charset=UTF-8';
  	} else if (isURLSearchParams(body)) {
  		// body is a URLSearchParams
  		return 'application/x-www-form-urlencoded;charset=UTF-8';
  	} else if (body instanceof Blob) {
  		// body is blob
  		return body.type || null;
  	} else if (Buffer.isBuffer(body)) {
  		// body is buffer
  		return null;
  	} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
  		// body is array buffer
  		return null;
  	} else if (typeof body.getBoundary === 'function') {
  		// detect form data input from form-data module
  		return `multipart/form-data;boundary=${body.getBoundary()}`;
  	} else {
  		// body is stream
  		// can't really do much about this
  		return null;
  	}
  }

  /**
   * The Fetch Standard treats this as if "total bytes" is a property on the body.
   * For us, we have to explicitly get it with a function.
   *
   * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
   *
   * @param   Body    instance   Instance of Body
   * @return  Number?            Number of bytes, or null if not possible
   */
  function getTotalBytes(instance) {
  	const body = instance.body;

  	// istanbul ignore if: included for completion

  	if (body === null) {
  		// body is null
  		return 0;
  	} else if (typeof body === 'string') {
  		// body is string
  		return Buffer.byteLength(body);
  	} else if (isURLSearchParams(body)) {
  		// body is URLSearchParams
  		return Buffer.byteLength(String(body));
  	} else if (body instanceof Blob) {
  		// body is blob
  		return body.size;
  	} else if (Buffer.isBuffer(body)) {
  		// body is buffer
  		return body.length;
  	} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
  		// body is array buffer
  		return body.byteLength;
  	} else if (body && typeof body.getLengthSync === 'function') {
  		// detect form data input from form-data module
  		if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
  		body.hasKnownLength && body.hasKnownLength()) {
  			// 2.x
  			return body.getLengthSync();
  		}
  		return null;
  	} else {
  		// body is stream
  		// can't really do much about this
  		return null;
  	}
  }

  /**
   * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
   *
   * @param   Body    instance   Instance of Body
   * @return  Void
   */
  function writeToStream(dest, instance) {
  	const body = instance.body;


  	if (body === null) {
  		// body is null
  		dest.end();
  	} else if (typeof body === 'string') {
  		// body is string
  		dest.write(body);
  		dest.end();
  	} else if (isURLSearchParams(body)) {
  		// body is URLSearchParams
  		dest.write(Buffer.from(String(body)));
  		dest.end();
  	} else if (body instanceof Blob) {
  		// body is blob
  		dest.write(body[BUFFER]);
  		dest.end();
  	} else if (Buffer.isBuffer(body)) {
  		// body is buffer
  		dest.write(body);
  		dest.end();
  	} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
  		// body is array buffer
  		dest.write(Buffer.from(body));
  		dest.end();
  	} else {
  		// body is stream
  		body.pipe(dest);
  	}
  }

  // expose Promise
  Body.Promise = global.Promise;

  /**
   * headers.js
   *
   * Headers class offers convenient helpers
   */

  const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
  const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;

  function validateName(name) {
  	name = `${name}`;
  	if (invalidTokenRegex.test(name)) {
  		throw new TypeError(`${name} is not a legal HTTP header name`);
  	}
  }

  function validateValue(value) {
  	value = `${value}`;
  	if (invalidHeaderCharRegex.test(value)) {
  		throw new TypeError(`${value} is not a legal HTTP header value`);
  	}
  }

  /**
   * Find the key in the map object given a header name.
   *
   * Returns undefined if not found.
   *
   * @param   String  name  Header name
   * @return  String|Undefined
   */
  function find(map, name) {
  	name = name.toLowerCase();
  	for (const key in map) {
  		if (key.toLowerCase() === name) {
  			return key;
  		}
  	}
  	return undefined;
  }

  const MAP = Symbol('map');
  class Headers {
  	/**
    * Headers class
    *
    * @param   Object  headers  Response headers
    * @return  Void
    */
  	constructor() {
  		let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

  		this[MAP] = Object.create(null);

  		if (init instanceof Headers) {
  			const rawHeaders = init.raw();
  			const headerNames = Object.keys(rawHeaders);

  			for (const headerName of headerNames) {
  				for (const value of rawHeaders[headerName]) {
  					this.append(headerName, value);
  				}
  			}

  			return;
  		}

  		// We don't worry about converting prop to ByteString here as append()
  		// will handle it.
  		if (init == null) ; else if (typeof init === 'object') {
  			const method = init[Symbol.iterator];
  			if (method != null) {
  				if (typeof method !== 'function') {
  					throw new TypeError('Header pairs must be iterable');
  				}

  				// sequence<sequence<ByteString>>
  				// Note: per spec we have to first exhaust the lists then process them
  				const pairs = [];
  				for (const pair of init) {
  					if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {
  						throw new TypeError('Each header pair must be iterable');
  					}
  					pairs.push(Array.from(pair));
  				}

  				for (const pair of pairs) {
  					if (pair.length !== 2) {
  						throw new TypeError('Each header pair must be a name/value tuple');
  					}
  					this.append(pair[0], pair[1]);
  				}
  			} else {
  				// record<ByteString, ByteString>
  				for (const key of Object.keys(init)) {
  					const value = init[key];
  					this.append(key, value);
  				}
  			}
  		} else {
  			throw new TypeError('Provided initializer must be an object');
  		}
  	}

  	/**
    * Return combined header value given name
    *
    * @param   String  name  Header name
    * @return  Mixed
    */
  	get(name) {
  		name = `${name}`;
  		validateName(name);
  		const key = find(this[MAP], name);
  		if (key === undefined) {
  			return null;
  		}

  		return this[MAP][key].join(', ');
  	}

  	/**
    * Iterate over all headers
    *
    * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
    * @param   Boolean   thisArg   `this` context for callback function
    * @return  Void
    */
  	forEach(callback) {
  		let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

  		let pairs = getHeaders(this);
  		let i = 0;
  		while (i < pairs.length) {
  			var _pairs$i = pairs[i];
  			const name = _pairs$i[0],
  			      value = _pairs$i[1];

  			callback.call(thisArg, value, name, this);
  			pairs = getHeaders(this);
  			i++;
  		}
  	}

  	/**
    * Overwrite header values given name
    *
    * @param   String  name   Header name
    * @param   String  value  Header value
    * @return  Void
    */
  	set(name, value) {
  		name = `${name}`;
  		value = `${value}`;
  		validateName(name);
  		validateValue(value);
  		const key = find(this[MAP], name);
  		this[MAP][key !== undefined ? key : name] = [value];
  	}

  	/**
    * Append a value onto existing header
    *
    * @param   String  name   Header name
    * @param   String  value  Header value
    * @return  Void
    */
  	append(name, value) {
  		name = `${name}`;
  		value = `${value}`;
  		validateName(name);
  		validateValue(value);
  		const key = find(this[MAP], name);
  		if (key !== undefined) {
  			this[MAP][key].push(value);
  		} else {
  			this[MAP][name] = [value];
  		}
  	}

  	/**
    * Check for header name existence
    *
    * @param   String   name  Header name
    * @return  Boolean
    */
  	has(name) {
  		name = `${name}`;
  		validateName(name);
  		return find(this[MAP], name) !== undefined;
  	}

  	/**
    * Delete all header values given name
    *
    * @param   String  name  Header name
    * @return  Void
    */
  	delete(name) {
  		name = `${name}`;
  		validateName(name);
  		const key = find(this[MAP], name);
  		if (key !== undefined) {
  			delete this[MAP][key];
  		}
  	}

  	/**
    * Return raw headers (non-spec api)
    *
    * @return  Object
    */
  	raw() {
  		return this[MAP];
  	}

  	/**
    * Get an iterator on keys.
    *
    * @return  Iterator
    */
  	keys() {
  		return createHeadersIterator(this, 'key');
  	}

  	/**
    * Get an iterator on values.
    *
    * @return  Iterator
    */
  	values() {
  		return createHeadersIterator(this, 'value');
  	}

  	/**
    * Get an iterator on entries.
    *
    * This is the default iterator of the Headers object.
    *
    * @return  Iterator
    */
  	[Symbol.iterator]() {
  		return createHeadersIterator(this, 'key+value');
  	}
  }
  Headers.prototype.entries = Headers.prototype[Symbol.iterator];

  Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
  	value: 'Headers',
  	writable: false,
  	enumerable: false,
  	configurable: true
  });

  Object.defineProperties(Headers.prototype, {
  	get: { enumerable: true },
  	forEach: { enumerable: true },
  	set: { enumerable: true },
  	append: { enumerable: true },
  	has: { enumerable: true },
  	delete: { enumerable: true },
  	keys: { enumerable: true },
  	values: { enumerable: true },
  	entries: { enumerable: true }
  });

  function getHeaders(headers) {
  	let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';

  	const keys = Object.keys(headers[MAP]).sort();
  	return keys.map(kind === 'key' ? function (k) {
  		return k.toLowerCase();
  	} : kind === 'value' ? function (k) {
  		return headers[MAP][k].join(', ');
  	} : function (k) {
  		return [k.toLowerCase(), headers[MAP][k].join(', ')];
  	});
  }

  const INTERNAL = Symbol('internal');

  function createHeadersIterator(target, kind) {
  	const iterator = Object.create(HeadersIteratorPrototype);
  	iterator[INTERNAL] = {
  		target,
  		kind,
  		index: 0
  	};
  	return iterator;
  }

  const HeadersIteratorPrototype = Object.setPrototypeOf({
  	next() {
  		// istanbul ignore if
  		if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
  			throw new TypeError('Value of `this` is not a HeadersIterator');
  		}

  		var _INTERNAL = this[INTERNAL];
  		const target = _INTERNAL.target,
  		      kind = _INTERNAL.kind,
  		      index = _INTERNAL.index;

  		const values = getHeaders(target, kind);
  		const len = values.length;
  		if (index >= len) {
  			return {
  				value: undefined,
  				done: true
  			};
  		}

  		this[INTERNAL].index = index + 1;

  		return {
  			value: values[index],
  			done: false
  		};
  	}
  }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));

  Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
  	value: 'HeadersIterator',
  	writable: false,
  	enumerable: false,
  	configurable: true
  });

  /**
   * Export the Headers object in a form that Node.js can consume.
   *
   * @param   Headers  headers
   * @return  Object
   */
  function exportNodeCompatibleHeaders(headers) {
  	const obj = Object.assign({ __proto__: null }, headers[MAP]);

  	// http.request() only supports string as Host header. This hack makes
  	// specifying custom Host header possible.
  	const hostHeaderKey = find(headers[MAP], 'Host');
  	if (hostHeaderKey !== undefined) {
  		obj[hostHeaderKey] = obj[hostHeaderKey][0];
  	}

  	return obj;
  }

  /**
   * Create a Headers object from an object of headers, ignoring those that do
   * not conform to HTTP grammar productions.
   *
   * @param   Object  obj  Object of headers
   * @return  Headers
   */
  function createHeadersLenient(obj) {
  	const headers = new Headers();
  	for (const name of Object.keys(obj)) {
  		if (invalidTokenRegex.test(name)) {
  			continue;
  		}
  		if (Array.isArray(obj[name])) {
  			for (const val of obj[name]) {
  				if (invalidHeaderCharRegex.test(val)) {
  					continue;
  				}
  				if (headers[MAP][name] === undefined) {
  					headers[MAP][name] = [val];
  				} else {
  					headers[MAP][name].push(val);
  				}
  			}
  		} else if (!invalidHeaderCharRegex.test(obj[name])) {
  			headers[MAP][name] = [obj[name]];
  		}
  	}
  	return headers;
  }

  /**
   * response.js
   *
   * Response class provides content decoding
   */

  var _require$1 = require('http');

  const STATUS_CODES = _require$1.STATUS_CODES;


  const INTERNALS$1 = Symbol('Response internals');

  /**
   * Response class
   *
   * @param   Stream  body  Readable stream
   * @param   Object  opts  Response options
   * @return  Void
   */
  class Response {
  	constructor() {
  		let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  		let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  		Body.call(this, body, opts);

  		const status = opts.status || 200;

  		this[INTERNALS$1] = {
  			url: opts.url,
  			status,
  			statusText: opts.statusText || STATUS_CODES[status],
  			headers: new Headers(opts.headers)
  		};
  	}

  	get url() {
  		return this[INTERNALS$1].url;
  	}

  	get status() {
  		return this[INTERNALS$1].status;
  	}

  	/**
    * Convenience property representing if the request ended normally
    */
  	get ok() {
  		return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
  	}

  	get statusText() {
  		return this[INTERNALS$1].statusText;
  	}

  	get headers() {
  		return this[INTERNALS$1].headers;
  	}

  	/**
    * Clone this response
    *
    * @return  Response
    */
  	clone() {
  		return new Response(clone(this), {
  			url: this.url,
  			status: this.status,
  			statusText: this.statusText,
  			headers: this.headers,
  			ok: this.ok
  		});
  	}
  }

  Body.mixIn(Response.prototype);

  Object.defineProperties(Response.prototype, {
  	url: { enumerable: true },
  	status: { enumerable: true },
  	ok: { enumerable: true },
  	statusText: { enumerable: true },
  	headers: { enumerable: true },
  	clone: { enumerable: true }
  });

  Object.defineProperty(Response.prototype, Symbol.toStringTag, {
  	value: 'Response',
  	writable: false,
  	enumerable: false,
  	configurable: true
  });

  /**
   * request.js
   *
   * Request class contains server only options
   *
   * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.
   */

  var _require$2 = require('url');

  const format_url = _require$2.format;
  const parse_url = _require$2.parse;


  const INTERNALS$2 = Symbol('Request internals');

  /**
   * Check if a value is an instance of Request.
   *
   * @param   Mixed   input
   * @return  Boolean
   */
  function isRequest(input) {
  	return typeof input === 'object' && typeof input[INTERNALS$2] === 'object';
  }

  /**
   * Request class
   *
   * @param   Mixed   input  Url or Request instance
   * @param   Object  init   Custom options
   * @return  Void
   */
  class Request {
  	constructor(input) {
  		let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  		let parsedURL;

  		// normalize input
  		if (!isRequest(input)) {
  			if (input && input.href) {
  				// in order to support Node.js' Url objects; though WHATWG's URL objects
  				// will fall into this branch also (since their `toString()` will return
  				// `href` property anyway)
  				parsedURL = parse_url(input.href);
  			} else {
  				// coerce input to a string before attempting to parse
  				parsedURL = parse_url(`${input}`);
  			}
  			input = {};
  		} else {
  			parsedURL = parse_url(input.url);
  		}

  		let method = init.method || input.method || 'GET';
  		method = method.toUpperCase();

  		if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
  			throw new TypeError('Request with GET/HEAD method cannot have body');
  		}

  		let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;

  		Body.call(this, inputBody, {
  			timeout: init.timeout || input.timeout || 0,
  			size: init.size || input.size || 0
  		});

  		const headers = new Headers(init.headers || input.headers || {});

  		if (init.body != null) {
  			const contentType = extractContentType(this);
  			if (contentType !== null && !headers.has('Content-Type')) {
  				headers.append('Content-Type', contentType);
  			}
  		}

  		this[INTERNALS$2] = {
  			method,
  			redirect: init.redirect || input.redirect || 'follow',
  			headers,
  			parsedURL
  		};

  		// node-fetch-only options
  		this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
  		this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
  		this.counter = init.counter || input.counter || 0;
  		this.agent = init.agent || input.agent;
  	}

  	get method() {
  		return this[INTERNALS$2].method;
  	}

  	get url() {
  		return format_url(this[INTERNALS$2].parsedURL);
  	}

  	get headers() {
  		return this[INTERNALS$2].headers;
  	}

  	get redirect() {
  		return this[INTERNALS$2].redirect;
  	}

  	/**
    * Clone this request
    *
    * @return  Request
    */
  	clone() {
  		return new Request(this);
  	}
  }

  Body.mixIn(Request.prototype);

  Object.defineProperty(Request.prototype, Symbol.toStringTag, {
  	value: 'Request',
  	writable: false,
  	enumerable: false,
  	configurable: true
  });

  Object.defineProperties(Request.prototype, {
  	method: { enumerable: true },
  	url: { enumerable: true },
  	headers: { enumerable: true },
  	redirect: { enumerable: true },
  	clone: { enumerable: true }
  });

  /**
   * Convert a Request to Node.js http request options.
   *
   * @param   Request  A Request instance
   * @return  Object   The options object to be passed to http.request
   */
  function getNodeRequestOptions(request) {
  	const parsedURL = request[INTERNALS$2].parsedURL;
  	const headers = new Headers(request[INTERNALS$2].headers);

  	// fetch step 1.3
  	if (!headers.has('Accept')) {
  		headers.set('Accept', '*/*');
  	}

  	// Basic fetch
  	if (!parsedURL.protocol || !parsedURL.hostname) {
  		throw new TypeError('Only absolute URLs are supported');
  	}

  	if (!/^https?:$/.test(parsedURL.protocol)) {
  		throw new TypeError('Only HTTP(S) protocols are supported');
  	}

  	// HTTP-network-or-cache fetch steps 2.4-2.7
  	let contentLengthValue = null;
  	if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
  		contentLengthValue = '0';
  	}
  	if (request.body != null) {
  		const totalBytes = getTotalBytes(request);
  		if (typeof totalBytes === 'number') {
  			contentLengthValue = String(totalBytes);
  		}
  	}
  	if (contentLengthValue) {
  		headers.set('Content-Length', contentLengthValue);
  	}

  	// HTTP-network-or-cache fetch step 2.11
  	if (!headers.has('User-Agent')) {
  		headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
  	}

  	// HTTP-network-or-cache fetch step 2.15
  	if (request.compress) {
  		headers.set('Accept-Encoding', 'gzip,deflate');
  	}
  	if (!headers.has('Connection') && !request.agent) {
  		headers.set('Connection', 'close');
  	}

  	// HTTP-network fetch step 4.2
  	// chunked encoding is handled by Node.js

  	return Object.assign({}, parsedURL, {
  		method: request.method,
  		headers: exportNodeCompatibleHeaders(headers),
  		agent: request.agent
  	});
  }

  /**
   * index.js
   *
   * a request API compatible with window.fetch
   *
   * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.
   */

  const http = require('http');
  const https = require('https');

  var _require$3 = require('stream');

  const PassThrough$1 = _require$3.PassThrough;

  var _require2 = require('url');

  const resolve_url = _require2.resolve;

  const zlib = require('zlib');

  /**
   * Fetch function
   *
   * @param   Mixed    url   Absolute url or Request instance
   * @param   Object   opts  Fetch options
   * @return  Promise
   */
  function fetch(url, opts) {

  	// allow custom promise
  	if (!fetch.Promise) {
  		throw new Error('native promise missing, set fetch.Promise to your favorite alternative');
  	}

  	Body.Promise = fetch.Promise;

  	// wrap http.request into fetch
  	return new fetch.Promise(function (resolve, reject) {
  		// build request object
  		const request = new Request(url, opts);
  		const options = getNodeRequestOptions(request);

  		const send = (options.protocol === 'https:' ? https : http).request;

  		// send request
  		const req = send(options);
  		let reqTimeout;

  		function finalize() {
  			req.abort();
  			clearTimeout(reqTimeout);
  		}

  		if (request.timeout) {
  			req.once('socket', function (socket) {
  				reqTimeout = setTimeout(function () {
  					reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));
  					finalize();
  				}, request.timeout);
  			});
  		}

  		req.on('error', function (err) {
  			reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));
  			finalize();
  		});

  		req.on('response', function (res) {
  			clearTimeout(reqTimeout);

  			const headers = createHeadersLenient(res.headers);

  			// HTTP fetch step 5
  			if (fetch.isRedirect(res.statusCode)) {
  				// HTTP fetch step 5.2
  				const location = headers.get('Location');

  				// HTTP fetch step 5.3
  				const locationURL = location === null ? null : resolve_url(request.url, location);

  				// HTTP fetch step 5.5
  				switch (request.redirect) {
  					case 'error':
  						reject(new FetchError(`redirect mode is set to error: ${request.url}`, 'no-redirect'));
  						finalize();
  						return;
  					case 'manual':
  						// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.
  						if (locationURL !== null) {
  							headers.set('Location', locationURL);
  						}
  						break;
  					case 'follow':
  						// HTTP-redirect fetch step 2
  						if (locationURL === null) {
  							break;
  						}

  						// HTTP-redirect fetch step 5
  						if (request.counter >= request.follow) {
  							reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
  							finalize();
  							return;
  						}

  						// HTTP-redirect fetch step 6 (counter increment)
  						// Create a new Request object.
  						const requestOpts = {
  							headers: new Headers(request.headers),
  							follow: request.follow,
  							counter: request.counter + 1,
  							agent: request.agent,
  							compress: request.compress,
  							method: request.method,
  							body: request.body
  						};

  						// HTTP-redirect fetch step 9
  						if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
  							reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
  							finalize();
  							return;
  						}

  						// HTTP-redirect fetch step 11
  						if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {
  							requestOpts.method = 'GET';
  							requestOpts.body = undefined;
  							requestOpts.headers.delete('content-length');
  						}

  						// HTTP-redirect fetch step 15
  						resolve(fetch(new Request(locationURL, requestOpts)));
  						finalize();
  						return;
  				}
  			}

  			// prepare response
  			let body = res.pipe(new PassThrough$1());
  			const response_options = {
  				url: request.url,
  				status: res.statusCode,
  				statusText: res.statusMessage,
  				headers: headers,
  				size: request.size,
  				timeout: request.timeout
  			};

  			// HTTP-network fetch step 12.1.1.3
  			const codings = headers.get('Content-Encoding');

  			// HTTP-network fetch step 12.1.1.4: handle content codings

  			// in following scenarios we ignore compression support
  			// 1. compression support is disabled
  			// 2. HEAD request
  			// 3. no Content-Encoding header
  			// 4. no content response (204)
  			// 5. content not modified response (304)
  			if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {
  				resolve(new Response(body, response_options));
  				return;
  			}

  			// For Node v6+
  			// Be less strict when decoding compressed responses, since sometimes
  			// servers send slightly invalid responses that are still accepted
  			// by common browsers.
  			// Always using Z_SYNC_FLUSH is what cURL does.
  			const zlibOptions = {
  				flush: zlib.Z_SYNC_FLUSH,
  				finishFlush: zlib.Z_SYNC_FLUSH
  			};

  			// for gzip
  			if (codings == 'gzip' || codings == 'x-gzip') {
  				body = body.pipe(zlib.createGunzip(zlibOptions));
  				resolve(new Response(body, response_options));
  				return;
  			}

  			// for deflate
  			if (codings == 'deflate' || codings == 'x-deflate') {
  				// handle the infamous raw deflate response from old servers
  				// a hack for old IIS and Apache servers
  				const raw = res.pipe(new PassThrough$1());
  				raw.once('data', function (chunk) {
  					// see http://stackoverflow.com/questions/37519828
  					if ((chunk[0] & 0x0F) === 0x08) {
  						body = body.pipe(zlib.createInflate());
  					} else {
  						body = body.pipe(zlib.createInflateRaw());
  					}
  					resolve(new Response(body, response_options));
  				});
  				return;
  			}

  			// otherwise, use response as-is
  			resolve(new Response(body, response_options));
  		});

  		writeToStream(req, request);
  	});
  }

  /**
   * Redirect code matching
   *
   * @param   Number   code  Status code
   * @return  Boolean
   */
  fetch.isRedirect = function (code) {
  	return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
  };

  // Needed for TypeScript.
  fetch.default = fetch;

  // expose Promise
  fetch.Promise = global.Promise;

  var index_es = /*#__PURE__*/Object.freeze({
    default: fetch,
    Headers: Headers,
    Request: Request,
    Response: Response,
    FetchError: FetchError
  });

  var nodeFetch = getCjsExportFromNamespace(index_es);

  var nodePonyfill = createCommonjsModule(function (module, exports) {
  var realFetch = nodeFetch.default || nodeFetch;

  var fetch = function (url, options) {
    // Support schemaless URIs on the server for parity with the browser.
    // Ex: //github.com/ -> https://github.com/
    if (/^\/\//.test(url)) {
      url = 'https:' + url;
    }
    return realFetch.call(this, url, options)
  };

  fetch.polyfill = false;

  module.exports = exports = fetch;
  exports.fetch = fetch;
  exports.Headers = nodeFetch.Headers;
  exports.Request = nodeFetch.Request;
  exports.Response = nodeFetch.Response;

  // Needed for TypeScript consumers without esModuleInterop.
  exports.default = fetch;
  });
  var nodePonyfill_1 = nodePonyfill.fetch;
  var nodePonyfill_2 = nodePonyfill.Headers;
  var nodePonyfill_3 = nodePonyfill.Request;
  var nodePonyfill_4 = nodePonyfill.Response;

  var WrapperDatePicker =
  /*#__PURE__*/
  function (_Component) {
    _inherits(WrapperDatePicker, _Component);

    function WrapperDatePicker(props) {
      var _this;

      _classCallCheck(this, WrapperDatePicker);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(WrapperDatePicker).call(this, props));

      if (props.value instanceof Array) {
        _this.state = {
          value: props.value && props.value.length == 2 ? [new moment(props.value[0], props.format), new moment(props.value[1], props.format)] : null
        };
      } else {
        _this.state = {
          value: props.value && props.value !== "" ? new moment(props.value, props.format) : null
        };
      }

      return _this;
    }

    _createClass(WrapperDatePicker, [{
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        if (JSON.stringify(nextProps.value) !== JSON.stringify(this.props.value)) {
          if (nextProps.value instanceof Array) {
            this.setState({
              value: nextProps.value && nextProps.value.length == 2 && nextProps.value[0] !== "" && nextProps.value[1] !== "" ? [new moment(nextProps.value[0], nextProps.format), new moment(nextProps.value[1], nextProps.format)] : null
            });
          } else {
            this.setState({
              value: nextProps.value && nextProps.value !== "" ? new moment(nextProps.value, nextProps.format) : null
            });
          }
        }
      }
    }, {
      key: "onChange",
      value: function onChange(date, dateString) {
        var _this$props = this.props,
            onChange = _this$props.onChange,
            children = _this$props.children;
        var format = children.props.format;

        if (date instanceof Array) {
          if (date.length == 0) {
            this.setState({
              value: date
            }, onChange(undefined));
          } else {
            // console.log(format,date[0].format(format),date[1].format(format))
            this.setState({
              value: date
            }, onChange([date[0].format(format), date[1].format(format)]));
          }
        } else {
          this.setState({
            value: date
          }, onChange(date.format(format)));
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props2 = this.props,
            children = _this$props2.children,
            otherProps = _this$props2.otherProps;
        var value = this.state.value;
        return React$1__default.cloneElement(children, _objectSpread({}, otherProps, {
          value: value,
          onChange: this.onChange.bind(this)
        }));
      }
    }]);

    return WrapperDatePicker;
  }(React$1.Component);

  var objectDestructuringEmpty = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;

  exports.default = function (obj) {
    if (obj == null) throw new TypeError("Cannot destructure undefined");
  };
  });

  var _objectDestructuringEmpty$1 = unwrapExports(objectDestructuringEmpty);

  /* eslint no-loop-func: 0*/

  var DRAG_SIDE_RANGE = 0.25;
  var DRAG_MIN_GAP = 2;

  function arrDel(list, value) {
    var clone = list.slice();
    var index = clone.indexOf(value);
    if (index >= 0) {
      clone.splice(index, 1);
    }
    return clone;
  }

  function arrAdd(list, value) {
    var clone = list.slice();
    if (clone.indexOf(value) === -1) {
      clone.push(value);
    }
    return clone;
  }

  function posToArr(pos) {
    return pos.split('-');
  }

  function getPosition(level, index) {
    return level + '-' + index;
  }

  function getNodeChildren(children) {
    var childList = Array.isArray(children) ? children : [children];
    return childList.filter(function (child) {
      return child && child.type && child.type.isTreeNode;
    });
  }

  function isCheckDisabled(node) {
    var _ref = node.props || {},
        disabled = _ref.disabled,
        disableCheckbox = _ref.disableCheckbox;

    return !!(disabled || disableCheckbox);
  }

  function traverseTreeNodes(treeNodes, subTreeData, callback) {
    if (typeof subTreeData === 'function') {
      callback = subTreeData;
      subTreeData = false;
    }

    function processNode(node, index, parent) {
      var children = node ? node.props.children : treeNodes;
      var pos = node ? getPosition(parent.pos, index) : 0;

      // Filter children
      var childList = getNodeChildren(children);

      // Process node if is not root
      if (node) {
        var data = {
          node: node,
          index: index,
          pos: pos,
          key: node.key || pos,
          parentPos: parent.node ? parent.pos : null
        };

        // Children data is not must have
        if (subTreeData) {
          // Statistic children
          var subNodes = [];
          React$1.Children.forEach(childList, function (subNode, subIndex) {
            // Provide limit snapshot
            var subPos = getPosition(pos, index);
            subNodes.push({
              node: subNode,
              key: subNode.key || subPos,
              pos: subPos,
              index: subIndex
            });
          });
          data.subNodes = subNodes;
        }

        // Can break traverse by return false
        if (callback(data) === false) {
          return;
        }
      }

      // Process children node
      React$1.Children.forEach(childList, function (subNode, subIndex) {
        processNode(subNode, subIndex, { node: node, pos: pos });
      });
    }

    processNode(null);
  }

  /**
   * [Legacy] Return halfChecked when it has value.
   * @param checkedKeys
   * @param halfChecked
   * @returns {*}
   */
  function getStrictlyValue(checkedKeys, halfChecked) {
    if (halfChecked) {
      return { checked: checkedKeys, halfChecked: halfChecked };
    }
    return checkedKeys;
  }

  function getFullKeyList(treeNodes) {
    var keyList = [];
    traverseTreeNodes(treeNodes, function (_ref2) {
      var key = _ref2.key;

      keyList.push(key);
    });
    return keyList;
  }

  /**
   * Check position relation.
   * @param parentPos
   * @param childPos
   * @param directly only directly parent can be true
   * @returns {boolean}
   */
  function isParent(parentPos, childPos) {
    var directly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (!parentPos || !childPos || parentPos.length > childPos.length) return false;

    var parentPath = posToArr(parentPos);
    var childPath = posToArr(childPos);

    // Directly check
    if (directly && parentPath.length !== childPath.length - 1) return false;

    var len = parentPath.length;
    for (var i = 0; i < len; i += 1) {
      if (parentPath[i] !== childPath[i]) return false;
    }

    return true;
  }

  /**
   * Statistic TreeNodes info
   * @param treeNodes
   * @returns {{}}
   */
  function getNodesStatistic(treeNodes) {
    var statistic = {
      keyNodes: {},
      posNodes: {},
      nodeList: []
    };

    traverseTreeNodes(treeNodes, true, function (_ref3) {
      var node = _ref3.node,
          index = _ref3.index,
          pos = _ref3.pos,
          key = _ref3.key,
          subNodes = _ref3.subNodes,
          parentPos = _ref3.parentPos;

      var data = { node: node, index: index, pos: pos, key: key, subNodes: subNodes, parentPos: parentPos };
      statistic.keyNodes[key] = data;
      statistic.posNodes[pos] = data;
      statistic.nodeList.push(data);
    });

    return statistic;
  }

  function getDragNodesKeys(treeNodes, node) {
    var _node$props = node.props,
        eventKey = _node$props.eventKey,
        pos = _node$props.pos;

    var dragNodesKeys = [];

    traverseTreeNodes(treeNodes, function (_ref4) {
      var nodePos = _ref4.pos,
          key = _ref4.key;

      if (isParent(pos, nodePos)) {
        dragNodesKeys.push(key);
      }
    });
    dragNodesKeys.push(eventKey || pos);
    return dragNodesKeys;
  }

  // Only used when drag, not affect SSR.
  function calcDropPosition(event, treeNode) {
    var clientY = event.clientY;

    var _treeNode$selectHandl = treeNode.selectHandle.getBoundingClientRect(),
        top = _treeNode$selectHandl.top,
        bottom = _treeNode$selectHandl.bottom,
        height = _treeNode$selectHandl.height;

    var des = Math.max(height * DRAG_SIDE_RANGE, DRAG_MIN_GAP);

    if (clientY <= top + des) {
      return -1;
    } else if (clientY >= bottom - des) {
      return 1;
    }

    return 0;
  }

  /**
   * Auto expand all related node when sub node is expanded
   * @param keyList
   * @param props
   * @returns [string]
   */
  function calcExpandedKeys(keyList, props) {
    if (!keyList) {
      return [];
    }

    var children = props.children;

    // Fill parent expanded keys

    var _getNodesStatistic = getNodesStatistic(children),
        keyNodes = _getNodesStatistic.keyNodes,
        nodeList = _getNodesStatistic.nodeList;

    var needExpandKeys = {};
    var needExpandPathList = [];

    // Fill expanded nodes
    keyList.forEach(function (key) {
      var node = keyNodes[key];
      if (node) {
        needExpandKeys[key] = true;
        needExpandPathList.push(node.pos);
      }
    });

    // Match parent by path
    nodeList.forEach(function (_ref5) {
      var pos = _ref5.pos,
          key = _ref5.key;

      if (needExpandPathList.some(function (childPos) {
        return isParent(pos, childPos);
      })) {
        needExpandKeys[key] = true;
      }
    });

    var calcExpandedKeyList = Object.keys(needExpandKeys);

    // [Legacy] Return origin keyList if calc list is empty
    return calcExpandedKeyList.length ? calcExpandedKeyList : keyList;
  }

  /**
   * Return selectedKeys according with multiple prop
   * @param selectedKeys
   * @param props
   * @returns [string]
   */
  function calcSelectedKeys(selectedKeys, props) {
    if (!selectedKeys) {
      return undefined;
    }

    var multiple = props.multiple;

    if (multiple) {
      return selectedKeys.slice();
    }

    if (selectedKeys.length) {
      return [selectedKeys[0]];
    }
    return selectedKeys;
  }

  /**
   * Check conduct is by key level. It pass though up & down.
   * When conduct target node is check means already conducted will be skip.
   * @param treeNodes
   * @param checkedKeys
   * @returns {{checkedKeys: Array, halfCheckedKeys: Array}}
   */
  function calcCheckStateConduct(treeNodes, checkedKeys) {
    var _getNodesStatistic2 = getNodesStatistic(treeNodes),
        keyNodes = _getNodesStatistic2.keyNodes,
        posNodes = _getNodesStatistic2.posNodes;

    var tgtCheckedKeys = {};
    var tgtHalfCheckedKeys = {};

    // Conduct up
    function conductUp(key, halfChecked) {
      if (tgtCheckedKeys[key]) return;

      var _keyNodes$key = keyNodes[key],
          _keyNodes$key$subNode = _keyNodes$key.subNodes,
          subNodes = _keyNodes$key$subNode === undefined ? [] : _keyNodes$key$subNode,
          parentPos = _keyNodes$key.parentPos,
          node = _keyNodes$key.node;

      if (isCheckDisabled(node)) return;

      var allSubChecked = !halfChecked && subNodes.filter(function (sub) {
        return !isCheckDisabled(sub.node);
      }).every(function (sub) {
        return tgtCheckedKeys[sub.key];
      });

      if (allSubChecked) {
        tgtCheckedKeys[key] = true;
      } else {
        tgtHalfCheckedKeys[key] = true;
      }

      if (parentPos !== null) {
        conductUp(posNodes[parentPos].key, !allSubChecked);
      }
    }

    // Conduct down
    function conductDown(key) {
      if (tgtCheckedKeys[key]) return;
      var _keyNodes$key2 = keyNodes[key],
          _keyNodes$key2$subNod = _keyNodes$key2.subNodes,
          subNodes = _keyNodes$key2$subNod === undefined ? [] : _keyNodes$key2$subNod,
          node = _keyNodes$key2.node;


      if (isCheckDisabled(node)) return;

      tgtCheckedKeys[key] = true;

      subNodes.forEach(function (sub) {
        conductDown(sub.key);
      });
    }

    function conduct(key) {
      if (!keyNodes[key]) {
        warning_1$1(false, '\'' + key + '\' does not exist in the tree.');
        return;
      }

      var _keyNodes$key3 = keyNodes[key],
          _keyNodes$key3$subNod = _keyNodes$key3.subNodes,
          subNodes = _keyNodes$key3$subNod === undefined ? [] : _keyNodes$key3$subNod,
          parentPos = _keyNodes$key3.parentPos,
          node = _keyNodes$key3.node;

      tgtCheckedKeys[key] = true;

      if (isCheckDisabled(node)) return;

      // Conduct down
      subNodes.filter(function (sub) {
        return !isCheckDisabled(sub.node);
      }).forEach(function (sub) {
        conductDown(sub.key);
      });

      // Conduct up
      if (parentPos !== null) {
        conductUp(posNodes[parentPos].key);
      }
    }

    checkedKeys.forEach(function (key) {
      conduct(key);
    });

    return {
      checkedKeys: Object.keys(tgtCheckedKeys),
      halfCheckedKeys: Object.keys(tgtHalfCheckedKeys).filter(function (key) {
        return !tgtCheckedKeys[key];
      })
    };
  }

  /**
   * Calculate the value of checked and halfChecked keys.
   * This should be only run in init or props changed.
   */
  function calcCheckedKeys(keys, props) {
    var checkable = props.checkable,
        children = props.children,
        checkStrictly = props.checkStrictly;


    if (!checkable || !keys) {
      return null;
    }

    // Convert keys to object format
    var keyProps = void 0;
    if (Array.isArray(keys)) {
      // [Legacy] Follow the api doc
      keyProps = {
        checkedKeys: keys,
        halfCheckedKeys: undefined
      };
    } else if (typeof keys === 'object') {
      keyProps = {
        checkedKeys: keys.checked || undefined,
        halfCheckedKeys: keys.halfChecked || undefined
      };
    } else {
      warning_1$1(false, '`CheckedKeys` is not an array or an object');
      return null;
    }

    // Do nothing if is checkStrictly mode
    if (checkStrictly) {
      return keyProps;
    }

    // Conduct calculate the check status
    var _keyProps = keyProps,
        _keyProps$checkedKeys = _keyProps.checkedKeys,
        checkedKeys = _keyProps$checkedKeys === undefined ? [] : _keyProps$checkedKeys;

    return calcCheckStateConduct(children, checkedKeys);
  }

  /**
   * Thought we still use `cloneElement` to pass `key`,
   * other props can pass with context for future refactor.
   */
  var contextTypes$1 = {
    rcTree: PropTypes.shape({
      root: PropTypes.object,

      prefixCls: PropTypes.string,
      selectable: PropTypes.bool,
      showIcon: PropTypes.bool,
      icon: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
      draggable: PropTypes.bool,
      checkable: PropTypes.oneOfType([PropTypes.bool, PropTypes.node]),
      checkStrictly: PropTypes.bool,
      disabled: PropTypes.bool,
      openTransitionName: PropTypes.string,
      openAnimation: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),

      loadData: PropTypes.func,
      filterTreeNode: PropTypes.func,
      renderTreeNode: PropTypes.func,

      isKeyChecked: PropTypes.func,

      onNodeExpand: PropTypes.func,
      onNodeSelect: PropTypes.func,
      onNodeMouseEnter: PropTypes.func,
      onNodeMouseLeave: PropTypes.func,
      onNodeContextMenu: PropTypes.func,
      onNodeDragStart: PropTypes.func,
      onNodeDragEnter: PropTypes.func,
      onNodeDragOver: PropTypes.func,
      onNodeDragLeave: PropTypes.func,
      onNodeDragEnd: PropTypes.func,
      onNodeDrop: PropTypes.func,
      onBatchNodeCheck: PropTypes.func,
      onCheckConductFinished: PropTypes.func
    })
  };

  var Tree = function (_React$Component) {
    _inherits$1(Tree, _React$Component);

    function Tree(props) {
      _classCallCheck$1(this, Tree);

      var _this = _possibleConstructorReturn$1(this, _React$Component.call(this, props));

      _initialiseProps$9.call(_this);

      var defaultExpandAll = props.defaultExpandAll,
          defaultExpandParent = props.defaultExpandParent,
          defaultExpandedKeys = props.defaultExpandedKeys,
          defaultCheckedKeys = props.defaultCheckedKeys,
          defaultSelectedKeys = props.defaultSelectedKeys,
          expandedKeys = props.expandedKeys;

      // Sync state with props

      var _ref = calcCheckedKeys(defaultCheckedKeys, props) || {},
          _ref$checkedKeys = _ref.checkedKeys,
          checkedKeys = _ref$checkedKeys === undefined ? [] : _ref$checkedKeys,
          _ref$halfCheckedKeys = _ref.halfCheckedKeys,
          halfCheckedKeys = _ref$halfCheckedKeys === undefined ? [] : _ref$halfCheckedKeys;

      var state = {
        selectedKeys: calcSelectedKeys(defaultSelectedKeys, props),
        checkedKeys: checkedKeys,
        halfCheckedKeys: halfCheckedKeys
      };

      if (defaultExpandAll) {
        state.expandedKeys = getFullKeyList(props.children);
      } else if (defaultExpandParent) {
        state.expandedKeys = calcExpandedKeys(expandedKeys || defaultExpandedKeys, props);
      } else {
        state.expandedKeys = defaultExpandedKeys;
      }

      _this.state = _extends$2({}, state, _this.getSyncProps(props) || {});

      // Cache for check status to optimize
      _this.checkedBatch = null;
      return _this;
    }

    Tree.prototype.getChildContext = function getChildContext() {
      var _props = this.props,
          prefixCls = _props.prefixCls,
          selectable = _props.selectable,
          showIcon = _props.showIcon,
          icon = _props.icon,
          draggable = _props.draggable,
          checkable = _props.checkable,
          checkStrictly = _props.checkStrictly,
          disabled = _props.disabled,
          loadData = _props.loadData,
          filterTreeNode = _props.filterTreeNode,
          openTransitionName = _props.openTransitionName,
          openAnimation = _props.openAnimation;


      return {
        rcTree: {
          // root: this,

          prefixCls: prefixCls,
          selectable: selectable,
          showIcon: showIcon,
          icon: icon,
          draggable: draggable,
          checkable: checkable,
          checkStrictly: checkStrictly,
          disabled: disabled,
          openTransitionName: openTransitionName,
          openAnimation: openAnimation,

          loadData: loadData,
          filterTreeNode: filterTreeNode,
          renderTreeNode: this.renderTreeNode,
          isKeyChecked: this.isKeyChecked,

          onNodeExpand: this.onNodeExpand,
          onNodeSelect: this.onNodeSelect,
          onNodeMouseEnter: this.onNodeMouseEnter,
          onNodeMouseLeave: this.onNodeMouseLeave,
          onNodeContextMenu: this.onNodeContextMenu,
          onNodeDragStart: this.onNodeDragStart,
          onNodeDragEnter: this.onNodeDragEnter,
          onNodeDragOver: this.onNodeDragOver,
          onNodeDragLeave: this.onNodeDragLeave,
          onNodeDragEnd: this.onNodeDragEnd,
          onNodeDrop: this.onNodeDrop,
          onBatchNodeCheck: this.onBatchNodeCheck,
          onCheckConductFinished: this.onCheckConductFinished
        }
      };
    };

    Tree.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var _this2 = this;

      // React 16 will not trigger update if new state is null
      this.setState(function (prevState) {
        return _this2.getSyncProps(nextProps, _this2.props, prevState);
      });
    };

    /**
     * [Legacy] Select handler is less small than node,
     * so that this will trigger when drag enter node or select handler.
     * This is a little tricky if customize css without padding.
     * Better for use mouse move event to refresh drag state.
     * But let's just keep it to avoid event trigger logic change.
     */


    /**
     * This will cache node check status to optimize update process.
     * When Tree get trigger `onCheckConductFinished` will flush all the update.
     */


    /**
     * When top `onCheckConductFinished` called, will execute all batch update.
     * And trigger `onCheck` event.
     */


    /**
     * Sync state with props if needed
     */


    /**
     * Only update the value which is not in props
     */


    /**
     * [Legacy] Original logic use `key` as tracking clue.
     * We have to use `cloneElement` to pass `key`.
     */


    Tree.prototype.render = function render() {
      var _classNames;

      var _props2 = this.props,
          prefixCls = _props2.prefixCls,
          className = _props2.className,
          focusable = _props2.focusable,
          showLine = _props2.showLine,
          children = _props2.children;

      var domProps = {};

      // [Legacy] Commit: 0117f0c9db0e2956e92cb208f51a42387dfcb3d1
      if (focusable) {
        domProps.tabIndex = '0';
        domProps.onKeyDown = this.onKeyDown;
      }

      return React$1__default.createElement(
        'ul',
        _extends$2({}, domProps, {
          className: classnames(prefixCls, className, (_classNames = {}, _classNames[prefixCls + '-show-line'] = showLine, _classNames)),
          role: 'tree-node',
          unselectable: 'on'
        }),
        React$1__default.Children.map(children, this.renderTreeNode, this)
      );
    };

    return Tree;
  }(React$1__default.Component);

  Tree.propTypes = {
    prefixCls: PropTypes.string,
    className: PropTypes.string,
    children: PropTypes.any,
    showLine: PropTypes.bool,
    showIcon: PropTypes.bool,
    icon: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
    focusable: PropTypes.bool,
    selectable: PropTypes.bool,
    disabled: PropTypes.bool,
    multiple: PropTypes.bool,
    checkable: PropTypes.oneOfType([PropTypes.bool, PropTypes.node]),
    checkStrictly: PropTypes.bool,
    draggable: PropTypes.bool,
    defaultExpandParent: PropTypes.bool,
    autoExpandParent: PropTypes.bool,
    defaultExpandAll: PropTypes.bool,
    defaultExpandedKeys: PropTypes.arrayOf(PropTypes.string),
    expandedKeys: PropTypes.arrayOf(PropTypes.string),
    defaultCheckedKeys: PropTypes.arrayOf(PropTypes.string),
    checkedKeys: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.object]),
    defaultSelectedKeys: PropTypes.arrayOf(PropTypes.string),
    selectedKeys: PropTypes.arrayOf(PropTypes.string),
    onExpand: PropTypes.func,
    onCheck: PropTypes.func,
    onSelect: PropTypes.func,
    loadData: PropTypes.func,
    onMouseEnter: PropTypes.func,
    onMouseLeave: PropTypes.func,
    onRightClick: PropTypes.func,
    onDragStart: PropTypes.func,
    onDragEnter: PropTypes.func,
    onDragOver: PropTypes.func,
    onDragLeave: PropTypes.func,
    onDragEnd: PropTypes.func,
    onDrop: PropTypes.func,
    filterTreeNode: PropTypes.func,
    openTransitionName: PropTypes.string,
    openAnimation: PropTypes.oneOfType([PropTypes.string, PropTypes.object])
  };
  Tree.childContextTypes = contextTypes$1;
  Tree.defaultProps = {
    prefixCls: 'rc-tree',
    showLine: false,
    showIcon: true,
    selectable: true,
    multiple: false,
    checkable: false,
    disabled: false,
    checkStrictly: false,
    draggable: false,
    defaultExpandParent: true,
    autoExpandParent: false,
    defaultExpandAll: false,
    defaultExpandedKeys: [],
    defaultCheckedKeys: [],
    defaultSelectedKeys: [],
    onExpand: null,
    onCheck: null,
    onSelect: null,
    onDragStart: null,
    onDragEnter: null,
    onDragOver: null,
    onDragLeave: null,
    onDrop: null,
    onDragEnd: null,
    onMouseEnter: null,
    onMouseLeave: null
  };

  var _initialiseProps$9 = function _initialiseProps() {
    var _this3 = this;

    this.onNodeDragStart = function (event, node) {
      var expandedKeys = _this3.state.expandedKeys;
      var onDragStart = _this3.props.onDragStart;
      var _node$props = node.props,
          eventKey = _node$props.eventKey,
          children = _node$props.children;


      _this3.dragNode = node;

      _this3.setState({
        dragNodesKeys: getDragNodesKeys(children, node),
        expandedKeys: arrDel(expandedKeys, eventKey)
      });

      if (onDragStart) {
        onDragStart({ event: event, node: node });
      }
    };

    this.onNodeDragEnter = function (event, node) {
      var expandedKeys = _this3.state.expandedKeys;
      var onDragEnter = _this3.props.onDragEnter;
      var _node$props2 = node.props,
          pos = _node$props2.pos,
          eventKey = _node$props2.eventKey;


      var dropPosition = calcDropPosition(event, node);

      // Skip if drag node is self
      if (_this3.dragNode.props.eventKey === eventKey && dropPosition === 0) {
        _this3.setState({
          dragOverNodeKey: '',
          dropPosition: null
        });
        return;
      }

      // Ref: https://github.com/react-component/tree/issues/132
      // Add timeout to let onDragLevel fire before onDragEnter,
      // so that we can clean drag props for onDragLeave node.
      // Macro task for this:
      // https://html.spec.whatwg.org/multipage/webappapis.html#clean-up-after-running-script
      setTimeout(function () {
        // Update drag over node
        _this3.setState({
          dragOverNodeKey: eventKey,
          dropPosition: dropPosition
        });

        // Side effect for delay drag
        if (!_this3.delayedDragEnterLogic) {
          _this3.delayedDragEnterLogic = {};
        }
        Object.keys(_this3.delayedDragEnterLogic).forEach(function (key) {
          clearTimeout(_this3.delayedDragEnterLogic[key]);
        });
        _this3.delayedDragEnterLogic[pos] = setTimeout(function () {
          var newExpandedKeys = arrAdd(expandedKeys, eventKey);
          _this3.setState({
            expandedKeys: newExpandedKeys
          });

          if (onDragEnter) {
            onDragEnter({ event: event, node: node, expandedKeys: newExpandedKeys });
          }
        }, 400);
      }, 0);
    };

    this.onNodeDragOver = function (event, node) {
      var onDragOver = _this3.props.onDragOver;
      var eventKey = node.props.eventKey;

      // Update drag position

      if (_this3.dragNode && eventKey === _this3.state.dragOverNodeKey) {
        var dropPosition = calcDropPosition(event, node);

        if (dropPosition === _this3.state.dropPosition) return;

        _this3.setState({
          dropPosition: dropPosition
        });
      }

      if (onDragOver) {
        onDragOver({ event: event, node: node });
      }
    };

    this.onNodeDragLeave = function (event, node) {
      var onDragLeave = _this3.props.onDragLeave;


      _this3.setState({
        dragOverNodeKey: ''
      });

      if (onDragLeave) {
        onDragLeave({ event: event, node: node });
      }
    };

    this.onNodeDragEnd = function (event, node) {
      var onDragEnd = _this3.props.onDragEnd;

      _this3.setState({
        dragOverNodeKey: ''
      });
      if (onDragEnd) {
        onDragEnd({ event: event, node: node });
      }
    };

    this.onNodeDrop = function (event, node) {
      var _state = _this3.state,
          dragNodesKeys = _state.dragNodesKeys,
          dropPosition = _state.dropPosition;
      var onDrop = _this3.props.onDrop;
      var _node$props3 = node.props,
          eventKey = _node$props3.eventKey,
          pos = _node$props3.pos;


      _this3.setState({
        dragOverNodeKey: '',
        dropNodeKey: eventKey
      });

      if (dragNodesKeys.indexOf(eventKey) !== -1) {
        warning_1$1(false, 'Can not drop to dragNode(include it\'s children node)');
        return;
      }

      var posArr = posToArr(pos);

      var dropResult = {
        event: event,
        node: node,
        dragNode: _this3.dragNode,
        dragNodesKeys: dragNodesKeys.slice(),
        dropPosition: dropPosition + Number(posArr[posArr.length - 1])
      };

      if (dropPosition !== 0) {
        dropResult.dropToGap = true;
      }

      if (onDrop) {
        onDrop(dropResult);
      }
    };

    this.onNodeSelect = function (e, treeNode) {
      var selectedKeys = _this3.state.selectedKeys;
      var _props3 = _this3.props,
          onSelect = _props3.onSelect,
          multiple = _props3.multiple,
          children = _props3.children;
      var _treeNode$props = treeNode.props,
          selected = _treeNode$props.selected,
          eventKey = _treeNode$props.eventKey;

      var targetSelected = !selected;

      // Update selected keys
      if (!targetSelected) {
        selectedKeys = arrDel(selectedKeys, eventKey);
      } else if (!multiple) {
        selectedKeys = [eventKey];
      } else {
        selectedKeys = arrAdd(selectedKeys, eventKey);
      }

      // [Legacy] Not found related usage in doc or upper libs
      // [Legacy] TODO: add optimize prop to skip node process
      var selectedNodes = [];
      if (selectedKeys.length) {
        traverseTreeNodes(children, function (_ref2) {
          var node = _ref2.node,
              key = _ref2.key;

          if (selectedKeys.indexOf(key) !== -1) {
            selectedNodes.push(node);
          }
        });
      }

      _this3.setUncontrolledState({ selectedKeys: selectedKeys });

      if (onSelect) {
        var eventObj = {
          event: 'select',
          selected: targetSelected,
          node: treeNode,
          selectedNodes: selectedNodes
        };
        onSelect(selectedKeys, eventObj);
      }
    };

    this.onBatchNodeCheck = function (key, checked, halfChecked, startNode) {
      if (startNode) {
        _this3.checkedBatch = {
          treeNode: startNode,
          checked: checked,
          list: []
        };
      }

      // This code should never called
      if (!_this3.checkedBatch) {
        _this3.checkedBatch = {
          list: []
        };
        warning_1$1(false, 'Checked batch not init. This should be a bug. Please fire a issue.');
      }

      _this3.checkedBatch.list.push({ key: key, checked: checked, halfChecked: halfChecked });
    };

    this.onCheckConductFinished = function () {
      var _state2 = _this3.state,
          checkedKeys = _state2.checkedKeys,
          halfCheckedKeys = _state2.halfCheckedKeys;
      var _props4 = _this3.props,
          onCheck = _props4.onCheck,
          checkStrictly = _props4.checkStrictly,
          children = _props4.children;

      // Use map to optimize update speed

      var checkedKeySet = {};
      var halfCheckedKeySet = {};

      checkedKeys.forEach(function (key) {
        checkedKeySet[key] = true;
      });
      halfCheckedKeys.forEach(function (key) {
        halfCheckedKeySet[key] = true;
      });

      // Batch process
      _this3.checkedBatch.list.forEach(function (_ref3) {
        var key = _ref3.key,
            checked = _ref3.checked,
            halfChecked = _ref3.halfChecked;

        checkedKeySet[key] = checked;
        halfCheckedKeySet[key] = halfChecked;
      });
      var newCheckedKeys = Object.keys(checkedKeySet).filter(function (key) {
        return checkedKeySet[key];
      });
      var newHalfCheckedKeys = Object.keys(halfCheckedKeySet).filter(function (key) {
        return halfCheckedKeySet[key];
      });

      // Trigger onChecked
      var selectedObj = void 0;

      var eventObj = {
        event: 'check',
        node: _this3.checkedBatch.treeNode,
        checked: _this3.checkedBatch.checked
      };

      if (checkStrictly) {
        selectedObj = getStrictlyValue(newCheckedKeys, newHalfCheckedKeys);

        // [Legacy] TODO: add optimize prop to skip node process
        eventObj.checkedNodes = [];
        traverseTreeNodes(children, function (_ref4) {
          var node = _ref4.node,
              key = _ref4.key;

          if (checkedKeySet[key]) {
            eventObj.checkedNodes.push(node);
          }
        });

        _this3.setUncontrolledState({ checkedKeys: newCheckedKeys });
      } else {
        selectedObj = newCheckedKeys;

        // [Legacy] TODO: add optimize prop to skip node process
        eventObj.checkedNodes = [];
        eventObj.checkedNodesPositions = []; // [Legacy] TODO: not in API
        eventObj.halfCheckedKeys = newHalfCheckedKeys; // [Legacy] TODO: not in API
        traverseTreeNodes(children, function (_ref5) {
          var node = _ref5.node,
              pos = _ref5.pos,
              key = _ref5.key;

          if (checkedKeySet[key]) {
            eventObj.checkedNodes.push(node);
            eventObj.checkedNodesPositions.push({ node: node, pos: pos });
          }
        });

        _this3.setUncontrolledState({
          checkedKeys: newCheckedKeys,
          halfCheckedKeys: newHalfCheckedKeys
        });
      }

      if (onCheck) {
        onCheck(selectedObj, eventObj);
      }

      // Clean up
      _this3.checkedBatch = null;
    };

    this.onNodeExpand = function (e, treeNode) {
      var expandedKeys = _this3.state.expandedKeys;
      var _props5 = _this3.props,
          onExpand = _props5.onExpand,
          loadData = _props5.loadData;
      var _treeNode$props2 = treeNode.props,
          eventKey = _treeNode$props2.eventKey,
          expanded = _treeNode$props2.expanded;

      // Update selected keys

      var index = expandedKeys.indexOf(eventKey);
      var targetExpanded = !expanded;

      warning_1$1(expanded && index !== -1 || !expanded && index === -1, 'Expand state not sync with index check');

      if (targetExpanded) {
        expandedKeys = arrAdd(expandedKeys, eventKey);
      } else {
        expandedKeys = arrDel(expandedKeys, eventKey);
      }

      _this3.setUncontrolledState({ expandedKeys: expandedKeys });

      if (onExpand) {
        onExpand(expandedKeys, { node: treeNode, expanded: targetExpanded });
      }

      // Async Load data
      if (targetExpanded && loadData) {
        return loadData(treeNode).then(function () {
          // [Legacy] Refresh logic
          _this3.setUncontrolledState({ expandedKeys: expandedKeys });
        });
      }

      return null;
    };

    this.onNodeMouseEnter = function (event, node) {
      var onMouseEnter = _this3.props.onMouseEnter;

      if (onMouseEnter) {
        onMouseEnter({ event: event, node: node });
      }
    };

    this.onNodeMouseLeave = function (event, node) {
      var onMouseLeave = _this3.props.onMouseLeave;

      if (onMouseLeave) {
        onMouseLeave({ event: event, node: node });
      }
    };

    this.onNodeContextMenu = function (event, node) {
      var onRightClick = _this3.props.onRightClick;

      if (onRightClick) {
        event.preventDefault();
        onRightClick({ event: event, node: node });
      }
    };

    this.getSyncProps = function () {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var prevProps = arguments[1];
      var preState = arguments[2];

      var needSync = false;
      var oriState = preState || _this3.state;
      var newState = {};
      var myPrevProps = prevProps || {};

      function checkSync(name) {
        if (props[name] !== myPrevProps[name]) {
          needSync = true;
          return true;
        }
        return false;
      }

      // Children change will affect check box status.
      // And no need to check when prev props not provided
      if (prevProps && checkSync('children')) {
        var newCheckedKeys = calcCheckedKeys(props.checkedKeys || oriState.checkedKeys, props);

        var _ref6 = newCheckedKeys || {},
            _ref6$checkedKeys = _ref6.checkedKeys,
            checkedKeys = _ref6$checkedKeys === undefined ? [] : _ref6$checkedKeys,
            _ref6$halfCheckedKeys = _ref6.halfCheckedKeys,
            halfCheckedKeys = _ref6$halfCheckedKeys === undefined ? [] : _ref6$halfCheckedKeys;

        newState.checkedKeys = checkedKeys;
        newState.halfCheckedKeys = halfCheckedKeys;
      }

      // Re-calculate when autoExpandParent or expandedKeys changed
      if (prevProps && (checkSync('autoExpandParent') || checkSync('expandedKeys'))) {
        newState.expandedKeys = props.autoExpandParent ? calcExpandedKeys(props.expandedKeys, props) : props.expandedKeys;
      }

      if (checkSync('selectedKeys')) {
        newState.selectedKeys = calcSelectedKeys(props.selectedKeys, props);
      }

      if (checkSync('checkedKeys')) {
        var _ref7 = calcCheckedKeys(props.checkedKeys, props) || {},
            _ref7$checkedKeys = _ref7.checkedKeys,
            _checkedKeys = _ref7$checkedKeys === undefined ? [] : _ref7$checkedKeys,
            _ref7$halfCheckedKeys = _ref7.halfCheckedKeys,
            _halfCheckedKeys = _ref7$halfCheckedKeys === undefined ? [] : _ref7$halfCheckedKeys;

        newState.checkedKeys = _checkedKeys;
        newState.halfCheckedKeys = _halfCheckedKeys;
      }

      return needSync ? newState : null;
    };

    this.setUncontrolledState = function (state) {
      var needSync = false;
      var newState = {};

      Object.keys(state).forEach(function (name) {
        if (name in _this3.props) return;

        needSync = true;
        newState[name] = state[name];
      });

      if (needSync) {
        _this3.setState(newState);
      }
    };

    this.isKeyChecked = function (key) {
      var _state$checkedKeys = _this3.state.checkedKeys,
          checkedKeys = _state$checkedKeys === undefined ? [] : _state$checkedKeys;

      return checkedKeys.indexOf(key) !== -1;
    };

    this.renderTreeNode = function (child, index) {
      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var _state3 = _this3.state,
          _state3$expandedKeys = _state3.expandedKeys,
          expandedKeys = _state3$expandedKeys === undefined ? [] : _state3$expandedKeys,
          _state3$selectedKeys = _state3.selectedKeys,
          selectedKeys = _state3$selectedKeys === undefined ? [] : _state3$selectedKeys,
          _state3$halfCheckedKe = _state3.halfCheckedKeys,
          halfCheckedKeys = _state3$halfCheckedKe === undefined ? [] : _state3$halfCheckedKe,
          dragOverNodeKey = _state3.dragOverNodeKey,
          dropPosition = _state3.dropPosition;

      _objectDestructuringEmpty$1(_this3.props);

      var pos = getPosition(level, index);
      var key = child.key || pos;

      return React$1__default.cloneElement(child, {
        eventKey: key,
        expanded: expandedKeys.indexOf(key) !== -1,
        selected: selectedKeys.indexOf(key) !== -1,
        checked: _this3.isKeyChecked(key),
        halfChecked: halfCheckedKeys.indexOf(key) !== -1,
        pos: pos,

        // [Legacy] Drag props
        dragOver: dragOverNodeKey === key && dropPosition === 0,
        dragOverGapTop: dragOverNodeKey === key && dropPosition === -1,
        dragOverGapBottom: dragOverNodeKey === key && dropPosition === 1
      });
    };
  };

  var ICON_OPEN = 'open';
  var ICON_CLOSE = 'close';

  var LOAD_STATUS_NONE = 0;
  var LOAD_STATUS_LOADING = 1;
  var LOAD_STATUS_LOADED = 2;
  var LOAD_STATUS_FAILED = 0; // Action align, let's make failed same as init.

  var defaultTitle = '---';

  var onlyTreeNodeWarned = false; // Only accept TreeNode

  var nodeContextTypes = _extends$2({}, contextTypes$1, {
    rcTreeNode: PropTypes.shape({
      onUpCheckConduct: PropTypes.func
    })
  });

  var TreeNode = function (_React$Component) {
    _inherits$1(TreeNode, _React$Component);

    function TreeNode(props) {
      _classCallCheck$1(this, TreeNode);

      var _this = _possibleConstructorReturn$1(this, _React$Component.call(this, props));

      _initialiseProps$a.call(_this);

      _this.state = {
        loadStatus: LOAD_STATUS_NONE,
        dragNodeHighlight: false
      };
      return _this;
    }

    TreeNode.prototype.getChildContext = function getChildContext() {
      return _extends$2({}, this.context, {
        rcTreeNode: {
          onUpCheckConduct: this.onUpCheckConduct
        }
      });
    };

    // Isomorphic needn't load data in server side


    TreeNode.prototype.componentDidMount = function componentDidMount() {
      this.syncLoadData(this.props);
    };

    TreeNode.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      this.syncLoadData(nextProps);
    };

    // Disabled item still can be switch


    // Drag usage


    TreeNode.prototype.isSelectable = function isSelectable() {
      var selectable = this.props.selectable;
      var treeSelectable = this.context.rcTree.selectable;

      // Ignore when selectable is undefined or null

      if (typeof selectable === 'boolean') {
        return selectable;
      }

      return treeSelectable;
    };

    // Load data to avoid default expanded tree without data


    // Switcher


    // Checkbox


    // Icon + Title


    // Children list wrapped with `Animation`


    TreeNode.prototype.render = function render() {
      var _classNames;

      var _props = this.props,
          className = _props.className,
          dragOver = _props.dragOver,
          dragOverGapTop = _props.dragOverGapTop,
          dragOverGapBottom = _props.dragOverGapBottom;
      var _context$rcTree = this.context.rcTree,
          prefixCls = _context$rcTree.prefixCls,
          filterTreeNode = _context$rcTree.filterTreeNode;

      var disabled = this.isDisabled();

      return React$1__default.createElement(
        'li',
        {
          className: classnames(className, (_classNames = {}, _classNames[prefixCls + '-treenode-disabled'] = disabled, _classNames['drag-over'] = !disabled && dragOver, _classNames['drag-over-gap-top'] = !disabled && dragOverGapTop, _classNames['drag-over-gap-bottom'] = !disabled && dragOverGapBottom, _classNames['filter-node'] = filterTreeNode && filterTreeNode(this), _classNames)),

          onDragEnter: this.onDragEnter,
          onDragOver: this.onDragOver,
          onDragLeave: this.onDragLeave,
          onDrop: this.onDrop,
          onDragEnd: this.onDragEnd
        },
        this.renderSwitcher(),
        this.renderCheckbox(),
        this.renderSelector(),
        this.renderChildren()
      );
    };

    return TreeNode;
  }(React$1__default.Component);

  TreeNode.propTypes = {
    eventKey: PropTypes.string, // Pass by parent `cloneElement`
    prefixCls: PropTypes.string,
    className: PropTypes.string,
    root: PropTypes.object,
    onSelect: PropTypes.func,

    // By parent
    expanded: PropTypes.bool,
    selected: PropTypes.bool,
    checked: PropTypes.bool,
    halfChecked: PropTypes.bool,
    children: PropTypes.node,
    title: PropTypes.node,
    pos: PropTypes.string,
    dragOver: PropTypes.bool,
    dragOverGapTop: PropTypes.bool,
    dragOverGapBottom: PropTypes.bool,

    // By user
    isLeaf: PropTypes.bool,
    selectable: PropTypes.bool,
    disabled: PropTypes.bool,
    disableCheckbox: PropTypes.bool,
    icon: PropTypes.oneOfType([PropTypes.node, PropTypes.func])
  };
  TreeNode.contextTypes = nodeContextTypes;
  TreeNode.childContextTypes = nodeContextTypes;
  TreeNode.defaultProps = {
    title: defaultTitle
  };

  var _initialiseProps$a = function _initialiseProps() {
    var _this2 = this;

    this.onUpCheckConduct = function (treeNode, nodeChecked, nodeHalfChecked) {
      var nodePos = treeNode.props.pos;
      var _props2 = _this2.props,
          eventKey = _props2.eventKey,
          pos = _props2.pos,
          checked = _props2.checked,
          halfChecked = _props2.halfChecked;
      var _context = _this2.context,
          _context$rcTree2 = _context.rcTree,
          checkStrictly = _context$rcTree2.checkStrictly,
          isKeyChecked = _context$rcTree2.isKeyChecked,
          onBatchNodeCheck = _context$rcTree2.onBatchNodeCheck,
          onCheckConductFinished = _context$rcTree2.onCheckConductFinished,
          _context$rcTreeNode = _context.rcTreeNode;
      _context$rcTreeNode = _context$rcTreeNode === undefined ? {} : _context$rcTreeNode;
      var onUpCheckConduct = _context$rcTreeNode.onUpCheckConduct;

      // Stop conduct when current node is disabled

      if (isCheckDisabled(_this2)) {
        onCheckConductFinished();
        return;
      }

      var children = _this2.getNodeChildren();

      var checkedCount = nodeChecked ? 1 : 0;

      // Statistic checked count
      children.forEach(function (node, index) {
        var childPos = getPosition(pos, index);

        if (nodePos === childPos || isCheckDisabled(node)) {
          return;
        }

        if (isKeyChecked(node.key || childPos)) {
          checkedCount += 1;
        }
      });

      // Static enabled children count
      var enabledChildrenCount = children.filter(function (node) {
        return !isCheckDisabled(node);
      }).length;

      // checkStrictly will not conduct check status
      var nextChecked = checkStrictly ? checked : enabledChildrenCount === checkedCount;
      var nextHalfChecked = checkStrictly ? // propagated or child checked
      halfChecked : nodeHalfChecked || checkedCount > 0 && !nextChecked;

      // Add into batch update
      if (checked !== nextChecked || halfChecked !== nextHalfChecked) {
        onBatchNodeCheck(eventKey, nextChecked, nextHalfChecked);

        if (onUpCheckConduct) {
          onUpCheckConduct(_this2, nextChecked, nextHalfChecked);
        } else {
          // Flush all the update
          onCheckConductFinished();
        }
      } else {
        // Flush all the update
        onCheckConductFinished();
      }
    };

    this.onDownCheckConduct = function (nodeChecked) {
      var children = _this2.props.children;
      var _context$rcTree3 = _this2.context.rcTree,
          checkStrictly = _context$rcTree3.checkStrictly,
          isKeyChecked = _context$rcTree3.isKeyChecked,
          onBatchNodeCheck = _context$rcTree3.onBatchNodeCheck;

      if (checkStrictly) return;

      traverseTreeNodes(children, function (_ref) {
        var node = _ref.node,
            key = _ref.key;

        if (isCheckDisabled(node)) return false;

        if (nodeChecked !== isKeyChecked(key)) {
          onBatchNodeCheck(key, nodeChecked, false);
        }
      });
    };

    this.onSelectorClick = function (e) {
      if (_this2.isSelectable()) {
        _this2.onSelect(e);
      } else {
        _this2.onCheck(e);
      }
    };

    this.onSelect = function (e) {
      if (_this2.isDisabled()) return;

      var onNodeSelect = _this2.context.rcTree.onNodeSelect;

      e.preventDefault();
      onNodeSelect(e, _this2);
    };

    this.onCheck = function (e) {
      if (_this2.isDisabled()) return;

      var _props3 = _this2.props,
          disableCheckbox = _props3.disableCheckbox,
          checked = _props3.checked,
          eventKey = _props3.eventKey;
      var _context2 = _this2.context,
          _context2$rcTree = _context2.rcTree,
          checkable = _context2$rcTree.checkable,
          onBatchNodeCheck = _context2$rcTree.onBatchNodeCheck,
          onCheckConductFinished = _context2$rcTree.onCheckConductFinished,
          _context2$rcTreeNode = _context2.rcTreeNode;
      _context2$rcTreeNode = _context2$rcTreeNode === undefined ? {} : _context2$rcTreeNode;
      var onUpCheckConduct = _context2$rcTreeNode.onUpCheckConduct;


      if (!checkable || disableCheckbox) return;

      e.preventDefault();
      var targetChecked = !checked;
      onBatchNodeCheck(eventKey, targetChecked, false, _this2);

      // Children conduct
      _this2.onDownCheckConduct(targetChecked);

      // Parent conduct
      if (onUpCheckConduct) {
        onUpCheckConduct(_this2, targetChecked, false);
      } else {
        onCheckConductFinished();
      }
    };

    this.onMouseEnter = function (e) {
      var onNodeMouseEnter = _this2.context.rcTree.onNodeMouseEnter;

      onNodeMouseEnter(e, _this2);
    };

    this.onMouseLeave = function (e) {
      var onNodeMouseLeave = _this2.context.rcTree.onNodeMouseLeave;

      onNodeMouseLeave(e, _this2);
    };

    this.onContextMenu = function (e) {
      var onNodeContextMenu = _this2.context.rcTree.onNodeContextMenu;

      onNodeContextMenu(e, _this2);
    };

    this.onDragStart = function (e) {
      var onNodeDragStart = _this2.context.rcTree.onNodeDragStart;


      e.stopPropagation();
      _this2.setState({
        dragNodeHighlight: true
      });
      onNodeDragStart(e, _this2);

      try {
        // ie throw error
        // firefox-need-it
        e.dataTransfer.setData('text/plain', '');
      } catch (error) {
        // empty
      }
    };

    this.onDragEnter = function (e) {
      var onNodeDragEnter = _this2.context.rcTree.onNodeDragEnter;


      e.preventDefault();
      e.stopPropagation();
      onNodeDragEnter(e, _this2);
    };

    this.onDragOver = function (e) {
      var onNodeDragOver = _this2.context.rcTree.onNodeDragOver;


      e.preventDefault();
      e.stopPropagation();
      onNodeDragOver(e, _this2);
    };

    this.onDragLeave = function (e) {
      var onNodeDragLeave = _this2.context.rcTree.onNodeDragLeave;


      e.stopPropagation();
      onNodeDragLeave(e, _this2);
    };

    this.onDragEnd = function (e) {
      var onNodeDragEnd = _this2.context.rcTree.onNodeDragEnd;


      e.stopPropagation();
      _this2.setState({
        dragNodeHighlight: false
      });
      onNodeDragEnd(e, _this2);
    };

    this.onDrop = function (e) {
      var onNodeDrop = _this2.context.rcTree.onNodeDrop;


      e.preventDefault();
      e.stopPropagation();
      _this2.setState({
        dragNodeHighlight: false
      });
      onNodeDrop(e, _this2);
    };

    this.onExpand = function (e) {
      var onNodeExpand = _this2.context.rcTree.onNodeExpand;

      var callbackPromise = onNodeExpand(e, _this2);

      // Promise like
      if (callbackPromise && callbackPromise.then) {
        _this2.setState({ loadStatus: LOAD_STATUS_LOADING });

        callbackPromise.then(function () {
          _this2.setState({ loadStatus: LOAD_STATUS_LOADED });
        })['catch'](function () {
          _this2.setState({ loadStatus: LOAD_STATUS_FAILED });
        });
      }
    };

    this.setSelectHandle = function (node) {
      _this2.selectHandle = node;
    };

    this.getNodeChildren = function () {
      var children = _this2.props.children;

      var originList = toArray(children).filter(function (node) {
        return node;
      });
      var targetList = getNodeChildren(originList);

      if (originList.length !== targetList.length && !onlyTreeNodeWarned) {
        onlyTreeNodeWarned = true;
        warning_1$1(false, 'Tree only accept TreeNode as children.');
      }

      return targetList;
    };

    this.getNodeState = function () {
      var expanded = _this2.props.expanded;


      if (_this2.isLeaf()) {
        return null;
      }

      return expanded ? ICON_OPEN : ICON_CLOSE;
    };

    this.isLeaf = function () {
      var loadStatus = _this2.state.loadStatus;
      var isLeaf = _this2.props.isLeaf;
      var loadData = _this2.context.rcTree.loadData;


      var hasChildren = _this2.getNodeChildren().length !== 0;

      return isLeaf || !loadData && !hasChildren || loadData && loadStatus === LOAD_STATUS_LOADED && !hasChildren;
    };

    this.isDisabled = function () {
      var disabled = _this2.props.disabled;
      var treeDisabled = _this2.context.rcTree.disabled;

      // Follow the logic of Selectable

      if (disabled === false) {
        return false;
      }

      return !!(treeDisabled || disabled);
    };

    this.syncLoadData = function (props) {
      var expanded = props.expanded;
      var loadData = _this2.context.rcTree.loadData;

      // read from state to avoid loadData at same time

      _this2.setState(function (_ref2) {
        var loadStatus = _ref2.loadStatus;

        if (loadData && loadStatus === LOAD_STATUS_NONE && expanded && !_this2.isLeaf()) {
          loadData(_this2).then(function () {
            _this2.setState({ loadStatus: LOAD_STATUS_LOADED });
          })['catch'](function () {
            _this2.setState({ loadStatus: LOAD_STATUS_FAILED });
          });

          return { loadStatus: LOAD_STATUS_LOADING };
        }

        return null;
      });
    };

    this.renderSwitcher = function () {
      var expanded = _this2.props.expanded;
      var prefixCls = _this2.context.rcTree.prefixCls;


      if (_this2.isLeaf()) {
        return React$1__default.createElement('span', { className: prefixCls + '-switcher ' + prefixCls + '-switcher-noop' });
      }

      return React$1__default.createElement('span', {
        className: classnames(prefixCls + '-switcher', prefixCls + '-switcher_' + (expanded ? ICON_OPEN : ICON_CLOSE)),
        onClick: _this2.onExpand
      });
    };

    this.renderCheckbox = function () {
      var _props4 = _this2.props,
          checked = _props4.checked,
          halfChecked = _props4.halfChecked,
          disableCheckbox = _props4.disableCheckbox;
      var _context$rcTree4 = _this2.context.rcTree,
          prefixCls = _context$rcTree4.prefixCls,
          checkable = _context$rcTree4.checkable;

      var disabled = _this2.isDisabled();

      if (!checkable) return null;

      // [Legacy] Custom element should be separate with `checkable` in future
      var $custom = typeof checkable !== 'boolean' ? checkable : null;

      return React$1__default.createElement(
        'span',
        {
          className: classnames(prefixCls + '-checkbox', checked && prefixCls + '-checkbox-checked', !checked && halfChecked && prefixCls + '-checkbox-indeterminate', (disabled || disableCheckbox) && prefixCls + '-checkbox-disabled'),
          onClick: _this2.onCheck
        },
        $custom
      );
    };

    this.renderIcon = function () {
      var loadStatus = _this2.state.loadStatus;
      var prefixCls = _this2.context.rcTree.prefixCls;


      return React$1__default.createElement('span', {
        className: classnames(prefixCls + '-iconEle', prefixCls + '-icon__' + (_this2.getNodeState() || 'docu'), loadStatus === LOAD_STATUS_LOADING && prefixCls + '-icon_loading')
      });
    };

    this.renderSelector = function () {
      var _state = _this2.state,
          loadStatus = _state.loadStatus,
          dragNodeHighlight = _state.dragNodeHighlight;
      var _props5 = _this2.props,
          title = _props5.title,
          selected = _props5.selected,
          icon = _props5.icon;
      var _context$rcTree5 = _this2.context.rcTree,
          prefixCls = _context$rcTree5.prefixCls,
          showIcon = _context$rcTree5.showIcon,
          treeIcon = _context$rcTree5.icon,
          draggable = _context$rcTree5.draggable,
          loadData = _context$rcTree5.loadData;

      var disabled = _this2.isDisabled();

      var wrapClass = prefixCls + '-node-content-wrapper';

      // Icon - Still show loading icon when loading without showIcon
      var $icon = void 0;

      if (showIcon) {
        var currentIcon = icon || treeIcon;

        $icon = currentIcon ? React$1__default.createElement(
          'span',
          {
            className: classnames(prefixCls + '-iconEle', prefixCls + '-icon__customize')
          },
          typeof currentIcon === 'function' ? React$1__default.createElement(currentIcon, _this2.props) : currentIcon
        ) : _this2.renderIcon();
      } else if (loadData && loadStatus === LOAD_STATUS_LOADING) {
        $icon = _this2.renderIcon();
      }

      // Title
      var $title = React$1__default.createElement(
        'span',
        { className: prefixCls + '-title' },
        title
      );

      return React$1__default.createElement(
        'span',
        {
          ref: _this2.setSelectHandle,
          title: typeof title === 'string' ? title : '',
          className: classnames('' + wrapClass, wrapClass + '-' + (_this2.getNodeState() || 'normal'), !disabled && (selected || dragNodeHighlight) && prefixCls + '-node-selected', !disabled && draggable && 'draggable'),
          draggable: !disabled && draggable || undefined,
          'aria-grabbed': !disabled && draggable || undefined,

          onMouseEnter: _this2.onMouseEnter,
          onMouseLeave: _this2.onMouseLeave,
          onContextMenu: _this2.onContextMenu,
          onClick: _this2.onSelectorClick,
          onDragStart: _this2.onDragStart
        },
        $icon,
        $title
      );
    };

    this.renderChildren = function () {
      var _props6 = _this2.props,
          expanded = _props6.expanded,
          pos = _props6.pos;
      var _context$rcTree6 = _this2.context.rcTree,
          prefixCls = _context$rcTree6.prefixCls,
          openTransitionName = _context$rcTree6.openTransitionName,
          openAnimation = _context$rcTree6.openAnimation,
          renderTreeNode = _context$rcTree6.renderTreeNode;

      // [Legacy] Animation control

      var renderFirst = _this2.renderFirst;
      _this2.renderFirst = 1;
      var transitionAppear = true;
      if (!renderFirst && expanded) {
        transitionAppear = false;
      }

      var animProps = {};
      if (openTransitionName) {
        animProps.transitionName = openTransitionName;
      } else if (typeof openAnimation === 'object') {
        animProps.animation = _extends$2({}, openAnimation);
        if (!transitionAppear) {
          delete animProps.animation.appear;
        }
      }

      // Children TreeNode
      var nodeList = _this2.getNodeChildren();

      if (nodeList.length === 0) {
        return null;
      }

      var $children = void 0;
      if (expanded) {
        $children = React$1__default.createElement(
          'ul',
          {
            className: classnames(prefixCls + '-child-tree', expanded && prefixCls + '-child-tree-open'),
            'data-expanded': expanded
          },
          React$1__default.Children.map(nodeList, function (node, index) {
            return renderTreeNode(node, index, pos);
          })
        );
      }

      return React$1__default.createElement(
        Animate,
        _extends$2({}, animProps, {
          showProp: 'data-expanded',
          transitionAppear: transitionAppear,
          component: ''
        }),
        $children
      );
    };
  };

  TreeNode.isTreeNode = 1;

  Tree.TreeNode = TreeNode;

  var es$6 = /*#__PURE__*/Object.freeze({
    TreeNode: TreeNode,
    default: Tree
  });

  var getRequestAnimationFrame_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports['default'] = getRequestAnimationFrame;
  exports.cancelRequestAnimationFrame = cancelRequestAnimationFrame;
  var availablePrefixs = ['moz', 'ms', 'webkit'];
  function requestAnimationFramePolyfill() {
      var lastTime = 0;
      return function (callback) {
          var currTime = new Date().getTime();
          var timeToCall = Math.max(0, 16 - (currTime - lastTime));
          var id = window.setTimeout(function () {
              callback(currTime + timeToCall);
          }, timeToCall);
          lastTime = currTime + timeToCall;
          return id;
      };
  }
  function getRequestAnimationFrame() {
      if (typeof window === 'undefined') {
          return function () {};
      }
      if (window.requestAnimationFrame) {
          // https://github.com/vuejs/vue/issues/4465
          return window.requestAnimationFrame.bind(window);
      }
      var prefix = availablePrefixs.filter(function (key) {
          return key + 'RequestAnimationFrame' in window;
      })[0];
      return prefix ? window[prefix + 'RequestAnimationFrame'] : requestAnimationFramePolyfill();
  }
  function cancelRequestAnimationFrame(id) {
      if (typeof window === 'undefined') {
          return null;
      }
      if (window.cancelAnimationFrame) {
          return window.cancelAnimationFrame(id);
      }
      var prefix = availablePrefixs.filter(function (key) {
          return key + 'CancelAnimationFrame' in window || key + 'CancelRequestAnimationFrame' in window;
      })[0];
      return prefix ? (window[prefix + 'CancelAnimationFrame'] || window[prefix + 'CancelRequestAnimationFrame']).call(this, id) : clearTimeout(id);
  }
  });

  unwrapExports(getRequestAnimationFrame_1);
  var getRequestAnimationFrame_2 = getRequestAnimationFrame_1.cancelRequestAnimationFrame;

  var _cssAnimation = getCjsExportFromNamespace(es$2);

  var openAnimation = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _cssAnimation2 = _interopRequireDefault(_cssAnimation);



  var _getRequestAnimationFrame2 = _interopRequireDefault(getRequestAnimationFrame_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var reqAnimFrame = (0, _getRequestAnimationFrame2['default'])();
  function animate(node, show, done) {
      var height = void 0;
      var requestAnimationFrameId = void 0;
      return (0, _cssAnimation2['default'])(node, 'ant-motion-collapse', {
          start: function start() {
              if (!show) {
                  node.style.height = node.offsetHeight + 'px';
                  node.style.opacity = '1';
              } else {
                  height = node.offsetHeight;
                  node.style.height = '0px';
                  node.style.opacity = '0';
              }
          },
          active: function active() {
              if (requestAnimationFrameId) {
                  (0, getRequestAnimationFrame_1.cancelRequestAnimationFrame)(requestAnimationFrameId);
              }
              requestAnimationFrameId = reqAnimFrame(function () {
                  node.style.height = (show ? height : 0) + 'px';
                  node.style.opacity = show ? '1' : '0';
              });
          },
          end: function end() {
              if (requestAnimationFrameId) {
                  (0, getRequestAnimationFrame_1.cancelRequestAnimationFrame)(requestAnimationFrameId);
              }
              node.style.height = '';
              node.style.opacity = '';
              done();
          }
      });
  }
  var animation = {
      enter: function enter(node, done) {
          return animate(node, true, done);
      },
      leave: function leave(node, done) {
          return animate(node, false, done);
      },
      appear: function appear(node, done) {
          return animate(node, true, done);
      }
  };
  exports['default'] = animation;
  module.exports = exports['default'];
  });

  unwrapExports(openAnimation);

  var _rcTree = getCjsExportFromNamespace(es$6);

  var tree = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var _rcTree2 = _interopRequireDefault(_rcTree);



  var _openAnimation2 = _interopRequireDefault(openAnimation);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var Tree = function (_React$Component) {
      (0, _inherits3['default'])(Tree, _React$Component);

      function Tree() {
          (0, _classCallCheck3['default'])(this, Tree);
          return (0, _possibleConstructorReturn3['default'])(this, (Tree.__proto__ || Object.getPrototypeOf(Tree)).apply(this, arguments));
      }

      (0, _createClass3['default'])(Tree, [{
          key: 'render',
          value: function render() {
              var props = this.props;
              var prefixCls = props.prefixCls,
                  className = props.className;

              var checkable = props.checkable;
              return React.createElement(
                  _rcTree2['default'],
                  (0, _extends3['default'])({}, props, { className: className, checkable: checkable ? React.createElement('span', { className: prefixCls + '-checkbox-inner' }) : checkable }),
                  this.props.children
              );
          }
      }]);
      return Tree;
  }(React.Component);

  exports['default'] = Tree;

  Tree.TreeNode = _rcTree.TreeNode;
  Tree.defaultProps = {
      prefixCls: 'ant-tree',
      checkable: false,
      showIcon: false,
      openAnimation: _openAnimation2['default']
  };
  module.exports = exports['default'];
  });

  var Tree$1 = unwrapExports(tree);

  function toTitle$1(title) {
    if (typeof title === 'string') {
      return title;
    }
    return null;
  }

  function getValuePropValue$1(child) {
    var props = child.props;
    if ('value' in props) {
      return props.value;
    }
    if (child.key) {
      return child.key;
    }
    throw new Error('no key or value for ' + child);
  }

  function getPropValue$1(child, prop) {
    if (prop === 'value') {
      return getValuePropValue$1(child);
    }
    return child.props[prop];
  }

  function isMultiple$1(props) {
    return !!(props.multiple || props.treeCheckable);
  }

  function toArray$2(value) {
    var ret = value;
    if (value === undefined) {
      ret = [];
    } else if (!Array.isArray(value)) {
      ret = [value];
    }
    return ret;
  }

  function preventDefaultEvent$1(e) {
    e.preventDefault();
  }

  var UNSELECTABLE_STYLE$1 = {
    userSelect: 'none',
    WebkitUserSelect: 'none'
  };

  var UNSELECTABLE_ATTRIBUTE$1 = {
    unselectable: 'unselectable'
  };

  function labelCompatible(prop) {
    var newProp = prop;
    if (newProp === 'label') {
      newProp = 'title';
    }
    return newProp;
  }

  function isInclude(smallArray, bigArray) {
    // attention: [0,0,1] [0,0,10]
    return smallArray.every(function (ii, i) {
      return ii === bigArray[i];
    });
  }

  function isPositionPrefix(smallPos, bigPos) {
    if (!bigPos || !smallPos) {
      // console.log(smallPos, bigPos);
      return false;
    }
    if (bigPos.length < smallPos.length) {
      return false;
    }
    // attention: "0-0-1" "0-0-10"
    if (bigPos.length > smallPos.length && bigPos.charAt(smallPos.length) !== '-') {
      return false;
    }
    return bigPos.substr(0, smallPos.length) === smallPos;
  }

  /*
  export function getCheckedKeys(node, checkedKeys, allCheckedNodesKeys) {
    const nodeKey = node.props.eventKey;
    let newCks = [...checkedKeys];
    let nodePos;
    const unCheck = allCheckedNodesKeys.some(item => {
      if (item.key === nodeKey) {
        nodePos = item.pos;
        return true;
      }
    });
    if (unCheck) {
      newCks = [];
      allCheckedNodesKeys.forEach(item => {
        if (isPositionPrefix(item.pos, nodePos) || isPositionPrefix(nodePos, item.pos)) {
          return;
        }
        newCks.push(item.key);
      });
    } else {
      newCks.push(nodeKey);
    }
    return newCks;
  }
  */

  function getChildrenlength(children) {
    var len = 1;
    if (Array.isArray(children)) {
      len = children.length;
    }
    return len;
  }

  function getSiblingPosition(index, len, siblingPosition) {
    if (len === 1) {
      siblingPosition.first = true;
      siblingPosition.last = true;
    } else {
      siblingPosition.first = index === 0;
      siblingPosition.last = index === len - 1;
    }
    return siblingPosition;
  }

  function loopAllChildren(childs, callback, parent) {
    var loop = function loop(children, level, _parent) {
      var len = getChildrenlength(children);
      React$1__default.Children.forEach(children, function handler(item, index) {
        // eslint-disable-line
        var pos = level + '-' + index;
        if (item && item.props.children && item.type) {
          loop(item.props.children, pos, { node: item, pos: pos });
        }
        if (item) {
          callback(item, index, pos, item.key || pos, getSiblingPosition(index, len, {}), _parent);
        }
      });
    };
    loop(childs, 0, parent);
  }

  // export function loopAllChildren(childs, callback) {
  //   const loop = (children, level) => {
  //     React.Children.forEach(children, (item, index) => {
  //       const pos = `${level}-${index}`;
  //       if (item && item.props.children) {
  //         loop(item.props.children, pos);
  //       }
  //       if (item) {
  //         callback(item, index, pos, getValuePropValue(item));
  //       }
  //     });
  //   };
  //   loop(childs, 0);
  // }

  // TODO: Here has the side effect. Update node children data affect.
  function flatToHierarchy(arr) {
    if (!arr.length) {
      return arr;
    }
    var hierarchyNodes = [];
    var levelObj = {};
    arr.forEach(function (item) {
      if (!item.pos) {
        return;
      }
      var posLen = item.pos.split('-').length;
      if (!levelObj[posLen]) {
        levelObj[posLen] = [];
      }
      levelObj[posLen].push(item);
    });
    var levelArr = Object.keys(levelObj).sort(function (a, b) {
      return b - a;
    });
    // const s = Date.now();
    // todo: there are performance issues!
    levelArr.reduce(function (pre, cur) {
      if (cur && cur !== pre) {
        levelObj[pre].forEach(function (item) {
          var haveParent = false;
          levelObj[cur].forEach(function (ii) {
            if (isPositionPrefix(ii.pos, item.pos)) {
              haveParent = true;
              if (!ii.children) {
                ii.children = [];
              }
              ii.children.push(item);
            }
          });
          if (!haveParent) {
            hierarchyNodes.push(item);
          }
        });
      }
      return cur;
    });
    // console.log(Date.now() - s);
    return levelObj[levelArr[levelArr.length - 1]].concat(hierarchyNodes);
  }

  // arr.length === 628, use time: ~20ms
  function filterParentPosition(arr) {
    var levelObj = {};
    arr.forEach(function (item) {
      var posLen = item.split('-').length;
      if (!levelObj[posLen]) {
        levelObj[posLen] = [];
      }
      levelObj[posLen].push(item);
    });
    var levelArr = Object.keys(levelObj).sort();

    var _loop = function _loop(i) {
      if (levelArr[i + 1]) {
        levelObj[levelArr[i]].forEach(function (ii) {
          var _loop2 = function _loop2(j) {
            levelObj[levelArr[j]].forEach(function (_i, index) {
              if (isPositionPrefix(ii, _i)) {
                levelObj[levelArr[j]][index] = null;
              }
            });
            levelObj[levelArr[j]] = levelObj[levelArr[j]].filter(function (p) {
              return p;
            });
          };

          for (var j = i + 1; j < levelArr.length; j++) {
            _loop2(j);
          }
        });
      }
    };

    for (var i = 0; i < levelArr.length; i++) {
      _loop(i);
    }
    var nArr = [];
    levelArr.forEach(function (i) {
      nArr = nArr.concat(levelObj[i]);
    });
    return nArr;
  }
  // console.log(filterParentPosition(
  // ['0-2', '0-3-3', '0-10', '0-10-0', '0-0-1', '0-0', '0-1-1', '0-1']
  // ));

  function stripTail(str) {
    var arr = str.match(/(.+)(-[^-]+)$/);
    var st = '';
    if (arr && arr.length === 3) {
      st = arr[1];
    }
    return st;
  }
  function splitPosition(pos) {
    return pos.split('-');
  }

  // todo: do optimization.
  function handleCheckState(obj, checkedPositionArr, checkIt) {
    // console.log(stripTail('0-101-000'));
    // let s = Date.now();
    var objKeys = Object.keys(obj);

    objKeys.forEach(function (i, index) {
      var iArr = splitPosition(i);
      var saved = false;
      checkedPositionArr.forEach(function (_pos) {
        var _posArr = splitPosition(_pos);
        if (iArr.length > _posArr.length && isInclude(_posArr, iArr)) {
          obj[i].halfChecked = false;
          obj[i].checked = checkIt;
          objKeys[index] = null;
        }
        if (iArr[0] === _posArr[0] && iArr[1] === _posArr[1]) {
          saved = true;
        }
      });
      if (!saved) {
        objKeys[index] = null;
      }
    });
    objKeys = objKeys.filter(function (i) {
      return i;
    }); // filter non null;

    var _loop3 = function _loop3(_pIndex) {
      // loop to set ancestral nodes's `checked` or `halfChecked`
      var loop = function loop(__pos) {
        var _posLen = splitPosition(__pos).length;
        if (_posLen <= 2) {
          // e.g. '0-0', '0-1'
          return;
        }
        var sibling = 0;
        var siblingChecked = 0;
        var parentPosition = stripTail(__pos);
        objKeys.forEach(function (i /* , index*/) {
          var iArr = splitPosition(i);
          if (iArr.length === _posLen && isInclude(splitPosition(parentPosition), iArr)) {
            sibling++;
            if (obj[i].checked) {
              siblingChecked++;
              var _i = checkedPositionArr.indexOf(i);
              if (_i > -1) {
                checkedPositionArr.splice(_i, 1);
                if (_i <= _pIndex) {
                  _pIndex--;
                }
              }
            } else if (obj[i].halfChecked) {
              siblingChecked += 0.5;
            }
            // objKeys[index] = null;
          }
        });
        // objKeys = objKeys.filter(i => i); // filter non null;
        var parent = obj[parentPosition];
        // not check, checked, halfChecked
        if (siblingChecked === 0) {
          parent.checked = false;
          parent.halfChecked = false;
        } else if (siblingChecked === sibling) {
          parent.checked = true;
          parent.halfChecked = false;
        } else {
          parent.halfChecked = true;
          parent.checked = false;
        }
        loop(parentPosition);
      };
      loop(checkedPositionArr[_pIndex], _pIndex);
      pIndex = _pIndex;
    };

    for (var pIndex = 0; pIndex < checkedPositionArr.length; pIndex++) {
      _loop3(pIndex);
    }
    // console.log(Date.now()-s, objKeys.length, checkIt);
  }

  function getCheck(treeNodesStates, checkedPositions) {
    var halfCheckedKeys = [];
    var checkedKeys = [];
    var checkedNodes = [];
    Object.keys(treeNodesStates).forEach(function (item) {
      var itemObj = treeNodesStates[item];
      if (itemObj.checked) {
        checkedKeys.push(itemObj.key);
        // checkedNodes.push(getValuePropValue(itemObj.node));
        checkedNodes.push(_extends$2({}, itemObj, { pos: item }));
      } else if (itemObj.halfChecked) {
        halfCheckedKeys.push(itemObj.key);
      }
    });
    return {
      halfCheckedKeys: halfCheckedKeys, checkedKeys: checkedKeys, checkedNodes: checkedNodes, treeNodesStates: treeNodesStates, checkedPositions: checkedPositions
    };
  }

  function getTreeNodesStates(children, values) {
    var checkedPositions = [];
    var treeNodesStates = {};
    loopAllChildren(children, function (item, index, pos, keyOrPos, siblingPosition) {
      treeNodesStates[pos] = {
        node: item,
        key: keyOrPos,
        checked: false,
        halfChecked: false,
        siblingPosition: siblingPosition
      };
      if (values.indexOf(getValuePropValue$1(item)) !== -1) {
        treeNodesStates[pos].checked = true;
        checkedPositions.push(pos);
      }
    });

    handleCheckState(treeNodesStates, filterParentPosition(checkedPositions.sort()), true);

    return getCheck(treeNodesStates, checkedPositions);
  }
  // const newChildren = recursiveCloneChildren(children, child => {
  //   const extraProps = {};
  //   if (child && child.type && child.type.xxx) {
  //     extraProps._prop = true;
  //     return React.cloneElement(child, extraProps);
  //   }
  //   return child;
  // });


  function recursiveGen(children) {
    var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    return React$1__default.Children.map(children, function (child, index) {
      var pos = level + '-' + index;

      var _child$props = child.props,
          title = _child$props.title,
          label = _child$props.label,
          value = _child$props.value,
          subChildren = _child$props.children,
          rest = _objectWithoutProperties$1(_child$props, ['title', 'label', 'value', 'children']);

      var o = _extends$2({}, rest, {
        title: title,
        label: label || title,
        value: value,
        key: child.key,
        _pos: pos
      });
      if (subChildren) {
        o.children = recursiveGen(subChildren, pos);
      }
      return o;
    });
  }

  function recursive(children, cb) {
    children.forEach(function (item) {
      cb(item);
      if (item.children) {
        recursive(item.children, cb);
      }
    });
  }

  // Get the tree's checkedNodes (todo: can merge to the `handleCheckState` function)
  // If one node checked, it's all children nodes checked.
  // If sibling nodes all checked, the parent checked.
  function filterAllCheckedData(vs, treeNodes) {
    var vals = [].concat(vs);
    if (!vals.length) {
      return vals;
    }

    var data = recursiveGen(treeNodes);
    var checkedNodesPositions = [];

    function checkChildren(children) {
      children.forEach(function (item) {
        if (item.__checked) {
          return;
        }
        var ci = vals.indexOf(item.value);
        var childs = item.children;
        if (ci > -1) {
          item.__checked = true;
          checkedNodesPositions.push({ node: item, pos: item._pos });
          vals.splice(ci, 1);
          if (childs) {
            recursive(childs, function (child) {
              child.__checked = true;
              checkedNodesPositions.push({ node: child, pos: child._pos });
            });
          }
        } else {
          if (childs) {
            checkChildren(childs);
          }
        }
      });
    }

    function checkParent(children) {
      var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { root: true };

      var siblingChecked = 0;
      children.forEach(function (item) {
        var childs = item.children;
        if (childs && !item.__checked && !item.__halfChecked) {
          var p = checkParent(childs, item);
          if (p.__checked) {
            siblingChecked++;
          } else if (p.__halfChecked) {
            siblingChecked += 0.5;
          }
        } else if (item.__checked) {
          siblingChecked++;
        } else if (item.__halfChecked) {
          siblingChecked += 0.5;
        }
      });
      var len = children.length;
      if (siblingChecked === len) {
        parent.__checked = true;
        checkedNodesPositions.push({ node: parent, pos: parent._pos });
      } else if (siblingChecked < len && siblingChecked > 0) {
        parent.__halfChecked = true;
      }
      if (parent.root) {
        return children;
      }
      return parent;
    }
    checkChildren(data);
    checkParent(data);

    checkedNodesPositions.forEach(function (i, index) {
      // clear private metadata
      delete checkedNodesPositions[index].node.__checked;
      delete checkedNodesPositions[index].node._pos;
      // create the same structure of `onCheck`'s return.
      checkedNodesPositions[index].node.props = {
        title: checkedNodesPositions[index].node.title,
        label: checkedNodesPositions[index].node.label || checkedNodesPositions[index].node.title,
        value: checkedNodesPositions[index].node.value
      };
      if (checkedNodesPositions[index].node.children) {
        checkedNodesPositions[index].node.props.children = checkedNodesPositions[index].node.children;
      }
      delete checkedNodesPositions[index].node.title;
      delete checkedNodesPositions[index].node.label;
      delete checkedNodesPositions[index].node.value;
      delete checkedNodesPositions[index].node.children;
    });
    return checkedNodesPositions;
  }

  function processSimpleTreeData(treeData, format) {
    function unflatten2(array) {
      var _ref;

      var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (_ref = {}, _ref[format.id] = format.rootPId, _ref);

      var children = [];
      for (var i = 0; i < array.length; i++) {
        array[i] = _extends$2({}, array[i]); // copy, can not corrupts original data
        if (array[i][format.pId] === parent[format.id]) {
          array[i].key = array[i][format.id];
          children.push(array[i]);
          array.splice(i--, 1);
        }
      }
      if (children.length) {
        parent.children = children;
        children.forEach(function (child) {
          return unflatten2(array, child);
        });
      }
      if (parent[format.id] === format.rootPId) {
        return children;
      }
    }
    return unflatten2(treeData);
  }

  function saveRef$3(instance, name) {
    if (!instance.saveRefs) {
      instance.saveRefs = {};
    }
    if (!instance.saveRefs[name]) {
      instance.saveRefs[name] = function (node) {
        instance[name] = node;
      };
    }
    return instance.saveRefs[name];
  }

  /* eslint no-loop-func: 0*/

  function getOffset$2(ele) {
    if (!ele.getClientRects().length) {
      return { top: 0, left: 0 };
    }

    var rect = ele.getBoundingClientRect();
    if (rect.width || rect.height) {
      var doc = ele.ownerDocument;
      var win = doc.defaultView;
      var docElem = doc.documentElement;

      return {
        top: rect.top + win.pageYOffset - docElem.clientTop,
        left: rect.left + win.pageXOffset - docElem.clientLeft
      };
    }

    return rect;
  }

  function traverseTreeNodes$1(treeNodes, callback) {
    var traverse = function traverse(subTreeNodes, level, parentsChildrenPos, parentPos) {
      if (Array.isArray(subTreeNodes)) {
        subTreeNodes = subTreeNodes.filter(function (item) {
          return !!item;
        });
      }
      React$1.Children.forEach(subTreeNodes, function (item, index) {
        var pos = level + '-' + index;
        parentsChildrenPos.push(pos); // Note: side effect

        var childrenPos = [];
        if (item.props.children && item.type && item.type.isTreeNode) {
          traverse(item.props.children, pos, childrenPos, pos);
        }
        callback(item, index, pos, item.key || pos, childrenPos, parentPos);
      });
    };
    traverse(treeNodes, 0, []);
  }

  function updateCheckState(obj, checkedPosition, checkIt) {
    var childrenLoop = function childrenLoop(parentObj) {
      parentObj.childrenPos.forEach(function (childPos) {
        var childObj = obj[childPos];
        // User click don't change disabled item checked state
        if (!childObj.disableCheckbox && !childObj.disabled) {
          childObj.halfChecked = false;
          childObj.checked = checkIt;
        }
        childrenLoop(childObj);
      });
    };

    childrenLoop(obj[checkedPosition]);

    var parentLoop = function parentLoop(childObj) {
      if (!childObj.parentPos) return;
      var parentObj = obj[childObj.parentPos];

      var childrenCount = parentObj.childrenPos.length;

      var checkedChildrenCount = 0;
      parentObj.childrenPos.forEach(function (childPos) {
        if (obj[childPos].disableCheckbox) {
          childrenCount -= 1;
          return;
        }
        if (obj[childPos].checked === true) checkedChildrenCount++;else if (obj[childPos].halfChecked === true) checkedChildrenCount += 0.5;
      });

      if (checkedChildrenCount === childrenCount) {
        parentObj.checked = true;
        parentObj.halfChecked = false;
      } else if (checkedChildrenCount > 0) {
        parentObj.halfChecked = true;
        parentObj.checked = false;
      } else {
        parentObj.checked = false;
        parentObj.halfChecked = false;
      }
      parentLoop(parentObj);
    };

    parentLoop(obj[checkedPosition]);
  }

  function getCheck$1(treeNodesStates) {
    var halfCheckedKeys = [];
    var checkedKeys = [];
    var checkedNodes = [];
    var checkedNodesPositions = [];
    Object.keys(treeNodesStates).forEach(function (item) {
      var itemObj = treeNodesStates[item];
      if (itemObj.checked) {
        checkedKeys.push(itemObj.key);
        checkedNodes.push(itemObj.node);
        checkedNodesPositions.push({ node: itemObj.node, pos: item });
      } else if (itemObj.halfChecked) {
        halfCheckedKeys.push(itemObj.key);
      }
    });
    return {
      halfCheckedKeys: halfCheckedKeys,
      checkedKeys: checkedKeys,
      checkedNodes: checkedNodes,
      checkedNodesPositions: checkedNodesPositions
    };
  }

  function getStrictlyValue$1(checkedKeys, halfChecked) {
    if (halfChecked) {
      return { checked: checkedKeys, halfChecked: halfChecked };
    }
    return checkedKeys;
  }

  function isPositionPrefix$1(smallPos, bigPos) {
    if (bigPos.length < smallPos.length) {
      return false;
    }
    // attention: "0-0-1" "0-0-10"
    if (bigPos.length > smallPos.length && bigPos.charAt(smallPos.length) !== '-') {
      return false;
    }
    return bigPos.substr(0, smallPos.length) === smallPos;
  }

  function noop$9() {}

  var contextTypes$2 = {
    rcTree: PropTypes.shape({
      selectable: PropTypes.bool
    })
  };

  var Tree$2 = function (_React$Component) {
    _inherits$1(Tree, _React$Component);

    function Tree(props) {
      _classCallCheck$1(this, Tree);

      var _this = _possibleConstructorReturn$1(this, _React$Component.call(this, props));

      _initialiseProps$b.call(_this);

      var checkedKeys = _this.calcCheckedKeys(props);
      _this.state = {
        expandedKeys: _this.calcExpandedKeys(props),
        checkedKeys: checkedKeys.checkedKeys,
        halfCheckedKeys: checkedKeys.halfCheckedKeys,
        selectedKeys: _this.calcSelectedKeys(props),
        dragNodesKeys: '',
        dragOverNodeKey: '',
        dropNodeKey: ''
      };
      return _this;
    }

    Tree.prototype.getChildContext = function getChildContext() {
      var selectable = this.props.selectable;

      return {
        rcTree: {
          selectable: selectable
        }
      };
    };

    Tree.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var props = this.props;

      var newState = {};
      var expandedKeys = nextProps.expandedKeys !== props.expandedKeys ? this.calcExpandedKeys(nextProps, true) : undefined;
      if (expandedKeys) {
        newState.expandedKeys = expandedKeys;
      }

      var checkedKeys = nextProps.checkedKeys !== props.checkedKeys || props.loadData ? this.calcCheckedKeys(nextProps, true) : undefined;
      if (checkedKeys) {
        newState.checkedKeys = checkedKeys.checkedKeys;
        newState.halfCheckedKeys = checkedKeys.halfCheckedKeys;
      }

      var selectedKeys = nextProps.selectedKeys !== props.selectedKeys ? this.calcSelectedKeys(nextProps, true) : undefined;
      if (selectedKeys) {
        newState.selectedKeys = selectedKeys;
      }
      this.setState(newState);
    };

    Tree.prototype.onDragStart = function onDragStart(e, treeNode) {
      this.dragNode = treeNode;
      var newState = {
        dragNodesKeys: this.getDragNodesKeys(treeNode)
      };
      var expandedKeys = this.getExpandedKeys(treeNode, false);
      if (expandedKeys) {
        newState.expandedKeys = expandedKeys;
      }
      this.setState(newState);
      this.props.onDragStart({
        event: e,
        node: treeNode
      });
    };

    Tree.prototype.onDragEnter = function onDragEnter(e, treeNode) {
      var _this2 = this;

      var dropPosition = this.calcDropPosition(e, treeNode);
      if (this.dragNode.props.eventKey === treeNode.props.eventKey && dropPosition === 0) {
        this.setState({
          dragOverNodeKey: '',
          dropPosition: null
        });
        return;
      }
      this.setState({
        dragOverNodeKey: treeNode.props.eventKey,
        dropPosition: dropPosition
      });

      if (!this.delayedDragEnterLogic) {
        this.delayedDragEnterLogic = {};
      }
      Object.keys(this.delayedDragEnterLogic).forEach(function (key) {
        clearTimeout(_this2.delayedDragEnterLogic[key]);
      });
      this.delayedDragEnterLogic[treeNode.props.pos] = setTimeout(function () {
        var expandedKeys = _this2.getExpandedKeys(treeNode, true);
        if (expandedKeys) {
          _this2.setState({ expandedKeys: expandedKeys });
        }
        _this2.props.onDragEnter({
          event: e,
          node: treeNode,
          expandedKeys: expandedKeys && [].concat(expandedKeys) || [].concat(_this2.state.expandedKeys)
        });
      }, 400);
    };

    Tree.prototype.onDragOver = function onDragOver(e, treeNode) {
      this.props.onDragOver({ event: e, node: treeNode });
    };

    Tree.prototype.onDragLeave = function onDragLeave(e, treeNode) {
      this.props.onDragLeave({ event: e, node: treeNode });
    };

    Tree.prototype.onDrop = function onDrop(e, treeNode) {
      var state = this.state;

      var eventKey = treeNode.props.eventKey;
      this.setState({
        dragOverNodeKey: '',
        dropNodeKey: eventKey
      });
      if (state.dragNodesKeys.indexOf(eventKey) > -1) {
        warning_1$1(false, 'Can not drop to dragNode(include it\'s children node)');
        return;
      }

      var posArr = treeNode.props.pos.split('-');
      var res = {
        event: e,
        node: treeNode,
        dragNode: this.dragNode,
        dragNodesKeys: [].concat(state.dragNodesKeys),
        dropPosition: state.dropPosition + Number(posArr[posArr.length - 1])
      };
      if (state.dropPosition !== 0) {
        res.dropToGap = true;
      }
      this.props.onDrop(res);
    };

    Tree.prototype.onDragEnd = function onDragEnd(e, treeNode) {
      this.setState({
        dragOverNodeKey: ''
      });
      this.props.onDragEnd({ event: e, node: treeNode });
    };

    Tree.prototype.onExpand = function onExpand(treeNode) {
      var _this3 = this;

      var props = this.props,
          state = this.state;

      var expanded = !treeNode.props.expanded;
      var expandedKeys = [].concat(state.expandedKeys);
      var eventKey = treeNode.props.eventKey;

      var index = expandedKeys.indexOf(eventKey);
      if (expanded && index === -1) {
        expandedKeys.push(eventKey);
      } else if (!expanded && index > -1) {
        expandedKeys.splice(index, 1);
      }

      var controlled = 'expandedKeys' in props;
      if (!controlled) {
        this.setState({ expandedKeys: expandedKeys });
      }
      props.onExpand(expandedKeys, { node: treeNode, expanded: expanded });

      // After data loaded, need set new expandedKeys
      if (expanded && props.loadData) {
        return props.loadData(treeNode).then(function () {
          if (!controlled) {
            _this3.setState({ expandedKeys: expandedKeys });
          }
        });
      }
    };

    Tree.prototype.onSelect = function onSelect(treeNode) {
      var props = this.props,
          state = this.state;

      var eventKey = treeNode.props.eventKey;
      var selected = !treeNode.props.selected;

      var selectedKeys = [].concat(state.selectedKeys);
      if (!selected) {
        var index = selectedKeys.indexOf(eventKey);
        selectedKeys.splice(index, 1);
      } else if (!props.multiple) {
        selectedKeys = [eventKey];
      } else {
        selectedKeys.push(eventKey);
      }

      // TODO: can be optimized if we remove selectedNodes in API
      var selectedNodes = [];
      if (selectedKeys.length) {
        traverseTreeNodes$1(props.children, function (item) {
          if (selectedKeys.indexOf(item.key) !== -1) {
            selectedNodes.push(item);
          }
        });
      }

      if (!('selectedKeys' in props)) {
        this.setState({
          selectedKeys: selectedKeys
        });
      }

      var eventObj = {
        event: 'select',
        selected: selected,
        node: treeNode,
        selectedNodes: selectedNodes
      };
      props.onSelect(selectedKeys, eventObj);
    };

    Tree.prototype.onMouseEnter = function onMouseEnter(e, treeNode) {
      this.props.onMouseEnter({ event: e, node: treeNode });
    };

    Tree.prototype.onMouseLeave = function onMouseLeave(e, treeNode) {
      this.props.onMouseLeave({ event: e, node: treeNode });
    };

    Tree.prototype.onContextMenu = function onContextMenu(e, treeNode) {
      if (this.props.onRightClick) {
        e.preventDefault();
        this.props.onRightClick({ event: e, node: treeNode });
      }
    };

    // all keyboard events callbacks run from here at first


    Tree.prototype.getOpenTransitionName = function getOpenTransitionName() {
      var props = this.props;
      var transitionName = props.openTransitionName;
      var animationName = props.openAnimation;
      if (!transitionName && typeof animationName === 'string') {
        return props.prefixCls + '-open-' + animationName;
      }
      return transitionName;
    };

    Tree.prototype.getDragNodesKeys = function getDragNodesKeys(treeNode) {
      var dragNodesKeys = [];
      traverseTreeNodes$1(treeNode.props.children, function (item, index, pos, key) {
        if (isPositionPrefix$1(treeNode.props.pos, pos)) {
          dragNodesKeys.push(key);
        }
      });
      dragNodesKeys.push(treeNode.props.eventKey || treeNode.props.pos);
      return dragNodesKeys;
    };

    Tree.prototype.getExpandedKeys = function getExpandedKeys(treeNode, expand) {
      var eventKey = treeNode.props.eventKey;
      var expandedKeys = this.state.expandedKeys;
      var expandedIndex = expandedKeys.indexOf(eventKey);
      if (!expand && expandedIndex > -1) {
        var exKeys = [].concat(expandedKeys);
        exKeys.splice(expandedIndex, 1);
        return exKeys;
      }
      if (expand && expandedKeys.indexOf(eventKey) === -1) {
        return expandedKeys.concat([eventKey]);
      }
    };

    Tree.prototype.generateTreeNodesStates = function generateTreeNodesStates(children, checkedKeys) {
      var checkedPositions = [];
      var treeNodesStates = {};
      traverseTreeNodes$1(children, function (item, _, pos, key, childrenPos, parentPos) {
        treeNodesStates[pos] = {
          node: item,
          key: key,
          checked: false,
          halfChecked: false,
          disabled: item.props.disabled,
          disableCheckbox: item.props.disableCheckbox,
          childrenPos: childrenPos,
          parentPos: parentPos
        };
        if (checkedKeys.indexOf(key) !== -1) {
          treeNodesStates[pos].checked = true;
          checkedPositions.push(pos);
        }
      });
      checkedPositions.forEach(function (checkedPosition) {
        updateCheckState(treeNodesStates, checkedPosition, true);
      });
      return treeNodesStates;
    };

    Tree.prototype.calcExpandedKeys = function calcExpandedKeys(props, isNotInit) {
      var expandedKeys = props.expandedKeys || (isNotInit ? undefined : props.defaultExpandedKeys);
      if (!expandedKeys) {
        return undefined;
      }
      var expandAll = isNotInit ? false : props.defaultExpandAll;
      if (!expandAll && !props.autoExpandParent) {
        return expandedKeys;
      }

      var expandedPositionArr = [];
      if (props.autoExpandParent) {
        traverseTreeNodes$1(props.children, function (item, index, pos, key) {
          if (expandedKeys.indexOf(key) > -1) {
            expandedPositionArr.push(pos);
          }
        });
      }
      var filterExpandedKeysSet = {};
      traverseTreeNodes$1(props.children, function (item, index, pos, key) {
        if (expandAll) {
          filterExpandedKeysSet[key] = true;
        } else if (props.autoExpandParent) {
          var isCurrentParentOfExpanded = expandedPositionArr.some(function (p) {
            return isPositionPrefix$1(pos, p);
          });
          if (isCurrentParentOfExpanded) {
            filterExpandedKeysSet[key] = true;
          }
        }
      });
      var filterExpandedKeys = Object.keys(filterExpandedKeysSet);
      return filterExpandedKeys.length ? filterExpandedKeys : expandedKeys;
    };

    Tree.prototype.calcCheckedKeys = function calcCheckedKeys(props, isNotInit) {
      if (!props.checkable) {
        return { checkedKeys: [], halfCheckedKeys: [] };
      }

      var checkedKeys = props.checkedKeys || (isNotInit && !props.loadData ? undefined : props.defaultCheckedKeys);
      if (!checkedKeys) {
        return undefined;
      }
      if (Array.isArray(checkedKeys)) {
        checkedKeys = { checkedKeys: checkedKeys, halfCheckedKeys: [] };
      } else if (typeof checkedKeys === 'object') {
        checkedKeys = { checkedKeys: checkedKeys.checked, halfCheckedKeys: checkedKeys.halfChecked };
      }

      if (!props.checkStrictly) {
        var checked = checkedKeys.checkedKeys || [];
        var treeNodesStates = this.generateTreeNodesStates(props.children, checked);
        return getCheck$1(treeNodesStates);
      }

      return checkedKeys;
    };

    Tree.prototype.calcSelectedKeys = function calcSelectedKeys(props, isNotInit) {
      var selectedKeys = props.selectedKeys || (isNotInit ? undefined : props.defaultSelectedKeys);
      if (!selectedKeys) {
        return undefined;
      }
      if (props.multiple) {
        return [].concat(selectedKeys);
      }
      if (selectedKeys.length) {
        return [selectedKeys[0]];
      }
      return selectedKeys;
    };

    Tree.prototype.calcDropPosition = function calcDropPosition(e, treeNode) {
      var offsetTop = getOffset$2(treeNode.selectHandle).top;
      var offsetHeight = treeNode.selectHandle.offsetHeight;
      var pageY = e.pageY;
      var gapHeight = 2; // TODO: remove hard code
      if (pageY > offsetTop + offsetHeight - gapHeight) {
        return 1;
      }
      if (pageY < offsetTop + gapHeight) {
        return -1;
      }
      return 0;
    };

    Tree.prototype.renderTreeNode = function renderTreeNode(child, index) {
      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var state = this.state,
          props = this.props;

      var pos = level + '-' + index;
      var key = child.key || pos;

      var childProps = {
        root: this,
        eventKey: key,
        pos: pos,
        loadData: props.loadData,
        prefixCls: props.prefixCls,
        showIcon: props.showIcon,
        draggable: props.draggable,
        dragOver: state.dragOverNodeKey === key && state.dropPosition === 0,
        dragOverGapTop: state.dragOverNodeKey === key && state.dropPosition === -1,
        dragOverGapBottom: state.dragOverNodeKey === key && state.dropPosition === 1,
        expanded: state.expandedKeys.indexOf(key) !== -1,
        selected: state.selectedKeys.indexOf(key) !== -1,
        openTransitionName: this.getOpenTransitionName(),
        openAnimation: props.openAnimation,
        filterTreeNode: this.filterTreeNode
      };
      if (props.checkable) {
        childProps.checkable = props.checkable;
        childProps.checked = state.checkedKeys.indexOf(key) !== -1;
        childProps.halfChecked = state.halfCheckedKeys.indexOf(key) !== -1;
      }
      return React$1__default.cloneElement(child, childProps);
    };

    Tree.prototype.render = function render() {
      var _classNames;

      var props = this.props;
      var className = classnames(props.prefixCls, props.className, (_classNames = {}, _classNames[props.prefixCls + '-show-line'] = props.showLine, _classNames));
      var domProps = {};
      if (props.focusable) {
        domProps.tabIndex = '0';
        domProps.onKeyDown = this.onKeyDown;
      }

      return React$1__default.createElement(
        'ul',
        _extends$2({}, domProps, {
          className: className,
          role: 'tree-node',
          unselectable: 'on'
        }),
        React$1__default.Children.map(props.children, this.renderTreeNode, this)
      );
    };

    return Tree;
  }(React$1__default.Component);

  Tree$2.propTypes = {
    prefixCls: PropTypes.string,
    children: PropTypes.any,
    showLine: PropTypes.bool,
    showIcon: PropTypes.bool,
    selectable: PropTypes.bool,
    multiple: PropTypes.bool,
    checkable: PropTypes.oneOfType([PropTypes.bool, PropTypes.node]),
    checkStrictly: PropTypes.bool,
    draggable: PropTypes.bool,
    autoExpandParent: PropTypes.bool,
    defaultExpandAll: PropTypes.bool,
    defaultExpandedKeys: PropTypes.arrayOf(PropTypes.string),
    expandedKeys: PropTypes.arrayOf(PropTypes.string),
    defaultCheckedKeys: PropTypes.arrayOf(PropTypes.string),
    checkedKeys: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.object]),
    defaultSelectedKeys: PropTypes.arrayOf(PropTypes.string),
    selectedKeys: PropTypes.arrayOf(PropTypes.string),
    onExpand: PropTypes.func,
    onCheck: PropTypes.func,
    onSelect: PropTypes.func,
    loadData: PropTypes.func,
    onMouseEnter: PropTypes.func,
    onMouseLeave: PropTypes.func,
    onRightClick: PropTypes.func,
    onDragStart: PropTypes.func,
    onDragEnter: PropTypes.func,
    onDragOver: PropTypes.func,
    onDragLeave: PropTypes.func,
    onDrop: PropTypes.func,
    onDragEnd: PropTypes.func,
    filterTreeNode: PropTypes.func,
    openTransitionName: PropTypes.string,
    openAnimation: PropTypes.oneOfType([PropTypes.string, PropTypes.object])
  };
  Tree$2.childContextTypes = contextTypes$2;
  Tree$2.defaultProps = {
    prefixCls: 'rc-tree',
    showLine: false,
    showIcon: true,
    selectable: true,
    multiple: false,
    checkable: false,
    checkStrictly: false,
    draggable: false,
    autoExpandParent: true,
    defaultExpandAll: false,
    defaultExpandedKeys: [],
    defaultCheckedKeys: [],
    defaultSelectedKeys: [],
    onExpand: noop$9,
    onCheck: noop$9,
    onSelect: noop$9,
    onDragStart: noop$9,
    onDragEnter: noop$9,
    onDragOver: noop$9,
    onDragLeave: noop$9,
    onDrop: noop$9,
    onDragEnd: noop$9,
    onMouseEnter: noop$9,
    onMouseLeave: noop$9
  };

  var _initialiseProps$b = function _initialiseProps() {
    var _this4 = this;

    this.onCheck = function (treeNode) {
      var props = _this4.props,
          state = _this4.state;

      var checked = !treeNode.props.checked || treeNode.props.halfChecked;
      var eventObj = {
        event: 'check',
        node: treeNode,
        checked: checked
      };

      if (props.checkStrictly) {
        var eventKey = treeNode.props.eventKey;
        var checkedKeys = [].concat(state.checkedKeys);
        var index = checkedKeys.indexOf(eventKey);
        if (checked && index === -1) {
          checkedKeys.push(eventKey);
        }
        if (!checked && index > -1) {
          checkedKeys.splice(index, 1);
        }

        eventObj.checkedNodes = [];
        traverseTreeNodes$1(props.children, function (item) {
          if (checkedKeys.indexOf(item.key) !== -1) {
            eventObj.checkedNodes.push(item);
          }
        });

        if (!('checkedKeys' in props)) {
          _this4.setState({
            checkedKeys: checkedKeys
          });
        }
        props.onCheck(getStrictlyValue$1(checkedKeys, state.halfCheckedKeys), eventObj);
      } else {
        var treeNodesStates = _this4.generateTreeNodesStates(props.children, state.checkedKeys);
        treeNodesStates[treeNode.props.pos].checked = checked;
        treeNodesStates[treeNode.props.pos].halfChecked = false;
        updateCheckState(treeNodesStates, treeNode.props.pos, checked);

        var checkKeys = getCheck$1(treeNodesStates);
        eventObj.checkedNodes = checkKeys.checkedNodes;
        eventObj.checkedNodesPositions = checkKeys.checkedNodesPositions; // TODO: not in API
        eventObj.halfCheckedKeys = checkKeys.halfCheckedKeys; // TODO: not in API

        if (!('checkedKeys' in props)) {
          _this4.setState({
            checkedKeys: checkKeys.checkedKeys,
            halfCheckedKeys: checkKeys.halfCheckedKeys
          });
        }
        props.onCheck(checkKeys.checkedKeys, eventObj);
      }
    };

    this.onKeyDown = function (e) {
      e.preventDefault();
    };

    this.filterTreeNode = function (treeNode) {
      var filterTreeNode = _this4.props.filterTreeNode;
      if (typeof filterTreeNode !== 'function' || treeNode.props.disabled) {
        return false;
      }
      return filterTreeNode.call(_this4, treeNode);
    };
  };

  var defaultTitle$1 = '---';

  var TreeNode$1 = function (_React$Component) {
    _inherits$1(TreeNode, _React$Component);

    function TreeNode(props) {
      _classCallCheck$1(this, TreeNode);

      var _this = _possibleConstructorReturn$1(this, _React$Component.call(this, props));

      _this.onCheck = function () {
        _this.props.root.onCheck(_this);
      };

      _this.onMouseEnter = function (e) {
        e.preventDefault();
        _this.props.root.onMouseEnter(e, _this);
      };

      _this.onMouseLeave = function (e) {
        e.preventDefault();
        _this.props.root.onMouseLeave(e, _this);
      };

      _this.onContextMenu = function (e) {
        _this.props.root.onContextMenu(e, _this);
      };

      _this.onDragStart = function (e) {
        e.stopPropagation();
        _this.setState({
          dragNodeHighlight: true
        });
        _this.props.root.onDragStart(e, _this);
        try {
          // ie throw error
          // firefox-need-it
          e.dataTransfer.setData('text/plain', '');
        } catch (error) {
          // empty
        }
      };

      _this.onDragEnter = function (e) {
        e.preventDefault();
        e.stopPropagation();
        _this.props.root.onDragEnter(e, _this);
      };

      _this.onDragOver = function (e) {
        e.preventDefault();
        e.stopPropagation();
        _this.props.root.onDragOver(e, _this);
      };

      _this.onDragLeave = function (e) {
        e.stopPropagation();
        _this.props.root.onDragLeave(e, _this);
      };

      _this.onDrop = function (e) {
        e.preventDefault();
        e.stopPropagation();
        _this.setState({
          dragNodeHighlight: false
        });
        _this.props.root.onDrop(e, _this);
      };

      _this.onDragEnd = function (e) {
        e.stopPropagation();
        _this.setState({
          dragNodeHighlight: false
        });
        _this.props.root.onDragEnd(e, _this);
      };

      _this.onExpand = function () {
        var callbackPromise = _this.props.root.onExpand(_this);
        if (callbackPromise && typeof callbackPromise === 'object') {
          var setLoading = function setLoading(dataLoading) {
            _this.setState({ dataLoading: dataLoading });
          };
          setLoading(true);
          callbackPromise.then(function () {
            setLoading(false);
          }, function () {
            setLoading(false);
          });
        }
      };

      _this.saveSelectHandle = function (node) {
        _this.selectHandle = node;
      };

      _this.state = {
        dataLoading: false,
        dragNodeHighlight: false
      };
      return _this;
    }

    TreeNode.prototype.onSelect = function onSelect() {
      this.props.root.onSelect(this);
    };

    // keyboard event support
    TreeNode.prototype.onKeyDown = function onKeyDown(e) {
      e.preventDefault();
    };

    TreeNode.prototype.isSelectable = function isSelectable() {
      var props = this.props,
          context = this.context;

      return 'selectable' in props ? props.selectable : context.rcTree.selectable;
    };

    TreeNode.prototype.renderSwitcher = function renderSwitcher(props, expandedState) {
      var prefixCls = props.prefixCls;
      var switcherCls = classnames(prefixCls + '-switcher', prefixCls + '-switcher_' + expandedState);
      return React$1__default.createElement('span', { className: switcherCls, onClick: this.onExpand });
    };

    TreeNode.prototype.renderCheckbox = function renderCheckbox(props) {
      var _checkboxCls;

      var prefixCls = props.prefixCls;
      var checkboxCls = (_checkboxCls = {}, _checkboxCls[prefixCls + '-checkbox'] = true, _checkboxCls);
      if (props.checked) {
        checkboxCls[prefixCls + '-checkbox-checked'] = true;
      } else if (props.halfChecked) {
        checkboxCls[prefixCls + '-checkbox-indeterminate'] = true;
      }
      var customEle = null;
      if (typeof props.checkable !== 'boolean') {
        customEle = props.checkable;
      }
      if (props.disabled || props.disableCheckbox) {
        checkboxCls[prefixCls + '-checkbox-disabled'] = true;
        return React$1__default.createElement(
          'span',
          { className: classnames(checkboxCls) },
          customEle
        );
      }
      return React$1__default.createElement(
        'span',
        {
          className: classnames(checkboxCls),
          onClick: this.onCheck
        },
        customEle
      );
    };

    TreeNode.prototype.renderChildren = function renderChildren(props) {
      var renderFirst = this.renderFirst;
      this.renderFirst = 1;
      var transitionAppear = true;
      if (!renderFirst && props.expanded) {
        transitionAppear = false;
      }
      var children = null;
      if (props.children) {
        children = toArray(props.children).filter(function (item) {
          return !!item;
        });
      }
      var newChildren = children;
      if (children && (Array.isArray(children) && children.length && children.every(function (item) {
        return item.type && item.type.isTreeNode;
      }) || children.type && children.type.isTreeNode)) {
        var _classNames;

        var animProps = {};
        if (props.openTransitionName) {
          animProps.transitionName = props.openTransitionName;
        } else if (typeof props.openAnimation === 'object') {
          animProps.animation = _extends$2({}, props.openAnimation);
          if (!transitionAppear) {
            delete animProps.animation.appear;
          }
        }
        var cls = classnames(props.prefixCls + '-child-tree', (_classNames = {}, _classNames[props.prefixCls + '-child-tree-open'] = props.expanded, _classNames));
        newChildren = React$1__default.createElement(
          Animate,
          _extends$2({}, animProps, {
            showProp: 'data-expanded',
            transitionAppear: transitionAppear,
            component: ''
          }),
          !props.expanded ? null : React$1__default.createElement(
            'ul',
            { className: cls, 'data-expanded': props.expanded },
            React$1__default.Children.map(children, function (item, index) {
              return props.root.renderTreeNode(item, index, props.pos);
            }, props.root)
          )
        );
      }
      return newChildren;
    };

    TreeNode.prototype.render = function render() {
      var _iconEleCls,
          _this2 = this;

      var props = this.props;

      var prefixCls = props.prefixCls;
      var expandedState = props.expanded ? 'open' : 'close';
      var iconState = expandedState;

      var canRenderSwitcher = true;
      var content = props.title;
      var newChildren = this.renderChildren(props);
      if (!newChildren || newChildren === props.children) {
        // content = newChildren;
        newChildren = null;
        if (!props.loadData || props.isLeaf) {
          canRenderSwitcher = false;
          iconState = 'docu';
        }
      }
      // For performance, does't render children into dom when `!props.expanded` (move to Animate)
      // if (!props.expanded) {
      //   newChildren = null;
      // }

      var iconEleCls = (_iconEleCls = {}, _iconEleCls[prefixCls + '-iconEle'] = true, _iconEleCls[prefixCls + '-icon_loading'] = this.state.dataLoading, _iconEleCls[prefixCls + '-icon__' + iconState] = true, _iconEleCls);

      var selectHandle = function selectHandle() {
        var icon = props.showIcon || props.loadData && _this2.state.dataLoading ? React$1__default.createElement('span', { className: classnames(iconEleCls) }) : null;
        var title = React$1__default.createElement(
          'span',
          { className: prefixCls + '-title' },
          content
        );
        var wrap = prefixCls + '-node-content-wrapper';
        var domProps = {
          className: wrap + ' ' + wrap + '-' + (iconState === expandedState ? iconState : 'normal'),
          onMouseEnter: _this2.onMouseEnter,
          onMouseLeave: _this2.onMouseLeave,
          onContextMenu: _this2.onContextMenu
        };
        if (!props.disabled) {
          if (props.selected || _this2.state.dragNodeHighlight) {
            domProps.className += ' ' + prefixCls + '-node-selected';
          }
          domProps.onClick = function (e) {
            if (_this2.isSelectable()) {
              e.preventDefault();
              _this2.onSelect();
            } else if (props.checkable && !props.disableCheckbox) {
              e.preventDefault();
              // && !props.disabled is checked on line 259
              _this2.onCheck();
            }
          };
          if (props.draggable) {
            domProps.className += ' draggable';
            domProps.draggable = true;
            domProps['aria-grabbed'] = true;
            domProps.onDragStart = _this2.onDragStart;
          }
        }
        return React$1__default.createElement(
          'span',
          _extends$2({
            ref: _this2.saveSelectHandle,
            title: typeof content === 'string' ? content : ''
          }, domProps),
          icon,
          title
        );
      };

      var liProps = {};
      if (props.draggable) {
        liProps.onDragEnter = this.onDragEnter;
        liProps.onDragOver = this.onDragOver;
        liProps.onDragLeave = this.onDragLeave;
        liProps.onDrop = this.onDrop;
        liProps.onDragEnd = this.onDragEnd;
      }

      var disabledCls = '';
      var dragOverCls = '';
      if (props.disabled) {
        disabledCls = prefixCls + '-treenode-disabled';
      } else if (props.dragOver) {
        dragOverCls = 'drag-over';
      } else if (props.dragOverGapTop) {
        dragOverCls = 'drag-over-gap-top';
      } else if (props.dragOverGapBottom) {
        dragOverCls = 'drag-over-gap-bottom';
      }

      var filterCls = props.filterTreeNode(this) ? 'filter-node' : '';

      var renderNoopSwitcher = function renderNoopSwitcher() {
        return React$1__default.createElement('span', { className: prefixCls + '-switcher ' + prefixCls + '-switcher-noop' });
      };

      return React$1__default.createElement(
        'li',
        _extends$2({}, liProps, {
          className: classnames(props.className, disabledCls, dragOverCls, filterCls)
        }),
        canRenderSwitcher ? this.renderSwitcher(props, expandedState) : renderNoopSwitcher(),
        props.checkable ? this.renderCheckbox(props) : null,
        selectHandle(),
        newChildren
      );
    };

    return TreeNode;
  }(React$1__default.Component);

  TreeNode$1.propTypes = {
    prefixCls: PropTypes.string,
    disabled: PropTypes.bool,
    disableCheckbox: PropTypes.bool,
    expanded: PropTypes.bool,
    isLeaf: PropTypes.bool,
    root: PropTypes.object,
    onSelect: PropTypes.func
  };
  TreeNode$1.contextTypes = contextTypes$2;
  TreeNode$1.defaultProps = {
    title: defaultTitle$1
  };


  TreeNode$1.isTreeNode = 1;

  Tree$2.TreeNode = TreeNode$1;

  var BUILT_IN_PLACEMENTS$1 = {
    bottomLeft: {
      points: ['tl', 'bl'],
      offset: [0, 4],
      overflow: {
        adjustX: 0,
        adjustY: 1
      }
    },
    topLeft: {
      points: ['bl', 'tl'],
      offset: [0, -4],
      overflow: {
        adjustX: 0,
        adjustY: 1
      }
    }
  };

  var SelectTrigger$1 = function (_Component) {
    _inherits$1(SelectTrigger, _Component);

    function SelectTrigger() {
      var _temp, _this, _ret;

      _classCallCheck$1(this, SelectTrigger);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn$1(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.state = {
        _expandedKeys: [],
        fireOnExpand: false,
        dropdownWidth: null
      }, _this.onExpand = function (expandedKeys) {
        // rerender
        _this.setState({
          _expandedKeys: expandedKeys,
          fireOnExpand: true
        }, function () {
          // Fix https://github.com/ant-design/ant-design/issues/5689
          if (_this.trigger && _this.trigger.forcePopupAlign) {
            _this.trigger.forcePopupAlign();
          }
        });
      }, _this.highlightTreeNode = function (treeNode) {
        var props = _this.props;
        var filterVal = treeNode.props[labelCompatible(props.treeNodeFilterProp)];
        if (typeof filterVal === 'string') {
          return props.inputValue && filterVal.indexOf(props.inputValue) > -1;
        }
        return false;
      }, _this.filterTreeNode = function (input, child) {
        if (!input) {
          return true;
        }
        var filterTreeNode = _this.props.filterTreeNode;
        if (!filterTreeNode) {
          return true;
        }
        if (child.props.disabled) {
          return false;
        }
        return filterTreeNode.call(_this, input, child);
      }, _temp), _possibleConstructorReturn$1(_this, _ret);
    }

    SelectTrigger.prototype.componentDidMount = function componentDidMount() {
      this.setDropdownWidth();
    };

    SelectTrigger.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (nextProps.inputValue && nextProps.inputValue !== this.props.inputValue) {
        // set autoExpandParent to true
        this.setState({
          _expandedKeys: [],
          fireOnExpand: false
        });
      }
    };

    SelectTrigger.prototype.componentDidUpdate = function componentDidUpdate() {
      this.setDropdownWidth();
    };

    SelectTrigger.prototype.setDropdownWidth = function setDropdownWidth() {
      var width = ReactDOM__default.findDOMNode(this).offsetWidth;
      if (width !== this.state.dropdownWidth) {
        this.setState({ dropdownWidth: width });
      }
    };

    SelectTrigger.prototype.getPopupEleRefs = function getPopupEleRefs() {
      return this.popupEle;
    };

    SelectTrigger.prototype.getPopupDOMNode = function getPopupDOMNode() {
      return this.trigger.getPopupDomNode();
    };

    SelectTrigger.prototype.getDropdownTransitionName = function getDropdownTransitionName() {
      var props = this.props;
      var transitionName = props.transitionName;
      if (!transitionName && props.animation) {
        transitionName = this.getDropdownPrefixCls() + '-' + props.animation;
      }
      return transitionName;
    };

    SelectTrigger.prototype.getDropdownPrefixCls = function getDropdownPrefixCls() {
      return this.props.prefixCls + '-dropdown';
    };

    SelectTrigger.prototype.processTreeNode = function processTreeNode(treeNodes) {
      var _this2 = this;

      var filterPoss = [];
      this._expandedKeys = [];
      loopAllChildren(treeNodes, function (child, index, pos) {
        if (_this2.filterTreeNode(_this2.props.inputValue, child)) {
          filterPoss.push(pos);
          _this2._expandedKeys.push(child.key);
        }
      });

      // Include the filtered nodes's ancestral nodes.
      var processedPoss = [];
      filterPoss.forEach(function (pos) {
        var arr = pos.split('-');
        arr.reduce(function (pre, cur) {
          var res = pre + '-' + cur;
          if (processedPoss.indexOf(res) < 0) {
            processedPoss.push(res);
          }
          return res;
        });
      });
      var filterNodesPositions = [];
      loopAllChildren(treeNodes, function (child, index, pos) {
        if (processedPoss.indexOf(pos) > -1) {
          filterNodesPositions.push({ node: child, pos: pos });
        }
      });

      var hierarchyNodes = flatToHierarchy(filterNodesPositions);

      var recursive = function recursive(children) {
        return children.map(function (child) {
          if (child.children) {
            return React$1__default.cloneElement(child.node, {}, recursive(child.children));
          }
          return child.node;
        });
      };
      return recursive(hierarchyNodes);
    };

    SelectTrigger.prototype.renderTree = function renderTree(keys, halfCheckedKeys, newTreeNodes, multiple) {
      var props = this.props;

      var trProps = {
        multiple: multiple,
        prefixCls: props.prefixCls + '-tree',
        showIcon: props.treeIcon,
        showLine: props.treeLine,
        defaultExpandAll: props.treeDefaultExpandAll,
        defaultExpandedKeys: props.treeDefaultExpandedKeys,
        filterTreeNode: this.highlightTreeNode
      };

      if (props.treeCheckable) {
        trProps.selectable = false;
        trProps.checkable = props.treeCheckable;
        trProps.onCheck = props.onSelect;
        trProps.checkStrictly = props.treeCheckStrictly;
        if (props.inputValue) {
          // enable checkStrictly when search tree.
          trProps.checkStrictly = true;
        } else {
          trProps._treeNodesStates = props._treeNodesStates;
        }
        if (trProps.treeCheckStrictly && halfCheckedKeys.length) {
          trProps.checkedKeys = { checked: keys, halfChecked: halfCheckedKeys };
        } else {
          trProps.checkedKeys = keys;
        }
      } else {
        trProps.selectedKeys = keys;
        trProps.onSelect = props.onSelect;
      }

      // expand keys
      if (!trProps.defaultExpandAll && !trProps.defaultExpandedKeys && !props.loadData) {
        trProps.expandedKeys = keys;
      }
      trProps.autoExpandParent = true;
      trProps.onExpand = this.onExpand;
      if (this._expandedKeys && this._expandedKeys.length) {
        trProps.expandedKeys = this._expandedKeys;
      }
      if (this.state.fireOnExpand) {
        trProps.expandedKeys = this.state._expandedKeys;
        trProps.autoExpandParent = false;
      }

      // async loadData
      if (props.loadData) {
        trProps.loadData = props.loadData;
      }

      return React$1__default.createElement(
        Tree$2,
        _extends$2({ ref: saveRef$3(this, 'popupEle') }, trProps),
        newTreeNodes
      );
    };

    SelectTrigger.prototype.render = function render() {
      var _popupClassName;

      var props = this.props;
      var multiple = props.multiple;
      var dropdownPrefixCls = this.getDropdownPrefixCls();
      var popupClassName = (_popupClassName = {}, _popupClassName[props.dropdownClassName] = !!props.dropdownClassName, _popupClassName[dropdownPrefixCls + '--' + (multiple ? 'multiple' : 'single')] = 1, _popupClassName);
      var visible = props.visible;
      var search = multiple || !props.showSearch ? null : React$1__default.createElement(
        'span',
        { className: dropdownPrefixCls + '-search' },
        props.inputElement
      );

      var recursive = function recursive(children) {
        // Note: if use `React.Children.map`, the node's key will be modified.
        return toArray(children).map(function handler(child) {
          // eslint-disable-line
          if (!child) {
            return null;
          }
          if (child && child.props.children) {
            // null or String has no Prop
            return React$1__default.createElement(
              TreeNode$1,
              _extends$2({}, child.props, { key: child.key }),
              recursive(child.props.children)
            );
          }
          return React$1__default.createElement(TreeNode$1, _extends$2({}, child.props, { key: child.key }));
        });
      };
      // const s = Date.now();
      var treeNodes = void 0;
      if (props._cachetreeData && this.treeNodes) {
        treeNodes = this.treeNodes;
      } else {
        treeNodes = recursive(props.treeData || props.treeNodes);
        this.treeNodes = treeNodes;
      }
      // console.log(Date.now()-s);

      if (props.inputValue) {
        treeNodes = this.processTreeNode(treeNodes);
      }

      var keys = [];
      var halfCheckedKeys = [];
      loopAllChildren(treeNodes, function (child) {
        if (props.value.some(function (item) {
          return item.value === getValuePropValue$1(child);
        })) {
          keys.push(child.key);
        }
        if (props.halfCheckedValues && props.halfCheckedValues.some(function (item) {
          return item.value === getValuePropValue$1(child);
        })) {
          halfCheckedKeys.push(child.key);
        }
      });

      var notFoundContent = void 0;
      if (!treeNodes.length) {
        if (props.notFoundContent) {
          notFoundContent = React$1__default.createElement(
            'span',
            { className: props.prefixCls + '-not-found' },
            props.notFoundContent
          );
        } else if (!search) {
          visible = false;
        }
      }
      var popupElement = React$1__default.createElement(
        'div',
        null,
        search,
        notFoundContent || this.renderTree(keys, halfCheckedKeys, treeNodes, multiple)
      );

      var popupStyle = _extends$2({}, props.dropdownStyle);
      var widthProp = props.dropdownMatchSelectWidth ? 'width' : 'minWidth';
      if (this.state.dropdownWidth) {
        popupStyle[widthProp] = this.state.dropdownWidth + 'px';
      }

      return React$1__default.createElement(
        Trigger,
        {
          action: props.disabled ? [] : ['click'],
          ref: saveRef$3(this, 'trigger'),
          popupPlacement: 'bottomLeft',
          builtinPlacements: BUILT_IN_PLACEMENTS$1,
          popupAlign: props.dropdownPopupAlign,
          prefixCls: dropdownPrefixCls,
          popupTransitionName: this.getDropdownTransitionName(),
          onPopupVisibleChange: props.onDropdownVisibleChange,
          popup: popupElement,
          popupVisible: visible,
          getPopupContainer: props.getPopupContainer,
          popupClassName: classnames(popupClassName),
          popupStyle: popupStyle
        },
        this.props.children
      );
    };

    return SelectTrigger;
  }(React$1.Component);

  SelectTrigger$1.propTypes = {
    dropdownMatchSelectWidth: PropTypes.bool,
    dropdownPopupAlign: PropTypes.object,
    visible: PropTypes.bool,
    filterTreeNode: PropTypes.any,
    treeNodes: PropTypes.any,
    inputValue: PropTypes.string,
    prefixCls: PropTypes.string,
    popupClassName: PropTypes.string,
    children: PropTypes.any
  };

  var TreeNode$2 = function (_React$Component) {
    _inherits$1(TreeNode, _React$Component);

    function TreeNode() {
      _classCallCheck$1(this, TreeNode);

      return _possibleConstructorReturn$1(this, _React$Component.apply(this, arguments));
    }

    return TreeNode;
  }(React$1__default.Component);

  TreeNode$2.propTypes = {
    value: PropTypes.string
  };

  var SHOW_ALL = 'SHOW_ALL';
  var SHOW_PARENT = 'SHOW_PARENT';
  var SHOW_CHILD = 'SHOW_CHILD';

  function nonEmptyStringType(props, propsName) {
    var value = props[propsName];
    if (typeof value !== 'string' || !value) {
      return new Error(); // Just a flag, so don't need message.
    }
  }

  function valueType$1(props, propName, componentName) {
    var labelInValueShape = PropTypes.shape({
      value: nonEmptyStringType,
      label: PropTypes.node
    });
    if (props.labelInValue) {
      var validate = PropTypes.oneOfType([PropTypes.arrayOf(labelInValueShape), labelInValueShape]);
      var error = validate.apply(undefined, arguments);
      if (error) {
        return new Error('Invalid prop `' + propName + '` supplied to `' + componentName + '`, ' + ('when `labelInValue` is `true`, `' + propName + '` should in ') + 'shape of `{ value: string, label?: string }`.');
      }
    } else if (props.treeCheckable && props.treeCheckStrictly) {
      var _validate = PropTypes.oneOfType([PropTypes.arrayOf(labelInValueShape), labelInValueShape]);
      var _error = _validate.apply(undefined, arguments);
      if (_error) {
        return new Error('Invalid prop `' + propName + '` supplied to `' + componentName + '`, ' + 'when `treeCheckable` and `treeCheckStrictly` are `true`, ' + ('`' + propName + '` should in shape of `{ value: string, label?: string }`.'));
      }
    } else if (props.multiple && props[propName] === '') {
      return new Error('Invalid prop `' + propName + '` of type `string` supplied to `' + componentName + '`, ' + 'expected `array` when `multiple` is `true`.');
    } else {
      var _validate2 = PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.string]);
      return _validate2.apply(undefined, arguments);
    }
  }

  var SelectPropTypes$1 = {
    className: PropTypes.string,
    prefixCls: PropTypes.string,
    multiple: PropTypes.bool,
    filterTreeNode: PropTypes.any,
    showSearch: PropTypes.bool,
    disabled: PropTypes.bool,
    showArrow: PropTypes.bool,
    allowClear: PropTypes.bool,
    defaultOpen: PropTypes.bool,
    open: PropTypes.bool,
    transitionName: PropTypes.string,
    animation: PropTypes.string,
    choiceTransitionName: PropTypes.string,
    onClick: PropTypes.func,
    onChange: PropTypes.func,
    onSelect: PropTypes.func,
    onDeselect: PropTypes.func,
    onSearch: PropTypes.func,
    searchPlaceholder: PropTypes.string,
    placeholder: PropTypes.any,
    inputValue: PropTypes.any,
    value: valueType$1,
    defaultValue: valueType$1,
    label: PropTypes.node,
    defaultLabel: PropTypes.any,
    labelInValue: PropTypes.bool,
    dropdownStyle: PropTypes.object,
    dropdownPopupAlign: PropTypes.object,
    onDropdownVisibleChange: PropTypes.func,
    maxTagTextLength: PropTypes.number,
    showCheckedStrategy: PropTypes.oneOf([SHOW_ALL, SHOW_PARENT, SHOW_CHILD]),
    treeCheckStrictly: PropTypes.bool,
    treeIcon: PropTypes.bool,
    treeLine: PropTypes.bool,
    treeDefaultExpandAll: PropTypes.bool,
    treeCheckable: PropTypes.oneOfType([PropTypes.bool, PropTypes.node]),
    treeNodeLabelProp: PropTypes.string,
    treeNodeFilterProp: PropTypes.string,
    treeData: PropTypes.array,
    treeDataSimpleMode: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),
    loadData: PropTypes.func
  };

  function noop$a() {}

  function filterFn(input, child) {
    return String(getPropValue$1(child, labelCompatible(this.props.treeNodeFilterProp))).indexOf(input) > -1;
  }

  function loopTreeData(data) {
    var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var treeCheckable = arguments[2];

    return data.map(function (item, index) {
      var pos = level + '-' + index;

      var label = item.label,
          value = item.value,
          disabled = item.disabled,
          key = item.key,
          hasOwnProperty = item.hasOwnProperty,
          selectable = item.selectable,
          children = item.children,
          isLeaf = item.isLeaf,
          otherProps = _objectWithoutProperties$1(item, ['label', 'value', 'disabled', 'key', 'hasOwnProperty', 'selectable', 'children', 'isLeaf']);

      var props = _extends$2({
        value: value,
        title: label,
        // value: value || String(key || label), // cause onChange callback error
        key: key || value || pos,
        disabled: disabled || false,
        selectable: selectable === false ? selectable : !treeCheckable
      }, otherProps);
      var ret = void 0;
      if (children && children.length) {
        ret = React$1__default.createElement(
          TreeNode$2,
          props,
          loopTreeData(children, pos, treeCheckable)
        );
      } else {
        ret = React$1__default.createElement(TreeNode$2, _extends$2({}, props, { isLeaf: isLeaf }));
      }
      return ret;
    });
  }

  var Select$3 = function (_Component) {
    _inherits$1(Select, _Component);

    function Select(props) {
      _classCallCheck$1(this, Select);

      var _this = _possibleConstructorReturn$1(this, _Component.call(this, props));

      _initialiseProps$c.call(_this);

      var value = [];
      if ('value' in props) {
        value = toArray$2(props.value);
      } else {
        value = toArray$2(props.defaultValue);
      }
      // save parsed treeData, for performance (treeData may be very big)
      _this.renderedTreeData = _this.renderTreeData();
      value = _this.addLabelToValue(props, value);
      value = _this.getValue(props, value, props.inputValue ? '__strict' : true);
      var inputValue = props.inputValue || '';
      // if (props.combobox) {
      //   inputValue = value.length ? String(value[0].value) : '';
      // }
      _this.state = {
        value: value,
        inputValue: inputValue,
        open: props.open || props.defaultOpen,
        focused: false
      };
      return _this;
    }

    Select.prototype.componentDidMount = function componentDidMount() {
      var _props2 = this.props,
          autoFocus = _props2.autoFocus,
          disabled = _props2.disabled;

      if (isMultiple$1(this.props)) {
        var inputNode = this.getInputDOMNode();
        if (inputNode.value) {
          inputNode.style.width = '';
          inputNode.style.width = this.inputMirrorInstance.clientWidth + 'px';
        } else {
          inputNode.style.width = '';
        }
      }
      if (autoFocus && !disabled) {
        this.focus();
      }
    };

    Select.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      // save parsed treeData, for performance (treeData may be very big)
      this.renderedTreeData = this.renderTreeData(nextProps);
      // Detecting whether the object of `onChange`'s argument  is old ref.
      // Better to do a deep equal later.
      this._cacheTreeNodesStates = this._cacheTreeNodesStates !== 'no' && this._savedValue && nextProps.value === this._savedValue;
      if (this.props.treeData !== nextProps.treeData || this.props.children !== nextProps.children) {
        // refresh this._treeNodesStates cache
        this._treeNodesStates = getTreeNodesStates(this.renderedTreeData || nextProps.children, this.state.value.map(function (item) {
          return item.value;
        }));
      }
      if ('value' in nextProps) {
        var value = toArray$2(nextProps.value);
        value = this.addLabelToValue(nextProps, value);
        value = this.getValue(nextProps, value);
        this.setState({
          value: value
        }, this.forcePopupAlign);
        // if (nextProps.combobox) {
        //   this.setState({
        //     inputValue: value.length ? String(value[0].key) : '',
        //   });
        // }
      }
      if (nextProps.inputValue !== this.props.inputValue) {
        this.setState({
          inputValue: nextProps.inputValue
        });
      }
      if ('open' in nextProps) {
        this.setState({
          open: nextProps.open
        });
      }
    };

    Select.prototype.componentWillUpdate = function componentWillUpdate(nextProps) {
      if (this._savedValue && nextProps.value && nextProps.value !== this._savedValue && nextProps.value === this.props.value) {
        this._cacheTreeNodesStates = false;
        this.getValue(nextProps, this.addLabelToValue(nextProps, toArray$2(nextProps.value)));
      }
    };

    Select.prototype.componentDidUpdate = function componentDidUpdate() {
      var state = this.state;
      var props = this.props;
      if (state.open && isMultiple$1(props)) {
        var inputNode = this.getInputDOMNode();
        if (inputNode.value) {
          inputNode.style.width = '';
          inputNode.style.width = this.inputMirrorInstance.clientWidth + 'px';
        } else {
          inputNode.style.width = '';
        }
      }
    };

    Select.prototype.componentWillUnmount = function componentWillUnmount() {
      this.clearDelayTimer();
      if (this.dropdownContainer) {
        ReactDOM__default.unmountComponentAtNode(this.dropdownContainer);
        document.body.removeChild(this.dropdownContainer);
        this.dropdownContainer = null;
      }
    };

    // combobox ignore


    Select.prototype.getLabelFromNode = function getLabelFromNode(child) {
      return getPropValue$1(child, this.props.treeNodeLabelProp);
    };

    Select.prototype.getLabelFromProps = function getLabelFromProps(props, value) {
      var _this2 = this;

      if (value === undefined) {
        return null;
      }
      var label = null;
      loopAllChildren(this.renderedTreeData || props.children, function (item) {
        if (getValuePropValue$1(item) === value) {
          label = _this2.getLabelFromNode(item);
        }
      });
      if (label === null) {
        return value;
      }
      return label;
    };

    Select.prototype.getDropdownContainer = function getDropdownContainer() {
      if (!this.dropdownContainer) {
        this.dropdownContainer = document.createElement('div');
        document.body.appendChild(this.dropdownContainer);
      }
      return this.dropdownContainer;
    };

    Select.prototype.getSearchPlaceholderElement = function getSearchPlaceholderElement(hidden) {
      var props = this.props;
      var placeholder = void 0;
      if (isMultiple$1(props)) {
        placeholder = props.placeholder || props.searchPlaceholder;
      } else {
        placeholder = props.searchPlaceholder;
      }
      if (placeholder) {
        return React$1__default.createElement(
          'span',
          {
            style: { display: hidden ? 'none' : 'block' },
            onClick: this.onPlaceholderClick,
            className: props.prefixCls + '-search__field__placeholder'
          },
          placeholder
        );
      }
      return null;
    };

    Select.prototype.getInputElement = function getInputElement() {
      var inputValue = this.state.inputValue;
      var _props3 = this.props,
          prefixCls = _props3.prefixCls,
          disabled = _props3.disabled;

      return React$1__default.createElement(
        'span',
        { className: prefixCls + '-search__field__wrap' },
        React$1__default.createElement('input', {
          ref: saveRef$3(this, 'inputInstance'),
          onChange: this.onInputChange,
          onKeyDown: this.onInputKeyDown,
          value: inputValue,
          disabled: disabled,
          className: prefixCls + '-search__field',
          role: 'textbox'
        }),
        React$1__default.createElement(
          'span',
          {
            ref: saveRef$3(this, 'inputMirrorInstance'),
            className: prefixCls + '-search__field__mirror'
          },
          inputValue,
          '\xA0'
        ),
        isMultiple$1(this.props) ? null : this.getSearchPlaceholderElement(!!inputValue)
      );
    };

    Select.prototype.getInputDOMNode = function getInputDOMNode() {
      return this.inputInstance;
    };

    Select.prototype.getPopupDOMNode = function getPopupDOMNode() {
      return this.trigger.getPopupDOMNode();
    };

    Select.prototype.getPopupComponentRefs = function getPopupComponentRefs() {
      return this.trigger.getPopupEleRefs();
    };

    Select.prototype.getValue = function getValue(_props, val) {
      var _this3 = this;

      var init = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var value = val;
      // if inputValue existing, tree is checkStrictly
      var _strict = init === '__strict' || init && (this.state && this.state.inputValue || this.props.inputValue !== _props.inputValue);
      if (_props.treeCheckable && (_props.treeCheckStrictly || _strict)) {
        this.halfCheckedValues = [];
        value = [];
        val.forEach(function (i) {
          if (!i.halfChecked) {
            value.push(i);
          } else {
            _this3.halfCheckedValues.push(i);
          }
        });
      }
      // if (!(_props.treeCheckable && !_props.treeCheckStrictly)) {
      if (!!!_props.treeCheckable || _props.treeCheckable && (_props.treeCheckStrictly || _strict)) {
        return value;
      }
      var checkedTreeNodes = void 0;
      if (this._cachetreeData && this._cacheTreeNodesStates && this._checkedNodes && this.state && !this.state.inputValue) {
        this.checkedTreeNodes = checkedTreeNodes = this._checkedNodes;
      } else {
        /**
         * Note: `this._treeNodesStates`'s treeNodesStates must correspond to nodes of the
         * final tree (`processTreeNode` function from SelectTrigger.jsx produce the final tree).
         *
         * And, `this._treeNodesStates` from `onSelect` is previous value,
         * so it perhaps only have a few nodes, but the newly filtered tree can have many nodes,
         * thus, you cannot use previous _treeNodesStates.
         */
        // getTreeNodesStates is not effective.
        this._treeNodesStates = getTreeNodesStates(this.renderedTreeData || _props.children, value.map(function (item) {
          return item.value;
        }));
        this.checkedTreeNodes = checkedTreeNodes = this._treeNodesStates.checkedNodes;
      }
      var mapLabVal = function mapLabVal(arr) {
        return arr.map(function (itemObj) {
          return {
            value: getValuePropValue$1(itemObj.node),
            label: getPropValue$1(itemObj.node, _props.treeNodeLabelProp)
          };
        });
      };
      var props = this.props;
      var checkedValues = [];
      if (props.showCheckedStrategy === SHOW_ALL) {
        checkedValues = mapLabVal(checkedTreeNodes);
      } else if (props.showCheckedStrategy === SHOW_PARENT) {
        var posArr = filterParentPosition(checkedTreeNodes.map(function (itemObj) {
          return itemObj.pos;
        }));
        checkedValues = mapLabVal(checkedTreeNodes.filter(function (itemObj) {
          return posArr.indexOf(itemObj.pos) !== -1;
        }));
      } else {
        checkedValues = mapLabVal(checkedTreeNodes.filter(function (itemObj) {
          return !itemObj.node.props.children;
        }));
      }
      return checkedValues;
    };

    Select.prototype.getCheckedNodes = function getCheckedNodes(info, props) {
      // TODO treeCheckable does not support tags/dynamic
      var checkedNodes = info.checkedNodes;
      // if inputValue existing, tree is checkStrictly

      if (props.treeCheckStrictly || this.state.inputValue) {
        return checkedNodes;
      }
      var checkedNodesPositions = info.checkedNodesPositions;
      if (props.showCheckedStrategy === SHOW_ALL) {
        checkedNodes = checkedNodes;
      } else if (props.showCheckedStrategy === SHOW_PARENT) {
        var posArr = filterParentPosition(checkedNodesPositions.map(function (itemObj) {
          return itemObj.pos;
        }));
        checkedNodes = checkedNodesPositions.filter(function (itemObj) {
          return posArr.indexOf(itemObj.pos) !== -1;
        }).map(function (itemObj) {
          return itemObj.node;
        });
      } else {
        checkedNodes = checkedNodes.filter(function (n) {
          return !n.props.children;
        });
      }
      return checkedNodes;
    };

    Select.prototype.getDeselectedValue = function getDeselectedValue(selectedValue) {
      var checkedTreeNodes = this.checkedTreeNodes;
      var unCheckPos = void 0;
      checkedTreeNodes.forEach(function (itemObj) {
        if (itemObj.node.props.value === selectedValue) {
          unCheckPos = itemObj.pos;
        }
      });
      var newVals = [];
      var newCkTns = [];
      checkedTreeNodes.forEach(function (itemObj) {
        if (isPositionPrefix(itemObj.pos, unCheckPos) || isPositionPrefix(unCheckPos, itemObj.pos)) {
          // Filter ancestral and children nodes when uncheck a node.
          return;
        }
        newCkTns.push(itemObj);
        newVals.push(itemObj.node.props.value);
      });
      this.checkedTreeNodes = this._checkedNodes = newCkTns;
      var nv = this.state.value.filter(function (val) {
        return newVals.indexOf(val.value) !== -1;
      });
      this.fireChange(nv, { triggerValue: selectedValue, clear: true });
    };

    Select.prototype.setOpenState = function setOpenState(open, needFocus) {
      var _this4 = this;

      var documentClickClose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      this.clearDelayTimer();
      var props = this.props;
      // can not optimize, if children is empty
      // if (this.state.open === open) {
      //   return;
      // }

      if (!this.props.onDropdownVisibleChange(open, { documentClickClose: documentClickClose })) {
        return;
      }
      this.setState({
        open: open
      }, function () {
        if (needFocus || open) {
          // Input dom init after first time component render
          // Add delay for this to get focus
          Promise.resolve().then(function () {
            if (open || isMultiple$1(props)) {
              var input = _this4.getInputDOMNode();
              if (input && document.activeElement !== input) {
                input.focus();
              }
            } else if (_this4.selection) {
              _this4.selection.focus();
            }
          });
        }
      });
    };

    Select.prototype.clearSearchInput = function clearSearchInput() {
      this.getInputDOMNode().focus();
      if (!('inputValue' in this.props)) {
        this.setState({ inputValue: '' });
      }
    };

    Select.prototype.addLabelToValue = function addLabelToValue(props, value_) {
      var _this5 = this;

      var value = value_;
      if (this.isLabelInValue()) {
        value.forEach(function (v, i) {
          if (Object.prototype.toString.call(value[i]) !== '[object Object]') {
            value[i] = {
              value: '',
              label: ''
            };
            return;
          }
          v.label = v.label || _this5.getLabelFromProps(props, v.value);
        });
      } else {
        value = value.map(function (v) {
          return {
            value: v,
            label: _this5.getLabelFromProps(props, v)
          };
        });
      }
      return value;
    };

    Select.prototype.clearDelayTimer = function clearDelayTimer() {
      if (this.delayTimer) {
        clearTimeout(this.delayTimer);
        this.delayTimer = null;
      }
    };

    Select.prototype.removeSelected = function removeSelected(selectedVal, e) {
      var props = this.props;
      if (props.disabled) {
        return;
      }

      // Do not trigger Trigger popup
      if (e && e.stopPropagation) {
        e.stopPropagation();
      }

      this._cacheTreeNodesStates = 'no';
      if (props.treeCheckable && (props.showCheckedStrategy === SHOW_ALL || props.showCheckedStrategy === SHOW_PARENT) && !(props.treeCheckStrictly || this.state.inputValue)) {
        this.getDeselectedValue(selectedVal);
        return;
      }
      // click the node's `x`(in select box), likely trigger the TreeNode's `unCheck` event,
      // cautiously, they are completely different, think about it, the tree may not render at first,
      // but the nodes in select box are ready.
      var label = void 0;
      var value = this.state.value.filter(function (singleValue) {
        if (singleValue.value === selectedVal) {
          label = singleValue.label;
        }
        return singleValue.value !== selectedVal;
      });
      var canMultiple = isMultiple$1(props);

      if (canMultiple) {
        var event = selectedVal;
        if (this.isLabelInValue()) {
          event = {
            value: selectedVal,
            label: label
          };
        }
        props.onDeselect(event);
      }
      if (props.treeCheckable) {
        if (this.checkedTreeNodes && this.checkedTreeNodes.length) {
          this.checkedTreeNodes = this._checkedNodes = this.checkedTreeNodes.filter(function (item) {
            return value.some(function (i) {
              return i.value === item.node.props.value;
            });
          });
        }
      }

      this.fireChange(value, { triggerValue: selectedVal, clear: true });
    };

    Select.prototype.openIfHasChildren = function openIfHasChildren() {
      var props = this.props;
      if (React$1__default.Children.count(props.children) || !isMultiple$1(props)) {
        this.setOpenState(true);
      }
    };

    Select.prototype.fireChange = function fireChange(value) {
      var _this6 = this;

      var extraInfo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var props = this.props;
      var vals = value.map(function (i) {
        return i.value;
      });
      var sv = this.state.value.map(function (i) {
        return i.value;
      });
      if (vals.length !== sv.length || !vals.every(function (val, index) {
        return sv[index] === val;
      })) {
        var ex = _extends$2({
          preValue: [].concat(this.state.value)
        }, extraInfo);
        var labs = null;
        var vls = value;
        if (!this.isLabelInValue()) {
          labs = value.map(function (i) {
            return i.label;
          });
          vls = vls.map(function (v) {
            return v.value;
          });
        } else if (this.halfCheckedValues && this.halfCheckedValues.length) {
          this.halfCheckedValues.forEach(function (i) {
            if (!vls.some(function (v) {
              return v.value === i.value;
            })) {
              vls.push(i);
            }
          });
        }
        if (props.treeCheckable && ex.clear) {
          var treeData = this.renderedTreeData || props.children;
          ex.allCheckedNodes = flatToHierarchy(filterAllCheckedData(vals, treeData));
        }
        if (props.treeCheckable && this.state.inputValue) {
          var _vls = [].concat(this.state.value);
          if (ex.checked) {
            value.forEach(function (i) {
              if (_vls.every(function (ii) {
                return ii.value !== i.value;
              })) {
                _vls.push(_extends$2({}, i));
              }
            });
          } else {
            var index = void 0;
            var includeVal = _vls.some(function (i, ind) {
              if (i.value === ex.triggerValue) {
                index = ind;
                return true;
              }
            });
            if (includeVal) {
              _vls.splice(index, 1);
            }
          }
          vls = _vls;
          if (!this.isLabelInValue()) {
            labs = _vls.map(function (v) {
              return v.label;
            });
            vls = _vls.map(function (v) {
              return v.value;
            });
          }
        }
        this._savedValue = isMultiple$1(props) ? vls : vls[0];
        props.onChange(this._savedValue, labs, ex);
        if (!('value' in props)) {
          this._cacheTreeNodesStates = false;
          this.setState({
            value: this.getValue(props, toArray$2(this._savedValue).map(function (v, i) {
              return _this6.isLabelInValue() ? v : {
                value: v,
                label: labs && labs[i]
              };
            }))
          }, this.forcePopupAlign);
        }
      }
    };

    Select.prototype.isLabelInValue = function isLabelInValue() {
      var _props4 = this.props,
          treeCheckable = _props4.treeCheckable,
          treeCheckStrictly = _props4.treeCheckStrictly,
          labelInValue = _props4.labelInValue;

      if (treeCheckable && treeCheckStrictly) {
        return true;
      }
      return labelInValue || false;
    };

    Select.prototype.focus = function focus() {
      if (!isMultiple$1(this.props)) {
        this.selection.focus();
      } else {
        this.getInputDOMNode().focus();
      }
    };

    Select.prototype.blur = function blur() {
      if (!isMultiple$1(this.props)) {
        this.selection.blur();
      } else {
        this.getInputDOMNode().blur();
      }
    };

    Select.prototype.renderTopControlNode = function renderTopControlNode() {
      var _this7 = this;

      var value = this.state.value;

      var props = this.props;
      var choiceTransitionName = props.choiceTransitionName,
          prefixCls = props.prefixCls,
          maxTagTextLength = props.maxTagTextLength;

      var multiple = isMultiple$1(props);

      // single and not combobox, input is inside dropdown
      if (!multiple) {
        var innerNode = React$1__default.createElement(
          'span',
          {
            key: 'placeholder',
            className: prefixCls + '-selection__placeholder'
          },
          props.placeholder
        );
        if (value.length) {
          innerNode = React$1__default.createElement(
            'span',
            {
              key: 'value',
              title: toTitle$1(value[0].label),
              className: prefixCls + '-selection-selected-value'
            },
            value[0].label
          );
        }
        return React$1__default.createElement(
          'span',
          { className: prefixCls + '-selection__rendered' },
          innerNode
        );
      }

      var selectedValueNodes = value.map(function (singleValue) {
        var content = singleValue.label;
        var title = content;
        if (maxTagTextLength && typeof content === 'string' && content.length > maxTagTextLength) {
          content = content.slice(0, maxTagTextLength) + '...';
        }
        return React$1__default.createElement(
          'li',
          _extends$2({
            style: UNSELECTABLE_STYLE$1
          }, UNSELECTABLE_ATTRIBUTE$1, {
            onMouseDown: preventDefaultEvent$1,
            className: prefixCls + '-selection__choice',
            key: singleValue.value,
            title: toTitle$1(title)
          }),
          React$1__default.createElement('span', {
            className: prefixCls + '-selection__choice__remove',
            onClick: function onClick(event) {
              _this7.removeSelected(singleValue.value, event);
            }
          }),
          React$1__default.createElement(
            'span',
            { className: prefixCls + '-selection__choice__content' },
            content
          )
        );
      });

      selectedValueNodes.push(React$1__default.createElement(
        'li',
        {
          className: prefixCls + '-search ' + prefixCls + '-search--inline',
          key: '__input'
        },
        this.getInputElement()
      ));
      var className = prefixCls + '-selection__rendered';
      if (choiceTransitionName) {
        return React$1__default.createElement(
          Animate,
          {
            className: className,
            component: 'ul',
            transitionName: choiceTransitionName,
            onLeave: this.onChoiceAnimationLeave
          },
          selectedValueNodes
        );
      }
      return React$1__default.createElement(
        'ul',
        { className: className },
        selectedValueNodes
      );
    };

    Select.prototype.renderTreeData = function renderTreeData(props) {
      var validProps = props || this.props;
      if (validProps.treeData) {
        if (props && props.treeData === this.props.treeData && this.renderedTreeData) {
          // cache and use pre data.
          this._cachetreeData = true;
          return this.renderedTreeData;
        }
        this._cachetreeData = false;
        var treeData = [].concat(validProps.treeData);
        // process treeDataSimpleMode
        if (validProps.treeDataSimpleMode) {
          var simpleFormat = {
            id: 'id',
            pId: 'pId',
            rootPId: null
          };
          if (Object.prototype.toString.call(validProps.treeDataSimpleMode) === '[object Object]') {
            simpleFormat = _extends$2({}, simpleFormat, validProps.treeDataSimpleMode);
          }
          treeData = processSimpleTreeData(treeData, simpleFormat);
        }
        return loopTreeData(treeData, undefined, this.props.treeCheckable);
      }
    };

    Select.prototype.render = function render() {
      var _rootCls;

      var props = this.props;
      var multiple = isMultiple$1(props);
      var state = this.state;
      var className = props.className,
          disabled = props.disabled,
          allowClear = props.allowClear,
          prefixCls = props.prefixCls;

      var ctrlNode = this.renderTopControlNode();
      var extraSelectionProps = {};
      if (!multiple) {
        extraSelectionProps = {
          onKeyDown: this.onKeyDown,
          tabIndex: 0
        };
      }
      var rootCls = (_rootCls = {}, _rootCls[className] = !!className, _rootCls[prefixCls] = 1, _rootCls[prefixCls + '-open'] = state.open, _rootCls[prefixCls + '-focused'] = state.open || state.focused, _rootCls[prefixCls + '-disabled'] = disabled, _rootCls[prefixCls + '-enabled'] = !disabled, _rootCls[prefixCls + '-allow-clear'] = !!props.allowClear, _rootCls);

      var clear = React$1__default.createElement('span', {
        key: 'clear',
        className: prefixCls + '-selection__clear',
        onClick: this.onClearSelection
      });
      return React$1__default.createElement(
        SelectTrigger$1,
        _extends$2({}, props, {
          treeNodes: props.children,
          treeData: this.renderedTreeData,
          _cachetreeData: this._cachetreeData,
          _treeNodesStates: this._treeNodesStates,
          halfCheckedValues: this.halfCheckedValues,
          multiple: multiple,
          disabled: disabled,
          visible: state.open,
          inputValue: state.inputValue,
          inputElement: this.getInputElement(),
          value: state.value,
          onDropdownVisibleChange: this.onDropdownVisibleChange,
          getPopupContainer: props.getPopupContainer,
          onSelect: this.onSelect,
          ref: saveRef$3(this, 'trigger')
        }),
        React$1__default.createElement(
          'span',
          {
            style: props.style,
            onClick: props.onClick,
            className: classnames(rootCls),
            onBlur: props.onBlur,
            onFocus: props.onFocus
          },
          React$1__default.createElement(
            'span',
            _extends$2({
              ref: saveRef$3(this, 'selection'),
              key: 'selection',
              className: prefixCls + '-selection\n            ' + prefixCls + '-selection--' + (multiple ? 'multiple' : 'single'),
              role: 'combobox',
              'aria-autocomplete': 'list',
              'aria-haspopup': 'true',
              'aria-expanded': state.open
            }, extraSelectionProps),
            ctrlNode,
            allowClear && this.state.value.length && this.state.value[0].value ? clear : null,
            multiple || !props.showArrow ? null : React$1__default.createElement(
              'span',
              {
                key: 'arrow',
                className: prefixCls + '-arrow',
                style: { outline: 'none' }
              },
              React$1__default.createElement('b', null)
            ),
            multiple ? this.getSearchPlaceholderElement(!!this.state.inputValue || this.state.value.length) : null
          )
        )
      );
    };

    return Select;
  }(React$1.Component);

  Select$3.propTypes = SelectPropTypes$1;
  Select$3.defaultProps = {
    prefixCls: 'rc-tree-select',
    filterTreeNode: filterFn, // [Legacy] TODO: Set false and filter not hide?
    showSearch: true,
    allowClear: false,
    placeholder: '',
    searchPlaceholder: '',
    labelInValue: false,
    onClick: noop$a,
    onChange: noop$a,
    onSelect: noop$a,
    onDeselect: noop$a,
    onSearch: noop$a,
    showArrow: true,
    dropdownMatchSelectWidth: true,
    dropdownStyle: {},
    onDropdownVisibleChange: function onDropdownVisibleChange() {
      return true;
    },
    notFoundContent: 'Not Found',
    showCheckedStrategy: SHOW_CHILD,
    // skipHandleInitValue: false, // Deprecated (use treeCheckStrictly)
    treeCheckStrictly: false,
    treeIcon: false,
    treeLine: false,
    treeDataSimpleMode: false,
    treeDefaultExpandAll: false,
    treeCheckable: false,
    treeNodeFilterProp: 'value',
    treeNodeLabelProp: 'title'
  };

  var _initialiseProps$c = function _initialiseProps() {
    var _this8 = this;

    this.onInputChange = function (event) {
      var val = event.target.value;
      var props = _this8.props;

      _this8.setState({
        inputValue: val,
        open: true
      }, _this8.forcePopupAlign);
      if (props.treeCheckable && !val) {
        _this8.setState({
          value: _this8.getValue(props, [].concat(_this8.state.value), false)
        });
      }
      props.onSearch(val);
    };

    this.onDropdownVisibleChange = function (open) {
      // selection inside combobox cause click
      if (!open && document.activeElement === _this8.getInputDOMNode()) ;
      _this8.setOpenState(open, undefined, !open);
    };

    this.onKeyDown = function (event) {
      var props = _this8.props;
      if (props.disabled) {
        return;
      }
      var keyCode = event.keyCode;
      if (_this8.state.open && !_this8.getInputDOMNode()) {
        _this8.onInputKeyDown(event);
      } else if (keyCode === KeyCode.ENTER || keyCode === KeyCode.DOWN) {
        _this8.setOpenState(true);
        event.preventDefault();
      }
    };

    this.onInputKeyDown = function (event) {
      var props = _this8.props;
      if (props.disabled) {
        return;
      }
      var state = _this8.state;
      var keyCode = event.keyCode;
      if (isMultiple$1(props) && !event.target.value && keyCode === KeyCode.BACKSPACE) {
        var value = state.value.concat();
        if (value.length) {
          var popValue = value.pop();
          _this8.removeSelected(_this8.isLabelInValue() ? popValue : popValue.value);
        }
        return;
      }
      if (keyCode === KeyCode.DOWN) {
        if (!state.open) {
          _this8.openIfHasChildren();
          event.preventDefault();
          event.stopPropagation();
          return;
        }
      } else if (keyCode === KeyCode.ESC) {
        if (state.open) {
          _this8.setOpenState(false);
          event.preventDefault();
          event.stopPropagation();
        }
        return;
      }
    };

    this.onSelect = function (selectedKeys, info) {
      var item = info.node;
      var value = _this8.state.value;
      var props = _this8.props;
      var selectedValue = getValuePropValue$1(item);
      var selectedLabel = _this8.getLabelFromNode(item);
      var checkableSelect = props.treeCheckable && info.event === 'select';
      var event = selectedValue;
      if (_this8.isLabelInValue()) {
        event = {
          value: event,
          label: selectedLabel
        };
      }
      if (info.selected === false) {
        _this8.onDeselect(info);
        if (!checkableSelect) return;
      }
      props.onSelect(event, item, info);

      var checkEvt = info.event === 'check';
      if (isMultiple$1(props)) {
        _this8.clearSearchInput();
        if (checkEvt) {
          value = _this8.getCheckedNodes(info, props).map(function (n) {
            return {
              value: getValuePropValue$1(n),
              label: _this8.getLabelFromNode(n)
            };
          });
        } else {
          if (value.some(function (i) {
            return i.value === selectedValue;
          })) {
            return;
          }
          value = value.concat([{
            value: selectedValue,
            label: selectedLabel
          }]);
        }
      } else {
        if (value.length && value[0].value === selectedValue) {
          _this8.setOpenState(false);
          return;
        }
        value = [{
          value: selectedValue,
          label: selectedLabel
        }];
        _this8.setOpenState(false);
      }

      var extraInfo = {
        triggerValue: selectedValue,
        triggerNode: item
      };
      if (checkEvt) {
        extraInfo.checked = info.checked;
        // if inputValue existing, tree is checkStrictly
        extraInfo.allCheckedNodes = props.treeCheckStrictly || _this8.state.inputValue ? info.checkedNodes : flatToHierarchy(info.checkedNodesPositions);
        _this8._checkedNodes = info.checkedNodesPositions;
        var _tree = _this8.trigger.popupEle;
        _this8._treeNodesStates = _tree.checkKeys;
      } else {
        extraInfo.selected = info.selected;
      }

      _this8.fireChange(value, extraInfo);
      if (props.inputValue === null) {
        _this8.setState({
          inputValue: ''
        });
      }
    };

    this.onDeselect = function (info) {
      _this8.removeSelected(getValuePropValue$1(info.node));
      if (!isMultiple$1(_this8.props)) {
        _this8.setOpenState(false);
      } else {
        _this8.clearSearchInput();
      }
    };

    this.onPlaceholderClick = function () {
      _this8.getInputDOMNode().focus();
    };

    this.onClearSelection = function (event) {
      var props = _this8.props;
      var state = _this8.state;
      if (props.disabled) {
        return;
      }
      event.stopPropagation();
      _this8._cacheTreeNodesStates = 'no';
      _this8._checkedNodes = [];
      if (state.inputValue || state.value.length) {
        _this8.setOpenState(false);
        if (typeof props.inputValue === 'undefined') {
          _this8.setState({
            inputValue: ''
          }, function () {
            _this8.fireChange([]);
          });
        } else {
          _this8.fireChange([]);
        }
      }
    };

    this.onChoiceAnimationLeave = function () {
      _this8.forcePopupAlign();
    };

    this.forcePopupAlign = function () {
      _this8.trigger.trigger.forcePopupAlign();
    };
  };

  Select$3.SHOW_ALL = SHOW_ALL;
  Select$3.SHOW_PARENT = SHOW_PARENT;
  Select$3.SHOW_CHILD = SHOW_CHILD;

  // export this package's api

  Select$3.TreeNode = TreeNode$2;

  var es$7 = /*#__PURE__*/Object.freeze({
    default: Select$3,
    TreeNode: TreeNode$2,
    SHOW_ALL: SHOW_ALL,
    SHOW_PARENT: SHOW_PARENT,
    SHOW_CHILD: SHOW_CHILD
  });

  var _rcTreeSelect = getCjsExportFromNamespace(es$7);

  var treeSelect = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var _rcTreeSelect2 = _interopRequireDefault(_rcTreeSelect);



  var _classnames2 = _interopRequireDefault(classnames);



  var _LocaleReceiver2 = _interopRequireDefault(LocaleReceiver_1);



  var _warning2 = _interopRequireDefault(warning$4);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var __rest = function (s, e) {
      var t = {};
      for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      }if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
      }return t;
  };

  var TreeSelect = function (_React$Component) {
      (0, _inherits3['default'])(TreeSelect, _React$Component);

      function TreeSelect(props) {
          (0, _classCallCheck3['default'])(this, TreeSelect);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (TreeSelect.__proto__ || Object.getPrototypeOf(TreeSelect)).call(this, props));

          _this.saveTreeSelect = function (node) {
              _this.rcTreeSelect = node;
          };
          _this.renderTreeSelect = function (locale) {
              var _classNames;

              var _a = _this.props,
                  prefixCls = _a.prefixCls,
                  className = _a.className,
                  size = _a.size,
                  notFoundContent = _a.notFoundContent,
                  dropdownStyle = _a.dropdownStyle,
                  dropdownClassName = _a.dropdownClassName,
                  restProps = __rest(_a, ["prefixCls", "className", "size", "notFoundContent", "dropdownStyle", "dropdownClassName"]);
              var cls = (0, _classnames2['default'])((_classNames = {}, (0, _defineProperty3['default'])(_classNames, prefixCls + '-lg', size === 'large'), (0, _defineProperty3['default'])(_classNames, prefixCls + '-sm', size === 'small'), _classNames), className);
              var checkable = restProps.treeCheckable;
              if (checkable) {
                  checkable = React.createElement('span', { className: prefixCls + '-tree-checkbox-inner' });
              }
              return React.createElement(_rcTreeSelect2['default'], (0, _extends3['default'])({}, restProps, { dropdownClassName: (0, _classnames2['default'])(dropdownClassName, prefixCls + '-tree-dropdown'), prefixCls: prefixCls, className: cls, dropdownStyle: (0, _extends3['default'])({ maxHeight: '100vh', overflow: 'auto' }, dropdownStyle), treeCheckable: checkable, notFoundContent: notFoundContent || locale.notFoundContent, ref: _this.saveTreeSelect }));
          };
          (0, _warning2['default'])(props.multiple !== false || !props.treeCheckable, '`multiple` will alway be `true` when `treeCheckable` is true');
          return _this;
      }

      (0, _createClass3['default'])(TreeSelect, [{
          key: 'focus',
          value: function focus() {
              this.rcTreeSelect.focus();
          }
      }, {
          key: 'blur',
          value: function blur() {
              this.rcTreeSelect.blur();
          }
      }, {
          key: 'render',
          value: function render() {
              return React.createElement(
                  _LocaleReceiver2['default'],
                  { componentName: 'Select', defaultLocale: {} },
                  this.renderTreeSelect
              );
          }
      }]);
      return TreeSelect;
  }(React.Component);

  exports['default'] = TreeSelect;

  TreeSelect.TreeNode = _rcTreeSelect.TreeNode;
  TreeSelect.SHOW_ALL = _rcTreeSelect.SHOW_ALL;
  TreeSelect.SHOW_PARENT = _rcTreeSelect.SHOW_PARENT;
  TreeSelect.SHOW_CHILD = _rcTreeSelect.SHOW_CHILD;
  TreeSelect.defaultProps = {
      prefixCls: 'ant-select',
      transitionName: 'slide-up',
      choiceTransitionName: 'zoom',
      showSearch: false
  };
  module.exports = exports['default'];
  });

  var TreeSelect = unwrapExports(treeSelect);

  var Search$1 = Input$1.Search;
  var TreeNode$3 = Tree$1.TreeNode,
      DirectoryTree = Tree$1.DirectoryTree;

  var TreeView =
  /*#__PURE__*/
  function (_Component) {
    _inherits(TreeView, _Component);

    // state = {
    // 	checkedKeys: [],
    // }
    function TreeView(props) {
      var _this;

      _classCallCheck(this, TreeView);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(TreeView).call(this, props));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onCheck", function (checkedKeys, e) {
        _this.setState({
          checkedKeys: checkedKeys.checked
        }, function () {
          _this.props.onChange(_this.state.checkedKeys);
        });
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onSelect", function (selectedKeys, e, selectedNodes) {
        // console.log(selectedKeys,e.node)
        var onSelect = _this.props.onSelect;

        _this.setState({
          selectedKeys: selectedKeys
        });

        if (onSelect) {
          onSelect(e.node);
        }
      });

      _this.state = {
        checkedKeys: props.value
      };
      return _this;
    }

    _createClass(TreeView, [{
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        if (JSON.stringify(nextProps.value) != JSON.stringify(this.props.value)) {
          this.setState({
            checkedKeys: nextProps.value
          });
        }
      }
    }, {
      key: "loopTreeNode",
      value: function loopTreeNode(data) {
        var _this2 = this;

        var renderNode = this.props.renderNode;
        return data.map(function (item) {
          if (item.children && item.children.length) {
            return React$1__default.cloneElement(renderNode(item), {}, _this2.loopTreeNode(item.children));
          }

          return React$1__default.cloneElement(renderNode(item));
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
            treeDataSource = _this$props.treeDataSource,
            treeConfig = _this$props.treeConfig,
            isTreeInModal = _this$props.isTreeInModal,
            value = _this$props.value,
            onSelect = _this$props.onSelect,
            defaultKey = _this$props.defaultKey;
        var checkedKeys = this.state.checkedKeys;
        return React$1__default.createElement("div", {
          className: "ant-tree-view"
        }, React$1__default.createElement(Tree$1, _extends({
          defaultExpandAll: true,
          defaultSelectedKeys: [checkedKeys],
          checkedKeys: checkedKeys
        }, treeConfig, {
          className: isTreeInModal ? "tree-in-modal" : '',
          defaultExpandAll: true,
          onCheck: this.onCheck,
          onSelect: this.onSelect
        }), this.loopTreeNode(treeDataSource)));
      }
    }]);

    return TreeView;
  }(React$1.Component);
  var TreeSelectPicker =
  /*#__PURE__*/
  function (_Component2) {
    _inherits(TreeSelectPicker, _Component2);

    function TreeSelectPicker(props) {
      var _this3;

      _classCallCheck(this, TreeSelectPicker);

      _this3 = _possibleConstructorReturn(this, _getPrototypeOf(TreeSelectPicker).call(this, props));
      _this3.state = {
        value: props.value
      };
      return _this3;
    } //


    _createClass(TreeSelectPicker, [{
      key: "onChange",
      value: function onChange(value, label) {
        var onChange = this.props.onChange; // console.log(value,label)

        this.setState({
          value: value
        }, function () {
          onChange(value);
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props2 = this.props,
            onChange = _this$props2.onChange,
            treeData = _this$props2.treeData,
            children = _this$props2.children,
            value = _this$props2.value,
            allowClear = _this$props2.allowClear,
            otherProps = _objectWithoutProperties(_this$props2, ["onChange", "treeData", "children", "value", "allowClear"]); // console.log(children,this.state.value)


        if (allowClear == true) {
          return React$1__default.createElement(TreeSelect, _extends({}, otherProps, {
            defaultValue: this.state.value,
            treeData: treeData,
            allowClear: allowClear,
            onChange: onChange,
            onSelect: this.onChange.bind(this)
          }));
        } else {
          return React$1__default.createElement(TreeSelect, _extends({}, otherProps, {
            value: this.state.value,
            treeData: treeData,
            onSelect: this.onChange.bind(this)
          }));
        }
      }
    }]);

    return TreeSelectPicker;
  }(React$1.Component);
  var TrewViewPanel =
  /*#__PURE__*/
  function (_Component3) {
    _inherits(TrewViewPanel, _Component3);

    function TrewViewPanel() {
      var _getPrototypeOf2;

      var _this4;

      _classCallCheck(this, TrewViewPanel);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this4 = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TrewViewPanel)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this4)), "state", {
        key: '',
        inside: false,
        label: "",
        value: ""
      });

      return _this4;
    }

    _createClass(TrewViewPanel, [{
      key: "onSearch",
      value: function onSearch(value, event) {
        this.setState({
          key: value
        });
      }
    }, {
      key: "onSelect",
      value: function onSelect(node, value) {
        // console.log(node.props.title)
        this.setState({
          label: node.props.title,
          value: node.props.value
        });
      }
    }, {
      key: "filterTree",
      value: function filterTree(data, regexp) {
        var _this5 = this;

        // let { renderNode } = this.props
        return new Array().concat(data).filter(function (item) {
          if (item.children && item.children.length) {
            // console.log(this.filterTree(item.children,regexp))
            item.children = _this5.filterTree(item.children, regexp);
          } // console.log(item.title,regexp.test(item.title))


          return regexp.test(item.title) || item.children && item.children.length > 0;
        });
      }
    }, {
      key: "onMouseHandler",
      value: function onMouseHandler(status) {
        var _this$state = this.state,
            key = _this$state.key,
            inside = _this$state.inside,
            label = _this$state.label,
            value = _this$state.value;

        if (label != "") {
          this.setState({
            inside: !status
          });
        }
      }
    }, {
      key: "renderPanel",
      value: function renderPanel() {
        var _this$props3 = this.props,
            treeDataSource = _this$props3.treeDataSource,
            renderNode = _this$props3.renderNode; // console.log(treeDataSource)

        var _this$state2 = this.state,
            key = _this$state2.key,
            inside = _this$state2.inside,
            label = _this$state2.label,
            value = _this$state2.value;

        if (inside) {
          return React$1__default.createElement("div", {
            className: ""
          }, label);
        } else {
          return React$1__default.createElement("div", {
            className: ""
          }, React$1__default.createElement(Search$1, {
            style: {
              marginBottom: 8
            },
            placeholder: "Search",
            onSearch: this.onSearch.bind(this)
          }), React$1__default.createElement(TreeView, {
            treeDataSource: this.filterTree(treeDataSource, new RegExp(key)),
            value: value,
            renderNode: renderNode,
            onSelect: this.onSelect.bind(this)
          }));
        }
      }
    }, {
      key: "render",
      value: function render() {
        // console.log(renderNode)
        var _this$props4 = this.props,
            treeDataSource = _this$props4.treeDataSource,
            renderNode = _this$props4.renderNode;
        var _this$state3 = this.state,
            key = _this$state3.key,
            inside = _this$state3.inside,
            label = _this$state3.label;
        return React$1__default.createElement("div", {
          className: ""
        }, React$1__default.createElement(Button, {
          onClick: this.onMouseHandler.bind(this, inside)
        }, !inside ? "收起" : "展开"), this.renderPanel());
      }
    }]);

    return TrewViewPanel;
  }(React$1.Component);

  var Option$1 = Select$1.Option;

  var FormItem$1 =
  /*#__PURE__*/
  function (_Component) {
    _inherits(FormItem, _Component);

    function FormItem(props) {
      var _this;

      _classCallCheck(this, FormItem);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(FormItem).call(this, props));
      var children = props.children;
      var field = children;

      if (children.props.options instanceof Array) {
        _this.state = {
          childData: children.props.options
        };
      } else {
        _this.state = {
          childData: []
        };
      }

      if (typeof field.props.fetch === 'string' && field.props.fetch.length > -1) {
        _this.fetchData(field.props.fetch, field.props.params);
      }

      return _this;
    }

    _createClass(FormItem, [{
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        var children = nextProps.children;
        var field = children; //  console.log(JSON.stringify(field.props.options),JSON.stringify(this.props.children.props.options))

        if (JSON.stringify(field.props.options) !== JSON.stringify(this.props.children.props.options)) {
          this.setState({
            childData: field.props.options
          });
        }

        if (field.props.fetch && typeof field.props.fetch === 'string' && field.props.fetch !== this.props.children.props.fetch) {
          this.fetchData(field.props.fetch, {}, field.props.fetchCallback);
        }
      }
    }, {
      key: "componentWillMount",
      value: function componentWillMount() {}
      /**
       * [fetchData 获取远程接口数据]
       * @param  {[type]} fetchUrl [description]
       * @return {[type]}          [description]
       */

    }, {
      key: "fetchData",
      value: function fetchData(fetchUrl, params, callback) {
        var _this2 = this;

        // let body={}
        nodePonyfill(fetchUrl, {
          method: 'GET'
        }).then(function (json) {
          return json.json();
        }).then(function (result) {
          if (result.code == 0) {
            if (callback) {
              _this2.setState({
                childData: callback(result)
              });
            } else {
              _this2.setState({
                childData: result.data.items
              });
            }
          }
        });
      }
    }, {
      key: "renderField",
      value: function renderField() {
        var _this$props = this.props,
            children = _this$props.children,
            containerTo = _this$props.containerTo;
        var childData = this.state.childData;
        var field = children;

        var _field$props = field.props,
            defaultValue = _field$props.defaultValue,
            renderable = _field$props.renderable,
            disabled = _field$props.disabled,
            otherProps = _objectWithoutProperties(_field$props, ["defaultValue", "renderable", "disabled"]); // console.log(ReactDOM.findDOMNode(this));
        // getPopupContainer


        var _this$context = this.context,
            formRef = _this$context.formRef,
            formLayout = _this$context.formLayout;
        var containerToProp = {};
        var treeDataProp = {};
        var disabledProp = {};

        if (disabled && typeof disabled === "function") {
          disabledProp = {
            disabled: disabled.apply(this, [formRef])
          };
        } else if (disabled && typeof disabled === "boolean") {
          disabledProp = {
            disabled: disabled
          };
        }

        if (containerTo && field.type === Select$1 && !field.props.changeCalendarContainer) {
          containerToProp = {
            getPopupContainer: function getPopupContainer(triggerNode) {
              return triggerNode.parentNode;
            }
          };
        }

        if (field.type == TreeSelectPicker) {
          treeDataProp = {
            treeData: this.loopTreeData(childData)
          };
        }

        if (field.type.name === "PickerWrapper") {
          var _field$props2 = field.props,
              _children = _field$props2.children,
              dislabled = _field$props2.dislabled,
              _otherProps = _field$props2.otherProps,
              _renderable = _field$props2.renderable;
          return React$1__default.createElement(WrapperDatePicker, Object.assign({}, _otherProps, disabledProp), field);
        } else {
          if (childData.length === 0) {
            return React$1__default.createElement(field.type, Object.assign({}, otherProps, containerToProp, treeDataProp, disabledProp));
          } else if (field.props.renderItem) {
            return React$1__default.createElement(field.type, Object.assign({
              key: new Date().valueOf()
            }, otherProps, containerToProp, treeDataProp, disabledProp), childData.map(function (d, idx) {
              return field.props.renderItem && field.props.renderItem(d, idx);
            }));
          } else {
            return React$1__default.createElement(field.type, Object.assign({}, otherProps, containerToProp, treeDataProp, disabledProp));
          }
        }
      }
    }, {
      key: "loopTreeData",
      value: function loopTreeData(data) {
        var _this3 = this;

        return data.map(function (item) {
          if (item.children && item.children.length) {
            return Object.assign(item, {
              title: item.text,
              value: item.id,
              key: item.id
            }, {
              children: _this3.loopTreeData(item.children)
            });
          } else {
            return Object.assign(item, {
              title: item.text,
              value: item.id,
              key: item.id
            });
          }
        });
      }
    }, {
      key: "render",
      value: function render() {
        var element = this.props.children;
        var _element$props = element.props,
            name = _element$props.name,
            label = _element$props.label,
            format = _element$props.format;

        var _element$props2 = element.props,
            defaultValue = _element$props2.defaultValue,
            allowClear = _element$props2.allowClear,
            hidden = _element$props2.hidden,
            disabled = _element$props2.disabled,
            renderable = _element$props2.renderable,
            otherProps = _objectWithoutProperties(_element$props2, ["defaultValue", "allowClear", "hidden", "disabled", "renderable"]);

        var _this$context2 = this.context,
            formRef = _this$context2.formRef,
            formLayout = _this$context2.formLayout;
        var getFieldDecorator = formRef.getFieldDecorator;
        var styles = {};
        var renderProps = true;

        if (element.type === Input$1 && element.props.type === "hidden") {
          styles = {
            style: {
              marginBottom: 0
            }
          };
        }

        if (element.props.hidden == true) {
          styles = {
            style: {
              display: "none"
            }
          };
        } // console.log(typeof(hiddenProp))


        if (typeof renderable === "boolean" && renderable === false || typeof renderable === "function" && renderable.apply(this, [formRef]) === false) {
          renderProps = false;
        }

        return renderProps ? React$1__default.createElement(Form$1.Item, _extends({
          label: label
        }, Object.assign({}, formLayout, this.props), styles), getFieldDecorator(name, _objectSpread({}, otherProps, {
          initialValue: defaultValue,
          hidden: element.props.hidden || false
        }))(this.renderField())) : null;
      }
    }]);

    return FormItem;
  }(React$1.Component);

  _defineProperty(FormItem$1, "defaultProps", {
    containerTo: true
  });

  _defineProperty(FormItem$1, "contextTypes", {
    formRef: PropTypes.object,
    formLayout: PropTypes.object
  });

  var Permission =
  /*#__PURE__*/
  function (_React$Component) {
    _inherits(Permission, _React$Component);

    function Permission() {
      _classCallCheck(this, Permission);

      return _possibleConstructorReturn(this, _getPrototypeOf(Permission).apply(this, arguments));
    }

    _createClass(Permission, [{
      key: "render",
      value: function render() {
        var expression = this.props.expression;
        var childrenWithProps = expression ? React$1__default.Children.map(this.props.children, function (child) {
          return React$1__default.cloneElement(child, {});
        }) : null;
        return childrenWithProps;
      }
    }]);

    return Permission;
  }(React$1__default.Component);

  Permission.propTypes = {
    expression: PropTypes.any
  };
  Permission.defaultProps = {
    expression: true
  };

  var Locale = {
    searchText: "搜索",
    resetText: "重置",
    upText: "收起",
    downText: "展开"
  };

  function styleInject(css, ref) {
    if ( ref === void 0 ) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === 'undefined') { return; }

    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';

    if (insertAt === 'top') {
      if (head.firstChild) {
        head.insertBefore(style, head.firstChild);
      } else {
        head.appendChild(style);
      }
    } else {
      head.appendChild(style);
    }

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  }

  var css$2 = ".advanced-search-panel {\n  flex-shrink: 0;\n  padding-right: 170px;\n  position: relative;\n}\n.advanced-search-panel .ant-col-8 .ant-form-item {\n  margin-bottom: 0;\n}\n.advanced-search-panel .ant-form-item-label {\n  line-height: 32px;\n}\n.advanced-search-panel .ant-input-group .ant-form-item .ant-form-item-control-wrapper .ant-select .ant-select-selection {\n  margin-right: -1px;\n  height: 32px;\n  border-radius: 4px 0 0 4px;\n}\n.advanced-search-panel .advanced-search-toolbar {\n  position: absolute;\n  right: 0;\n  top: 4px;\n}\n.advanced-search-panel .advanced-search-toolbar .ant-btn {\n  margin: 0 5px;\n}\n.advanced-search-panel .advanced-search-toolbar .ant-btn-ghost {\n  border-width: 0;\n  padding-left: 0;\n  padding-right: 0;\n}\n.advanced-search-panel .advanced-search-toolbar .anticon-down {\n  cursor: pointer;\n}\n.advanced-search-panel .ant-btn-circle {\n  border-width: 0;\n}\n.advanced-search-panel .ant-select-selection--multiple .ant-select-selection__rendered {\n  overflow: hidden;\n  height: 30px;\n}\n.advanced-search-panel .ant-select-selection--multiple .ant-select-selection__rendered ul {\n  position: absolute;\n  left: 0;\n  right: 0;\n  white-space: nowrap;\n}\n.advanced-search-panel .ant-select-selection--multiple .ant-select-selection__rendered ul li {\n  float: none;\n  margin-top: 8px;\n  display: inline-block;\n}\n";
  styleInject(css$2);

  var AdvancedSearchForm =
  /*#__PURE__*/
  function (_React$Component) {
    _inherits(AdvancedSearchForm, _React$Component);

    function AdvancedSearchForm(props) {
      var _this;

      _classCallCheck(this, AdvancedSearchForm);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AdvancedSearchForm).call(this, props));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", {
        expand: false,
        defKeyType: null,
        placeHolder: "",
        items: [],
        show: false,
        displayItem: []
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "handleSearch", function (e, values) {
        e.preventDefault();
        var filterSubmitHandler = _this.props.filterSubmitHandler;

        if (values) {
          filterSubmitHandler.call(_assertThisInitialized(_assertThisInitialized(_this)), values);
        } else {
          _this.form.validateFieldsAndScroll(function (err, values) {
            // console.log(this.form.getFieldsValue())
            // console.log(values)
            filterSubmitHandler.call(_assertThisInitialized(_assertThisInitialized(_this)), values);
          });
        }
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "handleReset", function () {
        var form = _this.form;
        var values = form.getFieldsValue();
        var emptyValue = {}; // this.form.resetFields();

        for (var v in values) {
          // console.log(v)
          if (values.hasOwnProperty(v)) {
            emptyValue[v] = undefined;
          }
        } // console.log(emptyValue)


        form.setFieldsValue(emptyValue);
      });

      _this.state.loading = props.loading;
      return _this;
    }

    _createClass(AdvancedSearchForm, [{
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        if (nextProps.loading !== this.props.loading) {
          this.setState({
            loading: nextProps.loading
          });
        }
      }
    }, {
      key: "toggleExpand",
      value: function toggleExpand() {
        var expand = this.state.expand;
        this.setState({
          expand: !expand
        });
      } // To generate mock Form.Item

    }, {
      key: "getFields",
      value: function getFields() {
        var _this2 = this;

        var _this$props = this.props,
            children = _this$props.children,
            layout = _this$props.layout,
            classNames = _this$props.classNames;
        var renderChildren;
        var formItemLayout = layout && layout !== 'inline' ? {
          labelCol: {
            span: 8
          },
          wrapperCol: {
            span: 16
          }
        } : {};

        if (React$1__default.Children.count(children) === 0) {
          return null;
        }

        if (this.state.expand == false) {
          renderChildren = [].concat(children).filter(function (ch, idx) {
            return idx < 3;
          });
        } else if (this.props.showConfig) {
          //高级配置后，前三固定 后四配置
          renderChildren = React$1__default.Children.toArray(children).filter(function (ch, idx) {
            //return this.state.displayItem.indexOf(ch.props.name)>=0 || idx<3
            return _this2.state.displayItem.indexOf(ch.props.name) >= 0 || idx < _this2.props.showExpand;
          });
        } else {
          renderChildren = React$1__default.Children.toArray(children).filter(function (ch, idx) {
            return idx < _this2.props.showExpand + 4;
          });
        }

        return renderChildren.map(function (it, i) {
          return React$1__default.createElement(Col, {
            span: 8,
            key: i
          }, React$1__default.createElement(FormItem$1, _extends({
            colon: true
          }, formItemLayout, {
            containerTo: false,
            className: classNames
          }), React$1__default.cloneElement(it)));
        }); //return children;
      }
    }, {
      key: "onTypeChange",
      value: function onTypeChange(value, option) {
        this.setState({
          placeHolder: option.props.placeholder
        });
      }
    }, {
      key: "handleAdvancedMenu",
      value: function handleAdvancedMenu(obj) {
        if (obj.key === 'advanced') {
          alert("call advanced");
        } else if (obj.key === 'clear') {
          this.handleReset();
        } else if (obj.key === 'preview') {
          alert("call restore");
        }
      }
    }, {
      key: "handleClose",
      value: function handleClose() {
        this.setState({
          show: false
        });
      }
    }, {
      key: "saveFormRef",
      value: function saveFormRef(insta) {
        if (insta) {
          this.form = insta.props.form;
        }
      }
    }, {
      key: "renderKeyword",
      value: function renderKeyword() {
        return React$1__default.createElement(Row, {
          gutter: 20
        }, this.getFields());
      }
    }, {
      key: "renderSearchToolbar",
      value: function renderSearchToolbar(locale) {
        var _this$state = this.state,
            loading = _this$state.loading,
            expand = _this$state.expand;
        var children = this.props.children;
        return React$1__default.createElement("div", {
          className: "advanced-search-toolbar"
        }, React$1__default.createElement(Button, {
          htmlType: "submit",
          disabled: loading,
          onClick: this.handleSearch.bind(this),
          type: "primary"
        }, locale.searchText), children.length > 3 ? React$1__default.createElement(Button, {
          type: "ghost",
          onClick: this.toggleExpand.bind(this)
        }, expand ? locale.upText : locale.downText, React$1__default.createElement(Icon, {
          type: expand ? "up" : "down"
        })) : "");
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props2 = this.props,
            showConfig = _this$props2.showConfig,
            children = _this$props2.children,
            className = _this$props2.className,
            autoSubmitForm = _this$props2.autoSubmitForm,
            layout = _this$props2.layout,
            locale = _this$props2.locale;
        return React$1__default.createElement("div", {
          className: classnames("advanced-search-panel", className)
        }, React$1__default.createElement(SubmitForm, {
          layout: layout,
          autoSubmitForm: autoSubmitForm,
          className: "advanced-search-form",
          onSubmit: this.handleSearch.bind(this),
          wrappedComponentRef: this.saveFormRef.bind(this)
        }, this.renderKeyword(), React$1__default.createElement(LocaleReceiver, {
          componentName: 'AdvancedSearch',
          defaultLocale: Locale
        }, this.renderSearchToolbar.bind(this))));
      }
    }]);

    return AdvancedSearchForm;
  }(React$1__default.Component);
  AdvancedSearchForm.propTypes = {
    filterSubmitHandler: PropTypes.func,
    showConfig: PropTypes.bool,
    loading: PropTypes.bool,
    footer: PropTypes.element,
    locale: PropTypes.object,
    showExpand: PropTypes.number
  };
  AdvancedSearchForm.defaultProps = {
    autoSubmitForm: false,
    showConfig: false,
    loading: false,
    filterSubmitHandler: function filterSubmitHandler() {},
    showExpand: 3,
    layout: 'horizontal' //export default AdvancedSearchForm = Form.create()(AdvancedSearchForm)

  };

  var autoAdjustOverflow$1 = {
    adjustX: 1,
    adjustY: 1
  };

  var targetOffset = [0, 0];

  var placements$3 = {
    left: {
      points: ['cr', 'cl'],
      overflow: autoAdjustOverflow$1,
      offset: [-4, 0],
      targetOffset: targetOffset
    },
    right: {
      points: ['cl', 'cr'],
      overflow: autoAdjustOverflow$1,
      offset: [4, 0],
      targetOffset: targetOffset
    },
    top: {
      points: ['bc', 'tc'],
      overflow: autoAdjustOverflow$1,
      offset: [0, -4],
      targetOffset: targetOffset
    },
    bottom: {
      points: ['tc', 'bc'],
      overflow: autoAdjustOverflow$1,
      offset: [0, 4],
      targetOffset: targetOffset
    },
    topLeft: {
      points: ['bl', 'tl'],
      overflow: autoAdjustOverflow$1,
      offset: [0, -4],
      targetOffset: targetOffset
    },
    leftTop: {
      points: ['tr', 'tl'],
      overflow: autoAdjustOverflow$1,
      offset: [-4, 0],
      targetOffset: targetOffset
    },
    topRight: {
      points: ['br', 'tr'],
      overflow: autoAdjustOverflow$1,
      offset: [0, -4],
      targetOffset: targetOffset
    },
    rightTop: {
      points: ['tl', 'tr'],
      overflow: autoAdjustOverflow$1,
      offset: [4, 0],
      targetOffset: targetOffset
    },
    bottomRight: {
      points: ['tr', 'br'],
      overflow: autoAdjustOverflow$1,
      offset: [0, 4],
      targetOffset: targetOffset
    },
    rightBottom: {
      points: ['bl', 'br'],
      overflow: autoAdjustOverflow$1,
      offset: [4, 0],
      targetOffset: targetOffset
    },
    bottomLeft: {
      points: ['tl', 'bl'],
      overflow: autoAdjustOverflow$1,
      offset: [0, 4],
      targetOffset: targetOffset
    },
    leftBottom: {
      points: ['br', 'bl'],
      overflow: autoAdjustOverflow$1,
      offset: [-4, 0],
      targetOffset: targetOffset
    }
  };

  var Content = function (_React$Component) {
    _inherits$1(Content, _React$Component);

    function Content() {
      _classCallCheck$1(this, Content);

      return _possibleConstructorReturn$1(this, _React$Component.apply(this, arguments));
    }

    Content.prototype.componentDidUpdate = function componentDidUpdate() {
      var trigger = this.props.trigger;

      if (trigger) {
        trigger.forcePopupAlign();
      }
    };

    Content.prototype.render = function render() {
      var _props = this.props,
          overlay = _props.overlay,
          prefixCls = _props.prefixCls,
          id = _props.id;

      return React$1__default.createElement(
        'div',
        { className: prefixCls + '-inner', id: id, role: 'tooltip' },
        typeof overlay === 'function' ? overlay() : overlay
      );
    };

    return Content;
  }(React$1__default.Component);

  Content.propTypes = {
    prefixCls: PropTypes.string,
    overlay: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,
    id: PropTypes.string,
    trigger: PropTypes.any
  };

  var Tooltip = function (_Component) {
    _inherits$1(Tooltip, _Component);

    function Tooltip() {
      var _temp, _this, _ret;

      _classCallCheck$1(this, Tooltip);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn$1(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.getPopupElement = function () {
        var _this$props = _this.props,
            arrowContent = _this$props.arrowContent,
            overlay = _this$props.overlay,
            prefixCls = _this$props.prefixCls,
            id = _this$props.id;

        return [React$1__default.createElement(
          'div',
          { className: prefixCls + '-arrow', key: 'arrow' },
          arrowContent
        ), React$1__default.createElement(Content, {
          key: 'content',
          trigger: _this.trigger,
          prefixCls: prefixCls,
          id: id,
          overlay: overlay
        })];
      }, _this.saveTrigger = function (node) {
        _this.trigger = node;
      }, _temp), _possibleConstructorReturn$1(_this, _ret);
    }

    Tooltip.prototype.getPopupDomNode = function getPopupDomNode() {
      return this.trigger.getPopupDomNode();
    };

    Tooltip.prototype.render = function render() {
      var _props = this.props,
          overlayClassName = _props.overlayClassName,
          trigger = _props.trigger,
          mouseEnterDelay = _props.mouseEnterDelay,
          mouseLeaveDelay = _props.mouseLeaveDelay,
          overlayStyle = _props.overlayStyle,
          prefixCls = _props.prefixCls,
          children = _props.children,
          onVisibleChange = _props.onVisibleChange,
          afterVisibleChange = _props.afterVisibleChange,
          transitionName = _props.transitionName,
          animation = _props.animation,
          placement = _props.placement,
          align = _props.align,
          destroyTooltipOnHide = _props.destroyTooltipOnHide,
          defaultVisible = _props.defaultVisible,
          getTooltipContainer = _props.getTooltipContainer,
          restProps = _objectWithoutProperties$1(_props, ['overlayClassName', 'trigger', 'mouseEnterDelay', 'mouseLeaveDelay', 'overlayStyle', 'prefixCls', 'children', 'onVisibleChange', 'afterVisibleChange', 'transitionName', 'animation', 'placement', 'align', 'destroyTooltipOnHide', 'defaultVisible', 'getTooltipContainer']);

      var extraProps = _extends$2({}, restProps);
      if ('visible' in this.props) {
        extraProps.popupVisible = this.props.visible;
      }
      return React$1__default.createElement(
        Trigger,
        _extends$2({
          popupClassName: overlayClassName,
          ref: this.saveTrigger,
          prefixCls: prefixCls,
          popup: this.getPopupElement,
          action: trigger,
          builtinPlacements: placements$3,
          popupPlacement: placement,
          popupAlign: align,
          getPopupContainer: getTooltipContainer,
          onPopupVisibleChange: onVisibleChange,
          afterPopupVisibleChange: afterVisibleChange,
          popupTransitionName: transitionName,
          popupAnimation: animation,
          defaultPopupVisible: defaultVisible,
          destroyPopupOnHide: destroyTooltipOnHide,
          mouseLeaveDelay: mouseLeaveDelay,
          popupStyle: overlayStyle,
          mouseEnterDelay: mouseEnterDelay
        }, extraProps),
        children
      );
    };

    return Tooltip;
  }(React$1.Component);

  Tooltip.propTypes = {
    trigger: PropTypes.any,
    children: PropTypes.any,
    defaultVisible: PropTypes.bool,
    visible: PropTypes.bool,
    placement: PropTypes.string,
    transitionName: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
    animation: PropTypes.any,
    onVisibleChange: PropTypes.func,
    afterVisibleChange: PropTypes.func,
    overlay: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,
    overlayStyle: PropTypes.object,
    overlayClassName: PropTypes.string,
    prefixCls: PropTypes.string,
    mouseEnterDelay: PropTypes.number,
    mouseLeaveDelay: PropTypes.number,
    getTooltipContainer: PropTypes.func,
    destroyTooltipOnHide: PropTypes.bool,
    align: PropTypes.object,
    arrowContent: PropTypes.any,
    id: PropTypes.string
  };
  Tooltip.defaultProps = {
    prefixCls: 'rc-tooltip',
    mouseEnterDelay: 0,
    destroyTooltipOnHide: false,
    mouseLeaveDelay: 0.1,
    align: {},
    placement: 'right',
    trigger: ['hover'],
    arrowContent: null
  };



  var es$8 = /*#__PURE__*/Object.freeze({
    default: Tooltip
  });

  var placements_1$2 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  var autoAdjustOverflow = {
    adjustX: 1,
    adjustY: 1
  };

  var targetOffset = [0, 0];

  var placements = exports.placements = {
    left: {
      points: ['cr', 'cl'],
      overflow: autoAdjustOverflow,
      offset: [-4, 0],
      targetOffset: targetOffset
    },
    right: {
      points: ['cl', 'cr'],
      overflow: autoAdjustOverflow,
      offset: [4, 0],
      targetOffset: targetOffset
    },
    top: {
      points: ['bc', 'tc'],
      overflow: autoAdjustOverflow,
      offset: [0, -4],
      targetOffset: targetOffset
    },
    bottom: {
      points: ['tc', 'bc'],
      overflow: autoAdjustOverflow,
      offset: [0, 4],
      targetOffset: targetOffset
    },
    topLeft: {
      points: ['bl', 'tl'],
      overflow: autoAdjustOverflow,
      offset: [0, -4],
      targetOffset: targetOffset
    },
    leftTop: {
      points: ['tr', 'tl'],
      overflow: autoAdjustOverflow,
      offset: [-4, 0],
      targetOffset: targetOffset
    },
    topRight: {
      points: ['br', 'tr'],
      overflow: autoAdjustOverflow,
      offset: [0, -4],
      targetOffset: targetOffset
    },
    rightTop: {
      points: ['tl', 'tr'],
      overflow: autoAdjustOverflow,
      offset: [4, 0],
      targetOffset: targetOffset
    },
    bottomRight: {
      points: ['tr', 'br'],
      overflow: autoAdjustOverflow,
      offset: [0, 4],
      targetOffset: targetOffset
    },
    rightBottom: {
      points: ['bl', 'br'],
      overflow: autoAdjustOverflow,
      offset: [4, 0],
      targetOffset: targetOffset
    },
    bottomLeft: {
      points: ['tl', 'bl'],
      overflow: autoAdjustOverflow,
      offset: [0, 4],
      targetOffset: targetOffset
    },
    leftBottom: {
      points: ['br', 'bl'],
      overflow: autoAdjustOverflow,
      offset: [-4, 0],
      targetOffset: targetOffset
    }
  };

  exports['default'] = placements;
  });

  unwrapExports(placements_1$2);
  var placements_2 = placements_1$2.placements;

  var placements$5 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);

  exports.getOverflowOptions = getOverflowOptions;
  exports['default'] = getPlacements;



  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var autoAdjustOverflowEnabled = {
      adjustX: 1,
      adjustY: 1
  };
  var autoAdjustOverflowDisabled = {
      adjustX: 0,
      adjustY: 0
  };
  var targetOffset = [0, 0];
  function getOverflowOptions(autoAdjustOverflow) {
      if (typeof autoAdjustOverflow === 'boolean') {
          return autoAdjustOverflow ? autoAdjustOverflowEnabled : autoAdjustOverflowDisabled;
      }
      return (0, _extends3['default'])({}, autoAdjustOverflowDisabled, autoAdjustOverflow);
  }
  function getPlacements() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _config$arrowWidth = config.arrowWidth,
          arrowWidth = _config$arrowWidth === undefined ? 5 : _config$arrowWidth,
          _config$horizontalArr = config.horizontalArrowShift,
          horizontalArrowShift = _config$horizontalArr === undefined ? 16 : _config$horizontalArr,
          _config$verticalArrow = config.verticalArrowShift,
          verticalArrowShift = _config$verticalArrow === undefined ? 12 : _config$verticalArrow,
          _config$autoAdjustOve = config.autoAdjustOverflow,
          autoAdjustOverflow = _config$autoAdjustOve === undefined ? true : _config$autoAdjustOve;

      var placementMap = {
          left: {
              points: ['cr', 'cl'],
              offset: [-4, 0]
          },
          right: {
              points: ['cl', 'cr'],
              offset: [4, 0]
          },
          top: {
              points: ['bc', 'tc'],
              offset: [0, -4]
          },
          bottom: {
              points: ['tc', 'bc'],
              offset: [0, 4]
          },
          topLeft: {
              points: ['bl', 'tc'],
              offset: [-(horizontalArrowShift + arrowWidth), -4]
          },
          leftTop: {
              points: ['tr', 'cl'],
              offset: [-4, -(verticalArrowShift + arrowWidth)]
          },
          topRight: {
              points: ['br', 'tc'],
              offset: [horizontalArrowShift + arrowWidth, -4]
          },
          rightTop: {
              points: ['tl', 'cr'],
              offset: [4, -(verticalArrowShift + arrowWidth)]
          },
          bottomRight: {
              points: ['tr', 'bc'],
              offset: [horizontalArrowShift + arrowWidth, 4]
          },
          rightBottom: {
              points: ['bl', 'cr'],
              offset: [4, verticalArrowShift + arrowWidth]
          },
          bottomLeft: {
              points: ['tl', 'bc'],
              offset: [-(horizontalArrowShift + arrowWidth), 4]
          },
          leftBottom: {
              points: ['br', 'cl'],
              offset: [-4, verticalArrowShift + arrowWidth]
          }
      };
      Object.keys(placementMap).forEach(function (key) {
          placementMap[key] = config.arrowPointAtCenter ? (0, _extends3['default'])({}, placementMap[key], { overflow: getOverflowOptions(autoAdjustOverflow), targetOffset: targetOffset }) : (0, _extends3['default'])({}, placements_1$2.placements[key], { overflow: getOverflowOptions(autoAdjustOverflow) });
      });
      return placementMap;
  }
  });

  unwrapExports(placements$5);
  var placements_1$3 = placements$5.getOverflowOptions;

  var _rcTooltip = getCjsExportFromNamespace(es$8);

  var tooltip = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var _extends3 = _interopRequireDefault(_extends$1);



  var React = _interopRequireWildcard(React$1__default);



  var _rcTooltip2 = _interopRequireDefault(_rcTooltip);



  var _classnames2 = _interopRequireDefault(classnames);



  var _placements2 = _interopRequireDefault(placements$5);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var splitObject = function splitObject(obj, keys) {
      var picked = {};
      var omitted = (0, _extends3['default'])({}, obj);
      keys.forEach(function (key) {
          if (obj && key in obj) {
              picked[key] = obj[key];
              delete omitted[key];
          }
      });
      return { picked: picked, omitted: omitted };
  };

  var Tooltip = function (_React$Component) {
      (0, _inherits3['default'])(Tooltip, _React$Component);

      function Tooltip(props) {
          (0, _classCallCheck3['default'])(this, Tooltip);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (Tooltip.__proto__ || Object.getPrototypeOf(Tooltip)).call(this, props));

          _this.onVisibleChange = function (visible) {
              var onVisibleChange = _this.props.onVisibleChange;

              if (!('visible' in _this.props)) {
                  _this.setState({ visible: _this.isNoTitle() ? false : visible });
              }
              if (onVisibleChange && !_this.isNoTitle()) {
                  onVisibleChange(visible);
              }
          };
          // 动态设置动画点
          _this.onPopupAlign = function (domNode, align) {
              var placements = _this.getPlacements();
              // 当前返回的位置
              var placement = Object.keys(placements).filter(function (key) {
                  return placements[key].points[0] === align.points[0] && placements[key].points[1] === align.points[1];
              })[0];
              if (!placement) {
                  return;
              }
              // 根据当前坐标设置动画点
              var rect = domNode.getBoundingClientRect();
              var transformOrigin = {
                  top: '50%',
                  left: '50%'
              };
              if (placement.indexOf('top') >= 0 || placement.indexOf('Bottom') >= 0) {
                  transformOrigin.top = rect.height - align.offset[1] + 'px';
              } else if (placement.indexOf('Top') >= 0 || placement.indexOf('bottom') >= 0) {
                  transformOrigin.top = -align.offset[1] + 'px';
              }
              if (placement.indexOf('left') >= 0 || placement.indexOf('Right') >= 0) {
                  transformOrigin.left = rect.width - align.offset[0] + 'px';
              } else if (placement.indexOf('right') >= 0 || placement.indexOf('Left') >= 0) {
                  transformOrigin.left = -align.offset[0] + 'px';
              }
              domNode.style.transformOrigin = transformOrigin.left + ' ' + transformOrigin.top;
          };
          _this.saveTooltip = function (node) {
              _this.tooltip = node;
          };
          _this.state = {
              visible: !!props.visible || !!props.defaultVisible
          };
          return _this;
      }

      (0, _createClass3['default'])(Tooltip, [{
          key: 'componentWillReceiveProps',
          value: function componentWillReceiveProps(nextProps) {
              if ('visible' in nextProps) {
                  this.setState({ visible: nextProps.visible });
              }
          }
      }, {
          key: 'getPopupDomNode',
          value: function getPopupDomNode() {
              return this.tooltip.getPopupDomNode();
          }
      }, {
          key: 'getPlacements',
          value: function getPlacements() {
              var _props = this.props,
                  builtinPlacements = _props.builtinPlacements,
                  arrowPointAtCenter = _props.arrowPointAtCenter,
                  autoAdjustOverflow = _props.autoAdjustOverflow;

              return builtinPlacements || (0, _placements2['default'])({
                  arrowPointAtCenter: arrowPointAtCenter,
                  verticalArrowShift: 8,
                  autoAdjustOverflow: autoAdjustOverflow
              });
          }
      }, {
          key: 'isHoverTrigger',
          value: function isHoverTrigger() {
              var trigger = this.props.trigger;

              if (!trigger || trigger === 'hover') {
                  return true;
              }
              if (Array.isArray(trigger)) {
                  return trigger.indexOf('hover') >= 0;
              }
              return false;
          }
          // Fix Tooltip won't hide at disabled button
          // mouse events don't trigger at disabled button in Chrome
          // https://github.com/react-component/tooltip/issues/18

      }, {
          key: 'getDisabledCompatibleChildren',
          value: function getDisabledCompatibleChildren(element) {
              if ((element.type.__ANT_BUTTON || element.type === 'button') && element.props.disabled && this.isHoverTrigger()) {
                  // Pick some layout related style properties up to span
                  // Prevent layout bugs like https://github.com/ant-design/ant-design/issues/5254
                  var _splitObject = splitObject(element.props.style, ['position', 'left', 'right', 'top', 'bottom', 'float', 'display', 'zIndex']),
                      picked = _splitObject.picked,
                      omitted = _splitObject.omitted;

                  var spanStyle = (0, _extends3['default'])({ display: 'inline-block' }, picked, { cursor: 'not-allowed' });
                  var buttonStyle = (0, _extends3['default'])({}, omitted, { pointerEvents: 'none' });
                  var child = (0, React$1__default.cloneElement)(element, {
                      style: buttonStyle,
                      className: null
                  });
                  return React.createElement(
                      'span',
                      { style: spanStyle, className: element.props.className },
                      child
                  );
              }
              return element;
          }
      }, {
          key: 'isNoTitle',
          value: function isNoTitle() {
              var _props2 = this.props,
                  title = _props2.title,
                  overlay = _props2.overlay;

              return !title && !overlay; // overlay for old version compatibility
          }
      }, {
          key: 'render',
          value: function render() {
              var props = this.props,
                  state = this.state;
              var prefixCls = props.prefixCls,
                  title = props.title,
                  overlay = props.overlay,
                  openClassName = props.openClassName,
                  getPopupContainer = props.getPopupContainer,
                  getTooltipContainer = props.getTooltipContainer;

              var children = props.children;
              var visible = state.visible;
              // Hide tooltip when there is no title
              if (!('visible' in props) && this.isNoTitle()) {
                  visible = false;
              }
              var child = this.getDisabledCompatibleChildren(React.isValidElement(children) ? children : React.createElement(
                  'span',
                  null,
                  children
              ));
              var childProps = child.props;
              var childCls = (0, _classnames2['default'])(childProps.className, (0, _defineProperty3['default'])({}, openClassName || prefixCls + '-open', true));
              return React.createElement(
                  _rcTooltip2['default'],
                  (0, _extends3['default'])({}, this.props, { getTooltipContainer: getPopupContainer || getTooltipContainer, ref: this.saveTooltip, builtinPlacements: this.getPlacements(), overlay: overlay || title || '', visible: visible, onVisibleChange: this.onVisibleChange, onPopupAlign: this.onPopupAlign }),
                  visible ? (0, React$1__default.cloneElement)(child, { className: childCls }) : child
              );
          }
      }]);
      return Tooltip;
  }(React.Component);

  exports['default'] = Tooltip;

  Tooltip.defaultProps = {
      prefixCls: 'ant-tooltip',
      placement: 'top',
      transitionName: 'zoom-big-fast',
      mouseEnterDelay: 0.1,
      mouseLeaveDelay: 0.1,
      arrowPointAtCenter: false,
      autoAdjustOverflow: true
  };
  module.exports = exports['default'];
  });

  var Tooltip$1 = unwrapExports(tooltip);

  var PropTypes$3 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.storeShape = undefined;



  var _propTypes2 = _interopRequireDefault(PropTypes);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var storeShape = exports.storeShape = _propTypes2.default.shape({
    subscribe: _propTypes2.default.func.isRequired,
    setState: _propTypes2.default.func.isRequired,
    getState: _propTypes2.default.func.isRequired
  });
  });

  unwrapExports(PropTypes$3);
  var PropTypes_1$1 = PropTypes$3.storeShape;

  var Provider_1$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



  var _react2 = _interopRequireDefault(React$1__default);



  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Provider = function (_Component) {
    _inherits(Provider, _Component);

    function Provider() {
      _classCallCheck(this, Provider);

      return _possibleConstructorReturn(this, (Provider.__proto__ || Object.getPrototypeOf(Provider)).apply(this, arguments));
    }

    _createClass(Provider, [{
      key: 'getChildContext',
      value: function getChildContext() {
        return {
          miniStore: this.props.store
        };
      }
    }, {
      key: 'render',
      value: function render() {
        return React$1__default.Children.only(this.props.children);
      }
    }]);

    return Provider;
  }(React$1__default.Component);

  Provider.propTypes = {
    store: PropTypes$3.storeShape.isRequired
  };
  Provider.childContextTypes = {
    miniStore: PropTypes$3.storeShape.isRequired
  };
  exports.default = Provider;
  });

  unwrapExports(Provider_1$1);

  var connect_1$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  exports.default = connect;



  var _react2 = _interopRequireDefault(React$1__default);



  var _shallowequal2 = _interopRequireDefault(shallowequal);



  var _hoistNonReactStatics2 = _interopRequireDefault(hoistNonReactStatics_cjs);





  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  function getDisplayName(WrappedComponent) {
    return WrappedComponent.displayName || WrappedComponent.name || 'Component';
  }

  function isStateless(Component) {
    return !Component.prototype.render;
  }

  var defaultMapStateToProps = function defaultMapStateToProps() {
    return {};
  };

  function connect(mapStateToProps) {
    var shouldSubscribe = !!mapStateToProps;
    var finnalMapStateToProps = mapStateToProps || defaultMapStateToProps;

    return function wrapWithConnect(WrappedComponent) {
      var Connect = function (_Component) {
        _inherits(Connect, _Component);

        _createClass(Connect, null, [{
          key: 'getDerivedStateFromProps',
          value: function getDerivedStateFromProps(props, prevState) {
            // using ownProps
            if (mapStateToProps && mapStateToProps.length === 2 && props !== prevState.props) {
              return {
                subscribed: finnalMapStateToProps(prevState.store.getState(), props),
                props: props
              };
            }
            return { props: props };
          }
        }]);

        function Connect(props, context) {
          _classCallCheck(this, Connect);

          var _this = _possibleConstructorReturn(this, (Connect.__proto__ || Object.getPrototypeOf(Connect)).call(this, props, context));

          _this.handleChange = function () {
            if (!_this.unsubscribe) {
              return;
            }
            var nextState = finnalMapStateToProps(_this.store.getState(), _this.props);
            if (!(0, _shallowequal2.default)(_this.state.subscribed, nextState)) {
              _this.setState({ subscribed: nextState });
            }
          };

          _this.store = context.miniStore;
          _this.state = {
            subscribed: finnalMapStateToProps(_this.store.getState(), props),
            store: _this.store,
            props: props
          };
          return _this;
        }

        _createClass(Connect, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
            this.trySubscribe();
          }
        }, {
          key: 'componentWillUnmount',
          value: function componentWillUnmount() {
            this.tryUnsubscribe();
          }
        }, {
          key: 'trySubscribe',
          value: function trySubscribe() {
            if (shouldSubscribe) {
              this.unsubscribe = this.store.subscribe(this.handleChange);
              this.handleChange();
            }
          }
        }, {
          key: 'tryUnsubscribe',
          value: function tryUnsubscribe() {
            if (this.unsubscribe) {
              this.unsubscribe();
              this.unsubscribe = null;
            }
          }
        }, {
          key: 'getWrappedInstance',
          value: function getWrappedInstance() {
            return this.wrappedInstance;
          }
        }, {
          key: 'render',
          value: function render() {
            var _this2 = this;

            var props = _extends({}, this.props, this.state.subscribed, {
              store: this.store
            });

            if (!isStateless(WrappedComponent)) {
              props = _extends({}, props, {
                ref: function ref(c) {
                  return _this2.wrappedInstance = c;
                }
              });
            }

            return _react2.default.createElement(WrappedComponent, props);
          }
        }]);

        return Connect;
      }(React$1__default.Component);

      Connect.displayName = 'Connect(' + getDisplayName(WrappedComponent) + ')';
      Connect.contextTypes = {
        miniStore: PropTypes$3.storeShape.isRequired
      };


      (0, reactLifecyclesCompat_es.polyfill)(Connect);

      return (0, _hoistNonReactStatics2.default)(Connect, WrappedComponent);
    };
  }
  });

  unwrapExports(connect_1$1);

  var create_1$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  exports.default = create;
  function create(initialState) {
    var state = initialState;
    var listeners = [];

    function setState(partial) {
      state = _extends({}, state, partial);
      for (var i = 0; i < listeners.length; i++) {
        listeners[i]();
      }
    }

    function getState() {
      return state;
    }

    function subscribe(listener) {
      listeners.push(listener);

      return function unsubscribe() {
        var index = listeners.indexOf(listener);
        listeners.splice(index, 1);
      };
    }

    return {
      setState: setState,
      getState: getState,
      subscribe: subscribe
    };
  }
  });

  unwrapExports(create_1$1);

  var lib$3 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.create = exports.connect = exports.Provider = undefined;



  var _Provider3 = _interopRequireDefault(Provider_1$1);



  var _connect3 = _interopRequireDefault(connect_1$1);



  var _create3 = _interopRequireDefault(create_1$1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.Provider = _Provider3.default;
  exports.connect = _connect3.default;
  exports.create = _create3.default;
  });

  unwrapExports(lib$3);
  var lib_1$1 = lib$3.create;
  var lib_2$1 = lib$3.connect;
  var lib_3$1 = lib$3.Provider;

  function noop$b() {}

  function getKeyFromChildrenIndex$1(child, menuEventKey, index) {
    var prefix = menuEventKey || '';
    return child.key || prefix + 'item_' + index;
  }

  function getMenuIdFromSubMenuEventKey$1(eventKey) {
    return eventKey + '-menu-';
  }

  function loopMenuItem$1(children, cb) {
    var index = -1;
    React$1__default.Children.forEach(children, function (c) {
      index++;
      if (c && c.type && c.type.isMenuItemGroup) {
        React$1__default.Children.forEach(c.props.children, function (c2) {
          index++;
          cb(c2, index);
        });
      } else {
        cb(c, index);
      }
    });
  }

  function loopMenuItemRecursively$1(children, keys, ret) {
    /* istanbul ignore if */
    if (!children || ret.find) {
      return;
    }
    React$1__default.Children.forEach(children, function (c) {
      if (c) {
        var construct = c.type;
        if (!construct || !(construct.isSubMenu || construct.isMenuItem || construct.isMenuItemGroup)) {
          return;
        }
        if (keys.indexOf(c.key) !== -1) {
          ret.find = true;
        } else if (c.props.children) {
          loopMenuItemRecursively$1(c.props.children, keys, ret);
        }
      }
    });
  }

  var menuAllProps$1 = ['defaultSelectedKeys', 'selectedKeys', 'defaultOpenKeys', 'openKeys', 'mode', 'getPopupContainer', 'onSelect', 'onDeselect', 'onDestroy', 'openTransitionName', 'openAnimation', 'subMenuOpenDelay', 'subMenuCloseDelay', 'forceSubMenuRender', 'triggerSubMenuAction', 'level', 'selectable', 'multiple', 'onOpenChange', 'visible', 'focusable', 'defaultActiveFirst', 'prefixCls', 'inlineIndent', 'parentMenu', 'title', 'rootPrefixCls', 'eventKey', 'active', 'onItemHover', 'onTitleMouseEnter', 'onTitleMouseLeave', 'onTitleClick', 'popupOffset', 'isOpen', 'renderMenuItem', 'manualRef', 'subMenuKey', 'disabled', 'index', 'isSelected', 'store', 'activeKey',

  // the following keys found need to be removed from test regression
  'attribute', 'value', 'popupClassName', 'inlineCollapsed', 'menu', 'theme'];

  var DOMWrap$1 = function (_React$Component) {
    _inherits$1(DOMWrap, _React$Component);

    function DOMWrap() {
      _classCallCheck$1(this, DOMWrap);

      return _possibleConstructorReturn$1(this, _React$Component.apply(this, arguments));
    }

    DOMWrap.prototype.render = function render() {
      var props = _extends$2({}, this.props);
      if (!props.visible) {
        props.className += ' ' + props.hiddenClassName;
      }
      var Tag = props.tag;
      delete props.tag;
      delete props.hiddenClassName;
      delete props.visible;
      return React$1__default.createElement(Tag, props);
    };

    return DOMWrap;
  }(React$1__default.Component);

  DOMWrap$1.propTypes = {
    tag: PropTypes.string,
    hiddenClassName: PropTypes.string,
    visible: PropTypes.bool
  };
  DOMWrap$1.defaultProps = {
    tag: 'div',
    className: ''
  };

  function allDisabled$1(arr) {
    if (!arr.length) {
      return true;
    }
    return arr.every(function (c) {
      return !!c.props.disabled;
    });
  }

  function updateActiveKey$1(store, menuId, activeKey) {
    var _extends2;

    var state = store.getState();
    store.setState({
      activeKey: _extends$2({}, state.activeKey, (_extends2 = {}, _extends2[menuId] = activeKey, _extends2))
    });
  }

  function getActiveKey$1(props, originalActiveKey) {
    var activeKey = originalActiveKey;
    var children = props.children,
        eventKey = props.eventKey;

    if (activeKey) {
      var found = void 0;
      loopMenuItem$1(children, function (c, i) {
        if (c && !c.props.disabled && activeKey === getKeyFromChildrenIndex$1(c, eventKey, i)) {
          found = true;
        }
      });
      if (found) {
        return activeKey;
      }
    }
    activeKey = null;
    if (props.defaultActiveFirst) {
      loopMenuItem$1(children, function (c, i) {
        if (!activeKey && c && !c.props.disabled) {
          activeKey = getKeyFromChildrenIndex$1(c, eventKey, i);
        }
      });
      return activeKey;
    }
    return activeKey;
  }

  function saveRef$4(c) {
    if (c) {
      var index = this.instanceArray.indexOf(c);
      if (index !== -1) {
        // update component if it's already inside instanceArray
        this.instanceArray[index] = c;
      } else {
        // add component if it's not in instanceArray yet;
        this.instanceArray.push(c);
      }
    }
  }

  var SubPopupMenu$1 = function (_React$Component) {
    _inherits$1(SubPopupMenu, _React$Component);

    function SubPopupMenu(props) {
      var _extends3;

      _classCallCheck$1(this, SubPopupMenu);

      var _this = _possibleConstructorReturn$1(this, _React$Component.call(this, props));

      _initialiseProps$d.call(_this);

      props.store.setState({
        activeKey: _extends$2({}, props.store.getState().activeKey, (_extends3 = {}, _extends3[props.eventKey] = getActiveKey$1(props, props.activeKey), _extends3))
      });
      return _this;
    }

    SubPopupMenu.prototype.componentWillMount = function componentWillMount() {
      this.instanceArray = [];
    };

    SubPopupMenu.prototype.componentDidMount = function componentDidMount() {
      // invoke customized ref to expose component to mixin
      if (this.props.manualRef) {
        this.props.manualRef(this);
      }
    };

    SubPopupMenu.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var originalActiveKey = 'activeKey' in nextProps ? nextProps.activeKey : this.getStore().getState().activeKey[this.getEventKey()];
      var activeKey = getActiveKey$1(nextProps, originalActiveKey);
      if (activeKey !== originalActiveKey) {
        updateActiveKey$1(this.getStore(), this.getEventKey(), activeKey);
      }
    };

    SubPopupMenu.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      return this.props.visible || nextProps.visible;
    };

    // all keyboard events callbacks run from here at first


    SubPopupMenu.prototype.render = function render() {
      var _this2 = this;

      var props = _objectWithoutProperties$1(this.props, []);

      this.instanceArray = [];
      var className = classnames(props.prefixCls, props.className, props.prefixCls + '-' + props.mode);
      var domProps = {
        className: className,
        // role could be 'select' and by default set to menu
        role: props.role || 'menu'
      };
      if (props.id) {
        domProps.id = props.id;
      }
      if (props.focusable) {
        domProps.tabIndex = '0';
        domProps.onKeyDown = this.onKeyDown;
      }
      var prefixCls = props.prefixCls,
          eventKey = props.eventKey,
          visible = props.visible;

      menuAllProps$1.forEach(function (key) {
        return delete props[key];
      });

      // Otherwise, the propagated click event will trigger another onClick
      delete props.onClick;
      return (
        // ESLint is not smart enough to know that the type of `children` was checked.
        /* eslint-disable */
        React$1__default.createElement(
          DOMWrap$1,
          _extends$2({}, props, {
            tag: 'ul',
            hiddenClassName: prefixCls + '-hidden',
            visible: visible
          }, domProps),
          React$1__default.Children.map(props.children, function (c, i) {
            return _this2.renderMenuItem(c, i, eventKey || '0-menu-');
          })
        )
        /*eslint-enable */

      );
    };

    return SubPopupMenu;
  }(React$1__default.Component);

  SubPopupMenu$1.propTypes = {
    onSelect: PropTypes.func,
    onClick: PropTypes.func,
    onDeselect: PropTypes.func,
    onOpenChange: PropTypes.func,
    onDestroy: PropTypes.func,
    openTransitionName: PropTypes.string,
    openAnimation: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
    openKeys: PropTypes.arrayOf(PropTypes.string),
    visible: PropTypes.bool,
    children: PropTypes.any,
    parentMenu: PropTypes.object,
    eventKey: PropTypes.string,
    store: PropTypes.shape({
      getState: PropTypes.func,
      setState: PropTypes.func
    }),

    // adding in refactor
    focusable: PropTypes.bool,
    multiple: PropTypes.bool,
    style: PropTypes.object,
    defaultActiveFirst: PropTypes.bool,
    activeKey: PropTypes.string,
    selectedKeys: PropTypes.arrayOf(PropTypes.string),
    defaultSelectedKeys: PropTypes.arrayOf(PropTypes.string),
    defaultOpenKeys: PropTypes.arrayOf(PropTypes.string),
    level: PropTypes.number,
    mode: PropTypes.oneOf(['horizontal', 'vertical', 'vertical-left', 'vertical-right', 'inline']),
    triggerSubMenuAction: PropTypes.oneOf(['click', 'hover']),
    inlineIndent: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    manualRef: PropTypes.func
  };
  SubPopupMenu$1.defaultProps = {
    prefixCls: 'rc-menu',
    className: '',
    mode: 'vertical',
    level: 1,
    inlineIndent: 24,
    visible: true,
    focusable: true,
    style: {},
    manualRef: noop$b
  };

  var _initialiseProps$d = function _initialiseProps() {
    var _this3 = this;

    this.onKeyDown = function (e, callback) {
      var keyCode = e.keyCode;
      var handled = void 0;
      _this3.getFlatInstanceArray().forEach(function (obj) {
        if (obj && obj.props.active && obj.onKeyDown) {
          handled = obj.onKeyDown(e);
        }
      });
      if (handled) {
        return 1;
      }
      var activeItem = null;
      if (keyCode === KeyCode.UP || keyCode === KeyCode.DOWN) {
        activeItem = _this3.step(keyCode === KeyCode.UP ? -1 : 1);
      }
      if (activeItem) {
        e.preventDefault();
        updateActiveKey$1(_this3.getStore(), _this3.getEventKey(), activeItem.props.eventKey);

        if (typeof callback === 'function') {
          callback(activeItem);
        }

        return 1;
      }
    };

    this.onItemHover = function (e) {
      var key = e.key,
          hover = e.hover;

      updateActiveKey$1(_this3.getStore(), _this3.getEventKey(), hover ? key : null);
    };

    this.onDeselect = function (selectInfo) {
      _this3.props.onDeselect(selectInfo);
    };

    this.onSelect = function (selectInfo) {
      _this3.props.onSelect(selectInfo);
    };

    this.onClick = function (e) {
      _this3.props.onClick(e);
    };

    this.onOpenChange = function (e) {
      _this3.props.onOpenChange(e);
    };

    this.onDestroy = function (key) {
      /* istanbul ignore next */
      _this3.props.onDestroy(key);
    };

    this.getFlatInstanceArray = function () {
      return _this3.instanceArray;
    };

    this.getStore = function () {
      return _this3.props.store;
    };

    this.getEventKey = function () {
      // when eventKey not available ,it's menu and return menu id '0-menu-'
      return _this3.props.eventKey || '0-menu-';
    };

    this.getOpenTransitionName = function () {
      return _this3.props.openTransitionName;
    };

    this.step = function (direction) {
      var children = _this3.getFlatInstanceArray();
      var activeKey = _this3.getStore().getState().activeKey[_this3.getEventKey()];
      var len = children.length;
      if (!len) {
        return null;
      }
      if (direction < 0) {
        children = children.concat().reverse();
      }
      // find current activeIndex
      var activeIndex = -1;
      children.every(function (c, ci) {
        if (c && c.props.eventKey === activeKey) {
          activeIndex = ci;
          return false;
        }
        return true;
      });
      if (!_this3.props.defaultActiveFirst && activeIndex !== -1 && allDisabled$1(children.slice(activeIndex, len - 1))) {
        return undefined;
      }
      var start = (activeIndex + 1) % len;
      var i = start;

      do {
        var child = children[i];
        if (!child || child.props.disabled) {
          i = (i + 1) % len;
        } else {
          return child;
        }
      } while (i !== start);

      return null;
    };

    this.renderCommonMenuItem = function (child, i, extraProps) {
      var state = _this3.getStore().getState();
      var props = _this3.props;
      var key = getKeyFromChildrenIndex$1(child, props.eventKey, i);
      var childProps = child.props;
      var isActive = key === state.activeKey;
      var newChildProps = _extends$2({
        mode: props.mode,
        level: props.level,
        inlineIndent: props.inlineIndent,
        renderMenuItem: _this3.renderMenuItem,
        rootPrefixCls: props.prefixCls,
        index: i,
        parentMenu: props.parentMenu,
        // customized ref function, need to be invoked manually in child's componentDidMount
        manualRef: childProps.disabled ? undefined : createChainedFunction(child.ref, saveRef$4.bind(_this3)),
        eventKey: key,
        active: !childProps.disabled && isActive,
        multiple: props.multiple,
        onClick: function onClick(e) {
          (childProps.onClick || noop$b)(e);
          _this3.onClick(e);
        },
        onItemHover: _this3.onItemHover,
        openTransitionName: _this3.getOpenTransitionName(),
        openAnimation: props.openAnimation,
        subMenuOpenDelay: props.subMenuOpenDelay,
        subMenuCloseDelay: props.subMenuCloseDelay,
        forceSubMenuRender: props.forceSubMenuRender,
        onOpenChange: _this3.onOpenChange,
        onDeselect: _this3.onDeselect,
        onSelect: _this3.onSelect
      }, extraProps);
      if (props.mode === 'inline') {
        newChildProps.triggerSubMenuAction = 'click';
      }
      return React$1__default.cloneElement(child, newChildProps);
    };

    this.renderMenuItem = function (c, i, subMenuKey) {
      /* istanbul ignore if */
      if (!c) {
        return null;
      }
      var state = _this3.getStore().getState();
      var extraProps = {
        openKeys: state.openKeys,
        selectedKeys: state.selectedKeys,
        triggerSubMenuAction: _this3.props.triggerSubMenuAction,
        subMenuKey: subMenuKey
      };
      return _this3.renderCommonMenuItem(c, i, extraProps);
    };
  };

  var SubPopupMenu$2 = lib_2$1()(SubPopupMenu$1);

  var Menu$1 = function (_React$Component) {
    _inherits$1(Menu, _React$Component);

    function Menu(props) {
      _classCallCheck$1(this, Menu);

      var _this = _possibleConstructorReturn$1(this, _React$Component.call(this, props));

      _initialiseProps$e.call(_this);

      _this.isRootMenu = true;

      var selectedKeys = props.defaultSelectedKeys;
      var openKeys = props.defaultOpenKeys;
      if ('selectedKeys' in props) {
        selectedKeys = props.selectedKeys || [];
      }
      if ('openKeys' in props) {
        openKeys = props.openKeys || [];
      }

      _this.store = lib_1$1({
        selectedKeys: selectedKeys,
        openKeys: openKeys,
        activeKey: { '0-menu-': getActiveKey$1(props, props.activeKey) }
      });
      return _this;
    }

    Menu.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if ('selectedKeys' in nextProps) {
        this.store.setState({
          selectedKeys: nextProps.selectedKeys || []
        });
      }
      if ('openKeys' in nextProps) {
        this.store.setState({
          openKeys: nextProps.openKeys || []
        });
      }
    };

    // onKeyDown needs to be exposed as a instance method
    // e.g., in rc-select, we need to navigate menu item while
    // current active item is rc-select input box rather than the menu itself


    Menu.prototype.render = function render() {
      var _this2 = this;

      var props = _objectWithoutProperties$1(this.props, []);

      props.className += ' ' + props.prefixCls + '-root';
      props = _extends$2({}, props, {
        onClick: this.onClick,
        onOpenChange: this.onOpenChange,
        onDeselect: this.onDeselect,
        onSelect: this.onSelect,
        openTransitionName: this.getOpenTransitionName(),
        parentMenu: this
      });
      return React$1__default.createElement(
        lib_3$1,
        { store: this.store },
        React$1__default.createElement(
          SubPopupMenu$2,
          _extends$2({}, props, { ref: function ref(c) {
              return _this2.innerMenu = c;
            } }),
          this.props.children
        )
      );
    };

    return Menu;
  }(React$1__default.Component);

  Menu$1.propTypes = {
    defaultSelectedKeys: PropTypes.arrayOf(PropTypes.string),
    defaultActiveFirst: PropTypes.bool,
    selectedKeys: PropTypes.arrayOf(PropTypes.string),
    defaultOpenKeys: PropTypes.arrayOf(PropTypes.string),
    openKeys: PropTypes.arrayOf(PropTypes.string),
    mode: PropTypes.oneOf(['horizontal', 'vertical', 'vertical-left', 'vertical-right', 'inline']),
    getPopupContainer: PropTypes.func,
    onClick: PropTypes.func,
    onSelect: PropTypes.func,
    onDeselect: PropTypes.func,
    onDestroy: PropTypes.func,
    openTransitionName: PropTypes.string,
    openAnimation: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
    subMenuOpenDelay: PropTypes.number,
    subMenuCloseDelay: PropTypes.number,
    forceSubMenuRender: PropTypes.bool,
    triggerSubMenuAction: PropTypes.string,
    level: PropTypes.number,
    selectable: PropTypes.bool,
    multiple: PropTypes.bool,
    children: PropTypes.any,
    className: PropTypes.string,
    style: PropTypes.object,
    activeKey: PropTypes.string,
    prefixCls: PropTypes.string
  };
  Menu$1.defaultProps = {
    selectable: true,
    onClick: noop$b,
    onSelect: noop$b,
    onOpenChange: noop$b,
    onDeselect: noop$b,
    defaultSelectedKeys: [],
    defaultOpenKeys: [],
    subMenuOpenDelay: 0.1,
    subMenuCloseDelay: 0.1,
    triggerSubMenuAction: 'hover',
    prefixCls: 'rc-menu',
    className: '',
    mode: 'vertical',
    style: {}
  };

  var _initialiseProps$e = function _initialiseProps() {
    var _this3 = this;

    this.onSelect = function (selectInfo) {
      var props = _this3.props;
      if (props.selectable) {
        // root menu
        var selectedKeys = _this3.store.getState().selectedKeys;
        var selectedKey = selectInfo.key;
        if (props.multiple) {
          selectedKeys = selectedKeys.concat([selectedKey]);
        } else {
          selectedKeys = [selectedKey];
        }
        if (!('selectedKeys' in props)) {
          _this3.store.setState({
            selectedKeys: selectedKeys
          });
        }
        props.onSelect(_extends$2({}, selectInfo, {
          selectedKeys: selectedKeys
        }));
      }
    };

    this.onClick = function (e) {
      _this3.props.onClick(e);
    };

    this.onKeyDown = function (e, callback) {
      _this3.innerMenu.getWrappedInstance().onKeyDown(e, callback);
    };

    this.onOpenChange = function (event) {
      var props = _this3.props;
      var openKeys = _this3.store.getState().openKeys.concat();
      var changed = false;
      var processSingle = function processSingle(e) {
        var oneChanged = false;
        if (e.open) {
          oneChanged = openKeys.indexOf(e.key) === -1;
          if (oneChanged) {
            openKeys.push(e.key);
          }
        } else {
          var index = openKeys.indexOf(e.key);
          oneChanged = index !== -1;
          if (oneChanged) {
            openKeys.splice(index, 1);
          }
        }
        changed = changed || oneChanged;
      };
      if (Array.isArray(event)) {
        // batch change call
        event.forEach(processSingle);
      } else {
        processSingle(event);
      }
      if (changed) {
        if (!('openKeys' in _this3.props)) {
          _this3.store.setState({ openKeys: openKeys });
        }
        props.onOpenChange(openKeys);
      }
    };

    this.onDeselect = function (selectInfo) {
      var props = _this3.props;
      if (props.selectable) {
        var selectedKeys = _this3.store.getState().selectedKeys.concat();
        var selectedKey = selectInfo.key;
        var index = selectedKeys.indexOf(selectedKey);
        if (index !== -1) {
          selectedKeys.splice(index, 1);
        }
        if (!('selectedKeys' in props)) {
          _this3.store.setState({
            selectedKeys: selectedKeys
          });
        }
        props.onDeselect(_extends$2({}, selectInfo, {
          selectedKeys: selectedKeys
        }));
      }
    };

    this.getOpenTransitionName = function () {
      var props = _this3.props;
      var transitionName = props.openTransitionName;
      var animationName = props.openAnimation;
      if (!transitionName && typeof animationName === 'string') {
        transitionName = props.prefixCls + '-open-' + animationName;
      }
      return transitionName;
    };
  };

  var autoAdjustOverflow$2 = {
    adjustX: 1,
    adjustY: 1
  };

  var placements$7 = {
    topLeft: {
      points: ['bl', 'tl'],
      overflow: autoAdjustOverflow$2,
      offset: [0, -7]
    },
    bottomLeft: {
      points: ['tl', 'bl'],
      overflow: autoAdjustOverflow$2,
      offset: [0, 7]
    },
    leftTop: {
      points: ['tr', 'tl'],
      overflow: autoAdjustOverflow$2,
      offset: [-4, 0]
    },
    rightTop: {
      points: ['tl', 'tr'],
      overflow: autoAdjustOverflow$2,
      offset: [4, 0]
    }
  };

  var guid$1 = 0;

  var popupPlacementMap$1 = {
    horizontal: 'bottomLeft',
    vertical: 'rightTop',
    'vertical-left': 'rightTop',
    'vertical-right': 'leftTop'
  };

  var updateDefaultActiveFirst$1 = function updateDefaultActiveFirst(store, eventKey, defaultActiveFirst) {
    var _extends2;

    var menuId = getMenuIdFromSubMenuEventKey$1(eventKey);
    var state = store.getState();
    store.setState({
      defaultActiveFirst: _extends$2({}, state.defaultActiveFirst, (_extends2 = {}, _extends2[menuId] = defaultActiveFirst, _extends2))
    });
  };

  var SubMenu$1 = function (_React$Component) {
    _inherits$1(SubMenu, _React$Component);

    function SubMenu(props) {
      _classCallCheck$1(this, SubMenu);

      var _this = _possibleConstructorReturn$1(this, _React$Component.call(this, props));

      _initialiseProps$f.call(_this);

      var store = props.store;
      var eventKey = props.eventKey;
      var defaultActiveFirst = store.getState().defaultActiveFirst;

      _this.isRootMenu = false;

      var value = false;

      if (defaultActiveFirst) {
        value = defaultActiveFirst[eventKey];
      }

      updateDefaultActiveFirst$1(store, eventKey, value);
      return _this;
    }

    SubMenu.prototype.componentDidMount = function componentDidMount() {
      this.componentDidUpdate();
    };

    SubMenu.prototype.componentDidUpdate = function componentDidUpdate() {
      var _this2 = this;

      var _props = this.props,
          mode = _props.mode,
          parentMenu = _props.parentMenu,
          manualRef = _props.manualRef;

      // invoke customized ref to expose component to mixin

      if (manualRef) {
        manualRef(this);
      }

      if (mode !== 'horizontal' || !parentMenu.isRootMenu || !this.props.isOpen) {
        return;
      }

      this.minWidthTimeout = setTimeout(function () {
        return _this2.adjustWidth();
      }, 0);
    };

    SubMenu.prototype.componentWillUnmount = function componentWillUnmount() {
      var _props2 = this.props,
          onDestroy = _props2.onDestroy,
          eventKey = _props2.eventKey;

      if (onDestroy) {
        onDestroy(eventKey);
      }

      /* istanbul ignore if */
      if (this.minWidthTimeout) {
        clearTimeout(this.minWidthTimeout);
      }

      /* istanbul ignore if */
      if (this.mouseenterTimeout) {
        clearTimeout(this.mouseenterTimeout);
      }
    };

    SubMenu.prototype.renderChildren = function renderChildren(children) {
      var props = this.props;
      var baseProps = {
        mode: props.mode === 'horizontal' ? 'vertical' : props.mode,
        visible: this.props.isOpen,
        level: props.level + 1,
        inlineIndent: props.inlineIndent,
        focusable: false,
        onClick: this.onSubMenuClick,
        onSelect: this.onSelect,
        onDeselect: this.onDeselect,
        onDestroy: this.onDestroy,
        selectedKeys: props.selectedKeys,
        eventKey: props.eventKey + '-menu-',
        openKeys: props.openKeys,
        openTransitionName: props.openTransitionName,
        openAnimation: props.openAnimation,
        onOpenChange: this.onOpenChange,
        subMenuOpenDelay: props.subMenuOpenDelay,
        parentMenu: this,
        subMenuCloseDelay: props.subMenuCloseDelay,
        forceSubMenuRender: props.forceSubMenuRender,
        triggerSubMenuAction: props.triggerSubMenuAction,
        defaultActiveFirst: props.store.getState().defaultActiveFirst[getMenuIdFromSubMenuEventKey$1(props.eventKey)],
        multiple: props.multiple,
        prefixCls: props.rootPrefixCls,
        id: this._menuId,
        manualRef: this.saveMenuInstance
      };

      var haveRendered = this.haveRendered;
      this.haveRendered = true;

      this.haveOpened = this.haveOpened || baseProps.visible || baseProps.forceSubMenuRender;
      // never rendered not planning to, don't render
      if (!this.haveOpened) {
        return React$1__default.createElement('div', null);
      }

      // don't show transition on first rendering (no animation for opened menu)
      // show appear transition if it's not visible (not sure why)
      // show appear transition if it's not inline mode
      var transitionAppear = haveRendered || !baseProps.visible || !baseProps.mode === 'inline';

      baseProps.className = ' ' + baseProps.prefixCls + '-sub';
      var animProps = {};

      if (baseProps.openTransitionName) {
        animProps.transitionName = baseProps.openTransitionName;
      } else if (typeof baseProps.openAnimation === 'object') {
        animProps.animation = _extends$2({}, baseProps.openAnimation);
        if (!transitionAppear) {
          delete animProps.animation.appear;
        }
      }

      return React$1__default.createElement(
        Animate,
        _extends$2({}, animProps, {
          showProp: 'visible',
          component: '',
          transitionAppear: transitionAppear
        }),
        React$1__default.createElement(
          SubPopupMenu$2,
          _extends$2({}, baseProps, { id: this._menuId }),
          children
        )
      );
    };

    SubMenu.prototype.render = function render() {
      var _classNames;

      var props = _extends$2({}, this.props);
      var isOpen = props.isOpen;
      var prefixCls = this.getPrefixCls();
      var isInlineMode = props.mode === 'inline';
      var className = classnames(prefixCls, prefixCls + '-' + props.mode, (_classNames = {}, _classNames[props.className] = !!props.className, _classNames[this.getOpenClassName()] = isOpen, _classNames[this.getActiveClassName()] = props.active || isOpen && !isInlineMode, _classNames[this.getDisabledClassName()] = props.disabled, _classNames[this.getSelectedClassName()] = this.isChildrenSelected(), _classNames));

      if (!this._menuId) {
        if (props.eventKey) {
          this._menuId = props.eventKey + '$Menu';
        } else {
          this._menuId = '$__$' + ++guid$1 + '$Menu';
        }
      }

      var mouseEvents = {};
      var titleClickEvents = {};
      var titleMouseEvents = {};
      if (!props.disabled) {
        mouseEvents = {
          onMouseLeave: this.onMouseLeave,
          onMouseEnter: this.onMouseEnter
        };

        // only works in title, not outer li
        titleClickEvents = {
          onClick: this.onTitleClick
        };
        titleMouseEvents = {
          onMouseEnter: this.onTitleMouseEnter,
          onMouseLeave: this.onTitleMouseLeave
        };
      }

      var style = {};
      if (isInlineMode) {
        style.paddingLeft = props.inlineIndent * props.level;
      }

      var ariaOwns = {};
      // only set aria-owns when menu is open
      // otherwise it would be an invalid aria-owns value
      // since corresponding node cannot be found
      if (this.props.isOpen) {
        ariaOwns = {
          'aria-owns': this._menuId
        };
      }

      var title = React$1__default.createElement(
        'div',
        _extends$2({
          ref: this.saveSubMenuTitle,
          style: style,
          className: prefixCls + '-title'
        }, titleMouseEvents, titleClickEvents, {
          'aria-expanded': isOpen
        }, ariaOwns, {
          'aria-haspopup': 'true',
          title: typeof props.title === 'string' ? props.title : undefined
        }),
        props.title,
        React$1__default.createElement('i', { className: prefixCls + '-arrow' })
      );
      var children = this.renderChildren(props.children);

      var getPopupContainer = props.parentMenu.isRootMenu ? props.parentMenu.props.getPopupContainer : function (triggerNode) {
        return triggerNode.parentNode;
      };
      var popupPlacement = popupPlacementMap$1[props.mode];
      var popupAlign = props.popupOffset ? { offset: props.popupOffset } : {};
      var popupClassName = props.mode === 'inline' ? '' : props.popupClassName;
      var disabled = props.disabled,
          triggerSubMenuAction = props.triggerSubMenuAction,
          subMenuOpenDelay = props.subMenuOpenDelay,
          forceSubMenuRender = props.forceSubMenuRender,
          subMenuCloseDelay = props.subMenuCloseDelay;

      menuAllProps$1.forEach(function (key) {
        return delete props[key];
      });
      // Set onClick to null, to ignore propagated onClick event
      delete props.onClick;

      return React$1__default.createElement(
        'li',
        _extends$2({}, props, mouseEvents, {
          className: className,
          role: 'menuitem'
        }),
        isInlineMode && title,
        isInlineMode && children,
        !isInlineMode && React$1__default.createElement(
          Trigger,
          {
            prefixCls: prefixCls,
            popupClassName: prefixCls + '-popup ' + popupClassName,
            getPopupContainer: getPopupContainer,
            builtinPlacements: placements$7,
            popupPlacement: popupPlacement,
            popupVisible: isOpen,
            popupAlign: popupAlign,
            popup: children,
            action: disabled ? [] : [triggerSubMenuAction],
            mouseEnterDelay: subMenuOpenDelay,
            mouseLeaveDelay: subMenuCloseDelay,
            onPopupVisibleChange: this.onPopupVisibleChange,
            forceRender: forceSubMenuRender
          },
          title
        )
      );
    };

    return SubMenu;
  }(React$1__default.Component);

  SubMenu$1.propTypes = {
    parentMenu: PropTypes.object,
    title: PropTypes.node,
    children: PropTypes.any,
    selectedKeys: PropTypes.array,
    openKeys: PropTypes.array,
    onClick: PropTypes.func,
    onOpenChange: PropTypes.func,
    rootPrefixCls: PropTypes.string,
    eventKey: PropTypes.string,
    multiple: PropTypes.bool,
    active: PropTypes.bool, // TODO: remove
    onItemHover: PropTypes.func,
    onSelect: PropTypes.func,
    triggerSubMenuAction: PropTypes.string,
    onDeselect: PropTypes.func,
    onDestroy: PropTypes.func,
    onMouseEnter: PropTypes.func,
    onMouseLeave: PropTypes.func,
    onTitleMouseEnter: PropTypes.func,
    onTitleMouseLeave: PropTypes.func,
    onTitleClick: PropTypes.func,
    popupOffset: PropTypes.array,
    isOpen: PropTypes.bool,
    store: PropTypes.object,
    mode: PropTypes.oneOf(['horizontal', 'vertical', 'vertical-left', 'vertical-right', 'inline']),
    manualRef: PropTypes.func
  };
  SubMenu$1.defaultProps = {
    onMouseEnter: noop$b,
    onMouseLeave: noop$b,
    onTitleMouseEnter: noop$b,
    onTitleMouseLeave: noop$b,
    onTitleClick: noop$b,
    manualRef: noop$b,
    mode: 'vertical',
    title: ''
  };

  var _initialiseProps$f = function _initialiseProps() {
    var _this3 = this;

    this.onDestroy = function (key) {
      _this3.props.onDestroy(key);
    };

    this.onKeyDown = function (e) {
      var keyCode = e.keyCode;
      var menu = _this3.menuInstance;
      var _props3 = _this3.props,
          isOpen = _props3.isOpen,
          store = _props3.store;


      if (keyCode === KeyCode.ENTER) {
        _this3.onTitleClick(e);
        updateDefaultActiveFirst$1(store, _this3.props.eventKey, true);
        return true;
      }

      if (keyCode === KeyCode.RIGHT) {
        if (isOpen) {
          menu.onKeyDown(e);
        } else {
          _this3.triggerOpenChange(true);
          // need to update current menu's defaultActiveFirst value
          updateDefaultActiveFirst$1(store, _this3.props.eventKey, true);
        }
        return true;
      }
      if (keyCode === KeyCode.LEFT) {
        var handled = void 0;
        if (isOpen) {
          handled = menu.onKeyDown(e);
        } else {
          return undefined;
        }
        if (!handled) {
          _this3.triggerOpenChange(false);
          handled = true;
        }
        return handled;
      }

      if (isOpen && (keyCode === KeyCode.UP || keyCode === KeyCode.DOWN)) {
        return menu.onKeyDown(e);
      }
    };

    this.onOpenChange = function (e) {
      _this3.props.onOpenChange(e);
    };

    this.onPopupVisibleChange = function (visible) {
      _this3.triggerOpenChange(visible, visible ? 'mouseenter' : 'mouseleave');
    };

    this.onMouseEnter = function (e) {
      var _props4 = _this3.props,
          key = _props4.eventKey,
          onMouseEnter = _props4.onMouseEnter,
          store = _props4.store;

      updateDefaultActiveFirst$1(store, _this3.props.eventKey, false);
      onMouseEnter({
        key: key,
        domEvent: e
      });
    };

    this.onMouseLeave = function (e) {
      var _props5 = _this3.props,
          parentMenu = _props5.parentMenu,
          eventKey = _props5.eventKey,
          onMouseLeave = _props5.onMouseLeave;

      parentMenu.subMenuInstance = _this3;
      onMouseLeave({
        key: eventKey,
        domEvent: e
      });
    };

    this.onTitleMouseEnter = function (domEvent) {
      var _props6 = _this3.props,
          key = _props6.eventKey,
          onItemHover = _props6.onItemHover,
          onTitleMouseEnter = _props6.onTitleMouseEnter;

      onItemHover({
        key: key,
        hover: true
      });
      onTitleMouseEnter({
        key: key,
        domEvent: domEvent
      });
    };

    this.onTitleMouseLeave = function (e) {
      var _props7 = _this3.props,
          parentMenu = _props7.parentMenu,
          eventKey = _props7.eventKey,
          onItemHover = _props7.onItemHover,
          onTitleMouseLeave = _props7.onTitleMouseLeave;

      parentMenu.subMenuInstance = _this3;
      onItemHover({
        key: eventKey,
        hover: false
      });
      onTitleMouseLeave({
        key: eventKey,
        domEvent: e
      });
    };

    this.onTitleClick = function (e) {
      var props = _this3.props;

      props.onTitleClick({
        key: props.eventKey,
        domEvent: e
      });
      if (props.triggerSubMenuAction === 'hover') {
        return;
      }
      _this3.triggerOpenChange(!props.isOpen, 'click');
      updateDefaultActiveFirst$1(props.store, _this3.props.eventKey, false);
    };

    this.onSubMenuClick = function (info) {
      _this3.props.onClick(_this3.addKeyPath(info));
    };

    this.onSelect = function (info) {
      _this3.props.onSelect(info);
    };

    this.onDeselect = function (info) {
      _this3.props.onDeselect(info);
    };

    this.getPrefixCls = function () {
      return _this3.props.rootPrefixCls + '-submenu';
    };

    this.getActiveClassName = function () {
      return _this3.getPrefixCls() + '-active';
    };

    this.getDisabledClassName = function () {
      return _this3.getPrefixCls() + '-disabled';
    };

    this.getSelectedClassName = function () {
      return _this3.getPrefixCls() + '-selected';
    };

    this.getOpenClassName = function () {
      return _this3.props.rootPrefixCls + '-submenu-open';
    };

    this.saveMenuInstance = function (c) {
      // children menu instance
      _this3.menuInstance = c;
    };

    this.addKeyPath = function (info) {
      return _extends$2({}, info, {
        keyPath: (info.keyPath || []).concat(_this3.props.eventKey)
      });
    };

    this.triggerOpenChange = function (open, type) {
      var key = _this3.props.eventKey;
      var openChange = function openChange() {
        _this3.onOpenChange({
          key: key,
          item: _this3,
          trigger: type,
          open: open
        });
      };
      if (type === 'mouseenter') {
        // make sure mouseenter happen after other menu item's mouseleave
        _this3.mouseenterTimeout = setTimeout(function () {
          openChange();
        }, 0);
      } else {
        openChange();
      }
    };

    this.isChildrenSelected = function () {
      var ret = { find: false };
      loopMenuItemRecursively$1(_this3.props.children, _this3.props.selectedKeys, ret);
      return ret.find;
    };

    this.isOpen = function () {
      return _this3.props.openKeys.indexOf(_this3.props.eventKey) !== -1;
    };

    this.adjustWidth = function () {
      /* istanbul ignore if */
      if (!_this3.subMenuTitle || !_this3.menuInstance) {
        return;
      }
      var popupMenu = ReactDOM__default.findDOMNode(_this3.menuInstance);
      if (popupMenu.offsetWidth >= _this3.subMenuTitle.offsetWidth) {
        return;
      }

      /* istanbul ignore next */
      popupMenu.style.minWidth = _this3.subMenuTitle.offsetWidth + 'px';
    };

    this.saveSubMenuTitle = function (subMenuTitle) {
      _this3.subMenuTitle = subMenuTitle;
    };
  };

  var connected$3 = lib_2$1(function (_ref, _ref2) {
    var openKeys = _ref.openKeys,
        activeKey = _ref.activeKey,
        selectedKeys = _ref.selectedKeys;
    var eventKey = _ref2.eventKey,
        subMenuKey = _ref2.subMenuKey;
    return {
      isOpen: openKeys.indexOf(eventKey) > -1,
      active: activeKey[subMenuKey] === eventKey,
      selectedKeys: selectedKeys
    };
  })(SubMenu$1);

  connected$3.isSubMenu = true;

  /* eslint react/no-is-mounted:0 */

  var MenuItem$1 = function (_React$Component) {
    _inherits$1(MenuItem, _React$Component);

    function MenuItem(props) {
      _classCallCheck$1(this, MenuItem);

      var _this = _possibleConstructorReturn$1(this, _React$Component.call(this, props));

      _this.onKeyDown = function (e) {
        var keyCode = e.keyCode;
        if (keyCode === KeyCode.ENTER) {
          _this.onClick(e);
          return true;
        }
      };

      _this.onMouseLeave = function (e) {
        var _this$props = _this.props,
            eventKey = _this$props.eventKey,
            onItemHover = _this$props.onItemHover,
            onMouseLeave = _this$props.onMouseLeave;

        onItemHover({
          key: eventKey,
          hover: false
        });
        onMouseLeave({
          key: eventKey,
          domEvent: e
        });
      };

      _this.onMouseEnter = function (e) {
        var _this$props2 = _this.props,
            eventKey = _this$props2.eventKey,
            onItemHover = _this$props2.onItemHover,
            onMouseEnter = _this$props2.onMouseEnter;

        onItemHover({
          key: eventKey,
          hover: true
        });
        onMouseEnter({
          key: eventKey,
          domEvent: e
        });
      };

      _this.onClick = function (e) {
        var _this$props3 = _this.props,
            eventKey = _this$props3.eventKey,
            multiple = _this$props3.multiple,
            onClick = _this$props3.onClick,
            onSelect = _this$props3.onSelect,
            onDeselect = _this$props3.onDeselect,
            isSelected = _this$props3.isSelected;

        var info = {
          key: eventKey,
          keyPath: [eventKey],
          item: _this,
          domEvent: e
        };
        onClick(info);
        if (multiple) {
          if (isSelected) {
            onDeselect(info);
          } else {
            onSelect(info);
          }
        } else if (!isSelected) {
          onSelect(info);
        }
      };

      return _this;
    }

    MenuItem.prototype.componentDidMount = function componentDidMount() {
      // invoke customized ref to expose component to mixin
      this.callRef();
    };

    MenuItem.prototype.componentDidUpdate = function componentDidUpdate() {
      if (this.props.active) {
        lib(ReactDOM__default.findDOMNode(this), ReactDOM__default.findDOMNode(this.props.parentMenu), {
          onlyScrollIfNeeded: true
        });
      }
      this.callRef();
    };

    MenuItem.prototype.componentWillUnmount = function componentWillUnmount() {
      var props = this.props;
      if (props.onDestroy) {
        props.onDestroy(props.eventKey);
      }
    };

    MenuItem.prototype.getPrefixCls = function getPrefixCls() {
      return this.props.rootPrefixCls + '-item';
    };

    MenuItem.prototype.getActiveClassName = function getActiveClassName() {
      return this.getPrefixCls() + '-active';
    };

    MenuItem.prototype.getSelectedClassName = function getSelectedClassName() {
      return this.getPrefixCls() + '-selected';
    };

    MenuItem.prototype.getDisabledClassName = function getDisabledClassName() {
      return this.getPrefixCls() + '-disabled';
    };

    MenuItem.prototype.callRef = function callRef() {
      if (this.props.manualRef) {
        this.props.manualRef(this);
      }
    };

    MenuItem.prototype.render = function render() {
      var _classNames;

      var props = _extends$2({}, this.props);
      var className = classnames(this.getPrefixCls(), props.className, (_classNames = {}, _classNames[this.getActiveClassName()] = !props.disabled && props.active, _classNames[this.getSelectedClassName()] = props.isSelected, _classNames[this.getDisabledClassName()] = props.disabled, _classNames));
      var attrs = _extends$2({}, props.attribute, {
        title: props.title,
        className: className,
        // set to menuitem by default
        role: 'menuitem',
        'aria-disabled': props.disabled
      });

      if (props.role === 'option') {
        // overwrite to option
        attrs = _extends$2({}, attrs, {
          role: 'option',
          'aria-selected': props.isSelected
        });
      } else if (props.role === null) {
        // sometimes we want to specify role inside <li/> element
        // <li><a role='menuitem'>Link</a></li> would be a good example
        delete attrs.role;
      }
      // In case that onClick/onMouseLeave/onMouseEnter is passed down from owner
      var mouseEvent = {
        onClick: props.disabled ? null : this.onClick,
        onMouseLeave: props.disabled ? null : this.onMouseLeave,
        onMouseEnter: props.disabled ? null : this.onMouseEnter
      };
      var style = _extends$2({}, props.style);
      if (props.mode === 'inline') {
        style.paddingLeft = props.inlineIndent * props.level;
      }
      menuAllProps$1.forEach(function (key) {
        return delete props[key];
      });
      return React$1__default.createElement(
        'li',
        _extends$2({}, props, attrs, mouseEvent, {
          style: style
        }),
        props.children
      );
    };

    return MenuItem;
  }(React$1__default.Component);

  MenuItem$1.propTypes = {
    attribute: PropTypes.object,
    rootPrefixCls: PropTypes.string,
    eventKey: PropTypes.string,
    active: PropTypes.bool,
    children: PropTypes.any,
    selectedKeys: PropTypes.array,
    disabled: PropTypes.bool,
    title: PropTypes.string,
    onItemHover: PropTypes.func,
    onSelect: PropTypes.func,
    onClick: PropTypes.func,
    onDeselect: PropTypes.func,
    parentMenu: PropTypes.object,
    onDestroy: PropTypes.func,
    onMouseEnter: PropTypes.func,
    onMouseLeave: PropTypes.func,
    multiple: PropTypes.bool,
    isSelected: PropTypes.bool,
    manualRef: PropTypes.func
  };
  MenuItem$1.defaultProps = {
    onSelect: noop$b,
    onMouseEnter: noop$b,
    onMouseLeave: noop$b,
    manualRef: noop$b
  };
  MenuItem$1.isMenuItem = true;

  var connected$4 = lib_2$1(function (_ref, _ref2) {
    var activeKey = _ref.activeKey,
        selectedKeys = _ref.selectedKeys;
    var eventKey = _ref2.eventKey,
        subMenuKey = _ref2.subMenuKey;
    return {
      active: activeKey[subMenuKey] === eventKey,
      isSelected: selectedKeys.indexOf(eventKey) !== -1
    };
  })(MenuItem$1);

  var MenuItemGroup$1 = function (_React$Component) {
    _inherits$1(MenuItemGroup, _React$Component);

    function MenuItemGroup() {
      var _temp, _this, _ret;

      _classCallCheck$1(this, MenuItemGroup);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn$1(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.renderInnerMenuItem = function (item) {
        var _this$props = _this.props,
            renderMenuItem = _this$props.renderMenuItem,
            index = _this$props.index;

        return renderMenuItem(item, index, _this.props.subMenuKey);
      }, _temp), _possibleConstructorReturn$1(_this, _ret);
    }

    MenuItemGroup.prototype.render = function render() {
      var props = _objectWithoutProperties$1(this.props, []);

      var _props$className = props.className,
          className = _props$className === undefined ? '' : _props$className,
          rootPrefixCls = props.rootPrefixCls;

      var titleClassName = rootPrefixCls + '-item-group-title';
      var listClassName = rootPrefixCls + '-item-group-list';
      var title = props.title,
          children = props.children;

      menuAllProps$1.forEach(function (key) {
        return delete props[key];
      });

      // Set onClick to null, to ignore propagated onClick event
      delete props.onClick;

      return React$1__default.createElement(
        'li',
        _extends$2({}, props, { className: className + ' ' + rootPrefixCls + '-item-group' }),
        React$1__default.createElement(
          'div',
          {
            className: titleClassName,
            title: typeof title === 'string' ? title : undefined
          },
          title
        ),
        React$1__default.createElement(
          'ul',
          { className: listClassName },
          React$1__default.Children.map(children, this.renderInnerMenuItem)
        )
      );
    };

    return MenuItemGroup;
  }(React$1__default.Component);

  MenuItemGroup$1.propTypes = {
    renderMenuItem: PropTypes.func,
    index: PropTypes.number,
    className: PropTypes.string,
    subMenuKey: PropTypes.string,
    rootPrefixCls: PropTypes.string
  };
  MenuItemGroup$1.defaultProps = {
    disabled: true
  };


  MenuItemGroup$1.isMenuItemGroup = true;

  var Divider$1 = function (_React$Component) {
    _inherits$1(Divider, _React$Component);

    function Divider() {
      _classCallCheck$1(this, Divider);

      return _possibleConstructorReturn$1(this, _React$Component.apply(this, arguments));
    }

    Divider.prototype.render = function render() {
      var _props = this.props,
          _props$className = _props.className,
          className = _props$className === undefined ? '' : _props$className,
          rootPrefixCls = _props.rootPrefixCls;

      return React$1__default.createElement('li', { className: className + ' ' + rootPrefixCls + '-item-divider' });
    };

    return Divider;
  }(React$1__default.Component);

  Divider$1.propTypes = {
    className: PropTypes.string,
    rootPrefixCls: PropTypes.string
  };
  Divider$1.defaultProps = {
    // To fix keyboard UX.
    disabled: true
  };



  var es$9 = /*#__PURE__*/Object.freeze({
    SubMenu: connected$3,
    Item: connected$4,
    MenuItem: connected$4,
    MenuItemGroup: MenuItemGroup$1,
    ItemGroup: MenuItemGroup$1,
    Divider: Divider$1,
    default: Menu$1
  });

  var _rcMenu = getCjsExportFromNamespace(es$9);

  var SubMenu_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var _propTypes2 = _interopRequireDefault(PropTypes);





  var _classnames2 = _interopRequireDefault(classnames);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var SubMenu = function (_React$Component) {
      (0, _inherits3['default'])(SubMenu, _React$Component);

      function SubMenu() {
          (0, _classCallCheck3['default'])(this, SubMenu);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (SubMenu.__proto__ || Object.getPrototypeOf(SubMenu)).apply(this, arguments));

          _this.onKeyDown = function (e) {
              _this.subMenu.onKeyDown(e);
          };
          _this.saveSubMenu = function (subMenu) {
              _this.subMenu = subMenu;
          };
          return _this;
      }

      (0, _createClass3['default'])(SubMenu, [{
          key: 'render',
          value: function render() {
              var _props = this.props,
                  rootPrefixCls = _props.rootPrefixCls,
                  className = _props.className;

              var theme = this.context.antdMenuTheme;
              return React.createElement(_rcMenu.SubMenu, (0, _extends3['default'])({}, this.props, { ref: this.saveSubMenu, popupClassName: (0, _classnames2['default'])(rootPrefixCls + '-' + theme, className) }));
          }
      }]);
      return SubMenu;
  }(React.Component);

  SubMenu.contextTypes = {
      antdMenuTheme: _propTypes2['default'].string
  };
  exports['default'] = SubMenu;
  module.exports = exports['default'];
  });

  unwrapExports(SubMenu_1);

  var MenuItem_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);





  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _tooltip2 = _interopRequireDefault(tooltip);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var MenuItem = function (_React$Component) {
      (0, _inherits3['default'])(MenuItem, _React$Component);

      function MenuItem() {
          (0, _classCallCheck3['default'])(this, MenuItem);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (MenuItem.__proto__ || Object.getPrototypeOf(MenuItem)).apply(this, arguments));

          _this.onKeyDown = function (e) {
              _this.menuItem.onKeyDown(e);
          };
          _this.saveMenuItem = function (menuItem) {
              _this.menuItem = menuItem;
          };
          return _this;
      }

      (0, _createClass3['default'])(MenuItem, [{
          key: 'render',
          value: function render() {
              var inlineCollapsed = this.context.inlineCollapsed;

              var props = this.props;
              return React.createElement(
                  _tooltip2['default'],
                  { title: inlineCollapsed && props.level === 1 ? props.children : '', placement: 'right', overlayClassName: props.rootPrefixCls + '-inline-collapsed-tooltip' },
                  React.createElement(_rcMenu.Item, (0, _extends3['default'])({}, props, { ref: this.saveMenuItem }))
              );
          }
      }]);
      return MenuItem;
  }(React.Component);

  MenuItem.contextTypes = {
      inlineCollapsed: _propTypes2['default'].bool
  };
  MenuItem.isMenuItem = 1;
  exports['default'] = MenuItem;
  module.exports = exports['default'];
  });

  unwrapExports(MenuItem_1);

  var menu = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _extends3 = _interopRequireDefault(_extends$1);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);





  var _rcMenu2 = _interopRequireDefault(_rcMenu);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _classnames2 = _interopRequireDefault(classnames);



  var _openAnimation2 = _interopRequireDefault(openAnimation);



  var _warning2 = _interopRequireDefault(warning$4);



  var _SubMenu2 = _interopRequireDefault(SubMenu_1);



  var _MenuItem2 = _interopRequireDefault(MenuItem_1);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var Menu = function (_React$Component) {
      (0, _inherits3['default'])(Menu, _React$Component);

      function Menu(props) {
          (0, _classCallCheck3['default'])(this, Menu);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (Menu.__proto__ || Object.getPrototypeOf(Menu)).call(this, props));

          _this.inlineOpenKeys = [];
          _this.handleClick = function (e) {
              _this.handleOpenChange([]);
              var onClick = _this.props.onClick;

              if (onClick) {
                  onClick(e);
              }
          };
          _this.handleOpenChange = function (openKeys) {
              _this.setOpenKeys(openKeys);
              var onOpenChange = _this.props.onOpenChange;

              if (onOpenChange) {
                  onOpenChange(openKeys);
              }
          };
          (0, _warning2['default'])(!('onOpen' in props || 'onClose' in props), '`onOpen` and `onClose` are removed, please use `onOpenChange` instead, ' + 'see: https://u.ant.design/menu-on-open-change.');
          (0, _warning2['default'])(!('inlineCollapsed' in props && props.mode !== 'inline'), '`inlineCollapsed` should only be used when Menu\'s `mode` is inline.');
          var openKeys = void 0;
          if ('defaultOpenKeys' in props) {
              openKeys = props.defaultOpenKeys;
          } else if ('openKeys' in props) {
              openKeys = props.openKeys;
          }
          _this.state = {
              openKeys: openKeys || []
          };
          return _this;
      }

      (0, _createClass3['default'])(Menu, [{
          key: 'getChildContext',
          value: function getChildContext() {
              return {
                  inlineCollapsed: this.getInlineCollapsed(),
                  antdMenuTheme: this.props.theme
              };
          }
      }, {
          key: 'componentWillReceiveProps',
          value: function componentWillReceiveProps(nextProps, nextContext) {
              var prefixCls = this.props.prefixCls;

              if (this.props.mode === 'inline' && nextProps.mode !== 'inline') {
                  this.switchModeFromInline = true;
              }
              if ('openKeys' in nextProps) {
                  this.setState({ openKeys: nextProps.openKeys });
                  return;
              }
              if (nextProps.inlineCollapsed && !this.props.inlineCollapsed || nextContext.siderCollapsed && !this.context.siderCollapsed) {
                  var menuNode = (0, ReactDOM__default.findDOMNode)(this);
                  this.switchModeFromInline = !!this.state.openKeys.length && !!menuNode.querySelectorAll('.' + prefixCls + '-submenu-open').length;
                  this.inlineOpenKeys = this.state.openKeys;
                  this.setState({ openKeys: [] });
              }
              if (!nextProps.inlineCollapsed && this.props.inlineCollapsed || !nextContext.siderCollapsed && this.context.siderCollapsed) {
                  this.setState({ openKeys: this.inlineOpenKeys });
                  this.inlineOpenKeys = [];
              }
          }
      }, {
          key: 'setOpenKeys',
          value: function setOpenKeys(openKeys) {
              if (!('openKeys' in this.props)) {
                  this.setState({ openKeys: openKeys });
              }
          }
      }, {
          key: 'getRealMenuMode',
          value: function getRealMenuMode() {
              var inlineCollapsed = this.getInlineCollapsed();
              if (this.switchModeFromInline && inlineCollapsed) {
                  return 'inline';
              }
              var mode = this.props.mode;

              return inlineCollapsed ? 'vertical' : mode;
          }
      }, {
          key: 'getInlineCollapsed',
          value: function getInlineCollapsed() {
              var inlineCollapsed = this.props.inlineCollapsed;

              if (this.context.siderCollapsed !== undefined) {
                  return this.context.siderCollapsed;
              }
              return inlineCollapsed;
          }
      }, {
          key: 'getMenuOpenAnimation',
          value: function getMenuOpenAnimation(menuMode) {
              var _this2 = this;

              var _props = this.props,
                  openAnimation$$1 = _props.openAnimation,
                  openTransitionName = _props.openTransitionName;

              var menuOpenAnimation = openAnimation$$1 || openTransitionName;
              if (openAnimation$$1 === undefined && openTransitionName === undefined) {
                  switch (menuMode) {
                      case 'horizontal':
                          menuOpenAnimation = 'slide-up';
                          break;
                      case 'vertical':
                      case 'vertical-left':
                      case 'vertical-right':
                          // When mode switch from inline
                          // submenu should hide without animation
                          if (this.switchModeFromInline) {
                              menuOpenAnimation = '';
                              this.switchModeFromInline = false;
                          } else {
                              menuOpenAnimation = 'zoom-big';
                          }
                          break;
                      case 'inline':
                          menuOpenAnimation = (0, _extends3['default'])({}, _openAnimation2['default'], { leave: function leave(node, done) {
                                  return _openAnimation2['default'].leave(node, function () {
                                      // Make sure inline menu leave animation finished before mode is switched
                                      _this2.switchModeFromInline = false;
                                      _this2.setState({});
                                      // when inlineCollapsed change false to true, all submenu will be unmounted,
                                      // so that we don't need handle animation leaving.
                                      if (_this2.getRealMenuMode() === 'vertical') {
                                          return;
                                      }
                                      done();
                                  });
                              } });
                          break;
                      default:
                  }
              }
              return menuOpenAnimation;
          }
      }, {
          key: 'render',
          value: function render() {
              var _props2 = this.props,
                  prefixCls = _props2.prefixCls,
                  className = _props2.className,
                  theme = _props2.theme;

              var menuMode = this.getRealMenuMode();
              var menuOpenAnimation = this.getMenuOpenAnimation(menuMode);
              var menuClassName = (0, _classnames2['default'])(className, prefixCls + '-' + theme, (0, _defineProperty3['default'])({}, prefixCls + '-inline-collapsed', this.getInlineCollapsed()));
              var menuProps = {
                  openKeys: this.state.openKeys,
                  onOpenChange: this.handleOpenChange,
                  className: menuClassName,
                  mode: menuMode
              };
              if (menuMode !== 'inline') {
                  // closing vertical popup submenu after click it
                  menuProps.onClick = this.handleClick;
                  menuProps.openTransitionName = menuOpenAnimation;
              } else {
                  menuProps.openAnimation = menuOpenAnimation;
              }
              // https://github.com/ant-design/ant-design/issues/8587
              var collapsedWidth = this.context.collapsedWidth;

              if (this.getInlineCollapsed() && (collapsedWidth === 0 || collapsedWidth === '0' || collapsedWidth === '0px')) {
                  return null;
              }
              return React.createElement(_rcMenu2['default'], (0, _extends3['default'])({}, this.props, menuProps));
          }
      }]);
      return Menu;
  }(React.Component);

  exports['default'] = Menu;

  Menu.Divider = _rcMenu.Divider;
  Menu.Item = _MenuItem2['default'];
  Menu.SubMenu = _SubMenu2['default'];
  Menu.ItemGroup = _rcMenu.ItemGroup;
  Menu.defaultProps = {
      prefixCls: 'ant-menu',
      className: '',
      theme: 'light',
      focusable: false
  };
  Menu.childContextTypes = {
      inlineCollapsed: _propTypes2['default'].bool,
      antdMenuTheme: _propTypes2['default'].string
  };
  Menu.contextTypes = {
      siderCollapsed: _propTypes2['default'].bool,
      collapsedWidth: _propTypes2['default'].oneOfType([_propTypes2['default'].number, _propTypes2['default'].string])
  };
  module.exports = exports['default'];
  });

  var Menu$2 = unwrapExports(menu);

  var autoAdjustOverflow$3 = {
    adjustX: 1,
    adjustY: 1
  };

  var targetOffset$1 = [0, 0];

  var placements$8 = {
    topLeft: {
      points: ['bl', 'tl'],
      overflow: autoAdjustOverflow$3,
      offset: [0, -4],
      targetOffset: targetOffset$1
    },
    topCenter: {
      points: ['bc', 'tc'],
      overflow: autoAdjustOverflow$3,
      offset: [0, -4],
      targetOffset: targetOffset$1
    },
    topRight: {
      points: ['br', 'tr'],
      overflow: autoAdjustOverflow$3,
      offset: [0, -4],
      targetOffset: targetOffset$1
    },
    bottomLeft: {
      points: ['tl', 'bl'],
      overflow: autoAdjustOverflow$3,
      offset: [0, 4],
      targetOffset: targetOffset$1
    },
    bottomCenter: {
      points: ['tc', 'bc'],
      overflow: autoAdjustOverflow$3,
      offset: [0, 4],
      targetOffset: targetOffset$1
    },
    bottomRight: {
      points: ['tr', 'br'],
      overflow: autoAdjustOverflow$3,
      offset: [0, 4],
      targetOffset: targetOffset$1
    }
  };

  var _extends$5 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  function _objectWithoutProperties$2(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

  function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn$2(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits$2(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Dropdown = function (_Component) {
    _inherits$2(Dropdown, _Component);

    function Dropdown(props) {
      _classCallCheck$2(this, Dropdown);

      var _this = _possibleConstructorReturn$2(this, _Component.call(this, props));

      _initialiseProps$g.call(_this);

      if ('visible' in props) {
        _this.state = {
          visible: props.visible
        };
      } else {
        _this.state = {
          visible: props.defaultVisible
        };
      }
      return _this;
    }

    Dropdown.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps) {
      if ('visible' in nextProps) {
        return {
          visible: nextProps.visible
        };
      }
      return null;
    };

    Dropdown.prototype.getMenuElement = function getMenuElement() {
      var _props = this.props,
          overlay = _props.overlay,
          prefixCls = _props.prefixCls;

      var extraOverlayProps = {
        prefixCls: prefixCls + '-menu',
        onClick: this.onClick
      };
      if (typeof overlay.type === 'string') {
        delete extraOverlayProps.prefixCls;
      }
      return React$1__default.cloneElement(overlay, extraOverlayProps);
    };

    Dropdown.prototype.getPopupDomNode = function getPopupDomNode() {
      return this.trigger.getPopupDomNode();
    };

    Dropdown.prototype.render = function render() {
      var _props2 = this.props,
          prefixCls = _props2.prefixCls,
          children = _props2.children,
          transitionName = _props2.transitionName,
          animation = _props2.animation,
          align = _props2.align,
          placement = _props2.placement,
          getPopupContainer = _props2.getPopupContainer,
          showAction = _props2.showAction,
          hideAction = _props2.hideAction,
          overlayClassName = _props2.overlayClassName,
          overlayStyle = _props2.overlayStyle,
          trigger = _props2.trigger,
          otherProps = _objectWithoutProperties$2(_props2, ['prefixCls', 'children', 'transitionName', 'animation', 'align', 'placement', 'getPopupContainer', 'showAction', 'hideAction', 'overlayClassName', 'overlayStyle', 'trigger']);

      return React$1__default.createElement(
        Trigger,
        _extends$5({}, otherProps, {
          prefixCls: prefixCls,
          ref: this.saveTrigger,
          popupClassName: overlayClassName,
          popupStyle: overlayStyle,
          builtinPlacements: placements$8,
          action: trigger,
          showAction: showAction,
          hideAction: hideAction,
          popupPlacement: placement,
          popupAlign: align,
          popupTransitionName: transitionName,
          popupAnimation: animation,
          popupVisible: this.state.visible,
          afterPopupVisibleChange: this.afterVisibleChange,
          popup: this.getMenuElement(),
          onPopupVisibleChange: this.onVisibleChange,
          getPopupContainer: getPopupContainer
        }),
        children
      );
    };

    return Dropdown;
  }(React$1.Component);

  Dropdown.propTypes = {
    minOverlayWidthMatchTrigger: PropTypes.bool,
    onVisibleChange: PropTypes.func,
    onOverlayClick: PropTypes.func,
    prefixCls: PropTypes.string,
    children: PropTypes.any,
    transitionName: PropTypes.string,
    overlayClassName: PropTypes.string,
    animation: PropTypes.any,
    align: PropTypes.object,
    overlayStyle: PropTypes.object,
    placement: PropTypes.string,
    overlay: PropTypes.node,
    trigger: PropTypes.array,
    showAction: PropTypes.array,
    hideAction: PropTypes.array,
    getPopupContainer: PropTypes.func,
    visible: PropTypes.bool,
    defaultVisible: PropTypes.bool
  };
  Dropdown.defaultProps = {
    minOverlayWidthMatchTrigger: true,
    prefixCls: 'rc-dropdown',
    trigger: ['hover'],
    showAction: [],
    hideAction: [],
    overlayClassName: '',
    overlayStyle: {},
    defaultVisible: false,
    onVisibleChange: function onVisibleChange() {},

    placement: 'bottomLeft'
  };

  var _initialiseProps$g = function _initialiseProps() {
    var _this2 = this;

    this.onClick = function (e) {
      var props = _this2.props;
      var overlayProps = props.overlay.props;
      // do no call onVisibleChange, if you need click to hide, use onClick and control visible
      if (!('visible' in props)) {
        _this2.setState({
          visible: false
        });
      }
      if (props.onOverlayClick) {
        props.onOverlayClick(e);
      }
      if (overlayProps.onClick) {
        overlayProps.onClick(e);
      }
    };

    this.onVisibleChange = function (visible) {
      var props = _this2.props;
      if (!('visible' in props)) {
        _this2.setState({
          visible: visible
        });
      }
      props.onVisibleChange(visible);
    };

    this.afterVisibleChange = function (visible) {
      if (visible && _this2.props.minOverlayWidthMatchTrigger) {
        var overlayNode = _this2.getPopupDomNode();
        var rootNode = ReactDOM__default.findDOMNode(_this2);
        if (rootNode && overlayNode && rootNode.offsetWidth > overlayNode.offsetWidth) {
          overlayNode.style.minWidth = rootNode.offsetWidth + 'px';
          if (_this2.trigger && _this2.trigger._component && _this2.trigger._component.alignInstance) {
            _this2.trigger._component.alignInstance.forceAlign();
          }
        }
      }
    };

    this.saveTrigger = function (node) {
      _this2.trigger = node;
    };
  };

  polyfill(Dropdown);



  var es$a = /*#__PURE__*/Object.freeze({
    default: Dropdown
  });

  var _rcDropdown = getCjsExportFromNamespace(es$a);

  var dropdown = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var _rcDropdown2 = _interopRequireDefault(_rcDropdown);



  var _classnames2 = _interopRequireDefault(classnames);



  var _warning2 = _interopRequireDefault(warning$4);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var Dropdown = function (_React$Component) {
      (0, _inherits3['default'])(Dropdown, _React$Component);

      function Dropdown() {
          (0, _classCallCheck3['default'])(this, Dropdown);
          return (0, _possibleConstructorReturn3['default'])(this, (Dropdown.__proto__ || Object.getPrototypeOf(Dropdown)).apply(this, arguments));
      }

      (0, _createClass3['default'])(Dropdown, [{
          key: 'getTransitionName',
          value: function getTransitionName() {
              var _props = this.props,
                  _props$placement = _props.placement,
                  placement = _props$placement === undefined ? '' : _props$placement,
                  transitionName = _props.transitionName;

              if (transitionName !== undefined) {
                  return transitionName;
              }
              if (placement.indexOf('top') >= 0) {
                  return 'slide-down';
              }
              return 'slide-up';
          }
      }, {
          key: 'componentDidMount',
          value: function componentDidMount() {
              var overlay = this.props.overlay;

              var overlayProps = overlay.props;
              (0, _warning2['default'])(!overlayProps.mode || overlayProps.mode === 'vertical', 'mode="' + overlayProps.mode + '" is not supported for Dropdown\'s Menu.');
          }
      }, {
          key: 'render',
          value: function render() {
              var _props2 = this.props,
                  children = _props2.children,
                  prefixCls = _props2.prefixCls,
                  overlayElements = _props2.overlay,
                  trigger = _props2.trigger,
                  disabled = _props2.disabled;

              var child = React.Children.only(children);
              var overlay = React.Children.only(overlayElements);
              var dropdownTrigger = React.cloneElement(child, {
                  className: (0, _classnames2['default'])(child.props.className, prefixCls + '-trigger'),
                  disabled: disabled
              });
              // menu cannot be selectable in dropdown defaultly
              // menu should be focusable in dropdown defaultly
              var _overlay$props = overlay.props,
                  _overlay$props$select = _overlay$props.selectable,
                  selectable = _overlay$props$select === undefined ? false : _overlay$props$select,
                  _overlay$props$focusa = _overlay$props.focusable,
                  focusable = _overlay$props$focusa === undefined ? true : _overlay$props$focusa;

              var fixedModeOverlay = React.cloneElement(overlay, {
                  mode: 'vertical',
                  selectable: selectable,
                  focusable: focusable
              });
              return React.createElement(
                  _rcDropdown2['default'],
                  (0, _extends3['default'])({}, this.props, { transitionName: this.getTransitionName(), trigger: disabled ? [] : trigger, overlay: fixedModeOverlay }),
                  dropdownTrigger
              );
          }
      }]);
      return Dropdown;
  }(React.Component);

  exports['default'] = Dropdown;

  Dropdown.defaultProps = {
      prefixCls: 'ant-dropdown',
      mouseEnterDelay: 0.15,
      mouseLeaveDelay: 0.1,
      placement: 'bottomLeft'
  };
  module.exports = exports['default'];
  });

  unwrapExports(dropdown);

  var dropdownButton = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var _button2 = _interopRequireDefault(button$2);



  var _icon2 = _interopRequireDefault(icon);



  var _dropdown2 = _interopRequireDefault(dropdown);



  var _classnames2 = _interopRequireDefault(classnames);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var __rest = function (s, e) {
      var t = {};
      for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      }if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
      }return t;
  };

  var ButtonGroup = _button2['default'].Group;

  var DropdownButton = function (_React$Component) {
      (0, _inherits3['default'])(DropdownButton, _React$Component);

      function DropdownButton() {
          (0, _classCallCheck3['default'])(this, DropdownButton);
          return (0, _possibleConstructorReturn3['default'])(this, (DropdownButton.__proto__ || Object.getPrototypeOf(DropdownButton)).apply(this, arguments));
      }

      (0, _createClass3['default'])(DropdownButton, [{
          key: 'render',
          value: function render() {
              var _a = this.props,
                  type = _a.type,
                  disabled = _a.disabled,
                  onClick = _a.onClick,
                  children = _a.children,
                  prefixCls = _a.prefixCls,
                  className = _a.className,
                  overlay = _a.overlay,
                  trigger = _a.trigger,
                  align = _a.align,
                  visible = _a.visible,
                  onVisibleChange = _a.onVisibleChange,
                  placement = _a.placement,
                  getPopupContainer = _a.getPopupContainer,
                  restProps = __rest(_a, ["type", "disabled", "onClick", "children", "prefixCls", "className", "overlay", "trigger", "align", "visible", "onVisibleChange", "placement", "getPopupContainer"]);
              var dropdownProps = {
                  align: align,
                  overlay: overlay,
                  disabled: disabled,
                  trigger: disabled ? [] : trigger,
                  onVisibleChange: onVisibleChange,
                  placement: placement,
                  getPopupContainer: getPopupContainer
              };
              if ('visible' in this.props) {
                  dropdownProps.visible = visible;
              }
              return React.createElement(
                  ButtonGroup,
                  (0, _extends3['default'])({}, restProps, { className: (0, _classnames2['default'])(prefixCls, className) }),
                  React.createElement(
                      _button2['default'],
                      { type: type, disabled: disabled, onClick: onClick },
                      children
                  ),
                  React.createElement(
                      _dropdown2['default'],
                      dropdownProps,
                      React.createElement(
                          _button2['default'],
                          { type: type },
                          React.createElement(_icon2['default'], { type: 'down' })
                      )
                  )
              );
          }
      }]);
      return DropdownButton;
  }(React.Component);

  exports['default'] = DropdownButton;

  DropdownButton.defaultProps = {
      placement: 'bottomRight',
      type: 'default',
      prefixCls: 'ant-dropdown-button'
  };
  module.exports = exports['default'];
  });

  unwrapExports(dropdownButton);

  var dropdown$2 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _dropdown2 = _interopRequireDefault(dropdown);



  var _dropdownButton2 = _interopRequireDefault(dropdownButton);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  _dropdown2['default'].Button = _dropdownButton2['default'];
  exports['default'] = _dropdown2['default'];
  module.exports = exports['default'];
  });

  var Dropdown$1 = unwrapExports(dropdown$2);

  var LazyRenderBox$1 = function (_React$Component) {
      _inherits$1(LazyRenderBox, _React$Component);

      function LazyRenderBox() {
          _classCallCheck$1(this, LazyRenderBox);

          return _possibleConstructorReturn$1(this, _React$Component.apply(this, arguments));
      }

      LazyRenderBox.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
          return !!nextProps.hiddenClassName || !!nextProps.visible;
      };

      LazyRenderBox.prototype.render = function render() {
          var className = this.props.className;
          if (!!this.props.hiddenClassName && !this.props.visible) {
              className += " " + this.props.hiddenClassName;
          }
          var props = _extends$2({}, this.props);
          delete props.hiddenClassName;
          delete props.visible;
          props.className = className;
          return React$1.createElement("div", _extends$2({}, props));
      };

      return LazyRenderBox;
  }(React$1.Component);

  var cached = void 0;

  function getScrollBarSize(fresh) {
    if (fresh || cached === undefined) {
      var inner = document.createElement('div');
      inner.style.width = '100%';
      inner.style.height = '200px';

      var outer = document.createElement('div');
      var outerStyle = outer.style;

      outerStyle.position = 'absolute';
      outerStyle.top = 0;
      outerStyle.left = 0;
      outerStyle.pointerEvents = 'none';
      outerStyle.visibility = 'hidden';
      outerStyle.width = '200px';
      outerStyle.height = '150px';
      outerStyle.overflow = 'hidden';

      outer.appendChild(inner);

      document.body.appendChild(outer);

      var widthContained = inner.offsetWidth;
      outer.style.overflow = 'scroll';
      var widthScroll = inner.offsetWidth;

      if (widthContained === widthScroll) {
        widthScroll = outer.clientWidth;
      }

      document.body.removeChild(outer);

      cached = widthContained - widthScroll;
    }
    return cached;
  }

  var uuid = 0;
  var openCount = 0;
  /* eslint react/no-is-mounted:0 */
  function getScroll$2(w, top) {
      var ret = w['page' + (top ? 'Y' : 'X') + 'Offset'];
      var method = 'scroll' + (top ? 'Top' : 'Left');
      if (typeof ret !== 'number') {
          var d = w.document;
          ret = d.documentElement[method];
          if (typeof ret !== 'number') {
              ret = d.body[method];
          }
      }
      return ret;
  }
  function setTransformOrigin(node, value) {
      var style = node.style;
      ['Webkit', 'Moz', 'Ms', 'ms'].forEach(function (prefix) {
          style[prefix + 'TransformOrigin'] = value;
      });
      style['transformOrigin'] = value;
  }
  function offset(el) {
      var rect = el.getBoundingClientRect();
      var pos = {
          left: rect.left,
          top: rect.top
      };
      var doc = el.ownerDocument;
      var w = doc.defaultView || doc.parentWindow;
      pos.left += getScroll$2(w);
      pos.top += getScroll$2(w, true);
      return pos;
  }

  var Dialog = function (_React$Component) {
      _inherits$1(Dialog, _React$Component);

      function Dialog() {
          _classCallCheck$1(this, Dialog);

          var _this = _possibleConstructorReturn$1(this, _React$Component.apply(this, arguments));

          _this.onAnimateLeave = function () {
              var afterClose = _this.props.afterClose;
              // need demo?
              // https://github.com/react-component/dialog/pull/28

              if (_this.wrap) {
                  _this.wrap.style.display = 'none';
              }
              _this.inTransition = false;
              _this.removeScrollingEffect();
              if (afterClose) {
                  afterClose();
              }
          };
          _this.onMaskClick = function (e) {
              // android trigger click on open (fastclick??)
              if (Date.now() - _this.openTime < 300) {
                  return;
              }
              if (e.target === e.currentTarget) {
                  _this.close(e);
              }
          };
          _this.onKeyDown = function (e) {
              var props = _this.props;
              if (props.keyboard && e.keyCode === KeyCode.ESC) {
                  e.stopPropagation();
                  _this.close(e);
                  return;
              }
              // keep focus inside dialog
              if (props.visible) {
                  if (e.keyCode === KeyCode.TAB) {
                      var activeElement = document.activeElement;
                      var dialogRoot = _this.wrap;
                      if (e.shiftKey) {
                          if (activeElement === dialogRoot) {
                              _this.sentinel.focus();
                          }
                      } else if (activeElement === _this.sentinel) {
                          dialogRoot.focus();
                      }
                  }
              }
          };
          _this.getDialogElement = function () {
              var props = _this.props;
              var closable = props.closable;
              var prefixCls = props.prefixCls;
              var dest = {};
              if (props.width !== undefined) {
                  dest.width = props.width;
              }
              if (props.height !== undefined) {
                  dest.height = props.height;
              }
              var footer = void 0;
              if (props.footer) {
                  footer = React$1.createElement("div", { className: prefixCls + '-footer', ref: _this.saveRef('footer') }, props.footer);
              }
              var header = void 0;
              if (props.title) {
                  header = React$1.createElement("div", { className: prefixCls + '-header', ref: _this.saveRef('header') }, React$1.createElement("div", { className: prefixCls + '-title', id: _this.titleId }, props.title));
              }
              var closer = void 0;
              if (closable) {
                  closer = React$1.createElement("button", { onClick: _this.close, "aria-label": "Close", className: prefixCls + '-close' }, React$1.createElement("span", { className: prefixCls + '-close-x' }));
              }
              var style = _extends$2({}, props.style, dest);
              var transitionName = _this.getTransitionName();
              var dialogElement = React$1.createElement(LazyRenderBox$1, { key: "dialog-element", role: "document", ref: _this.saveRef('dialog'), style: style, className: prefixCls + ' ' + (props.className || ''), visible: props.visible }, React$1.createElement("div", { className: prefixCls + '-content' }, closer, header, React$1.createElement("div", _extends$2({ className: prefixCls + '-body', style: props.bodyStyle, ref: _this.saveRef('body') }, props.bodyProps), props.children), footer), React$1.createElement("div", { tabIndex: 0, ref: _this.saveRef('sentinel'), style: { width: 0, height: 0, overflow: 'hidden' } }, "sentinel"));
              return React$1.createElement(Animate, { key: "dialog", showProp: "visible", onLeave: _this.onAnimateLeave, transitionName: transitionName, component: "", transitionAppear: true }, props.visible || !props.destroyOnClose ? dialogElement : null);
          };
          _this.getZIndexStyle = function () {
              var style = {};
              var props = _this.props;
              if (props.zIndex !== undefined) {
                  style.zIndex = props.zIndex;
              }
              return style;
          };
          _this.getWrapStyle = function () {
              return _extends$2({}, _this.getZIndexStyle(), _this.props.wrapStyle);
          };
          _this.getMaskStyle = function () {
              return _extends$2({}, _this.getZIndexStyle(), _this.props.maskStyle);
          };
          _this.getMaskElement = function () {
              var props = _this.props;
              var maskElement = void 0;
              if (props.mask) {
                  var maskTransition = _this.getMaskTransitionName();
                  maskElement = React$1.createElement(LazyRenderBox$1, _extends$2({ style: _this.getMaskStyle(), key: "mask", className: props.prefixCls + '-mask', hiddenClassName: props.prefixCls + '-mask-hidden', visible: props.visible }, props.maskProps));
                  if (maskTransition) {
                      maskElement = React$1.createElement(Animate, { key: "mask", showProp: "visible", transitionAppear: true, component: "", transitionName: maskTransition }, maskElement);
                  }
              }
              return maskElement;
          };
          _this.getMaskTransitionName = function () {
              var props = _this.props;
              var transitionName = props.maskTransitionName;
              var animation = props.maskAnimation;
              if (!transitionName && animation) {
                  transitionName = props.prefixCls + '-' + animation;
              }
              return transitionName;
          };
          _this.getTransitionName = function () {
              var props = _this.props;
              var transitionName = props.transitionName;
              var animation = props.animation;
              if (!transitionName && animation) {
                  transitionName = props.prefixCls + '-' + animation;
              }
              return transitionName;
          };
          _this.setScrollbar = function () {
              if (_this.bodyIsOverflowing && _this.scrollbarWidth !== undefined) {
                  document.body.style.paddingRight = _this.scrollbarWidth + 'px';
              }
          };
          _this.addScrollingEffect = function () {
              openCount++;
              if (openCount !== 1) {
                  return;
              }
              _this.checkScrollbar();
              _this.setScrollbar();
              document.body.style.overflow = 'hidden';
              // this.adjustDialog();
          };
          _this.removeScrollingEffect = function () {
              openCount--;
              if (openCount !== 0) {
                  return;
              }
              document.body.style.overflow = '';
              _this.resetScrollbar();
              // this.resetAdjustments();
          };
          _this.close = function (e) {
              var onClose = _this.props.onClose;

              if (onClose) {
                  onClose(e);
              }
          };
          _this.checkScrollbar = function () {
              var fullWindowWidth = window.innerWidth;
              if (!fullWindowWidth) {
                  // workaround for missing window.innerWidth in IE8
                  var documentElementRect = document.documentElement.getBoundingClientRect();
                  fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);
              }
              _this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;
              if (_this.bodyIsOverflowing) {
                  _this.scrollbarWidth = getScrollBarSize();
              }
          };
          _this.resetScrollbar = function () {
              document.body.style.paddingRight = '';
          };
          _this.adjustDialog = function () {
              if (_this.wrap && _this.scrollbarWidth !== undefined) {
                  var modalIsOverflowing = _this.wrap.scrollHeight > document.documentElement.clientHeight;
                  _this.wrap.style.paddingLeft = (!_this.bodyIsOverflowing && modalIsOverflowing ? _this.scrollbarWidth : '') + 'px';
                  _this.wrap.style.paddingRight = (_this.bodyIsOverflowing && !modalIsOverflowing ? _this.scrollbarWidth : '') + 'px';
              }
          };
          _this.resetAdjustments = function () {
              if (_this.wrap) {
                  _this.wrap.style.paddingLeft = _this.wrap.style.paddingLeft = '';
              }
          };
          _this.saveRef = function (name) {
              return function (node) {
                  _this[name] = node;
              };
          };
          return _this;
      }

      Dialog.prototype.componentWillMount = function componentWillMount() {
          this.inTransition = false;
          this.titleId = 'rcDialogTitle' + uuid++;
      };

      Dialog.prototype.componentDidMount = function componentDidMount() {
          this.componentDidUpdate({});
      };

      Dialog.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
          var props = this.props;
          var mousePosition = this.props.mousePosition;
          if (props.visible) {
              // first show
              if (!prevProps.visible) {
                  this.openTime = Date.now();
                  this.addScrollingEffect();
                  this.tryFocus();
                  var dialogNode = ReactDOM.findDOMNode(this.dialog);
                  if (mousePosition) {
                      var elOffset = offset(dialogNode);
                      setTransformOrigin(dialogNode, mousePosition.x - elOffset.left + 'px ' + (mousePosition.y - elOffset.top) + 'px');
                  } else {
                      setTransformOrigin(dialogNode, '');
                  }
              }
          } else if (prevProps.visible) {
              this.inTransition = true;
              if (props.mask && this.lastOutSideFocusNode) {
                  try {
                      this.lastOutSideFocusNode.focus();
                  } catch (e) {
                      this.lastOutSideFocusNode = null;
                  }
                  this.lastOutSideFocusNode = null;
              }
          }
      };

      Dialog.prototype.componentWillUnmount = function componentWillUnmount() {
          if (this.props.visible || this.inTransition) {
              this.removeScrollingEffect();
          }
      };

      Dialog.prototype.tryFocus = function tryFocus() {
          if (!contains(this.wrap, document.activeElement)) {
              this.lastOutSideFocusNode = document.activeElement;
              this.wrap.focus();
          }
      };

      Dialog.prototype.render = function render() {
          var props = this.props;
          var prefixCls = props.prefixCls,
              maskClosable = props.maskClosable;

          var style = this.getWrapStyle();
          // clear hide display
          // and only set display after async anim, not here for hide
          if (props.visible) {
              style.display = null;
          }
          return React$1.createElement("div", null, this.getMaskElement(), React$1.createElement("div", _extends$2({ tabIndex: -1, onKeyDown: this.onKeyDown, className: prefixCls + '-wrap ' + (props.wrapClassName || ''), ref: this.saveRef('wrap'), onClick: maskClosable ? this.onMaskClick : undefined, role: "dialog", "aria-labelledby": props.title ? this.titleId : null, style: style }, props.wrapProps), this.getDialogElement()));
      };

      return Dialog;
  }(React$1.Component);

  Dialog.defaultProps = {
      className: '',
      mask: true,
      visible: false,
      keyboard: true,
      closable: true,
      maskClosable: true,
      destroyOnClose: false,
      prefixCls: 'rc-dialog'
  };

  var IS_REACT_16$1 = 'createPortal' in ReactDOM;

  var DialogWrap = function (_React$Component) {
      _inherits$1(DialogWrap, _React$Component);

      function DialogWrap() {
          _classCallCheck$1(this, DialogWrap);

          var _this = _possibleConstructorReturn$1(this, _React$Component.apply(this, arguments));

          _this.saveDialog = function (node) {
              _this._component = node;
          };
          _this.getComponent = function () {
              var extra = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              return React$1.createElement(Dialog, _extends$2({ ref: _this.saveDialog }, _this.props, extra, { key: "dialog" }));
          };
          // fix issue #10656
          /*
          * Custom container should not be return, because in the Portal component, it will remove the
          * return container element here, if the custom container is the only child of it's component,
          * like issue #10656, It will has a conflict with removeChild method in react-dom.
          * So here should add a child (div element) to custom container.
          * */
          _this.getContainer = function () {
              var container = document.createElement('div');
              if (_this.props.getContainer) {
                  _this.props.getContainer().appendChild(container);
              } else {
                  document.body.appendChild(container);
              }
              return container;
          };
          return _this;
      }

      DialogWrap.prototype.shouldComponentUpdate = function shouldComponentUpdate(_ref) {
          var visible = _ref.visible;

          return !!(this.props.visible || visible);
      };

      DialogWrap.prototype.componentWillUnmount = function componentWillUnmount() {
          if (IS_REACT_16$1) {
              return;
          }
          if (this.props.visible) {
              this.renderComponent({
                  afterClose: this.removeContainer,
                  onClose: function onClose() {},

                  visible: false
              });
          } else {
              this.removeContainer();
          }
      };

      DialogWrap.prototype.render = function render() {
          var _this2 = this;

          var visible = this.props.visible;

          var portal = null;
          if (!IS_REACT_16$1) {
              return React$1.createElement(ContainerRender, { parent: this, visible: visible, autoDestroy: false, getComponent: this.getComponent, getContainer: this.getContainer }, function (_ref2) {
                  var renderComponent = _ref2.renderComponent,
                      removeContainer = _ref2.removeContainer;

                  _this2.renderComponent = renderComponent;
                  _this2.removeContainer = removeContainer;
                  return null;
              });
          }
          if (visible || this._component) {
              portal = React$1.createElement(Portal, { getContainer: this.getContainer }, this.getComponent());
          }
          return portal;
      };

      return DialogWrap;
  }(React$1.Component);

  DialogWrap.defaultProps = {
      visible: false
  };

  var DialogWrap$1 = /*#__PURE__*/Object.freeze({
    default: DialogWrap
  });

  var addEventListener$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports['default'] = addEventListenerWrap;



  var _addDomEventListener2 = _interopRequireDefault(lib$2);



  var _reactDom2 = _interopRequireDefault(ReactDOM__default);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function addEventListenerWrap(target, eventType, cb, option) {
    /* eslint camelcase: 2 */
    var callback = _reactDom2['default'].unstable_batchedUpdates ? function run(e) {
      _reactDom2['default'].unstable_batchedUpdates(cb, e);
    } : cb;
    return (0, _addDomEventListener2['default'])(target, eventType, callback, option);
  }
  module.exports = exports['default'];
  });

  unwrapExports(addEventListener$1);

  var locale = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);

  exports.changeConfirmLocale = changeConfirmLocale;
  exports.getConfirmLocale = getConfirmLocale;



  var _default2 = _interopRequireDefault(_default);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var runtimeLocale = (0, _extends3['default'])({}, _default2['default'].Modal);
  function changeConfirmLocale(newLocale) {
      if (newLocale) {
          runtimeLocale = (0, _extends3['default'])({}, runtimeLocale, newLocale);
      } else {
          runtimeLocale = (0, _extends3['default'])({}, _default2['default'].Modal);
      }
  }
  function getConfirmLocale() {
      return runtimeLocale;
  }
  });

  unwrapExports(locale);
  var locale_1 = locale.changeConfirmLocale;
  var locale_2 = locale.getConfirmLocale;

  var _rcDialog = getCjsExportFromNamespace(DialogWrap$1);

  var Modal_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var _rcDialog2 = _interopRequireDefault(_rcDialog);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _addEventListener2 = _interopRequireDefault(addEventListener$1);



  var _button2 = _interopRequireDefault(button$2);



  var _LocaleReceiver2 = _interopRequireDefault(LocaleReceiver_1);



  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var mousePosition = void 0;
  var mousePositionEventBinded = void 0;

  var Modal = function (_React$Component) {
      (0, _inherits3['default'])(Modal, _React$Component);

      function Modal() {
          (0, _classCallCheck3['default'])(this, Modal);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (Modal.__proto__ || Object.getPrototypeOf(Modal)).apply(this, arguments));

          _this.handleCancel = function (e) {
              var onCancel = _this.props.onCancel;
              if (onCancel) {
                  onCancel(e);
              }
          };
          _this.handleOk = function (e) {
              var onOk = _this.props.onOk;
              if (onOk) {
                  onOk(e);
              }
          };
          _this.renderFooter = function (locale$$1) {
              var _this$props = _this.props,
                  okText = _this$props.okText,
                  okType = _this$props.okType,
                  cancelText = _this$props.cancelText,
                  confirmLoading = _this$props.confirmLoading;

              return React.createElement(
                  'div',
                  null,
                  React.createElement(
                      _button2['default'],
                      { onClick: _this.handleCancel },
                      cancelText || locale$$1.cancelText
                  ),
                  React.createElement(
                      _button2['default'],
                      { type: okType, loading: confirmLoading, onClick: _this.handleOk },
                      okText || locale$$1.okText
                  )
              );
          };
          return _this;
      }

      (0, _createClass3['default'])(Modal, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              if (mousePositionEventBinded) {
                  return;
              }
              // 只有点击事件支持从鼠标位置动画展开
              (0, _addEventListener2['default'])(document.documentElement, 'click', function (e) {
                  mousePosition = {
                      x: e.pageX,
                      y: e.pageY
                  };
                  // 100ms 内发生过点击事件，则从点击位置动画展示
                  // 否则直接 zoom 展示
                  // 这样可以兼容非点击方式展开
                  setTimeout(function () {
                      return mousePosition = null;
                  }, 100);
              });
              mousePositionEventBinded = true;
          }
      }, {
          key: 'render',
          value: function render() {
              var _props = this.props,
                  footer = _props.footer,
                  visible = _props.visible;

              var defaultFooter = React.createElement(
                  _LocaleReceiver2['default'],
                  { componentName: 'Modal', defaultLocale: (0, locale.getConfirmLocale)() },
                  this.renderFooter
              );
              return React.createElement(_rcDialog2['default'], (0, _extends3['default'])({}, this.props, { footer: footer === undefined ? defaultFooter : footer, visible: visible, mousePosition: mousePosition, onClose: this.handleCancel }));
          }
      }]);
      return Modal;
  }(React.Component);

  exports['default'] = Modal;

  Modal.defaultProps = {
      prefixCls: 'ant-modal',
      width: 520,
      transitionName: 'zoom',
      maskTransitionName: 'fade',
      confirmLoading: false,
      visible: false,
      okType: 'primary'
  };
  Modal.propTypes = {
      prefixCls: _propTypes2['default'].string,
      onOk: _propTypes2['default'].func,
      onCancel: _propTypes2['default'].func,
      okText: _propTypes2['default'].node,
      cancelText: _propTypes2['default'].node,
      width: _propTypes2['default'].oneOfType([_propTypes2['default'].number, _propTypes2['default'].string]),
      confirmLoading: _propTypes2['default'].bool,
      visible: _propTypes2['default'].bool,
      align: _propTypes2['default'].object,
      footer: _propTypes2['default'].node,
      title: _propTypes2['default'].node,
      closable: _propTypes2['default'].bool
  };
  module.exports = exports['default'];
  });

  unwrapExports(Modal_1);

  var ActionButton_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var ReactDOM$$1 = _interopRequireWildcard(ReactDOM__default);



  var _button2 = _interopRequireDefault(button$2);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var ActionButton = function (_React$Component) {
      (0, _inherits3['default'])(ActionButton, _React$Component);

      function ActionButton(props) {
          (0, _classCallCheck3['default'])(this, ActionButton);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (ActionButton.__proto__ || Object.getPrototypeOf(ActionButton)).call(this, props));

          _this.onClick = function () {
              var _this$props = _this.props,
                  actionFn = _this$props.actionFn,
                  closeModal = _this$props.closeModal;

              if (actionFn) {
                  var ret = void 0;
                  if (actionFn.length) {
                      ret = actionFn(closeModal);
                  } else {
                      ret = actionFn();
                      if (!ret) {
                          closeModal();
                      }
                  }
                  if (ret && ret.then) {
                      _this.setState({ loading: true });
                      ret.then(function () {
                          // It's unnecessary to set loading=false, for the Modal will be unmounted after close.
                          // this.setState({ loading: false });
                          closeModal.apply(undefined, arguments);
                      }, function () {
                          // See: https://github.com/ant-design/ant-design/issues/6183
                          _this.setState({ loading: false });
                      });
                  }
              } else {
                  closeModal();
              }
          };
          _this.state = {
              loading: false
          };
          return _this;
      }

      (0, _createClass3['default'])(ActionButton, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              if (this.props.autoFocus) {
                  var $this = ReactDOM$$1.findDOMNode(this);
                  this.timeoutId = setTimeout(function () {
                      return $this.focus();
                  });
              }
          }
      }, {
          key: 'componentWillUnmount',
          value: function componentWillUnmount() {
              clearTimeout(this.timeoutId);
          }
      }, {
          key: 'render',
          value: function render() {
              var _props = this.props,
                  type = _props.type,
                  children = _props.children;

              var loading = this.state.loading;
              return React.createElement(
                  _button2['default'],
                  { type: type, onClick: this.onClick, loading: loading },
                  children
              );
          }
      }]);
      return ActionButton;
  }(React.Component);

  exports['default'] = ActionButton;
  module.exports = exports['default'];
  });

  unwrapExports(ActionButton_1);

  var confirm_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);

  exports['default'] = confirm;



  var React = _interopRequireWildcard(React$1__default);



  var ReactDOM$$1 = _interopRequireWildcard(ReactDOM__default);



  var _classnames2 = _interopRequireDefault(classnames);



  var _icon2 = _interopRequireDefault(icon);



  var _Modal2 = _interopRequireDefault(Modal_1);



  var _ActionButton2 = _interopRequireDefault(ActionButton_1);



  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var IS_REACT_16 = !!ReactDOM$$1.createPortal;
  var ConfirmDialog = function ConfirmDialog(props) {
      var onCancel = props.onCancel,
          onOk = props.onOk,
          close = props.close,
          zIndex = props.zIndex,
          afterClose = props.afterClose,
          visible = props.visible,
          keyboard = props.keyboard;

      var iconType = props.iconType || 'question-circle';
      var okType = props.okType || 'primary';
      var prefixCls = props.prefixCls || 'ant-confirm';
      // 默认为 true，保持向下兼容
      var okCancel = 'okCancel' in props ? props.okCancel : true;
      var width = props.width || 416;
      var style = props.style || {};
      // 默认为 false，保持旧版默认行为
      var maskClosable = props.maskClosable === undefined ? false : props.maskClosable;
      var runtimeLocale = (0, locale.getConfirmLocale)();
      var okText = props.okText || (okCancel ? runtimeLocale.okText : runtimeLocale.justOkText);
      var cancelText = props.cancelText || runtimeLocale.cancelText;
      var classString = (0, _classnames2['default'])(prefixCls, prefixCls + '-' + props.type, props.className);
      var cancelButton = okCancel && React.createElement(
          _ActionButton2['default'],
          { actionFn: onCancel, closeModal: close },
          cancelText
      );
      return React.createElement(
          _Modal2['default'],
          { className: classString, onCancel: close.bind(undefined, { triggerCancel: true }), visible: visible, title: '', transitionName: 'zoom', footer: '', maskTransitionName: 'fade', maskClosable: maskClosable, style: style, width: width, zIndex: zIndex, afterClose: afterClose, keyboard: keyboard },
          React.createElement(
              'div',
              { className: prefixCls + '-body-wrapper' },
              React.createElement(
                  'div',
                  { className: prefixCls + '-body' },
                  React.createElement(_icon2['default'], { type: iconType }),
                  React.createElement(
                      'span',
                      { className: prefixCls + '-title' },
                      props.title
                  ),
                  React.createElement(
                      'div',
                      { className: prefixCls + '-content' },
                      props.content
                  )
              ),
              React.createElement(
                  'div',
                  { className: prefixCls + '-btns' },
                  cancelButton,
                  React.createElement(
                      _ActionButton2['default'],
                      { type: okType, actionFn: onOk, closeModal: close, autoFocus: true },
                      okText
                  )
              )
          )
      );
  };
  function confirm(config) {
      var div = document.createElement('div');
      document.body.appendChild(div);
      function close() {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
          }

          if (IS_REACT_16) {
              render((0, _extends3['default'])({}, config, { close: close, visible: false, afterClose: destroy.bind.apply(destroy, [this].concat(args)) }));
          } else {
              destroy.apply(undefined, args);
          }
      }
      function destroy() {
          var unmountResult = ReactDOM$$1.unmountComponentAtNode(div);
          if (unmountResult && div.parentNode) {
              div.parentNode.removeChild(div);
          }

          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
          }

          var triggerCancel = args && args.length && args.some(function (param) {
              return param && param.triggerCancel;
          });
          if (config.onCancel && triggerCancel) {
              config.onCancel.apply(config, args);
          }
      }
      function render(props) {
          ReactDOM$$1.render(React.createElement(ConfirmDialog, props), div);
      }
      render((0, _extends3['default'])({}, config, { visible: true, close: close }));
      return {
          destroy: close
      };
  }
  module.exports = exports['default'];
  });

  unwrapExports(confirm_1);

  var modal = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _Modal2 = _interopRequireDefault(Modal_1);



  var _confirm2 = _interopRequireDefault(confirm_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  _Modal2['default'].info = function (props) {
      var config = (0, _extends3['default'])({ type: 'info', iconType: 'info-circle', okCancel: false }, props);
      return (0, _confirm2['default'])(config);
  };
  _Modal2['default'].success = function (props) {
      var config = (0, _extends3['default'])({ type: 'success', iconType: 'check-circle', okCancel: false }, props);
      return (0, _confirm2['default'])(config);
  };
  _Modal2['default'].error = function (props) {
      var config = (0, _extends3['default'])({ type: 'error', iconType: 'cross-circle', okCancel: false }, props);
      return (0, _confirm2['default'])(config);
  };
  _Modal2['default'].warning = _Modal2['default'].warn = function (props) {
      var config = (0, _extends3['default'])({ type: 'warning', iconType: 'exclamation-circle', okCancel: false }, props);
      return (0, _confirm2['default'])(config);
  };
  _Modal2['default'].confirm = function (props) {
      var config = (0, _extends3['default'])({ type: 'confirm', okCancel: true }, props);
      return (0, _confirm2['default'])(config);
  };
  exports['default'] = _Modal2['default'];
  module.exports = exports['default'];
  });

  var Modal$1 = unwrapExports(modal);

  var css$3 = ".button-groups .ant-btn-group > span {\n  vertical-align: top;\n}\n";
  styleInject(css$3);

  /*
  *children 1个 多个数据格式处理
  *
  */

  var Confirm =
  /*#__PURE__*/
  function (_Component) {
    _inherits(Confirm, _Component);

    function Confirm() {
      _classCallCheck(this, Confirm);

      return _possibleConstructorReturn(this, _getPrototypeOf(Confirm).apply(this, arguments));
    }

    _createClass(Confirm, [{
      key: "onConfirmClick",
      value: function onConfirmClick() {
        var _this$props = this.props,
            onConfirm = _this$props.onConfirm,
            title = _this$props.title,
            content = _this$props.content;
        return Modal$1.confirm({
          title: title || "确认框",
          content: content,
          okText: '确认',
          onOk: onConfirm,
          cancelText: '取消'
        });
      }
    }, {
      key: "render",
      value: function render() {
        var children = this.props.children;
        return React$1__default.cloneElement(children, {
          onClick: this.onConfirmClick.bind(this)
        });
      }
    }]);

    return Confirm;
  }(React$1.Component);

  var ButtonGroups =
  /*#__PURE__*/
  function (_Component2) {
    _inherits(ButtonGroups, _Component2);

    function ButtonGroups() {
      _classCallCheck(this, ButtonGroups);

      return _possibleConstructorReturn(this, _getPrototypeOf(ButtonGroups).apply(this, arguments));
    }

    _createClass(ButtonGroups, [{
      key: "renderButtonOnly",
      value: function renderButtonOnly() {
        var _this = this;

        var children = this.props.children;
        var childrenArray = React$1__default.Children.toArray(children); // let {appReducer} = this.context
        // console.log(this.context.appReducer)

        return childrenArray.filter(function (it) {
          if (it.props.permission === undefined) {
            return true;
          } else {
            return it.props.permission && it.props.permission === true;
          }
        }).map(function (it, idx) {
          return _this.renderReactElement(it, idx);
        });
      }
    }, {
      key: "renderReactElement",
      value: function renderReactElement(it, idx) {
        var handleClick = this.props.handleClick;

        var _it$props = it.props,
            tip = _it$props.tip,
            confirm = _it$props.confirm,
            placement = _it$props.placement,
            children = _it$props.children,
            block = _it$props.block,
            actionkey = _it$props.actionkey,
            disabled = _it$props.disabled,
            permission = _it$props.permission,
            otherProps = _objectWithoutProperties(_it$props, ["tip", "confirm", "placement", "children", "block", "actionkey", "disabled", "permission"]);

        if (confirm && !disabled) {
          return React$1__default.createElement(Confirm, Object.assign({}, {
            key: idx,
            title: "确认框",
            content: confirm,
            placement: placement,
            onConfirm: function onConfirm() {
              handleClick(actionkey);
            }
          }), React$1__default.createElement(Tooltip$1, Object.assign({}, {
            key: idx,
            title: tip
          }), React$1__default.createElement(Button, Object.assign({
            actionkey: actionkey,
            disabled: disabled
          }, otherProps), children)));
        } else {
          return React$1__default.createElement(Tooltip$1, Object.assign({}, {
            key: idx,
            title: tip
          }), React$1__default.createElement(Button, Object.assign({
            actionkey: actionkey,
            disabled: disabled
          }, otherProps, !disabled ? {
            onClick: function onClick() {
              handleClick(actionkey);
            }
          } : {}), children));
        }
      } // return

    }, {
      key: "renderMenuReactElement",
      value: function renderMenuReactElement(it, idx) {
        var _it$props2 = it.props,
            tip = _it$props2.tip,
            children = _it$props2.children;
        return React$1__default.createElement(Tooltip$1, Object.assign({}, {
          key: idx,
          title: tip
        }), React$1__default.cloneElement(it, Object.assign({}, it.props), children));
      }
    }, {
      key: "renderMixButtonMenu",
      value: function renderMixButtonMenu() {
        var _this2 = this;

        var _this$props2 = this.props,
            children = _this$props2.children,
            showSize = _this$props2.showSize;
        var childrenArray = React$1__default.Children.toArray(children);
        var endArray = childrenArray.splice(showSize);
        return React$1__default.createElement("div", null, childrenArray // .filter((it)=>{
        //   console.log(it.props.permission)
        //   return it.props.permission==true
        // })
        .map(function (it, idx) {
          return _this2.renderReactElement(it, idx);
        }), React$1__default.createElement(Dropdown$1, {
          overlay: this.renderMenuItem(endArray)
        }, React$1__default.createElement(Button, null, React$1__default.createElement(Icon, {
          type: "ellipsis"
        }))));
      }
    }, {
      key: "renderMenuItem",
      value: function renderMenuItem(itemList) {
        var _this3 = this;

        var handleClick = this.props.handleClick;
        return React$1__default.createElement(Menu$2, {
          onClick: handleClick
        }, itemList.map(function (it, idx) {
          return React$1__default.createElement(Menu$2.Item, {
            key: idx
          }, _this3.renderMenuReactElement(it, idx));
        }));
      }
    }, {
      key: "renderChildren",
      value: function renderChildren() {
        var _this$props3 = this.props,
            children = _this$props3.children,
            showSize = _this$props3.showSize,
            mode = _this$props3.mode;
        var childrenArray = React$1__default.Children.toArray(children);
        return React$1__default.createElement(Button.Group, null, mode === 'ButtonGroup' ? this.renderButtonOnly() : this.renderMixButtonMenu());
      }
    }, {
      key: "render",
      value: function render() {
        return React$1__default.createElement("div", {
          className: "button-groups"
        }, this.renderChildren());
      }
    }]);

    return ButtonGroups;
  }(React$1.Component);
  /*
  * showSize:超过收起的数目
  * handleClick : 点击事件（需子元素以actionKey区分）
  * 子元素如需confirm确认 子元素自身添加confirm 属性 value为提醒文字
  * tip 为元素上移显示文字
  */


  _defineProperty(ButtonGroups, "contextTypes", {// appReducer:PropTypes.object
  });
  ButtonGroups.propTypes = {
    showSize: PropTypes.number,
    handleClick: PropTypes.func,
    mode: PropTypes.oneOf(['ButtonGroup', 'ButtonMenu'])
  };
  ButtonGroups.defaultProps = {
    showSize: 5,
    handleClick: function handleClick(actionkey) {},
    mode: 'ButtonGroup'
  };

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear() {
    this.__data__ = new _ListCache;
    this.size = 0;
  }

  var _stackClear = stackClear;

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);

    this.size = data.size;
    return result;
  }

  var _stackDelete = stackDelete;

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  var _stackGet = stackGet;

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  var _stackHas = stackHas;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof _ListCache) {
      var pairs = data.__data__;
      if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new _MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }

  var _stackSet = stackSet;

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack(entries) {
    var data = this.__data__ = new _ListCache(entries);
    this.size = data.size;
  }

  // Add methods to `Stack`.
  Stack.prototype.clear = _stackClear;
  Stack.prototype['delete'] = _stackDelete;
  Stack.prototype.get = _stackGet;
  Stack.prototype.has = _stackHas;
  Stack.prototype.set = _stackSet;

  var _Stack = Stack;

  /**
   * This function is like `assignValue` except that it doesn't assign
   * `undefined` values.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignMergeValue(object, key, value) {
    if ((value !== undefined && !eq_1(object[key], value)) ||
        (value === undefined && !(key in object))) {
      _baseAssignValue(object, key, value);
    }
  }

  var _assignMergeValue = assignMergeValue;

  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }

  var _createBaseFor = createBaseFor;

  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */
  var baseFor = _createBaseFor();

  var _baseFor = baseFor;

  var _cloneBuffer = createCommonjsModule(function (module, exports) {
  /** Detect free variable `exports`. */
  var freeExports = exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Built-in value references. */
  var Buffer = moduleExports ? _root.Buffer : undefined,
      allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length,
        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

    buffer.copy(result);
    return result;
  }

  module.exports = cloneBuffer;
  });

  /** Built-in value references. */
  var Uint8Array = _root.Uint8Array;

  var _Uint8Array = Uint8Array;

  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
    return result;
  }

  var _cloneArrayBuffer = cloneArrayBuffer;

  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  var _cloneTypedArray = cloneTypedArray;

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray(source, array) {
    var index = -1,
        length = source.length;

    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }

  var _copyArray = copyArray;

  /** Built-in value references. */
  var objectCreate = Object.create;

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} proto The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  var baseCreate = (function() {
    function object() {}
    return function(proto) {
      if (!isObject_1(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object;
      object.prototype = undefined;
      return result;
    };
  }());

  var _baseCreate = baseCreate;

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  var _overArg = overArg;

  /** Built-in value references. */
  var getPrototype = _overArg(Object.getPrototypeOf, Object);

  var _getPrototype = getPrototype;

  /** Used for built-in method references. */
  var objectProto$8 = Object.prototype;

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$8;

    return value === proto;
  }

  var _isPrototype = isPrototype;

  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneObject(object) {
    return (typeof object.constructor == 'function' && !_isPrototype(object))
      ? _baseCreate(_getPrototype(object))
      : {};
  }

  var _initCloneObject = initCloneObject;

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength_1(value.length) && !isFunction_1(value);
  }

  var isArrayLike_1 = isArrayLike;

  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */
  function isArrayLikeObject(value) {
    return isObjectLike_1(value) && isArrayLike_1(value);
  }

  var isArrayLikeObject_1 = isArrayLikeObject;

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  var stubFalse_1 = stubFalse;

  var isBuffer_1 = createCommonjsModule(function (module, exports) {
  /** Detect free variable `exports`. */
  var freeExports = exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Built-in value references. */
  var Buffer = moduleExports ? _root.Buffer : undefined;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse_1;

  module.exports = isBuffer;
  });

  /** `Object#toString` result references. */
  var objectTag = '[object Object]';

  /** Used for built-in method references. */
  var funcProto$2 = Function.prototype,
      objectProto$9 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$2 = funcProto$2.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$9 = objectProto$9.hasOwnProperty;

  /** Used to infer the `Object` constructor. */
  var objectCtorString = funcToString$2.call(Object);

  /**
   * Checks if `value` is a plain object, that is, an object created by the
   * `Object` constructor or one with a `[[Prototype]]` of `null`.
   *
   * @static
   * @memberOf _
   * @since 0.8.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * _.isPlainObject(new Foo);
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'x': 0, 'y': 0 });
   * // => true
   *
   * _.isPlainObject(Object.create(null));
   * // => true
   */
  function isPlainObject(value) {
    if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag) {
      return false;
    }
    var proto = _getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty$9.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor &&
      funcToString$2.call(Ctor) == objectCtorString;
  }

  var isPlainObject_1 = isPlainObject;

  /** `Object#toString` result references. */
  var argsTag$1 = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag$1 = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag$1 = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag$1] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray(value) {
    return isObjectLike_1(value) &&
      isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
  }

  var _baseIsTypedArray = baseIsTypedArray;

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  var _baseUnary = baseUnary;

  var _nodeUtil = createCommonjsModule(function (module, exports) {
  /** Detect free variable `exports`. */
  var freeExports = exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && _freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  module.exports = nodeUtil;
  });

  /* Node.js helper references. */
  var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

  var isTypedArray_1 = isTypedArray;

  /**
   * Gets the value at `key`, unless `key` is "__proto__".
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function safeGet(object, key) {
    if (key == '__proto__') {
      return;
    }

    return object[key];
  }

  var _safeGet = safeGet;

  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});

    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];

      var newValue = customizer
        ? customizer(object[key], source[key], key, object, source)
        : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }
      if (isNew) {
        _baseAssignValue(object, key, newValue);
      } else {
        _assignValue(object, key, newValue);
      }
    }
    return object;
  }

  var _copyObject = copyObject;

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  var _baseTimes = baseTimes;

  /** Used for built-in method references. */
  var objectProto$a = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$a = objectProto$a.hasOwnProperty;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray_1(value),
        isArg = !isArr && isArguments_1(value),
        isBuff = !isArr && !isArg && isBuffer_1(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? _baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$a.call(value, key)) &&
          !(skipIndexes && (
             // Safari 9 has enumerable `arguments.length` in strict mode.
             key == 'length' ||
             // Node.js 0.10 has enumerable non-index properties on buffers.
             (isBuff && (key == 'offset' || key == 'parent')) ||
             // PhantomJS 2 has enumerable non-index properties on typed arrays.
             (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
             // Skip index properties.
             _isIndex(key, length)
          ))) {
        result.push(key);
      }
    }
    return result;
  }

  var _arrayLikeKeys = arrayLikeKeys;

  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }

  var _nativeKeysIn = nativeKeysIn;

  /** Used for built-in method references. */
  var objectProto$b = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$b = objectProto$b.hasOwnProperty;

  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeysIn(object) {
    if (!isObject_1(object)) {
      return _nativeKeysIn(object);
    }
    var isProto = _isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty$b.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }

  var _baseKeysIn = baseKeysIn;

  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */
  function keysIn(object) {
    return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
  }

  var keysIn_1 = keysIn;

  /**
   * Converts `value` to a plain object flattening inherited enumerable string
   * keyed properties of `value` to own properties of the plain object.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {Object} Returns the converted plain object.
   * @example
   *
   * function Foo() {
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.assign({ 'a': 1 }, new Foo);
   * // => { 'a': 1, 'b': 2 }
   *
   * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
   * // => { 'a': 1, 'b': 2, 'c': 3 }
   */
  function toPlainObject(value) {
    return _copyObject(value, keysIn_1(value));
  }

  var toPlainObject_1 = toPlainObject;

  /**
   * A specialized version of `baseMerge` for arrays and objects which performs
   * deep merges and tracks traversed objects enabling objects with circular
   * references to be merged.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {string} key The key of the value to merge.
   * @param {number} srcIndex The index of `source`.
   * @param {Function} mergeFunc The function to merge values.
   * @param {Function} [customizer] The function to customize assigned values.
   * @param {Object} [stack] Tracks traversed source values and their merged
   *  counterparts.
   */
  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = _safeGet(object, key),
        srcValue = _safeGet(source, key),
        stacked = stack.get(srcValue);

    if (stacked) {
      _assignMergeValue(object, key, stacked);
      return;
    }
    var newValue = customizer
      ? customizer(objValue, srcValue, (key + ''), object, source, stack)
      : undefined;

    var isCommon = newValue === undefined;

    if (isCommon) {
      var isArr = isArray_1(srcValue),
          isBuff = !isArr && isBuffer_1(srcValue),
          isTyped = !isArr && !isBuff && isTypedArray_1(srcValue);

      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray_1(objValue)) {
          newValue = objValue;
        }
        else if (isArrayLikeObject_1(objValue)) {
          newValue = _copyArray(objValue);
        }
        else if (isBuff) {
          isCommon = false;
          newValue = _cloneBuffer(srcValue, true);
        }
        else if (isTyped) {
          isCommon = false;
          newValue = _cloneTypedArray(srcValue, true);
        }
        else {
          newValue = [];
        }
      }
      else if (isPlainObject_1(srcValue) || isArguments_1(srcValue)) {
        newValue = objValue;
        if (isArguments_1(objValue)) {
          newValue = toPlainObject_1(objValue);
        }
        else if (!isObject_1(objValue) || isFunction_1(objValue)) {
          newValue = _initCloneObject(srcValue);
        }
      }
      else {
        isCommon = false;
      }
    }
    if (isCommon) {
      // Recursively merge objects and arrays (susceptible to call stack limits).
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack['delete'](srcValue);
    }
    _assignMergeValue(object, key, newValue);
  }

  var _baseMergeDeep = baseMergeDeep;

  /**
   * The base implementation of `_.merge` without support for multiple sources.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {number} srcIndex The index of `source`.
   * @param {Function} [customizer] The function to customize merged values.
   * @param {Object} [stack] Tracks traversed source values and their merged
   *  counterparts.
   */
  function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }
    _baseFor(source, function(srcValue, key) {
      if (isObject_1(srcValue)) {
        stack || (stack = new _Stack);
        _baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
      }
      else {
        var newValue = customizer
          ? customizer(_safeGet(object, key), srcValue, (key + ''), object, source, stack)
          : undefined;

        if (newValue === undefined) {
          newValue = srcValue;
        }
        _assignMergeValue(object, key, newValue);
      }
    }, keysIn_1);
  }

  var _baseMerge = baseMerge;

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */
  function identity$1(value) {
    return value;
  }

  var identity_1 = identity$1;

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  var _apply = apply;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max;

  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */
  function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
    return function() {
      var args = arguments,
          index = -1,
          length = nativeMax(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return _apply(func, this, otherArgs);
    };
  }

  var _overRest = overRest;

  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new constant function.
   * @example
   *
   * var objects = _.times(2, _.constant({ 'a': 1 }));
   *
   * console.log(objects);
   * // => [{ 'a': 1 }, { 'a': 1 }]
   *
   * console.log(objects[0] === objects[1]);
   * // => true
   */
  function constant(value) {
    return function() {
      return value;
    };
  }

  var constant_1 = constant;

  /**
   * The base implementation of `setToString` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var baseSetToString = !_defineProperty$2 ? identity_1 : function(func, string) {
    return _defineProperty$2(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant_1(string),
      'writable': true
    });
  };

  var _baseSetToString = baseSetToString;

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeNow = Date.now;

  /**
   * Creates a function that'll short out and invoke `identity` instead
   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
   * milliseconds.
   *
   * @private
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new shortable function.
   */
  function shortOut(func) {
    var count = 0,
        lastCalled = 0;

    return function() {
      var stamp = nativeNow(),
          remaining = HOT_SPAN - (stamp - lastCalled);

      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(undefined, arguments);
    };
  }

  var _shortOut = shortOut;

  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var setToString = _shortOut(_baseSetToString);

  var _setToString = setToString;

  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */
  function baseRest(func, start) {
    return _setToString(_overRest(func, start, identity_1), func + '');
  }

  var _baseRest = baseRest;

  /**
   * Checks if the given arguments are from an iteratee call.
   *
   * @private
   * @param {*} value The potential iteratee value argument.
   * @param {*} index The potential iteratee index or key argument.
   * @param {*} object The potential iteratee object argument.
   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
   *  else `false`.
   */
  function isIterateeCall(value, index, object) {
    if (!isObject_1(object)) {
      return false;
    }
    var type = typeof index;
    if (type == 'number'
          ? (isArrayLike_1(object) && _isIndex(index, object.length))
          : (type == 'string' && index in object)
        ) {
      return eq_1(object[index], value);
    }
    return false;
  }

  var _isIterateeCall = isIterateeCall;

  /**
   * Creates a function like `_.assign`.
   *
   * @private
   * @param {Function} assigner The function to assign values.
   * @returns {Function} Returns the new assigner function.
   */
  function createAssigner(assigner) {
    return _baseRest(function(object, sources) {
      var index = -1,
          length = sources.length,
          customizer = length > 1 ? sources[length - 1] : undefined,
          guard = length > 2 ? sources[2] : undefined;

      customizer = (assigner.length > 3 && typeof customizer == 'function')
        ? (length--, customizer)
        : undefined;

      if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  }

  var _createAssigner = createAssigner;

  /**
   * This method is like `_.assign` except that it recursively merges own and
   * inherited enumerable string keyed properties of source objects into the
   * destination object. Source properties that resolve to `undefined` are
   * skipped if a destination value exists. Array and plain object properties
   * are merged recursively. Other objects and value types are overridden by
   * assignment. Source objects are applied from left to right. Subsequent
   * sources overwrite property assignments of previous sources.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 0.5.0
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @example
   *
   * var object = {
   *   'a': [{ 'b': 2 }, { 'd': 4 }]
   * };
   *
   * var other = {
   *   'a': [{ 'c': 3 }, { 'e': 5 }]
   * };
   *
   * _.merge(object, other);
   * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
   */
  var merge = _createAssigner(function(object, source, srcIndex) {
    _baseMerge(object, source, srcIndex);
  });

  var merge_1 = merge;

  var scrollbarSize = void 0;

  // Measure scrollbar width for padding body during modal show/hide
  var scrollbarMeasure = {
    position: 'absolute',
    top: '-9999px',
    width: '50px',
    height: '50px',
    overflow: 'scroll'
  };

  function measureScrollbar() {
    var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'vertical';

    if (typeof document === 'undefined' || typeof window === 'undefined') {
      return 0;
    }
    if (scrollbarSize) {
      return scrollbarSize;
    }
    var scrollDiv = document.createElement('div');
    Object.keys(scrollbarMeasure).forEach(function (scrollProp) {
      scrollDiv.style[scrollProp] = scrollbarMeasure[scrollProp];
    });
    document.body.appendChild(scrollDiv);
    var size = 0;
    if (direction === 'vertical') {
      size = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    } else if (direction === 'horizontal') {
      size = scrollDiv.offsetHeight - scrollDiv.clientHeight;
    }

    document.body.removeChild(scrollDiv);
    scrollbarSize = size;
    return scrollbarSize;
  }

  function debounce(func, wait, immediate) {
    var timeout = void 0;
    function debounceFunc() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var context = this;
      // https://fb.me/react-event-pooling
      if (args[0] && args[0].persist) {
        args[0].persist();
      }
      var later = function later() {
        timeout = null;
        if (!immediate) {
          func.apply(context, args);
        }
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) {
        func.apply(context, args);
      }
    }
    debounceFunc.cancel = function cancel() {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
    };
    return debounceFunc;
  }

  var warned = {};
  function warningOnce(condition, format, args) {
    if (!warned[format]) {
      warning_1$1(condition, format, args);
      warned[format] = !condition;
    }
  }

  function remove(array, item) {
    var index = array.indexOf(item);
    var front = array.slice(0, index);
    var last = array.slice(index + 1, array.length);
    return front.concat(last);
  }

  var ColumnManager = function () {
    function ColumnManager(columns, elements) {
      _classCallCheck$1(this, ColumnManager);

      this._cached = {};

      this.columns = columns || this.normalize(elements);
    }

    ColumnManager.prototype.isAnyColumnsFixed = function isAnyColumnsFixed() {
      var _this = this;

      return this._cache('isAnyColumnsFixed', function () {
        return _this.columns.some(function (column) {
          return !!column.fixed;
        });
      });
    };

    ColumnManager.prototype.isAnyColumnsLeftFixed = function isAnyColumnsLeftFixed() {
      var _this2 = this;

      return this._cache('isAnyColumnsLeftFixed', function () {
        return _this2.columns.some(function (column) {
          return column.fixed === 'left' || column.fixed === true;
        });
      });
    };

    ColumnManager.prototype.isAnyColumnsRightFixed = function isAnyColumnsRightFixed() {
      var _this3 = this;

      return this._cache('isAnyColumnsRightFixed', function () {
        return _this3.columns.some(function (column) {
          return column.fixed === 'right';
        });
      });
    };

    ColumnManager.prototype.leftColumns = function leftColumns() {
      var _this4 = this;

      return this._cache('leftColumns', function () {
        return _this4.groupedColumns().filter(function (column) {
          return column.fixed === 'left' || column.fixed === true;
        });
      });
    };

    ColumnManager.prototype.rightColumns = function rightColumns() {
      var _this5 = this;

      return this._cache('rightColumns', function () {
        return _this5.groupedColumns().filter(function (column) {
          return column.fixed === 'right';
        });
      });
    };

    ColumnManager.prototype.leafColumns = function leafColumns() {
      var _this6 = this;

      return this._cache('leafColumns', function () {
        return _this6._leafColumns(_this6.columns);
      });
    };

    ColumnManager.prototype.leftLeafColumns = function leftLeafColumns() {
      var _this7 = this;

      return this._cache('leftLeafColumns', function () {
        return _this7._leafColumns(_this7.leftColumns());
      });
    };

    ColumnManager.prototype.rightLeafColumns = function rightLeafColumns() {
      var _this8 = this;

      return this._cache('rightLeafColumns', function () {
        return _this8._leafColumns(_this8.rightColumns());
      });
    };

    // add appropriate rowspan and colspan to column


    ColumnManager.prototype.groupedColumns = function groupedColumns() {
      var _this9 = this;

      return this._cache('groupedColumns', function () {
        var _groupColumns = function _groupColumns(columns) {
          var currentRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var parentColumn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var rows = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

          // track how many rows we got
          rows[currentRow] = rows[currentRow] || [];
          var grouped = [];
          var setRowSpan = function setRowSpan(column) {
            var rowSpan = rows.length - currentRow;
            if (column && !column.children && // parent columns are supposed to be one row
            rowSpan > 1 && (!column.rowSpan || column.rowSpan < rowSpan)) {
              column.rowSpan = rowSpan;
            }
          };
          columns.forEach(function (column, index) {
            var newColumn = _extends$2({}, column);
            rows[currentRow].push(newColumn);
            parentColumn.colSpan = parentColumn.colSpan || 0;
            if (newColumn.children && newColumn.children.length > 0) {
              newColumn.children = _groupColumns(newColumn.children, currentRow + 1, newColumn, rows);
              parentColumn.colSpan += newColumn.colSpan;
            } else {
              parentColumn.colSpan++;
            }
            // update rowspan to all same row columns
            for (var i = 0; i < rows[currentRow].length - 1; ++i) {
              setRowSpan(rows[currentRow][i]);
            }
            // last column, update rowspan immediately
            if (index + 1 === columns.length) {
              setRowSpan(newColumn);
            }
            grouped.push(newColumn);
          });
          return grouped;
        };
        return _groupColumns(_this9.columns);
      });
    };

    ColumnManager.prototype.normalize = function normalize(elements) {
      var _this10 = this;

      var columns = [];
      React$1__default.Children.forEach(elements, function (element) {
        if (!React$1__default.isValidElement(element)) {
          return;
        }
        var column = _extends$2({}, element.props);
        if (element.key) {
          column.key = element.key;
        }
        if (element.type.isTableColumnGroup) {
          column.children = _this10.normalize(column.children);
        }
        columns.push(column);
      });
      return columns;
    };

    ColumnManager.prototype.reset = function reset(columns, elements) {
      this.columns = columns || this.normalize(elements);
      this._cached = {};
    };

    ColumnManager.prototype._cache = function _cache(name, fn) {
      if (name in this._cached) {
        return this._cached[name];
      }
      this._cached[name] = fn();
      return this._cached[name];
    };

    ColumnManager.prototype._leafColumns = function _leafColumns(columns) {
      var _this11 = this;

      var leafColumns = [];
      columns.forEach(function (column) {
        if (!column.children) {
          leafColumns.push(column);
        } else {
          leafColumns.push.apply(leafColumns, _this11._leafColumns(column.children));
        }
      });
      return leafColumns;
    };

    return ColumnManager;
  }();

  function ColGroup(props, _ref) {
    var table = _ref.table;
    var _table$props = table.props,
        prefixCls = _table$props.prefixCls,
        expandIconAsCell = _table$props.expandIconAsCell;
    var fixed = props.fixed;


    var cols = [];

    if (expandIconAsCell && fixed !== 'right') {
      cols.push(React$1__default.createElement('col', { className: prefixCls + '-expand-icon-col', key: 'rc-table-expand-icon-col' }));
    }

    var leafColumns = void 0;

    if (fixed === 'left') {
      leafColumns = table.columnManager.leftLeafColumns();
    } else if (fixed === 'right') {
      leafColumns = table.columnManager.rightLeafColumns();
    } else {
      leafColumns = table.columnManager.leafColumns();
    }
    cols = cols.concat(leafColumns.map(function (c) {
      return React$1__default.createElement('col', { key: c.key || c.dataIndex, style: { width: c.width, minWidth: c.width } });
    }));

    return React$1__default.createElement(
      'colgroup',
      null,
      cols
    );
  }

  ColGroup.propTypes = {
    fixed: PropTypes.string
  };

  ColGroup.contextTypes = {
    table: PropTypes.any
  };

  function TableHeaderRow(_ref) {
    var row = _ref.row,
        index = _ref.index,
        height = _ref.height,
        components = _ref.components,
        onHeaderRow = _ref.onHeaderRow;

    var HeaderRow = components.header.row;
    var HeaderCell = components.header.cell;
    var rowProps = onHeaderRow(row.map(function (cell) {
      return cell.column;
    }), index);
    var customStyle = rowProps ? rowProps.style : {};
    var style = _extends$2({ height: height }, customStyle);

    return React$1__default.createElement(
      HeaderRow,
      _extends$2({}, rowProps, { style: style }),
      row.map(function (cell, i) {
        var column = cell.column,
            cellProps = _objectWithoutProperties$1(cell, ['column']);

        var customProps = column.onHeaderCell ? column.onHeaderCell(column) : {};
        if (column.align) {
          customProps.style = _extends$2({}, customProps.style, { textAlign: column.align });
        }
        return React$1__default.createElement(HeaderCell, _extends$2({}, cellProps, customProps, { key: column.key || column.dataIndex || i }));
      })
    );
  }

  TableHeaderRow.propTypes = {
    row: PropTypes.array,
    index: PropTypes.number,
    height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    components: PropTypes.any,
    onHeaderRow: PropTypes.func
  };

  function getRowHeight(state, props) {
    var fixedColumnsHeadRowsHeight = state.fixedColumnsHeadRowsHeight;
    var columns = props.columns,
        rows = props.rows,
        fixed = props.fixed;

    var headerHeight = fixedColumnsHeadRowsHeight[0];

    if (!fixed) {
      return null;
    }

    if (headerHeight && columns) {
      if (headerHeight === 'auto') {
        return 'auto';
      }
      return headerHeight / rows.length;
    }
    return null;
  }

  var TableHeaderRow$1 = lib_2$1(function (state, props) {
    return {
      height: getRowHeight(state, props)
    };
  })(TableHeaderRow);

  function getHeaderRows(columns) {
    var currentRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var rows = arguments[2];

    rows = rows || [];
    rows[currentRow] = rows[currentRow] || [];

    columns.forEach(function (column) {
      if (column.rowSpan && rows.length < column.rowSpan) {
        while (rows.length < column.rowSpan) {
          rows.push([]);
        }
      }
      var cell = {
        key: column.key,
        className: column.className || '',
        children: column.title,
        column: column
      };
      if (column.children) {
        getHeaderRows(column.children, currentRow + 1, rows);
      }
      if ('colSpan' in column) {
        cell.colSpan = column.colSpan;
      }
      if ('rowSpan' in column) {
        cell.rowSpan = column.rowSpan;
      }
      if (cell.colSpan !== 0) {
        rows[currentRow].push(cell);
      }
    });
    return rows.filter(function (row) {
      return row.length > 0;
    });
  }

  function TableHeader(props, _ref) {
    var table = _ref.table;
    var components = table.components;
    var _table$props = table.props,
        prefixCls = _table$props.prefixCls,
        showHeader = _table$props.showHeader,
        onHeaderRow = _table$props.onHeaderRow;
    var expander = props.expander,
        columns = props.columns,
        fixed = props.fixed;


    if (!showHeader) {
      return null;
    }

    var rows = getHeaderRows(columns);

    expander.renderExpandIndentCell(rows, fixed);

    var HeaderWrapper = components.header.wrapper;

    return React$1__default.createElement(
      HeaderWrapper,
      { className: prefixCls + '-thead' },
      rows.map(function (row, index) {
        return React$1__default.createElement(TableHeaderRow$1, {
          key: index,
          index: index,
          fixed: fixed,
          columns: columns,
          rows: rows,
          row: row,
          components: components,
          onHeaderRow: onHeaderRow
        });
      })
    );
  }

  TableHeader.propTypes = {
    fixed: PropTypes.string,
    columns: PropTypes.array.isRequired,
    expander: PropTypes.object.isRequired,
    onHeaderRow: PropTypes.func
  };

  TableHeader.contextTypes = {
    table: PropTypes.any
  };

  function isInvalidRenderCellText(text) {
    return text && !React$1__default.isValidElement(text) && Object.prototype.toString.call(text) === '[object Object]';
  }

  var TableCell = function (_React$Component) {
    _inherits$1(TableCell, _React$Component);

    function TableCell() {
      var _temp, _this, _ret;

      _classCallCheck$1(this, TableCell);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn$1(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleClick = function (e) {
        var _this$props = _this.props,
            record = _this$props.record,
            onCellClick = _this$props.column.onCellClick;

        if (onCellClick) {
          onCellClick(record, e);
        }
      }, _temp), _possibleConstructorReturn$1(_this, _ret);
    }

    TableCell.prototype.render = function render() {
      var _props = this.props,
          record = _props.record,
          indentSize = _props.indentSize,
          prefixCls = _props.prefixCls,
          indent = _props.indent,
          index = _props.index,
          expandIcon = _props.expandIcon,
          column = _props.column,
          BodyCell = _props.component;
      var dataIndex = column.dataIndex,
          render = column.render,
          _column$className = column.className,
          className = _column$className === undefined ? '' : _column$className;

      // We should return undefined if no dataIndex is specified, but in order to
      // be compatible with object-path's behavior, we return the record object instead.

      var text = void 0;
      if (typeof dataIndex === 'number') {
        text = get_1(record, dataIndex);
      } else if (!dataIndex || dataIndex.length === 0) {
        text = record;
      } else {
        text = get_1(record, dataIndex);
      }
      var tdProps = {};
      var colSpan = void 0;
      var rowSpan = void 0;

      if (render) {
        text = render(text, record, index);
        if (isInvalidRenderCellText(text)) {
          tdProps = text.props || tdProps;
          colSpan = tdProps.colSpan;
          rowSpan = tdProps.rowSpan;
          text = text.children;
        }
      }

      if (column.onCell) {
        tdProps = _extends$2({}, tdProps, column.onCell(record));
      }

      // Fix https://github.com/ant-design/ant-design/issues/1202
      if (isInvalidRenderCellText(text)) {
        text = null;
      }

      var indentText = expandIcon ? React$1__default.createElement('span', {
        style: { paddingLeft: indentSize * indent + 'px' },
        className: prefixCls + '-indent indent-level-' + indent
      }) : null;

      if (rowSpan === 0 || colSpan === 0) {
        return null;
      }

      if (column.align) {
        tdProps.style = _extends$2({}, tdProps.style, { textAlign: column.align });
      }

      return React$1__default.createElement(
        BodyCell,
        _extends$2({ className: className, onClick: this.handleClick }, tdProps),
        indentText,
        expandIcon,
        text
      );
    };

    return TableCell;
  }(React$1__default.Component);

  TableCell.propTypes = {
    record: PropTypes.object,
    prefixCls: PropTypes.string,
    index: PropTypes.number,
    indent: PropTypes.number,
    indentSize: PropTypes.number,
    column: PropTypes.object,
    expandIcon: PropTypes.node,
    component: PropTypes.any
  };

  var TableRow = function (_React$Component) {
    _inherits$1(TableRow, _React$Component);

    TableRow.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
      if (prevState.visible || !prevState.visible && nextProps.visible) {
        return {
          shouldRender: true,
          visible: nextProps.visible
        };
      }
      return {
        visible: nextProps.visible
      };
    };

    function TableRow(props) {
      _classCallCheck$1(this, TableRow);

      var _this = _possibleConstructorReturn$1(this, _React$Component.call(this, props));

      _this.onRowClick = function (event) {
        var _this$props = _this.props,
            record = _this$props.record,
            index = _this$props.index,
            onRowClick = _this$props.onRowClick;

        if (onRowClick) {
          onRowClick(record, index, event);
        }
      };

      _this.onRowDoubleClick = function (event) {
        var _this$props2 = _this.props,
            record = _this$props2.record,
            index = _this$props2.index,
            onRowDoubleClick = _this$props2.onRowDoubleClick;

        if (onRowDoubleClick) {
          onRowDoubleClick(record, index, event);
        }
      };

      _this.onContextMenu = function (event) {
        var _this$props3 = _this.props,
            record = _this$props3.record,
            index = _this$props3.index,
            onRowContextMenu = _this$props3.onRowContextMenu;

        if (onRowContextMenu) {
          onRowContextMenu(record, index, event);
        }
      };

      _this.onMouseEnter = function (event) {
        var _this$props4 = _this.props,
            record = _this$props4.record,
            index = _this$props4.index,
            onRowMouseEnter = _this$props4.onRowMouseEnter,
            onHover = _this$props4.onHover,
            rowKey = _this$props4.rowKey;

        onHover(true, rowKey);
        if (onRowMouseEnter) {
          onRowMouseEnter(record, index, event);
        }
      };

      _this.onMouseLeave = function (event) {
        var _this$props5 = _this.props,
            record = _this$props5.record,
            index = _this$props5.index,
            onRowMouseLeave = _this$props5.onRowMouseLeave,
            onHover = _this$props5.onHover,
            rowKey = _this$props5.rowKey;

        onHover(false, rowKey);
        if (onRowMouseLeave) {
          onRowMouseLeave(record, index, event);
        }
      };

      _this.shouldRender = props.visible;

      _this.state = {};
      return _this;
    }

    TableRow.prototype.componentDidMount = function componentDidMount() {
      if (this.state.shouldRender) {
        this.saveRowRef();
      }
    };

    TableRow.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      return !!(this.props.visible || nextProps.visible);
    };

    TableRow.prototype.componentDidUpdate = function componentDidUpdate() {
      if (this.state.shouldRender && !this.rowRef) {
        this.saveRowRef();
      }
    };

    TableRow.prototype.setExpanedRowHeight = function setExpanedRowHeight() {
      var _extends2;

      var _props = this.props,
          store = _props.store,
          rowKey = _props.rowKey;

      var _store$getState = store.getState(),
          expandedRowsHeight = _store$getState.expandedRowsHeight;

      var height = this.rowRef.getBoundingClientRect().height;
      expandedRowsHeight = _extends$2({}, expandedRowsHeight, (_extends2 = {}, _extends2[rowKey] = height, _extends2));
      store.setState({ expandedRowsHeight: expandedRowsHeight });
    };

    TableRow.prototype.setRowHeight = function setRowHeight() {
      var _props2 = this.props,
          store = _props2.store,
          index = _props2.index;

      var fixedColumnsBodyRowsHeight = store.getState().fixedColumnsBodyRowsHeight.slice();
      var height = this.rowRef.getBoundingClientRect().height;
      fixedColumnsBodyRowsHeight[index] = height;
      store.setState({ fixedColumnsBodyRowsHeight: fixedColumnsBodyRowsHeight });
    };

    TableRow.prototype.getStyle = function getStyle() {
      var _props3 = this.props,
          height = _props3.height,
          visible = _props3.visible;


      if (height && height !== this.style.height) {
        this.style = _extends$2({}, this.style, { height: height });
      }

      if (!visible && !this.style.display) {
        this.style = _extends$2({}, this.style, { display: 'none' });
      }

      return this.style;
    };

    TableRow.prototype.saveRowRef = function saveRowRef() {
      this.rowRef = ReactDOM__default.findDOMNode(this);

      var _props4 = this.props,
          isAnyColumnsFixed = _props4.isAnyColumnsFixed,
          fixed = _props4.fixed,
          expandedRow = _props4.expandedRow,
          ancestorKeys = _props4.ancestorKeys;


      if (!isAnyColumnsFixed) {
        return;
      }

      if (!fixed && expandedRow) {
        this.setExpanedRowHeight();
      }

      if (!fixed && ancestorKeys.length >= 0) {
        this.setRowHeight();
      }
    };

    TableRow.prototype.render = function render() {
      if (!this.state.shouldRender) {
        return null;
      }

      var _props5 = this.props,
          prefixCls = _props5.prefixCls,
          columns = _props5.columns,
          record = _props5.record,
          index = _props5.index,
          onRow = _props5.onRow,
          indent = _props5.indent,
          indentSize = _props5.indentSize,
          hovered = _props5.hovered,
          height = _props5.height,
          visible = _props5.visible,
          components = _props5.components,
          hasExpandIcon = _props5.hasExpandIcon,
          renderExpandIcon = _props5.renderExpandIcon,
          renderExpandIconCell = _props5.renderExpandIconCell;


      var BodyRow = components.body.row;
      var BodyCell = components.body.cell;

      var className = this.props.className;


      if (hovered) {
        className += ' ' + prefixCls + '-hover';
      }

      var cells = [];

      renderExpandIconCell(cells);

      for (var i = 0; i < columns.length; i++) {
        var column = columns[i];

        warningOnce(column.onCellClick === undefined, 'column[onCellClick] is deprecated, please use column[onCell] instead.');

        cells.push(React$1__default.createElement(TableCell, {
          prefixCls: prefixCls,
          record: record,
          indentSize: indentSize,
          indent: indent,
          index: index,
          column: column,
          key: column.key || column.dataIndex,
          expandIcon: hasExpandIcon(i) && renderExpandIcon(),
          component: BodyCell
        }));
      }

      var rowClassName = (prefixCls + ' ' + className + ' ' + prefixCls + '-level-' + indent).trim();

      var rowProps = onRow(record, index);
      var customStyle = rowProps ? rowProps.style : {};
      var style = { height: height };

      if (!visible) {
        style.display = 'none';
      }

      style = _extends$2({}, style, customStyle);

      return React$1__default.createElement(
        BodyRow,
        _extends$2({
          onClick: this.onRowClick,
          onDoubleClick: this.onRowDoubleClick,
          onMouseEnter: this.onMouseEnter,
          onMouseLeave: this.onMouseLeave,
          onContextMenu: this.onContextMenu,
          className: rowClassName
        }, rowProps, {
          style: style
        }),
        cells
      );
    };

    return TableRow;
  }(React$1__default.Component);

  TableRow.propTypes = {
    onRow: PropTypes.func,
    onRowClick: PropTypes.func,
    onRowDoubleClick: PropTypes.func,
    onRowContextMenu: PropTypes.func,
    onRowMouseEnter: PropTypes.func,
    onRowMouseLeave: PropTypes.func,
    record: PropTypes.object,
    prefixCls: PropTypes.string,
    onHover: PropTypes.func,
    columns: PropTypes.array,
    height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    index: PropTypes.number,
    rowKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,
    className: PropTypes.string,
    indent: PropTypes.number,
    indentSize: PropTypes.number,
    hasExpandIcon: PropTypes.func,
    hovered: PropTypes.bool.isRequired,
    visible: PropTypes.bool.isRequired,
    store: PropTypes.object.isRequired,
    fixed: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),
    renderExpandIcon: PropTypes.func,
    renderExpandIconCell: PropTypes.func,
    components: PropTypes.any,
    expandedRow: PropTypes.bool,
    isAnyColumnsFixed: PropTypes.bool,
    ancestorKeys: PropTypes.array.isRequired
  };
  TableRow.defaultProps = {
    onRow: function onRow() {},
    onHover: function onHover() {},
    hasExpandIcon: function hasExpandIcon() {},
    renderExpandIcon: function renderExpandIcon() {},
    renderExpandIconCell: function renderExpandIconCell() {}
  };


  function getRowHeight$1(state, props) {
    var expandedRowsHeight = state.expandedRowsHeight,
        fixedColumnsBodyRowsHeight = state.fixedColumnsBodyRowsHeight;
    var fixed = props.fixed,
        index = props.index,
        rowKey = props.rowKey;


    if (!fixed) {
      return null;
    }

    if (expandedRowsHeight[rowKey]) {
      return expandedRowsHeight[rowKey];
    }

    if (fixedColumnsBodyRowsHeight[index]) {
      return fixedColumnsBodyRowsHeight[index];
    }

    return null;
  }

  polyfill(TableRow);

  var TableRow$1 = lib_2$1(function (state, props) {
    var currentHoverKey = state.currentHoverKey,
        expandedRowKeys = state.expandedRowKeys;
    var rowKey = props.rowKey,
        ancestorKeys = props.ancestorKeys;

    var visible = ancestorKeys.length === 0 || ancestorKeys.every(function (k) {
      return ~expandedRowKeys.indexOf(k);
    });

    return {
      visible: visible,
      hovered: currentHoverKey === rowKey,
      height: getRowHeight$1(state, props)
    };
  })(TableRow);

  var ExpandIcon = function (_React$Component) {
    _inherits$1(ExpandIcon, _React$Component);

    function ExpandIcon() {
      _classCallCheck$1(this, ExpandIcon);

      return _possibleConstructorReturn$1(this, _React$Component.apply(this, arguments));
    }

    ExpandIcon.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      return !shallowequal(nextProps, this.props);
    };

    ExpandIcon.prototype.render = function render() {
      var _props = this.props,
          expandable = _props.expandable,
          prefixCls = _props.prefixCls,
          onExpand = _props.onExpand,
          needIndentSpaced = _props.needIndentSpaced,
          expanded = _props.expanded,
          record = _props.record;

      if (expandable) {
        var expandClassName = expanded ? 'expanded' : 'collapsed';
        return React$1__default.createElement('span', {
          className: prefixCls + '-expand-icon ' + prefixCls + '-' + expandClassName,
          onClick: function onClick(e) {
            return onExpand(record, e);
          }
        });
      } else if (needIndentSpaced) {
        return React$1__default.createElement('span', { className: prefixCls + '-expand-icon ' + prefixCls + '-spaced' });
      }
      return null;
    };

    return ExpandIcon;
  }(React$1__default.Component);

  ExpandIcon.propTypes = {
    record: PropTypes.object,
    prefixCls: PropTypes.string,
    expandable: PropTypes.any,
    expanded: PropTypes.bool,
    needIndentSpaced: PropTypes.bool,
    onExpand: PropTypes.func
  };

  var ExpandableRow = function (_React$Component) {
    _inherits$1(ExpandableRow, _React$Component);

    function ExpandableRow() {
      var _temp, _this, _ret;

      _classCallCheck$1(this, ExpandableRow);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn$1(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.hasExpandIcon = function (columnIndex) {
        var expandRowByClick = _this.props.expandRowByClick;

        return !_this.expandIconAsCell && !expandRowByClick && columnIndex === _this.expandIconColumnIndex;
      }, _this.handleExpandChange = function (record, event) {
        var _this$props = _this.props,
            onExpandedChange = _this$props.onExpandedChange,
            expanded = _this$props.expanded,
            rowKey = _this$props.rowKey;

        if (_this.expandable) {
          onExpandedChange(!expanded, record, event, rowKey);
        }
      }, _this.handleRowClick = function (record, index, event) {
        var _this$props2 = _this.props,
            expandRowByClick = _this$props2.expandRowByClick,
            onRowClick = _this$props2.onRowClick;

        if (expandRowByClick) {
          _this.handleExpandChange(record, event);
        }
        if (onRowClick) {
          onRowClick(record, index, event);
        }
      }, _this.renderExpandIcon = function () {
        var _this$props3 = _this.props,
            prefixCls = _this$props3.prefixCls,
            expanded = _this$props3.expanded,
            record = _this$props3.record,
            needIndentSpaced = _this$props3.needIndentSpaced;


        return React$1__default.createElement(ExpandIcon, {
          expandable: _this.expandable,
          prefixCls: prefixCls,
          onExpand: _this.handleExpandChange,
          needIndentSpaced: needIndentSpaced,
          expanded: expanded,
          record: record
        });
      }, _this.renderExpandIconCell = function (cells) {
        if (!_this.expandIconAsCell) {
          return;
        }
        var prefixCls = _this.props.prefixCls;


        cells.push(React$1__default.createElement(
          'td',
          { className: prefixCls + '-expand-icon-cell', key: 'rc-table-expand-icon-cell' },
          _this.renderExpandIcon()
        ));
      }, _temp), _possibleConstructorReturn$1(_this, _ret);
    }

    ExpandableRow.prototype.componentWillUnmount = function componentWillUnmount() {
      this.handleDestroy();
    };

    ExpandableRow.prototype.handleDestroy = function handleDestroy() {
      var _props = this.props,
          onExpandedChange = _props.onExpandedChange,
          rowKey = _props.rowKey,
          record = _props.record;

      if (this.expandable) {
        onExpandedChange(false, record, null, rowKey, true);
      }
    };

    ExpandableRow.prototype.render = function render() {
      var _props2 = this.props,
          childrenColumnName = _props2.childrenColumnName,
          expandedRowRender = _props2.expandedRowRender,
          indentSize = _props2.indentSize,
          record = _props2.record,
          fixed = _props2.fixed;


      this.expandIconAsCell = fixed !== 'right' ? this.props.expandIconAsCell : false;
      this.expandIconColumnIndex = fixed !== 'right' ? this.props.expandIconColumnIndex : -1;
      var childrenData = record[childrenColumnName];
      this.expandable = !!(childrenData || expandedRowRender);

      var expandableRowProps = {
        indentSize: indentSize,
        onRowClick: this.handleRowClick,
        hasExpandIcon: this.hasExpandIcon,
        renderExpandIcon: this.renderExpandIcon,
        renderExpandIconCell: this.renderExpandIconCell
      };

      return this.props.children(expandableRowProps);
    };

    return ExpandableRow;
  }(React$1__default.Component);

  ExpandableRow.propTypes = {
    prefixCls: PropTypes.string.isRequired,
    rowKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,
    fixed: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),
    record: PropTypes.object.isRequired,
    indentSize: PropTypes.number,
    needIndentSpaced: PropTypes.bool.isRequired,
    expandRowByClick: PropTypes.bool,
    expanded: PropTypes.bool.isRequired,
    expandIconAsCell: PropTypes.bool,
    expandIconColumnIndex: PropTypes.number,
    childrenColumnName: PropTypes.string,
    expandedRowRender: PropTypes.func,
    onExpandedChange: PropTypes.func.isRequired,
    onRowClick: PropTypes.func,
    children: PropTypes.func.isRequired
  };


  var ExpandableRow$1 = lib_2$1(function (_ref, _ref2) {
    var expandedRowKeys = _ref.expandedRowKeys;
    var rowKey = _ref2.rowKey;
    return {
      expanded: !!~expandedRowKeys.indexOf(rowKey)
    };
  })(ExpandableRow);

  var BaseTable = function (_React$Component) {
    _inherits$1(BaseTable, _React$Component);

    function BaseTable() {
      var _temp, _this, _ret;

      _classCallCheck$1(this, BaseTable);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn$1(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleRowHover = function (isHover, key) {
        _this.props.store.setState({
          currentHoverKey: isHover ? key : null
        });
      }, _this.renderRows = function (renderData, indent) {
        var ancestorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        var table = _this.context.table;
        var columnManager = table.columnManager,
            components = table.components;
        var _table$props = table.props,
            prefixCls = _table$props.prefixCls,
            childrenColumnName = _table$props.childrenColumnName,
            rowClassName = _table$props.rowClassName,
            rowRef = _table$props.rowRef,
            onRowClick = _table$props.onRowClick,
            onRowDoubleClick = _table$props.onRowDoubleClick,
            onRowContextMenu = _table$props.onRowContextMenu,
            onRowMouseEnter = _table$props.onRowMouseEnter,
            onRowMouseLeave = _table$props.onRowMouseLeave,
            onRow = _table$props.onRow;
        var _this$props = _this.props,
            getRowKey = _this$props.getRowKey,
            fixed = _this$props.fixed,
            expander = _this$props.expander,
            isAnyColumnsFixed = _this$props.isAnyColumnsFixed;


        var rows = [];

        var _loop = function _loop(i) {
          var record = renderData[i];
          var key = getRowKey(record, i);
          var className = typeof rowClassName === 'string' ? rowClassName : rowClassName(record, i, indent);

          var onHoverProps = {};
          if (columnManager.isAnyColumnsFixed()) {
            onHoverProps.onHover = _this.handleRowHover;
          }

          var leafColumns = void 0;
          if (fixed === 'left') {
            leafColumns = columnManager.leftLeafColumns();
          } else if (fixed === 'right') {
            leafColumns = columnManager.rightLeafColumns();
          } else {
            leafColumns = columnManager.leafColumns();
          }

          var rowPrefixCls = prefixCls + '-row';

          var row = React$1__default.createElement(
            ExpandableRow$1,
            _extends$2({}, expander.props, {
              fixed: fixed,
              index: i,
              prefixCls: rowPrefixCls,
              record: record,
              key: key,
              rowKey: key,
              onRowClick: onRowClick,
              needIndentSpaced: expander.needIndentSpaced,
              onExpandedChange: expander.handleExpandChange
            }),
            function (expandableRow) {
              return (// eslint-disable-line
                React$1__default.createElement(TableRow$1, _extends$2({
                  fixed: fixed,
                  indent: indent,
                  className: className,
                  record: record,
                  index: i,
                  prefixCls: rowPrefixCls,
                  childrenColumnName: childrenColumnName,
                  columns: leafColumns,
                  onRow: onRow,
                  onRowDoubleClick: onRowDoubleClick,
                  onRowContextMenu: onRowContextMenu,
                  onRowMouseEnter: onRowMouseEnter,
                  onRowMouseLeave: onRowMouseLeave
                }, onHoverProps, {
                  rowKey: key,
                  ancestorKeys: ancestorKeys,
                  ref: rowRef(record, i, indent),
                  components: components,
                  isAnyColumnsFixed: isAnyColumnsFixed
                }, expandableRow))
              );
            }
          );

          rows.push(row);

          expander.renderRows(_this.renderRows, rows, record, i, indent, fixed, key, ancestorKeys);
        };

        for (var i = 0; i < renderData.length; i++) {
          _loop(i);
        }
        return rows;
      }, _temp), _possibleConstructorReturn$1(_this, _ret);
    }

    BaseTable.prototype.render = function render() {
      var table = this.context.table;
      var components = table.components;
      var _table$props2 = table.props,
          prefixCls = _table$props2.prefixCls,
          scroll = _table$props2.scroll,
          data = _table$props2.data,
          getBodyWrapper = _table$props2.getBodyWrapper;
      var _props = this.props,
          expander = _props.expander,
          tableClassName = _props.tableClassName,
          hasHead = _props.hasHead,
          hasBody = _props.hasBody,
          fixed = _props.fixed,
          columns = _props.columns;

      var tableStyle = {};

      if (!fixed && scroll.x) {
        // not set width, then use content fixed width
        if (scroll.x === true) {
          tableStyle.tableLayout = 'fixed';
        } else {
          tableStyle.width = scroll.x;
        }
      }

      var Table = hasBody ? components.table : 'table';
      var BodyWrapper = components.body.wrapper;

      var body = void 0;
      if (hasBody) {
        body = React$1__default.createElement(
          BodyWrapper,
          { className: prefixCls + '-tbody' },
          this.renderRows(data, 0)
        );
        if (getBodyWrapper) {
          body = getBodyWrapper(body);
        }
      }

      return React$1__default.createElement(
        Table,
        { className: tableClassName, style: tableStyle, key: 'table' },
        React$1__default.createElement(ColGroup, { columns: columns, fixed: fixed }),
        hasHead && React$1__default.createElement(TableHeader, { expander: expander, columns: columns, fixed: fixed }),
        body
      );
    };

    return BaseTable;
  }(React$1__default.Component);

  BaseTable.propTypes = {
    fixed: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),
    columns: PropTypes.array.isRequired,
    tableClassName: PropTypes.string.isRequired,
    hasHead: PropTypes.bool.isRequired,
    hasBody: PropTypes.bool.isRequired,
    store: PropTypes.object.isRequired,
    expander: PropTypes.object.isRequired,
    getRowKey: PropTypes.func,
    isAnyColumnsFixed: PropTypes.bool
  };
  BaseTable.contextTypes = {
    table: PropTypes.any
  };


  var BaseTable$1 = lib_2$1()(BaseTable);

  function HeadTable(props, _ref) {
    var table = _ref.table;
    var _table$props = table.props,
        prefixCls = _table$props.prefixCls,
        scroll = _table$props.scroll,
        showHeader = _table$props.showHeader;
    var columns = props.columns,
        fixed = props.fixed,
        tableClassName = props.tableClassName,
        handleBodyScrollLeft = props.handleBodyScrollLeft,
        expander = props.expander;
    var saveRef = table.saveRef;
    var useFixedHeader = table.props.useFixedHeader;

    var headStyle = {};

    if (scroll.y) {
      useFixedHeader = true;
      // Add negative margin bottom for scroll bar overflow bug
      var scrollbarWidth = measureScrollbar('horizontal');
      if (scrollbarWidth > 0 && !fixed) {
        headStyle.marginBottom = '-' + scrollbarWidth + 'px';
        headStyle.paddingBottom = '0px';
      }
    }

    if (!useFixedHeader || !showHeader) {
      return null;
    }

    return React$1__default.createElement(
      'div',
      {
        key: 'headTable',
        ref: fixed ? null : saveRef('headTable'),
        className: prefixCls + '-header',
        style: headStyle,
        onScroll: handleBodyScrollLeft
      },
      React$1__default.createElement(BaseTable$1, {
        tableClassName: tableClassName,
        hasHead: true,
        hasBody: false,
        fixed: fixed,
        columns: columns,
        expander: expander
      })
    );
  }

  HeadTable.propTypes = {
    fixed: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),
    columns: PropTypes.array.isRequired,
    tableClassName: PropTypes.string.isRequired,
    handleBodyScrollLeft: PropTypes.func.isRequired,
    expander: PropTypes.object.isRequired
  };

  HeadTable.contextTypes = {
    table: PropTypes.any
  };

  function BodyTable(props, _ref) {
    var table = _ref.table;
    var _table$props = table.props,
        prefixCls = _table$props.prefixCls,
        scroll = _table$props.scroll;
    var columns = props.columns,
        fixed = props.fixed,
        tableClassName = props.tableClassName,
        getRowKey = props.getRowKey,
        handleBodyScroll = props.handleBodyScroll,
        handleWheel = props.handleWheel,
        expander = props.expander,
        isAnyColumnsFixed = props.isAnyColumnsFixed;
    var saveRef = table.saveRef;
    var useFixedHeader = table.props.useFixedHeader;

    var bodyStyle = _extends$2({}, table.props.bodyStyle);
    var innerBodyStyle = {};

    if (scroll.x || fixed) {
      bodyStyle.overflowX = bodyStyle.overflowX || 'scroll';
      // Fix weired webkit render bug
      // https://github.com/ant-design/ant-design/issues/7783
      bodyStyle.WebkitTransform = 'translate3d (0, 0, 0)';
    }

    if (scroll.y) {
      // maxHeight will make fixed-Table scrolling not working
      // so we only set maxHeight to body-Table here
      if (fixed) {
        innerBodyStyle.maxHeight = bodyStyle.maxHeight || scroll.y;
        innerBodyStyle.overflowY = bodyStyle.overflowY || 'scroll';
      } else {
        bodyStyle.maxHeight = bodyStyle.maxHeight || scroll.y;
      }
      bodyStyle.overflowY = bodyStyle.overflowY || 'scroll';
      useFixedHeader = true;

      // Add negative margin bottom for scroll bar overflow bug
      var scrollbarWidth = measureScrollbar();
      if (scrollbarWidth > 0 && fixed) {
        bodyStyle.marginBottom = '-' + scrollbarWidth + 'px';
        bodyStyle.paddingBottom = '0px';
      }
    }

    var baseTable = React$1__default.createElement(BaseTable$1, {
      tableClassName: tableClassName,
      hasHead: !useFixedHeader,
      hasBody: true,
      fixed: fixed,
      columns: columns,
      expander: expander,
      getRowKey: getRowKey,
      isAnyColumnsFixed: isAnyColumnsFixed
    });

    if (fixed && columns.length) {
      var refName = void 0;
      if (columns[0].fixed === 'left' || columns[0].fixed === true) {
        refName = 'fixedColumnsBodyLeft';
      } else if (columns[0].fixed === 'right') {
        refName = 'fixedColumnsBodyRight';
      }
      delete bodyStyle.overflowX;
      delete bodyStyle.overflowY;
      return React$1__default.createElement(
        'div',
        { key: 'bodyTable', className: prefixCls + '-body-outer', style: _extends$2({}, bodyStyle) },
        React$1__default.createElement(
          'div',
          {
            className: prefixCls + '-body-inner',
            style: innerBodyStyle,
            ref: saveRef(refName),
            onWheel: handleWheel,
            onScroll: handleBodyScroll
          },
          baseTable
        )
      );
    }

    return React$1__default.createElement(
      'div',
      {
        key: 'bodyTable',
        className: prefixCls + '-body',
        style: bodyStyle,
        ref: saveRef('bodyTable'),
        onWheel: handleWheel,
        onScroll: handleBodyScroll
      },
      baseTable
    );
  }

  BodyTable.propTypes = {
    fixed: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),
    columns: PropTypes.array.isRequired,
    tableClassName: PropTypes.string.isRequired,
    handleWheel: PropTypes.func.isRequired,
    handleBodyScroll: PropTypes.func.isRequired,
    getRowKey: PropTypes.func.isRequired,
    expander: PropTypes.object.isRequired,
    isAnyColumnsFixed: PropTypes.bool
  };

  BodyTable.contextTypes = {
    table: PropTypes.any
  };

  var ExpandableTable = function (_React$Component) {
    _inherits$1(ExpandableTable, _React$Component);

    function ExpandableTable(props) {
      _classCallCheck$1(this, ExpandableTable);

      var _this = _possibleConstructorReturn$1(this, _React$Component.call(this, props));

      _initialiseProps$h.call(_this);

      var data = props.data,
          childrenColumnName = props.childrenColumnName,
          defaultExpandAllRows = props.defaultExpandAllRows,
          expandedRowKeys = props.expandedRowKeys,
          defaultExpandedRowKeys = props.defaultExpandedRowKeys,
          getRowKey = props.getRowKey;


      var finnalExpandedRowKeys = [];
      var rows = [].concat(data);

      if (defaultExpandAllRows) {
        for (var i = 0; i < rows.length; i++) {
          var row = rows[i];
          finnalExpandedRowKeys.push(getRowKey(row, i));
          rows = rows.concat(row[childrenColumnName] || []);
        }
      } else {
        finnalExpandedRowKeys = expandedRowKeys || defaultExpandedRowKeys;
      }

      _this.columnManager = props.columnManager;
      _this.store = props.store;

      _this.store.setState({
        expandedRowsHeight: {},
        expandedRowKeys: finnalExpandedRowKeys
      });
      return _this;
    }

    ExpandableTable.prototype.componentDidUpdate = function componentDidUpdate() {
      if ('expandedRowKeys' in this.props) {
        this.store.setState({
          expandedRowKeys: this.props.expandedRowKeys
        });
      }
    };

    ExpandableTable.prototype.renderExpandedRow = function renderExpandedRow(record, index, _render, className, ancestorKeys, indent, fixed) {
      var _props = this.props,
          prefixCls = _props.prefixCls,
          expandIconAsCell = _props.expandIconAsCell,
          indentSize = _props.indentSize;

      var colCount = void 0;
      if (fixed === 'left') {
        colCount = this.columnManager.leftLeafColumns().length;
      } else if (fixed === 'right') {
        colCount = this.columnManager.rightLeafColumns().length;
      } else {
        colCount = this.columnManager.leafColumns().length;
      }
      var columns = [{
        key: 'extra-row',
        render: function render() {
          return {
            props: {
              colSpan: colCount
            },
            children: fixed !== 'right' ? _render(record, index, indent) : '&nbsp;'
          };
        }
      }];
      if (expandIconAsCell && fixed !== 'right') {
        columns.unshift({
          key: 'expand-icon-placeholder',
          render: function render() {
            return null;
          }
        });
      }
      var parentKey = ancestorKeys[ancestorKeys.length - 1];
      var rowKey = parentKey + '-extra-row';
      var components = {
        body: {
          row: 'tr',
          cell: 'td'
        }
      };

      return React$1__default.createElement(TableRow$1, {
        key: rowKey,
        columns: columns,
        className: className,
        rowKey: rowKey,
        ancestorKeys: ancestorKeys,
        prefixCls: prefixCls + '-expanded-row',
        indentSize: indentSize,
        indent: indent,
        fixed: fixed,
        components: components,
        expandedRow: true
      });
    };

    ExpandableTable.prototype.render = function render() {
      var _props2 = this.props,
          data = _props2.data,
          childrenColumnName = _props2.childrenColumnName,
          children = _props2.children;

      var needIndentSpaced = data.some(function (record) {
        return record[childrenColumnName];
      });

      return children({
        props: this.props,
        needIndentSpaced: needIndentSpaced,
        renderRows: this.renderRows,
        handleExpandChange: this.handleExpandChange,
        renderExpandIndentCell: this.renderExpandIndentCell
      });
    };

    return ExpandableTable;
  }(React$1__default.Component);

  ExpandableTable.propTypes = {
    expandIconAsCell: PropTypes.bool,
    expandedRowKeys: PropTypes.array,
    expandedRowClassName: PropTypes.func,
    defaultExpandAllRows: PropTypes.bool,
    defaultExpandedRowKeys: PropTypes.array,
    expandIconColumnIndex: PropTypes.number,
    expandedRowRender: PropTypes.func,
    childrenColumnName: PropTypes.string,
    indentSize: PropTypes.number,
    onExpand: PropTypes.func,
    onExpandedRowsChange: PropTypes.func,
    columnManager: PropTypes.object.isRequired,
    store: PropTypes.object.isRequired,
    prefixCls: PropTypes.string.isRequired,
    data: PropTypes.array,
    children: PropTypes.func.isRequired,
    getRowKey: PropTypes.func.isRequired
  };
  ExpandableTable.defaultProps = {
    expandIconAsCell: false,
    expandedRowClassName: function expandedRowClassName() {
      return '';
    },
    expandIconColumnIndex: 0,
    defaultExpandAllRows: false,
    defaultExpandedRowKeys: [],
    childrenColumnName: 'children',
    indentSize: 15,
    onExpand: function onExpand() {},
    onExpandedRowsChange: function onExpandedRowsChange() {}
  };

  var _initialiseProps$h = function _initialiseProps() {
    var _this2 = this;

    this.handleExpandChange = function (expanded, record, event, rowKey) {
      var destroy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }

      var _props3 = _this2.props,
          onExpandedRowsChange = _props3.onExpandedRowsChange,
          onExpand = _props3.onExpand;

      var _store$getState = _this2.store.getState(),
          expandedRowKeys = _store$getState.expandedRowKeys;

      if (expanded) {
        // row was expaned
        expandedRowKeys = [].concat(expandedRowKeys, [rowKey]);
      } else {
        // row was collapse
        var expandedRowIndex = expandedRowKeys.indexOf(rowKey);
        if (expandedRowIndex !== -1) {
          expandedRowKeys = remove(expandedRowKeys, rowKey);
        }
      }

      if (!_this2.props.expandedRowKeys) {
        _this2.store.setState({ expandedRowKeys: expandedRowKeys });
      }

      onExpandedRowsChange(expandedRowKeys);
      if (!destroy) {
        onExpand(expanded, record);
      }
    };

    this.renderExpandIndentCell = function (rows, fixed) {
      var _props4 = _this2.props,
          prefixCls = _props4.prefixCls,
          expandIconAsCell = _props4.expandIconAsCell;

      if (!expandIconAsCell || fixed === 'right' || !rows.length) {
        return;
      }

      var iconColumn = {
        key: 'rc-table-expand-icon-cell',
        className: prefixCls + '-expand-icon-th',
        title: '',
        rowSpan: rows.length
      };

      rows[0].unshift(_extends$2({}, iconColumn, { column: iconColumn }));
    };

    this.renderRows = function (renderRows, rows, record, index, indent, fixed, parentKey, ancestorKeys) {
      var _props5 = _this2.props,
          expandedRowClassName = _props5.expandedRowClassName,
          expandedRowRender = _props5.expandedRowRender,
          childrenColumnName = _props5.childrenColumnName;

      var childrenData = record[childrenColumnName];
      var nextAncestorKeys = [].concat(ancestorKeys, [parentKey]);
      var nextIndent = indent + 1;

      if (expandedRowRender) {
        rows.push(_this2.renderExpandedRow(record, index, expandedRowRender, expandedRowClassName(record, index, indent), nextAncestorKeys, nextIndent, fixed));
      }

      if (childrenData) {
        rows.push.apply(rows, renderRows(childrenData, nextIndent, nextAncestorKeys));
      }
    };
  };

  polyfill(ExpandableTable);

  var ExpandableTable$1 = lib_2$1()(ExpandableTable);

  var Table = function (_React$Component) {
    _inherits$1(Table, _React$Component);

    Table.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
      if (nextProps.columns && nextProps.columns !== prevState.columns) {
        return {
          columns: nextProps.columns,
          children: null
        };
      } else if (nextProps.children !== prevState.children) {
        return {
          columns: null,
          children: nextProps.children
        };
      }
      return null;
    };

    function Table(props) {
      _classCallCheck$1(this, Table);

      var _this = _possibleConstructorReturn$1(this, _React$Component.call(this, props));

      _this.state = {};

      _this.getRowKey = function (record, index) {
        var rowKey = _this.props.rowKey;
        var key = typeof rowKey === 'function' ? rowKey(record, index) : record[rowKey];
        warningOnce(key !== undefined, 'Each record in table should have a unique `key` prop,' + 'or set `rowKey` to an unique primary key.');
        return key === undefined ? index : key;
      };

      _this.handleWindowResize = function () {
        _this.syncFixedTableRowHeight();
        _this.setScrollPositionClassName();
      };

      _this.syncFixedTableRowHeight = function () {
        var tableRect = _this.tableNode.getBoundingClientRect();
        // If tableNode's height less than 0, suppose it is hidden and don't recalculate rowHeight.
        // see: https://github.com/ant-design/ant-design/issues/4836
        if (tableRect.height !== undefined && tableRect.height <= 0) {
          return;
        }
        var prefixCls = _this.props.prefixCls;

        var headRows = _this.headTable ? _this.headTable.querySelectorAll('thead') : _this.bodyTable.querySelectorAll('thead');
        var bodyRows = _this.bodyTable.querySelectorAll('.' + prefixCls + '-row') || [];
        var fixedColumnsHeadRowsHeight = [].map.call(headRows, function (row) {
          return row.getBoundingClientRect().height || 'auto';
        });
        var fixedColumnsBodyRowsHeight = [].map.call(bodyRows, function (row) {
          return row.getBoundingClientRect().height || 'auto';
        });
        var state = _this.store.getState();
        if (shallowequal(state.fixedColumnsHeadRowsHeight, fixedColumnsHeadRowsHeight) && shallowequal(state.fixedColumnsBodyRowsHeight, fixedColumnsBodyRowsHeight)) {
          return;
        }

        _this.store.setState({
          fixedColumnsHeadRowsHeight: fixedColumnsHeadRowsHeight,
          fixedColumnsBodyRowsHeight: fixedColumnsBodyRowsHeight
        });
      };

      _this.handleBodyScrollLeft = function (e) {
        // Fix https://github.com/ant-design/ant-design/issues/7635
        if (e.currentTarget !== e.target) {
          return;
        }
        var target = e.target;
        var _this$props$scroll = _this.props.scroll,
            scroll = _this$props$scroll === undefined ? {} : _this$props$scroll;
        var headTable = _this.headTable,
            bodyTable = _this.bodyTable;

        if (target.scrollLeft !== _this.lastScrollLeft && scroll.x) {
          if (target === bodyTable && headTable) {
            headTable.scrollLeft = target.scrollLeft;
          } else if (target === headTable && bodyTable) {
            bodyTable.scrollLeft = target.scrollLeft;
          }
          _this.setScrollPositionClassName();
        }
        // Remember last scrollLeft for scroll direction detecting.
        _this.lastScrollLeft = target.scrollLeft;
      };

      _this.handleBodyScrollTop = function (e) {
        var target = e.target;
        // Fix https://github.com/ant-design/ant-design/issues/9033
        if (e.currentTarget !== target) {
          return;
        }
        var _this$props$scroll2 = _this.props.scroll,
            scroll = _this$props$scroll2 === undefined ? {} : _this$props$scroll2;
        var headTable = _this.headTable,
            bodyTable = _this.bodyTable,
            fixedColumnsBodyLeft = _this.fixedColumnsBodyLeft,
            fixedColumnsBodyRight = _this.fixedColumnsBodyRight;

        if (target.scrollTop !== _this.lastScrollTop && scroll.y && target !== headTable) {
          var scrollTop = target.scrollTop;
          if (fixedColumnsBodyLeft && target !== fixedColumnsBodyLeft) {
            fixedColumnsBodyLeft.scrollTop = scrollTop;
          }
          if (fixedColumnsBodyRight && target !== fixedColumnsBodyRight) {
            fixedColumnsBodyRight.scrollTop = scrollTop;
          }
          if (bodyTable && target !== bodyTable) {
            bodyTable.scrollTop = scrollTop;
          }
        }
        // Remember last scrollTop for scroll direction detecting.
        _this.lastScrollTop = target.scrollTop;
      };

      _this.handleBodyScroll = function (e) {
        _this.handleBodyScrollLeft(e);
        _this.handleBodyScrollTop(e);
      };

      _this.handleWheel = function (event) {
        var _this$props$scroll3 = _this.props.scroll,
            scroll = _this$props$scroll3 === undefined ? {} : _this$props$scroll3;

        if (window.navigator.userAgent.match(/Trident\/7\./) && scroll.y) {
          event.preventDefault();
          var wd = event.deltaY;
          var target = event.target;
          var bodyTable = _this.bodyTable,
              fixedColumnsBodyLeft = _this.fixedColumnsBodyLeft,
              fixedColumnsBodyRight = _this.fixedColumnsBodyRight;

          var scrollTop = 0;

          if (_this.lastScrollTop) {
            scrollTop = _this.lastScrollTop + wd;
          } else {
            scrollTop = wd;
          }

          if (fixedColumnsBodyLeft && target !== fixedColumnsBodyLeft) {
            fixedColumnsBodyLeft.scrollTop = scrollTop;
          }
          if (fixedColumnsBodyRight && target !== fixedColumnsBodyRight) {
            fixedColumnsBodyRight.scrollTop = scrollTop;
          }
          if (bodyTable && target !== bodyTable) {
            bodyTable.scrollTop = scrollTop;
          }
        }
      };

      _this.saveRef = function (name) {
        return function (node) {
          _this[name] = node;
        };
      };

      ['onRowClick', 'onRowDoubleClick', 'onRowContextMenu', 'onRowMouseEnter', 'onRowMouseLeave'].forEach(function (name) {
        warningOnce(props[name] === undefined, name + ' is deprecated, please use onRow instead.');
      });

      warningOnce(props.getBodyWrapper === undefined, 'getBodyWrapper is deprecated, please use custom components instead.');

      _this.columnManager = new ColumnManager(props.columns, props.children);

      _this.store = lib_1$1({
        currentHoverKey: null,
        fixedColumnsHeadRowsHeight: [],
        fixedColumnsBodyRowsHeight: []
      });

      _this.setScrollPosition('left');

      _this.debouncedWindowResize = debounce(_this.handleWindowResize, 150);
      return _this;
    }

    Table.prototype.getChildContext = function getChildContext() {
      return {
        table: {
          props: this.props,
          columnManager: this.columnManager,
          saveRef: this.saveRef,
          components: merge_1({
            table: 'table',
            header: {
              wrapper: 'thead',
              row: 'tr',
              cell: 'th'
            },
            body: {
              wrapper: 'tbody',
              row: 'tr',
              cell: 'td'
            }
          }, this.props.components)
        }
      };
    };

    Table.prototype.componentDidMount = function componentDidMount() {
      if (this.columnManager.isAnyColumnsFixed()) {
        this.handleWindowResize();
        this.resizeEvent = addEventListenerWrap(window, 'resize', this.debouncedWindowResize);
      }
    };

    Table.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
      if (this.columnManager.isAnyColumnsFixed()) {
        this.handleWindowResize();
        if (!this.resizeEvent) {
          this.resizeEvent = addEventListenerWrap(window, 'resize', this.debouncedWindowResize);
        }
      }
      // when table changes to empty, reset scrollLeft
      if (prevProps.data.length > 0 && this.props.data.length === 0 && this.hasScrollX()) {
        this.resetScrollX();
      }
    };

    Table.prototype.componentWillUnmount = function componentWillUnmount() {
      if (this.resizeEvent) {
        this.resizeEvent.remove();
      }
      if (this.debouncedWindowResize) {
        this.debouncedWindowResize.cancel();
      }
    };

    Table.prototype.setScrollPosition = function setScrollPosition(position) {
      this.scrollPosition = position;
      if (this.tableNode) {
        var prefixCls = this.props.prefixCls;

        if (position === 'both') {
          componentClasses(this.tableNode).remove(new RegExp('^' + prefixCls + '-scroll-position-.+$')).add(prefixCls + '-scroll-position-left').add(prefixCls + '-scroll-position-right');
        } else {
          componentClasses(this.tableNode).remove(new RegExp('^' + prefixCls + '-scroll-position-.+$')).add(prefixCls + '-scroll-position-' + position);
        }
      }
    };

    Table.prototype.setScrollPositionClassName = function setScrollPositionClassName() {
      var node = this.bodyTable;
      var scrollToLeft = node.scrollLeft === 0;
      var scrollToRight = node.scrollLeft + 1 >= node.children[0].getBoundingClientRect().width - node.getBoundingClientRect().width;
      if (scrollToLeft && scrollToRight) {
        this.setScrollPosition('both');
      } else if (scrollToLeft) {
        this.setScrollPosition('left');
      } else if (scrollToRight) {
        this.setScrollPosition('right');
      } else if (this.scrollPosition !== 'middle') {
        this.setScrollPosition('middle');
      }
    };

    Table.prototype.resetScrollX = function resetScrollX() {
      if (this.headTable) {
        this.headTable.scrollLeft = 0;
      }
      if (this.bodyTable) {
        this.bodyTable.scrollLeft = 0;
      }
    };

    Table.prototype.hasScrollX = function hasScrollX() {
      var _props$scroll = this.props.scroll,
          scroll = _props$scroll === undefined ? {} : _props$scroll;

      return 'x' in scroll;
    };

    Table.prototype.renderMainTable = function renderMainTable() {
      var _props = this.props,
          scroll = _props.scroll,
          prefixCls = _props.prefixCls;

      var isAnyColumnsFixed = this.columnManager.isAnyColumnsFixed();
      var scrollable = isAnyColumnsFixed || scroll.x || scroll.y;

      var table = [this.renderTable({
        columns: this.columnManager.groupedColumns(),
        isAnyColumnsFixed: isAnyColumnsFixed
      }), this.renderEmptyText(), this.renderFooter()];

      return scrollable ? React$1__default.createElement(
        'div',
        { className: prefixCls + '-scroll' },
        table
      ) : table;
    };

    Table.prototype.renderLeftFixedTable = function renderLeftFixedTable() {
      var prefixCls = this.props.prefixCls;


      return React$1__default.createElement(
        'div',
        { className: prefixCls + '-fixed-left' },
        this.renderTable({
          columns: this.columnManager.leftColumns(),
          fixed: 'left'
        })
      );
    };

    Table.prototype.renderRightFixedTable = function renderRightFixedTable() {
      var prefixCls = this.props.prefixCls;


      return React$1__default.createElement(
        'div',
        { className: prefixCls + '-fixed-right' },
        this.renderTable({
          columns: this.columnManager.rightColumns(),
          fixed: 'right'
        })
      );
    };

    Table.prototype.renderTable = function renderTable(options) {
      var columns = options.columns,
          fixed = options.fixed,
          isAnyColumnsFixed = options.isAnyColumnsFixed;
      var _props2 = this.props,
          prefixCls = _props2.prefixCls,
          _props2$scroll = _props2.scroll,
          scroll = _props2$scroll === undefined ? {} : _props2$scroll;

      var tableClassName = scroll.x || fixed ? prefixCls + '-fixed' : '';

      var headTable = React$1__default.createElement(HeadTable, {
        key: 'head',
        columns: columns,
        fixed: fixed,
        tableClassName: tableClassName,
        handleBodyScrollLeft: this.handleBodyScrollLeft,
        expander: this.expander
      });

      var bodyTable = React$1__default.createElement(BodyTable, {
        key: 'body',
        columns: columns,
        fixed: fixed,
        tableClassName: tableClassName,
        getRowKey: this.getRowKey,
        handleWheel: this.handleWheel,
        handleBodyScroll: this.handleBodyScroll,
        expander: this.expander,
        isAnyColumnsFixed: isAnyColumnsFixed
      });

      return [headTable, bodyTable];
    };

    Table.prototype.renderTitle = function renderTitle() {
      var _props3 = this.props,
          title = _props3.title,
          prefixCls = _props3.prefixCls;

      return title ? React$1__default.createElement(
        'div',
        { className: prefixCls + '-title', key: 'title' },
        title(this.props.data)
      ) : null;
    };

    Table.prototype.renderFooter = function renderFooter() {
      var _props4 = this.props,
          footer = _props4.footer,
          prefixCls = _props4.prefixCls;

      return footer ? React$1__default.createElement(
        'div',
        { className: prefixCls + '-footer', key: 'footer' },
        footer(this.props.data)
      ) : null;
    };

    Table.prototype.renderEmptyText = function renderEmptyText() {
      var _props5 = this.props,
          emptyText = _props5.emptyText,
          prefixCls = _props5.prefixCls,
          data = _props5.data;

      if (data.length) {
        return null;
      }
      var emptyClassName = prefixCls + '-placeholder';
      return React$1__default.createElement(
        'div',
        { className: emptyClassName, key: 'emptyText' },
        typeof emptyText === 'function' ? emptyText() : emptyText
      );
    };

    Table.prototype.render = function render() {
      var _this2 = this;

      var props = this.props;
      var prefixCls = props.prefixCls;

      if (this.state.columns) {
        this.columnManager.reset(props.columns);
      } else if (this.state.children) {
        this.columnManager.reset(null, props.children);
      }

      var className = props.prefixCls;
      if (props.className) {
        className += ' ' + props.className;
      }
      if (props.useFixedHeader || props.scroll && props.scroll.y) {
        className += ' ' + prefixCls + '-fixed-header';
      }
      if (this.scrollPosition === 'both') {
        className += ' ' + prefixCls + '-scroll-position-left ' + prefixCls + '-scroll-position-right';
      } else {
        className += ' ' + prefixCls + '-scroll-position-' + this.scrollPosition;
      }
      var hasLeftFixed = this.columnManager.isAnyColumnsLeftFixed();
      var hasRightFixed = this.columnManager.isAnyColumnsRightFixed();

      return React$1__default.createElement(
        lib_3$1,
        { store: this.store },
        React$1__default.createElement(
          ExpandableTable$1,
          _extends$2({}, props, { columnManager: this.columnManager, getRowKey: this.getRowKey }),
          function (expander) {
            _this2.expander = expander;
            return React$1__default.createElement(
              'div',
              {
                ref: _this2.saveRef('tableNode'),
                className: className,
                style: props.style,
                id: props.id
              },
              _this2.renderTitle(),
              React$1__default.createElement(
                'div',
                { className: prefixCls + '-content' },
                _this2.renderMainTable(),
                hasLeftFixed && _this2.renderLeftFixedTable(),
                hasRightFixed && _this2.renderRightFixedTable()
              )
            );
          }
        )
      );
    };

    return Table;
  }(React$1__default.Component);

  Table.propTypes = _extends$2({
    data: PropTypes.array,
    useFixedHeader: PropTypes.bool,
    columns: PropTypes.array,
    prefixCls: PropTypes.string,
    bodyStyle: PropTypes.object,
    style: PropTypes.object,
    rowKey: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
    rowClassName: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
    onRow: PropTypes.func,
    onHeaderRow: PropTypes.func,
    onRowClick: PropTypes.func,
    onRowDoubleClick: PropTypes.func,
    onRowContextMenu: PropTypes.func,
    onRowMouseEnter: PropTypes.func,
    onRowMouseLeave: PropTypes.func,
    showHeader: PropTypes.bool,
    title: PropTypes.func,
    id: PropTypes.string,
    footer: PropTypes.func,
    emptyText: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
    scroll: PropTypes.object,
    rowRef: PropTypes.func,
    getBodyWrapper: PropTypes.func,
    children: PropTypes.node,
    components: PropTypes.shape({
      table: PropTypes.any,
      header: PropTypes.shape({
        wrapper: PropTypes.any,
        row: PropTypes.any,
        cell: PropTypes.any
      }),
      body: PropTypes.shape({
        wrapper: PropTypes.any,
        row: PropTypes.any,
        cell: PropTypes.any
      })
    })
  }, ExpandableTable$1.PropTypes);
  Table.childContextTypes = {
    table: PropTypes.any,
    components: PropTypes.any
  };
  Table.defaultProps = {
    data: [],
    useFixedHeader: false,
    rowKey: 'key',
    rowClassName: function rowClassName() {
      return '';
    },
    onRow: function onRow() {},
    onHeaderRow: function onHeaderRow() {},

    prefixCls: 'rc-table',
    bodyStyle: {},
    style: {},
    showHeader: true,
    scroll: {},
    rowRef: function rowRef() {
      return null;
    },
    emptyText: function emptyText() {
      return 'No Data';
    }
  };


  polyfill(Table);

  function Column() {}

  Column.propTypes = {
    className: PropTypes.string,
    colSpan: PropTypes.number,
    title: PropTypes.node,
    dataIndex: PropTypes.string,
    width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    fixed: PropTypes.oneOf([true, 'left', 'right']),
    render: PropTypes.func,
    onCellClick: PropTypes.func,
    onCell: PropTypes.func,
    onHeaderCell: PropTypes.func
  };

  var ColumnGroup = function (_Component) {
    _inherits$1(ColumnGroup, _Component);

    function ColumnGroup() {
      _classCallCheck$1(this, ColumnGroup);

      return _possibleConstructorReturn$1(this, _Component.apply(this, arguments));
    }

    return ColumnGroup;
  }(React$1.Component);

  ColumnGroup.propTypes = {
    title: PropTypes.node
  };
  ColumnGroup.isTableColumnGroup = true;

  Table.Column = Column;
  Table.ColumnGroup = ColumnGroup;

  var es$b = /*#__PURE__*/Object.freeze({
    default: Table,
    Column: Column,
    ColumnGroup: ColumnGroup
  });

  var Pager = function Pager(props) {
    var prefixCls = props.rootPrefixCls + '-item';
    var cls = prefixCls + ' ' + prefixCls + '-' + props.page;

    if (props.active) {
      cls = cls + ' ' + prefixCls + '-active';
    }

    if (props.className) {
      cls = cls + ' ' + props.className;
    }

    var handleClick = function handleClick() {
      props.onClick(props.page);
    };

    var handleKeyPress = function handleKeyPress(e) {
      props.onKeyPress(e, props.onClick, props.page);
    };

    return React$1__default.createElement(
      'li',
      {
        title: props.showTitle ? props.page : null,
        className: cls,
        onClick: handleClick,
        onKeyPress: handleKeyPress,
        tabIndex: '0'
      },
      props.itemRender(props.page, 'page', React$1__default.createElement(
        'a',
        null,
        props.page
      ))
    );
  };

  Pager.propTypes = {
    page: PropTypes.number,
    active: PropTypes.bool,
    last: PropTypes.bool,
    locale: PropTypes.object,
    className: PropTypes.string,
    showTitle: PropTypes.bool,
    rootPrefixCls: PropTypes.string,
    onClick: PropTypes.func,
    onKeyPress: PropTypes.func,
    itemRender: PropTypes.func
  };

  var KEYCODE = {
    ZERO: 48,
    NINE: 57,

    NUMPAD_ZERO: 96,
    NUMPAD_NINE: 105,

    BACKSPACE: 8,
    DELETE: 46,
    ENTER: 13,

    ARROW_UP: 38,
    ARROW_DOWN: 40
  };

  var Options = function (_React$Component) {
    _inherits$1(Options, _React$Component);

    function Options(props) {
      _classCallCheck$1(this, Options);

      var _this = _possibleConstructorReturn$1(this, (Options.__proto__ || Object.getPrototypeOf(Options)).call(this, props));

      _this.buildOptionText = function (value) {
        return value + ' ' + _this.props.locale.items_per_page;
      };

      _this.changeSize = function (value) {
        _this.props.changeSize(Number(value));
      };

      _this.handleChange = function (e) {
        _this.setState({
          goInputText: e.target.value
        });
      };

      _this.go = function (e) {
        var val = _this.state.goInputText;
        if (val === '') {
          return;
        }
        val = isNaN(val) ? _this.props.current : Number(val);
        if (e.keyCode === KEYCODE.ENTER || e.type === 'click') {
          _this.setState({
            goInputText: ''
          });
          _this.props.quickGo(val);
        }
      };

      _this.state = {
        goInputText: ''
      };
      return _this;
    }

    _createClass$1(Options, [{
      key: 'render',
      value: function render() {
        var props = this.props;
        var state = this.state;
        var locale = props.locale;
        var prefixCls = props.rootPrefixCls + '-options';
        var changeSize = props.changeSize;
        var quickGo = props.quickGo;
        var goButton = props.goButton;
        var buildOptionText = props.buildOptionText || this.buildOptionText;
        var Select = props.selectComponentClass;
        var changeSelect = null;
        var goInput = null;
        var gotoButton = null;

        if (!(changeSize || quickGo)) {
          return null;
        }

        if (changeSize && Select) {
          var Option = Select.Option;
          var pageSize = props.pageSize || props.pageSizeOptions[0];
          var options = props.pageSizeOptions.map(function (opt, i) {
            return React$1__default.createElement(
              Option,
              { key: i, value: opt },
              buildOptionText(opt)
            );
          });

          changeSelect = React$1__default.createElement(
            Select,
            {
              prefixCls: props.selectPrefixCls,
              showSearch: false,
              className: prefixCls + '-size-changer',
              optionLabelProp: 'children',
              dropdownMatchSelectWidth: false,
              value: pageSize.toString(),
              onChange: this.changeSize,
              getPopupContainer: function getPopupContainer(triggerNode) {
                return triggerNode.parentNode;
              }
            },
            options
          );
        }

        if (quickGo) {
          if (goButton) {
            if (typeof goButton === 'boolean') {
              gotoButton = React$1__default.createElement(
                'button',
                {
                  type: 'button',
                  onClick: this.go,
                  onKeyUp: this.go
                },
                locale.jump_to_confirm
              );
            } else {
              gotoButton = React$1__default.createElement(
                'span',
                {
                  onClick: this.go,
                  onKeyUp: this.go
                },
                goButton
              );
            }
          }
          goInput = React$1__default.createElement(
            'div',
            { className: prefixCls + '-quick-jumper' },
            locale.jump_to,
            React$1__default.createElement('input', {
              type: 'text',
              value: state.goInputText,
              onChange: this.handleChange,
              onKeyUp: this.go
            }),
            locale.page,
            gotoButton
          );
        }

        return React$1__default.createElement(
          'li',
          { className: '' + prefixCls },
          changeSelect,
          goInput
        );
      }
    }]);

    return Options;
  }(React$1__default.Component);

  Options.propTypes = {
    changeSize: PropTypes.func,
    quickGo: PropTypes.func,
    selectComponentClass: PropTypes.func,
    current: PropTypes.number,
    pageSizeOptions: PropTypes.arrayOf(PropTypes.string),
    pageSize: PropTypes.number,
    buildOptionText: PropTypes.func,
    locale: PropTypes.object
  };
  Options.defaultProps = {
    pageSizeOptions: ['10', '20', '30', '40']
  };

  var LOCALE = {
    // Options.jsx
    items_per_page: '条/页',
    jump_to: '跳至',
    jump_to_confirm: '确定',
    page: '页',

    // Pagination.jsx
    prev_page: '上一页',
    next_page: '下一页',
    prev_5: '向前 5 页',
    next_5: '向后 5 页',
    prev_3: '向前 3 页',
    next_3: '向后 3 页'
  };

  function noop$c() {}

  function isInteger(value) {
    return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
  }

  function defaultItemRender(page, type, element) {
    return element;
  }

  var Pagination = function (_React$Component) {
    _inherits$1(Pagination, _React$Component);

    function Pagination(props) {
      _classCallCheck$1(this, Pagination);

      var _this = _possibleConstructorReturn$1(this, (Pagination.__proto__ || Object.getPrototypeOf(Pagination)).call(this, props));

      _initialiseProps$i.call(_this);

      var hasOnChange = props.onChange !== noop$c;
      var hasCurrent = 'current' in props;
      if (hasCurrent && !hasOnChange) {
        console.warn('Warning: You provided a `current` prop to a Pagination component without an `onChange` handler. This will render a read-only component.'); // eslint-disable-line
      }

      var current = props.defaultCurrent;
      if ('current' in props) {
        current = props.current;
      }

      var pageSize = props.defaultPageSize;
      if ('pageSize' in props) {
        pageSize = props.pageSize;
      }

      _this.state = {
        current: current,
        currentInputValue: current,
        pageSize: pageSize
      };
      return _this;
    }

    _createClass$1(Pagination, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        if ('current' in nextProps) {
          this.setState({
            current: nextProps.current,
            currentInputValue: nextProps.current
          });
        }

        if ('pageSize' in nextProps) {
          var newState = {};
          var current = this.state.current;
          var newCurrent = this.calculatePage(nextProps.pageSize);
          current = current > newCurrent ? newCurrent : current;
          if (!('current' in nextProps)) {
            newState.current = current;
            newState.currentInputValue = current;
          }
          newState.pageSize = nextProps.pageSize;
          this.setState(newState);
        }
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate(prevProps, prevState) {
        // When current page change, fix focused style of prev item
        // A hacky solution of https://github.com/ant-design/ant-design/issues/8948
        var prefixCls = this.props.prefixCls;

        if (prevState.current !== this.state.current && this.paginationNode) {
          var lastCurrentNode = this.paginationNode.querySelector('.' + prefixCls + '-item-' + prevState.current);
          if (lastCurrentNode && document.activeElement === lastCurrentNode) {
            lastCurrentNode.blur();
          }
        }
      }
    }, {
      key: 'getJumpPrevPage',
      value: function getJumpPrevPage() {
        return Math.max(1, this.state.current - (this.props.showLessItems ? 3 : 5));
      }
    }, {
      key: 'getJumpNextPage',
      value: function getJumpNextPage() {
        return Math.min(this.calculatePage(), this.state.current + (this.props.showLessItems ? 3 : 5));
      }
    }, {
      key: 'getJumpPrevPage',
      value: function getJumpPrevPage() {
        return Math.max(1, this.state.current - (this.props.showLessItems ? 3 : 5));
      }
    }, {
      key: 'getJumpNextPage',
      value: function getJumpNextPage() {
        return Math.min(this.calculatePage(), this.state.current + (this.props.showLessItems ? 3 : 5));
      }
    }, {
      key: 'render',
      value: function render() {
        // When hideOnSinglePage is true and there is only 1 page, hide the pager
        if (this.props.hideOnSinglePage === true && this.props.total <= this.state.pageSize) {
          return null;
        }

        var props = this.props;
        var locale = props.locale;

        var prefixCls = props.prefixCls;
        var allPages = this.calculatePage();
        var pagerList = [];
        var jumpPrev = null;
        var jumpNext = null;
        var firstPager = null;
        var lastPager = null;
        var gotoButton = null;

        var goButton = props.showQuickJumper && props.showQuickJumper.goButton;
        var pageBufferSize = props.showLessItems ? 1 : 2;
        var _state = this.state,
            current = _state.current,
            pageSize = _state.pageSize;


        var prevPage = current - 1 > 0 ? current - 1 : 0;
        var nextPage = current + 1 < allPages ? current + 1 : allPages;

        var dataOrAriaAttributeProps = Object.keys(props).reduce(function (prev, key) {
          if (key.substr(0, 5) === 'data-' || key.substr(0, 5) === 'aria-' || key === 'role') {
            prev[key] = props[key];
          }
          return prev;
        }, {});

        if (props.simple) {
          if (goButton) {
            if (typeof goButton === 'boolean') {
              gotoButton = React$1__default.createElement(
                'button',
                {
                  type: 'button',
                  onClick: this.handleGoTO,
                  onKeyUp: this.handleGoTO
                },
                locale.jump_to_confirm
              );
            } else {
              gotoButton = React$1__default.createElement(
                'span',
                {
                  onClick: this.handleGoTO,
                  onKeyUp: this.handleGoTO
                },
                goButton
              );
            }
            gotoButton = React$1__default.createElement(
              'li',
              {
                title: props.showTitle ? '' + locale.jump_to + this.state.current + '/' + allPages : null,
                className: prefixCls + '-simple-pager'
              },
              gotoButton
            );
          }

          return React$1__default.createElement(
            'ul',
            _extends$2({
              className: prefixCls + ' ' + prefixCls + '-simple ' + props.className,
              style: props.style,
              ref: this.savePaginationNode
            }, dataOrAriaAttributeProps),
            React$1__default.createElement(
              'li',
              {
                title: props.showTitle ? locale.prev_page : null,
                onClick: this.prev,
                tabIndex: this.hasPrev() ? 0 : null,
                onKeyPress: this.runIfEnterPrev,
                className: (this.hasPrev() ? '' : prefixCls + '-disabled') + ' ' + prefixCls + '-prev',
                'aria-disabled': !this.hasPrev()
              },
              props.itemRender(prevPage, 'prev', React$1__default.createElement('a', { className: prefixCls + '-item-link' }))
            ),
            React$1__default.createElement(
              'li',
              {
                title: props.showTitle ? this.state.current + '/' + allPages : null,
                className: prefixCls + '-simple-pager'
              },
              React$1__default.createElement('input', {
                type: 'text',
                value: this.state.currentInputValue,
                onKeyDown: this.handleKeyDown,
                onKeyUp: this.handleKeyUp,
                onChange: this.handleKeyUp,
                size: '3'
              }),
              React$1__default.createElement(
                'span',
                { className: prefixCls + '-slash' },
                '\uFF0F'
              ),
              allPages
            ),
            React$1__default.createElement(
              'li',
              {
                title: props.showTitle ? locale.next_page : null,
                onClick: this.next,
                tabIndex: this.hasPrev() ? 0 : null,
                onKeyPress: this.runIfEnterNext,
                className: (this.hasNext() ? '' : prefixCls + '-disabled') + ' ' + prefixCls + '-next',
                'aria-disabled': !this.hasNext()
              },
              props.itemRender(nextPage, 'next', React$1__default.createElement('a', { className: prefixCls + '-item-link' }))
            ),
            gotoButton
          );
        }

        if (allPages <= 5 + pageBufferSize * 2) {
          for (var i = 1; i <= allPages; i++) {
            var active = this.state.current === i;
            pagerList.push(React$1__default.createElement(Pager, {
              locale: locale,
              rootPrefixCls: prefixCls,
              onClick: this.handleChange,
              onKeyPress: this.runIfEnter,
              key: i,
              page: i,
              active: active,
              showTitle: props.showTitle,
              itemRender: props.itemRender
            }));
          }
        } else {
          var prevItemTitle = props.showLessItems ? locale.prev_3 : locale.prev_5;
          var nextItemTitle = props.showLessItems ? locale.next_3 : locale.next_5;
          if (props.showPrevNextJumpers) {
            jumpPrev = React$1__default.createElement(
              'li',
              {
                title: props.showTitle ? prevItemTitle : null,
                key: 'prev',
                onClick: this.jumpPrev,
                tabIndex: '0',
                onKeyPress: this.runIfEnterJumpPrev,
                className: prefixCls + '-jump-prev'
              },
              props.itemRender(this.getJumpPrevPage(), 'jump-prev', React$1__default.createElement('a', { className: prefixCls + '-item-link' }))
            );
            jumpNext = React$1__default.createElement(
              'li',
              {
                title: props.showTitle ? nextItemTitle : null,
                key: 'next',
                tabIndex: '0',
                onClick: this.jumpNext,
                onKeyPress: this.runIfEnterJumpNext,
                className: prefixCls + '-jump-next'
              },
              props.itemRender(this.getJumpNextPage(), 'jump-next', React$1__default.createElement('a', { className: prefixCls + '-item-link' }))
            );
          }
          lastPager = React$1__default.createElement(Pager, {
            locale: props.locale,
            last: true,
            rootPrefixCls: prefixCls,
            onClick: this.handleChange,
            onKeyPress: this.runIfEnter,
            key: allPages,
            page: allPages,
            active: false,
            showTitle: props.showTitle,
            itemRender: props.itemRender
          });
          firstPager = React$1__default.createElement(Pager, {
            locale: props.locale,
            rootPrefixCls: prefixCls,
            onClick: this.handleChange,
            onKeyPress: this.runIfEnter,
            key: 1,
            page: 1,
            active: false,
            showTitle: props.showTitle,
            itemRender: props.itemRender
          });

          var left = Math.max(1, current - pageBufferSize);
          var right = Math.min(current + pageBufferSize, allPages);

          if (current - 1 <= pageBufferSize) {
            right = 1 + pageBufferSize * 2;
          }

          if (allPages - current <= pageBufferSize) {
            left = allPages - pageBufferSize * 2;
          }

          for (var _i = left; _i <= right; _i++) {
            var _active = current === _i;
            pagerList.push(React$1__default.createElement(Pager, {
              locale: props.locale,
              rootPrefixCls: prefixCls,
              onClick: this.handleChange,
              onKeyPress: this.runIfEnter,
              key: _i,
              page: _i,
              active: _active,
              showTitle: props.showTitle,
              itemRender: props.itemRender
            }));
          }

          if (current - 1 >= pageBufferSize * 2 && current !== 1 + 2) {
            pagerList[0] = React$1__default.cloneElement(pagerList[0], {
              className: prefixCls + '-item-after-jump-prev'
            });
            pagerList.unshift(jumpPrev);
          }
          if (allPages - current >= pageBufferSize * 2 && current !== allPages - 2) {
            pagerList[pagerList.length - 1] = React$1__default.cloneElement(pagerList[pagerList.length - 1], {
              className: prefixCls + '-item-before-jump-next'
            });
            pagerList.push(jumpNext);
          }

          if (left !== 1) {
            pagerList.unshift(firstPager);
          }
          if (right !== allPages) {
            pagerList.push(lastPager);
          }
        }

        var totalText = null;

        if (props.showTotal) {
          totalText = React$1__default.createElement(
            'li',
            { className: prefixCls + '-total-text' },
            props.showTotal(props.total, [(current - 1) * pageSize + 1, current * pageSize > props.total ? props.total : current * pageSize])
          );
        }
        var prevDisabled = !this.hasPrev();
        var nextDisabled = !this.hasNext();
        return React$1__default.createElement(
          'ul',
          _extends$2({
            className: prefixCls + ' ' + props.className,
            style: props.style,
            unselectable: 'unselectable',
            ref: this.savePaginationNode
          }, dataOrAriaAttributeProps),
          totalText,
          React$1__default.createElement(
            'li',
            {
              title: props.showTitle ? locale.prev_page : null,
              onClick: this.prev,
              tabIndex: prevDisabled ? null : 0,
              onKeyPress: this.runIfEnterPrev,
              className: (!prevDisabled ? '' : prefixCls + '-disabled') + ' ' + prefixCls + '-prev',
              'aria-disabled': prevDisabled
            },
            props.itemRender(prevPage, 'prev', React$1__default.createElement('a', { className: prefixCls + '-item-link' }))
          ),
          pagerList,
          React$1__default.createElement(
            'li',
            {
              title: props.showTitle ? locale.next_page : null,
              onClick: this.next,
              tabIndex: nextDisabled ? null : 0,
              onKeyPress: this.runIfEnterNext,
              className: (!nextDisabled ? '' : prefixCls + '-disabled') + ' ' + prefixCls + '-next',
              'aria-disabled': nextDisabled
            },
            props.itemRender(nextPage, 'next', React$1__default.createElement('a', { className: prefixCls + '-item-link' }))
          ),
          React$1__default.createElement(Options, {
            locale: props.locale,
            rootPrefixCls: prefixCls,
            selectComponentClass: props.selectComponentClass,
            selectPrefixCls: props.selectPrefixCls,
            changeSize: this.props.showSizeChanger ? this.changePageSize : null,
            current: this.state.current,
            pageSize: this.state.pageSize,
            pageSizeOptions: this.props.pageSizeOptions,
            quickGo: this.props.showQuickJumper ? this.handleChange : null,
            goButton: goButton
          })
        );
      }
    }]);

    return Pagination;
  }(React$1__default.Component);

  Pagination.propTypes = {
    prefixCls: PropTypes.string,
    current: PropTypes.number,
    defaultCurrent: PropTypes.number,
    total: PropTypes.number,
    pageSize: PropTypes.number,
    defaultPageSize: PropTypes.number,
    onChange: PropTypes.func,
    hideOnSinglePage: PropTypes.bool,
    showSizeChanger: PropTypes.bool,
    showLessItems: PropTypes.bool,
    onShowSizeChange: PropTypes.func,
    selectComponentClass: PropTypes.func,
    showPrevNextJumpers: PropTypes.bool,
    showQuickJumper: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),
    showTitle: PropTypes.bool,
    pageSizeOptions: PropTypes.arrayOf(PropTypes.string),
    showTotal: PropTypes.func,
    locale: PropTypes.object,
    style: PropTypes.object,
    itemRender: PropTypes.func
  };
  Pagination.defaultProps = {
    defaultCurrent: 1,
    total: 0,
    defaultPageSize: 10,
    onChange: noop$c,
    className: '',
    selectPrefixCls: 'rc-select',
    prefixCls: 'rc-pagination',
    selectComponentClass: null,
    hideOnSinglePage: false,
    showPrevNextJumpers: true,
    showQuickJumper: false,
    showSizeChanger: false,
    showLessItems: false,
    showTitle: true,
    onShowSizeChange: noop$c,
    locale: LOCALE,
    style: {},
    itemRender: defaultItemRender
  };

  var _initialiseProps$i = function _initialiseProps() {
    var _this2 = this;

    this.savePaginationNode = function (node) {
      _this2.paginationNode = node;
    };

    this.calculatePage = function (p) {
      var pageSize = p;
      if (typeof pageSize === 'undefined') {
        pageSize = _this2.state.pageSize;
      }
      return Math.floor((_this2.props.total - 1) / pageSize) + 1;
    };

    this.isValid = function (page) {
      return isInteger(page) && page >= 1 && page !== _this2.state.current;
    };

    this.handleKeyDown = function (e) {
      if (e.keyCode === KEYCODE.ARROW_UP || e.keyCode === KEYCODE.ARROW_DOWN) {
        e.preventDefault();
      }
    };

    this.handleKeyUp = function (e) {
      var inputValue = e.target.value;
      var currentInputValue = _this2.state.currentInputValue;
      var value = void 0;

      if (inputValue === '') {
        value = inputValue;
      } else if (isNaN(Number(inputValue))) {
        value = currentInputValue;
      } else {
        value = Number(inputValue);
      }

      if (value !== currentInputValue) {
        _this2.setState({
          currentInputValue: value
        });
      }

      if (e.keyCode === KEYCODE.ENTER) {
        _this2.handleChange(value);
      } else if (e.keyCode === KEYCODE.ARROW_UP) {
        _this2.handleChange(value - 1);
      } else if (e.keyCode === KEYCODE.ARROW_DOWN) {
        _this2.handleChange(value + 1);
      }
    };

    this.changePageSize = function (size) {
      var current = _this2.state.current;
      var newCurrent = _this2.calculatePage(size);
      current = current > newCurrent ? newCurrent : current;
      // fix the issue:
      // Once 'total' is 0, 'current' in 'onShowSizeChange' is 0, which is not correct.
      if (newCurrent === 0) {
        current = _this2.state.current;
      }

      if (typeof size === 'number') {
        if (!('pageSize' in _this2.props)) {
          _this2.setState({
            pageSize: size
          });
        }
        if (!('current' in _this2.props)) {
          _this2.setState({
            current: current,
            currentInputValue: current
          });
        }
      }
      _this2.props.onShowSizeChange(current, size);
    };

    this.handleChange = function (p) {
      var page = p;
      if (_this2.isValid(page)) {
        if (page > _this2.calculatePage()) {
          page = _this2.calculatePage();
        }

        if (!('current' in _this2.props)) {
          _this2.setState({
            current: page,
            currentInputValue: page
          });
        }

        var pageSize = _this2.state.pageSize;
        _this2.props.onChange(page, pageSize);

        return page;
      }

      return _this2.state.current;
    };

    this.prev = function () {
      if (_this2.hasPrev()) {
        _this2.handleChange(_this2.state.current - 1);
      }
    };

    this.next = function () {
      if (_this2.hasNext()) {
        _this2.handleChange(_this2.state.current + 1);
      }
    };

    this.jumpPrev = function () {
      _this2.handleChange(_this2.getJumpPrevPage());
    };

    this.jumpNext = function () {
      _this2.handleChange(_this2.getJumpNextPage());
    };

    this.hasPrev = function () {
      return _this2.state.current > 1;
    };

    this.hasNext = function () {
      return _this2.state.current < _this2.calculatePage();
    };

    this.runIfEnter = function (event, callback) {
      for (var _len = arguments.length, restParams = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        restParams[_key - 2] = arguments[_key];
      }

      if (event.key === 'Enter' || event.charCode === 13) {
        callback.apply(undefined, restParams);
      }
    };

    this.runIfEnterPrev = function (e) {
      _this2.runIfEnter(e, _this2.prev);
    };

    this.runIfEnterNext = function (e) {
      _this2.runIfEnter(e, _this2.next);
    };

    this.runIfEnterJumpPrev = function (e) {
      _this2.runIfEnter(e, _this2.jumpPrev);
    };

    this.runIfEnterJumpNext = function (e) {
      _this2.runIfEnter(e, _this2.jumpNext);
    };

    this.handleGoTO = function (e) {
      if (e.keyCode === KEYCODE.ENTER || e.type === 'click') {
        _this2.handleChange(_this2.state.currentInputValue);
      }
    };
  };



  var es$c = /*#__PURE__*/Object.freeze({
    default: Pagination
  });

  var MiniSelect_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var _select2 = _interopRequireDefault(select);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var MiniSelect = function (_React$Component) {
      (0, _inherits3['default'])(MiniSelect, _React$Component);

      function MiniSelect() {
          (0, _classCallCheck3['default'])(this, MiniSelect);
          return (0, _possibleConstructorReturn3['default'])(this, (MiniSelect.__proto__ || Object.getPrototypeOf(MiniSelect)).apply(this, arguments));
      }

      (0, _createClass3['default'])(MiniSelect, [{
          key: 'render',
          value: function render() {
              return React.createElement(_select2['default'], (0, _extends3['default'])({ size: 'small' }, this.props));
          }
      }]);
      return MiniSelect;
  }(React.Component);

  exports['default'] = MiniSelect;

  MiniSelect.Option = _select2['default'].Option;
  module.exports = exports['default'];
  });

  unwrapExports(MiniSelect_1);

  var _rcPagination = getCjsExportFromNamespace(es$c);

  var Pagination_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var _rcPagination2 = _interopRequireDefault(_rcPagination);



  var _en_US2 = _interopRequireDefault(en_US);



  var _classnames2 = _interopRequireDefault(classnames);



  var _LocaleReceiver2 = _interopRequireDefault(LocaleReceiver_1);



  var _select2 = _interopRequireDefault(select);



  var _MiniSelect2 = _interopRequireDefault(MiniSelect_1);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var __rest = function (s, e) {
      var t = {};
      for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      }if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
      }return t;
  };

  var Pagination = function (_React$Component) {
      (0, _inherits3['default'])(Pagination, _React$Component);

      function Pagination() {
          (0, _classCallCheck3['default'])(this, Pagination);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (Pagination.__proto__ || Object.getPrototypeOf(Pagination)).apply(this, arguments));

          _this.renderPagination = function (locale) {
              var _a = _this.props,
                  className = _a.className,
                  size = _a.size,
                  restProps = __rest(_a, ["className", "size"]);
              var isSmall = size === 'small';
              return React.createElement(_rcPagination2['default'], (0, _extends3['default'])({}, restProps, { className: (0, _classnames2['default'])(className, { mini: isSmall }), selectComponentClass: isSmall ? _MiniSelect2['default'] : _select2['default'], locale: locale }));
          };
          return _this;
      }

      (0, _createClass3['default'])(Pagination, [{
          key: 'render',
          value: function render() {
              return React.createElement(
                  _LocaleReceiver2['default'],
                  { componentName: 'Pagination', defaultLocale: _en_US2['default'] },
                  this.renderPagination
              );
          }
      }]);
      return Pagination;
  }(React.Component);

  exports['default'] = Pagination;

  Pagination.defaultProps = {
      prefixCls: 'ant-pagination',
      selectPrefixCls: 'ant-select'
  };
  module.exports = exports['default'];
  });

  unwrapExports(Pagination_1);

  var pagination = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _Pagination2 = _interopRequireDefault(Pagination_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  exports['default'] = _Pagination2['default'];
  module.exports = exports['default'];
  });

  unwrapExports(pagination);

  var isCssAnimationSupported_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  var animation = void 0;
  function isCssAnimationSupported() {
      if (animation !== undefined) {
          return animation;
      }
      var domPrefixes = 'Webkit Moz O ms Khtml'.split(' ');
      var elm = document.createElement('div');
      if (elm.style.animationName !== undefined) {
          animation = true;
      }
      if (animation !== undefined) {
          for (var i = 0; i < domPrefixes.length; i++) {
              if (elm.style[domPrefixes[i] + 'AnimationName'] !== undefined) {
                  animation = true;
                  break;
              }
          }
      }
      animation = animation || false;
      return animation;
  }
  exports['default'] = isCssAnimationSupported;
  module.exports = exports['default'];
  });

  unwrapExports(isCssAnimationSupported_1);

  var spin = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _classnames2 = _interopRequireDefault(classnames);



  var _rcAnimate2 = _interopRequireDefault(_rcAnimate);



  var _isCssAnimationSupported2 = _interopRequireDefault(isCssAnimationSupported_1);



  var _omit2 = _interopRequireDefault(_omit);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var __rest = function (s, e) {
      var t = {};
      for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      }if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
      }return t;
  };

  var Spin = function (_React$Component) {
      (0, _inherits3['default'])(Spin, _React$Component);

      function Spin(props) {
          (0, _classCallCheck3['default'])(this, Spin);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (Spin.__proto__ || Object.getPrototypeOf(Spin)).call(this, props));

          var spinning = props.spinning;
          _this.state = {
              spinning: spinning
          };
          return _this;
      }

      (0, _createClass3['default'])(Spin, [{
          key: 'isNestedPattern',
          value: function isNestedPattern() {
              return !!(this.props && this.props.children);
          }
      }, {
          key: 'componentDidMount',
          value: function componentDidMount() {
              if (!(0, _isCssAnimationSupported2['default'])()) {
                  // Show text in IE9
                  this.setState({
                      notCssAnimationSupported: true
                  });
              }
          }
      }, {
          key: 'componentWillUnmount',
          value: function componentWillUnmount() {
              if (this.debounceTimeout) {
                  clearTimeout(this.debounceTimeout);
              }
              if (this.delayTimeout) {
                  clearTimeout(this.delayTimeout);
              }
          }
      }, {
          key: 'componentWillReceiveProps',
          value: function componentWillReceiveProps(nextProps) {
              var _this2 = this;

              var currentSpinning = this.props.spinning;
              var spinning = nextProps.spinning;
              var delay = this.props.delay;

              if (this.debounceTimeout) {
                  clearTimeout(this.debounceTimeout);
              }
              if (currentSpinning && !spinning) {
                  this.debounceTimeout = window.setTimeout(function () {
                      return _this2.setState({ spinning: spinning });
                  }, 200);
                  if (this.delayTimeout) {
                      clearTimeout(this.delayTimeout);
                  }
              } else {
                  if (spinning && delay && !isNaN(Number(delay))) {
                      if (this.delayTimeout) {
                          clearTimeout(this.delayTimeout);
                      }
                      this.delayTimeout = window.setTimeout(function () {
                          return _this2.setState({ spinning: spinning });
                      }, delay);
                  } else {
                      this.setState({ spinning: spinning });
                  }
              }
          }
      }, {
          key: 'renderIndicator',
          value: function renderIndicator() {
              var _props = this.props,
                  prefixCls = _props.prefixCls,
                  indicator = _props.indicator;

              var dotClassName = prefixCls + '-dot';
              if (React.isValidElement(indicator)) {
                  return React.cloneElement(indicator, {
                      className: (0, _classnames2['default'])(indicator.props.className, dotClassName)
                  });
              }
              return React.createElement(
                  'span',
                  { className: (0, _classnames2['default'])(dotClassName, prefixCls + '-dot-spin') },
                  React.createElement('i', null),
                  React.createElement('i', null),
                  React.createElement('i', null),
                  React.createElement('i', null)
              );
          }
      }, {
          key: 'render',
          value: function render() {
              var _classNames;

              var _a = this.props,
                  className = _a.className,
                  size = _a.size,
                  prefixCls = _a.prefixCls,
                  tip = _a.tip,
                  wrapperClassName = _a.wrapperClassName,
                  restProps = __rest(_a, ["className", "size", "prefixCls", "tip", "wrapperClassName"]);var _state = this.state,
                  spinning = _state.spinning,
                  notCssAnimationSupported = _state.notCssAnimationSupported;

              var spinClassName = (0, _classnames2['default'])(prefixCls, (_classNames = {}, (0, _defineProperty3['default'])(_classNames, prefixCls + '-sm', size === 'small'), (0, _defineProperty3['default'])(_classNames, prefixCls + '-lg', size === 'large'), (0, _defineProperty3['default'])(_classNames, prefixCls + '-spinning', spinning), (0, _defineProperty3['default'])(_classNames, prefixCls + '-show-text', !!tip || notCssAnimationSupported), _classNames), className);
              // fix https://fb.me/react-unknown-prop
              var divProps = (0, _omit2['default'])(restProps, ['spinning', 'delay', 'indicator']);
              var spinElement = React.createElement(
                  'div',
                  (0, _extends3['default'])({}, divProps, { className: spinClassName }),
                  this.renderIndicator(),
                  tip ? React.createElement(
                      'div',
                      { className: prefixCls + '-text' },
                      tip
                  ) : null
              );
              if (this.isNestedPattern()) {
                  var _classNames2;

                  var animateClassName = prefixCls + '-nested-loading';
                  if (wrapperClassName) {
                      animateClassName += ' ' + wrapperClassName;
                  }
                  var containerClassName = (0, _classnames2['default'])((_classNames2 = {}, (0, _defineProperty3['default'])(_classNames2, prefixCls + '-container', true), (0, _defineProperty3['default'])(_classNames2, prefixCls + '-blur', spinning), _classNames2));
                  return React.createElement(
                      _rcAnimate2['default'],
                      (0, _extends3['default'])({}, divProps, { component: 'div', className: animateClassName, style: null, transitionName: 'fade' }),
                      spinning && React.createElement(
                          'div',
                          { key: 'loading' },
                          spinElement
                      ),
                      React.createElement(
                          'div',
                          { className: containerClassName, key: 'container' },
                          this.props.children
                      )
                  );
              }
              return spinElement;
          }
      }]);
      return Spin;
  }(React.Component);

  exports['default'] = Spin;

  Spin.defaultProps = {
      prefixCls: 'ant-spin',
      spinning: true,
      size: 'default',
      wrapperClassName: ''
  };
  Spin.propTypes = {
      prefixCls: _propTypes2['default'].string,
      className: _propTypes2['default'].string,
      spinning: _propTypes2['default'].bool,
      size: _propTypes2['default'].oneOf(['small', 'default', 'large']),
      wrapperClassName: _propTypes2['default'].string,
      indicator: _propTypes2['default'].node
  };
  module.exports = exports['default'];
  });

  var Spin = unwrapExports(spin);

  /**
   * Determine if a DOM element matches a CSS selector
   *
   * @param {Element} elem
   * @param {String} selector
   * @return {Boolean}
   * @api public
   */

  function matches(elem, selector) {
    // Vendor-specific implementations of `Element.prototype.matches()`.
    var proto = window.Element.prototype;
    var nativeMatches = proto.matches ||
        proto.mozMatchesSelector ||
        proto.msMatchesSelector ||
        proto.oMatchesSelector ||
        proto.webkitMatchesSelector;

    if (!elem || elem.nodeType !== 1) {
      return false;
    }

    var parentElem = elem.parentNode;

    // use native 'matches'
    if (nativeMatches) {
      return nativeMatches.call(elem, selector);
    }

    // native support for `matches` is missing and a fallback is required
    var nodes = parentElem.querySelectorAll(selector);
    var len = nodes.length;

    for (var i = 0; i < len; i++) {
      if (nodes[i] === elem) {
        return true;
      }
    }

    return false;
  }

  /**
   * Expose `matches`
   */

  var domMatches = matches;

  /**
   * Module dependencies
   */



  /**
   * @param element {Element}
   * @param selector {String}
   * @param context {Element}
   * @return {Element}
   */
  var domClosest = function (element, selector, context) {
    context = context || document;
    // guard against orphans
    element = { parentNode: element };

    while ((element = element.parentNode) && element !== context) {
      if (domMatches(element, selector)) {
        return element;
      }
    }
  };

  /**
   * lodash 3.9.1 (Custom Build) <https://lodash.com/>
   * Build: `lodash modern modularize exports="npm" -o ./`
   * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   * Available under MIT license <https://lodash.com/license>
   */

  /** `Object#toString` result references. */
  var funcTag$2 = '[object Function]';

  /** Used to detect host constructors (Safari > 5). */
  var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;

  /**
   * Checks if `value` is object-like.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   */
  function isObjectLike$1(value) {
    return !!value && typeof value == 'object';
  }

  /** Used for native method references. */
  var objectProto$c = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var fnToString = Function.prototype.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$c = objectProto$c.hasOwnProperty;

  /**
   * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
   * of values.
   */
  var objToString = objectProto$c.toString;

  /** Used to detect if a method is native. */
  var reIsNative$1 = RegExp('^' +
    fnToString.call(hasOwnProperty$c).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative$1(object, key) {
    var value = object == null ? undefined : object[key];
    return isNative(value) ? value : undefined;
  }

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction$3(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in older versions of Chrome and Safari which return 'function' for regexes
    // and Safari 8 equivalents which return 'object' for typed array constructors.
    return isObject$1(value) && objToString.call(value) == funcTag$2;
  }

  /**
   * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
   * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(1);
   * // => false
   */
  function isObject$1(value) {
    // Avoid a V8 JIT bug in Chrome 19-20.
    // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }

  /**
   * Checks if `value` is a native function.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
   * @example
   *
   * _.isNative(Array.prototype.push);
   * // => true
   *
   * _.isNative(_);
   * // => false
   */
  function isNative(value) {
    if (value == null) {
      return false;
    }
    if (isFunction$3(value)) {
      return reIsNative$1.test(fnToString.call(value));
    }
    return isObjectLike$1(value) && reIsHostCtor$1.test(value);
  }

  var lodash__getnative = getNative$1;

  /**
   * lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="npm" -o ./`
   * Copyright jQuery Foundation and other contributors <https://jquery.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$2 = 9007199254740991;

  /** `Object#toString` result references. */
  var argsTag$2 = '[object Arguments]',
      funcTag$3 = '[object Function]',
      genTag$1 = '[object GeneratorFunction]';

  /** Used for built-in method references. */
  var objectProto$d = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$d = objectProto$d.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var objectToString$1 = objectProto$d.toString;

  /** Built-in value references. */
  var propertyIsEnumerable$1 = objectProto$d.propertyIsEnumerable;

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  function isArguments$1(value) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    return isArrayLikeObject$1(value) && hasOwnProperty$d.call(value, 'callee') &&
      (!propertyIsEnumerable$1.call(value, 'callee') || objectToString$1.call(value) == argsTag$2);
  }

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike$1(value) {
    return value != null && isLength$1(value.length) && !isFunction$4(value);
  }

  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */
  function isArrayLikeObject$1(value) {
    return isObjectLike$2(value) && isArrayLike$1(value);
  }

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction$4(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject$2(value) ? objectToString$1.call(value) : '';
    return tag == funcTag$3 || tag == genTag$1;
  }

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength$1(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$2;
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject$2(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike$2(value) {
    return !!value && typeof value == 'object';
  }

  var lodash_isarguments = isArguments$1;

  /**
   * lodash 3.0.4 (Custom Build) <https://lodash.com/>
   * Build: `lodash modern modularize exports="npm" -o ./`
   * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   * Available under MIT license <https://lodash.com/license>
   */

  /** `Object#toString` result references. */
  var arrayTag$1 = '[object Array]',
      funcTag$4 = '[object Function]';

  /** Used to detect host constructors (Safari > 5). */
  var reIsHostCtor$2 = /^\[object .+?Constructor\]$/;

  /**
   * Checks if `value` is object-like.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   */
  function isObjectLike$3(value) {
    return !!value && typeof value == 'object';
  }

  /** Used for native method references. */
  var objectProto$e = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var fnToString$1 = Function.prototype.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$e = objectProto$e.hasOwnProperty;

  /**
   * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
   * of values.
   */
  var objToString$1 = objectProto$e.toString;

  /** Used to detect if a method is native. */
  var reIsNative$2 = RegExp('^' +
    fnToString$1.call(hasOwnProperty$e).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /* Native method references for those with the same name as other `lodash` methods. */
  var nativeIsArray = getNative$2(Array, 'isArray');

  /**
   * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
   * of an array-like value.
   */
  var MAX_SAFE_INTEGER$3 = 9007199254740991;

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative$2(object, key) {
    var value = object == null ? undefined : object[key];
    return isNative$1(value) ? value : undefined;
  }

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   */
  function isLength$2(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$3;
  }

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(function() { return arguments; }());
   * // => false
   */
  var isArray$3 = nativeIsArray || function(value) {
    return isObjectLike$3(value) && isLength$2(value.length) && objToString$1.call(value) == arrayTag$1;
  };

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction$5(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in older versions of Chrome and Safari which return 'function' for regexes
    // and Safari 8 equivalents which return 'object' for typed array constructors.
    return isObject$3(value) && objToString$1.call(value) == funcTag$4;
  }

  /**
   * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
   * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(1);
   * // => false
   */
  function isObject$3(value) {
    // Avoid a V8 JIT bug in Chrome 19-20.
    // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }

  /**
   * Checks if `value` is a native function.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
   * @example
   *
   * _.isNative(Array.prototype.push);
   * // => true
   *
   * _.isNative(_);
   * // => false
   */
  function isNative$1(value) {
    if (value == null) {
      return false;
    }
    if (isFunction$5(value)) {
      return reIsNative$2.test(fnToString$1.call(value));
    }
    return isObjectLike$3(value) && reIsHostCtor$2.test(value);
  }

  var lodash_isarray = isArray$3;

  /**
   * lodash 3.1.2 (Custom Build) <https://lodash.com/>
   * Build: `lodash modern modularize exports="npm" -o ./`
   * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   * Available under MIT license <https://lodash.com/license>
   */


  /** Used to detect unsigned integer values. */
  var reIsUint$1 = /^\d+$/;

  /** Used for native method references. */
  var objectProto$f = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$f = objectProto$f.hasOwnProperty;

  /* Native method references for those with the same name as other `lodash` methods. */
  var nativeKeys = lodash__getnative(Object, 'keys');

  /**
   * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
   * of an array-like value.
   */
  var MAX_SAFE_INTEGER$4 = 9007199254740991;

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * Gets the "length" property value of `object`.
   *
   * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
   * that affects Safari on at least iOS 8.1-8.3 ARM64.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {*} Returns the "length" value.
   */
  var getLength = baseProperty('length');

  /**
   * Checks if `value` is array-like.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   */
  function isArrayLike$2(value) {
    return value != null && isLength$3(getLength(value));
  }

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex$1(value, length) {
    value = (typeof value == 'number' || reIsUint$1.test(value)) ? +value : -1;
    length = length == null ? MAX_SAFE_INTEGER$4 : length;
    return value > -1 && value % 1 == 0 && value < length;
  }

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   */
  function isLength$3(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$4;
  }

  /**
   * A fallback implementation of `Object.keys` which creates an array of the
   * own enumerable property names of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function shimKeys(object) {
    var props = keysIn$1(object),
        propsLength = props.length,
        length = propsLength && object.length;

    var allowIndexes = !!length && isLength$3(length) &&
      (lodash_isarray(object) || lodash_isarguments(object));

    var index = -1,
        result = [];

    while (++index < propsLength) {
      var key = props[index];
      if ((allowIndexes && isIndex$1(key, length)) || hasOwnProperty$f.call(object, key)) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
   * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(1);
   * // => false
   */
  function isObject$4(value) {
    // Avoid a V8 JIT bug in Chrome 19-20.
    // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  var keys = !nativeKeys ? shimKeys : function(object) {
    var Ctor = object == null ? undefined : object.constructor;
    if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
        (typeof object != 'function' && isArrayLike$2(object))) {
      return shimKeys(object);
    }
    return isObject$4(object) ? nativeKeys(object) : [];
  };

  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */
  function keysIn$1(object) {
    if (object == null) {
      return [];
    }
    if (!isObject$4(object)) {
      object = Object(object);
    }
    var length = object.length;
    length = (length && isLength$3(length) &&
      (lodash_isarray(object) || lodash_isarguments(object)) && length) || 0;

    var Ctor = object.constructor,
        index = -1,
        isProto = typeof Ctor == 'function' && Ctor.prototype === object,
        result = Array(length),
        skipIndexes = length > 0;

    while (++index < length) {
      result[index] = (index + '');
    }
    for (var key in object) {
      if (!(skipIndexes && isIndex$1(key, length)) &&
          !(key == 'constructor' && (isProto || !hasOwnProperty$f.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }

  var lodash_keys = keys;

  var modules = function shallowEqual(objA, objB, compare, compareContext) {

      var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

      if (ret !== void 0) {
          return !!ret;
      }

      if (objA === objB) {
          return true;
      }

      if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
          return false;
      }

      var keysA = lodash_keys(objA);
      var keysB = lodash_keys(objB);

      var len = keysA.length;
      if (len !== keysB.length) {
          return false;
      }

      compareContext = compareContext || null;

      // Test for A's keys different from B.
      var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
      for (var i = 0; i < len; i++) {
          var key = keysA[i];
          if (!bHasOwnProperty(key)) {
              return false;
          }
          var valueA = objA[key];
          var valueB = objB[key];

          var _ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
          if (_ret === false || _ret === void 0 && valueA !== valueB) {
              return false;
          }
      }

      return true;
  };

  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule ReactComponentWithPureRenderMixin
   */



  function shallowCompare(instance, nextProps, nextState) {
    return !modules(instance.props, nextProps) || !modules(instance.state, nextState);
  }

  /**
   * If your React component's render function is "pure", e.g. it will render the
   * same result given the same props and state, provide this mixin for a
   * considerable performance boost.
   *
   * Most React components have pure render functions.
   *
   * Example:
   *
   *   var ReactComponentWithPureRenderMixin =
   *     require('ReactComponentWithPureRenderMixin');
   *   React.createClass({
   *     mixins: [ReactComponentWithPureRenderMixin],
   *
   *     render: function() {
   *       return <div className={this.props.className}>foo</div>;
   *     }
   *   });
   *
   * Note: This only checks shallow equality for props and state. If these contain
   * complex data structures this mixin may have false-negatives for deeper
   * differences. Only mixin to components which have simple props and state, or
   * use `forceUpdate()` when you know deep data structures have changed.
   *
   * See https://facebook.github.io/react/docs/pure-render-mixin.html
   */
  var ReactComponentWithPureRenderMixin = {
    shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
      return shallowCompare(this, nextProps, nextState);
    }
  };

  var PureRenderMixin = ReactComponentWithPureRenderMixin;

  var Checkbox = function (_React$Component) {
    _inherits$1(Checkbox, _React$Component);

    function Checkbox(props) {
      _classCallCheck$1(this, Checkbox);

      var _this = _possibleConstructorReturn$1(this, _React$Component.call(this, props));

      _initialiseProps$j.call(_this);

      var checked = 'checked' in props ? props.checked : props.defaultChecked;

      _this.state = {
        checked: checked
      };
      return _this;
    }

    Checkbox.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if ('checked' in nextProps) {
        this.setState({
          checked: nextProps.checked
        });
      }
    };

    Checkbox.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return PureRenderMixin.shouldComponentUpdate.apply(this, args);
    };

    Checkbox.prototype.focus = function focus() {
      this.input.focus();
    };

    Checkbox.prototype.blur = function blur() {
      this.input.blur();
    };

    Checkbox.prototype.render = function render() {
      var _classNames;

      var _props = this.props,
          prefixCls = _props.prefixCls,
          className = _props.className,
          style = _props.style,
          name = _props.name,
          id = _props.id,
          type = _props.type,
          disabled = _props.disabled,
          readOnly = _props.readOnly,
          tabIndex = _props.tabIndex,
          onClick = _props.onClick,
          onFocus = _props.onFocus,
          onBlur = _props.onBlur,
          autoFocus = _props.autoFocus,
          value = _props.value,
          others = _objectWithoutProperties$1(_props, ['prefixCls', 'className', 'style', 'name', 'id', 'type', 'disabled', 'readOnly', 'tabIndex', 'onClick', 'onFocus', 'onBlur', 'autoFocus', 'value']);

      var globalProps = Object.keys(others).reduce(function (prev, key) {
        if (key.substr(0, 5) === 'aria-' || key.substr(0, 5) === 'data-' || key === 'role') {
          prev[key] = others[key];
        }
        return prev;
      }, {});

      var checked = this.state.checked;

      var classString = classnames(prefixCls, className, (_classNames = {}, _classNames[prefixCls + '-checked'] = checked, _classNames[prefixCls + '-disabled'] = disabled, _classNames));

      return React$1__default.createElement(
        'span',
        { className: classString, style: style },
        React$1__default.createElement('input', _extends$2({
          name: name,
          id: id,
          type: type,
          readOnly: readOnly,
          disabled: disabled,
          tabIndex: tabIndex,
          className: prefixCls + '-input',
          checked: !!checked,
          onClick: onClick,
          onFocus: onFocus,
          onBlur: onBlur,
          onChange: this.handleChange,
          autoFocus: autoFocus,
          ref: this.saveInput,
          value: value
        }, globalProps)),
        React$1__default.createElement('span', { className: prefixCls + '-inner' })
      );
    };

    return Checkbox;
  }(React$1__default.Component);

  Checkbox.propTypes = {
    prefixCls: PropTypes.string,
    className: PropTypes.string,
    style: PropTypes.object,
    name: PropTypes.string,
    id: PropTypes.string,
    type: PropTypes.string,
    defaultChecked: PropTypes.oneOfType([PropTypes.number, PropTypes.bool]),
    checked: PropTypes.oneOfType([PropTypes.number, PropTypes.bool]),
    disabled: PropTypes.bool,
    onFocus: PropTypes.func,
    onBlur: PropTypes.func,
    onChange: PropTypes.func,
    onClick: PropTypes.func,
    tabIndex: PropTypes.string,
    readOnly: PropTypes.bool,
    autoFocus: PropTypes.bool,
    value: PropTypes.any
  };
  Checkbox.defaultProps = {
    prefixCls: 'rc-checkbox',
    className: '',
    style: {},
    type: 'checkbox',
    defaultChecked: false,
    onFocus: function onFocus() {},
    onBlur: function onBlur() {},
    onChange: function onChange() {}
  };

  var _initialiseProps$j = function _initialiseProps() {
    var _this2 = this;

    this.handleChange = function (e) {
      var props = _this2.props;

      if (props.disabled) {
        return;
      }
      if (!('checked' in props)) {
        _this2.setState({
          checked: e.target.checked
        });
      }
      props.onChange({
        target: _extends$2({}, props, {
          checked: e.target.checked
        }),
        stopPropagation: function stopPropagation() {
          e.stopPropagation();
        },
        preventDefault: function preventDefault() {
          e.preventDefault();
        },

        nativeEvent: e.nativeEvent
      });
    };

    this.saveInput = function (node) {
      _this2.input = node;
    };
  };



  var es$d = /*#__PURE__*/Object.freeze({
    default: Checkbox
  });

  var _rcCheckbox = getCjsExportFromNamespace(es$d);

  var Checkbox_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _extends3 = _interopRequireDefault(_extends$1);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _classnames2 = _interopRequireDefault(classnames);



  var _rcCheckbox2 = _interopRequireDefault(_rcCheckbox);



  var _shallowequal2 = _interopRequireDefault(shallowequal);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var __rest = function (s, e) {
      var t = {};
      for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      }if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
      }return t;
  };

  var Checkbox = function (_React$Component) {
      (0, _inherits3['default'])(Checkbox, _React$Component);

      function Checkbox() {
          (0, _classCallCheck3['default'])(this, Checkbox);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (Checkbox.__proto__ || Object.getPrototypeOf(Checkbox)).apply(this, arguments));

          _this.saveCheckbox = function (node) {
              _this.rcCheckbox = node;
          };
          return _this;
      }

      (0, _createClass3['default'])(Checkbox, [{
          key: 'shouldComponentUpdate',
          value: function shouldComponentUpdate(nextProps, nextState, nextContext) {
              return !(0, _shallowequal2['default'])(this.props, nextProps) || !(0, _shallowequal2['default'])(this.state, nextState) || !(0, _shallowequal2['default'])(this.context.checkboxGroup, nextContext.checkboxGroup);
          }
      }, {
          key: 'focus',
          value: function focus() {
              this.rcCheckbox.focus();
          }
      }, {
          key: 'blur',
          value: function blur() {
              this.rcCheckbox.blur();
          }
      }, {
          key: 'render',
          value: function render() {
              var props = this.props,
                  context = this.context;

              var prefixCls = props.prefixCls,
                  className = props.className,
                  children = props.children,
                  indeterminate = props.indeterminate,
                  style = props.style,
                  onMouseEnter = props.onMouseEnter,
                  onMouseLeave = props.onMouseLeave,
                  restProps = __rest(props, ["prefixCls", "className", "children", "indeterminate", "style", "onMouseEnter", "onMouseLeave"]);

              var checkboxGroup = context.checkboxGroup;

              var checkboxProps = (0, _extends3['default'])({}, restProps);
              if (checkboxGroup) {
                  checkboxProps.onChange = function () {
                      return checkboxGroup.toggleOption({ label: children, value: props.value });
                  };
                  checkboxProps.checked = checkboxGroup.value.indexOf(props.value) !== -1;
                  checkboxProps.disabled = props.disabled || checkboxGroup.disabled;
              }
              var classString = (0, _classnames2['default'])(className, (0, _defineProperty3['default'])({}, prefixCls + '-wrapper', true));
              var checkboxClass = (0, _classnames2['default'])((0, _defineProperty3['default'])({}, prefixCls + '-indeterminate', indeterminate));
              return React.createElement(
                  'label',
                  { className: classString, style: style, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave },
                  React.createElement(_rcCheckbox2['default'], (0, _extends3['default'])({}, checkboxProps, { prefixCls: prefixCls, className: checkboxClass, ref: this.saveCheckbox })),
                  children !== undefined ? React.createElement(
                      'span',
                      null,
                      children
                  ) : null
              );
          }
      }]);
      return Checkbox;
  }(React.Component);

  exports['default'] = Checkbox;

  Checkbox.defaultProps = {
      prefixCls: 'ant-checkbox',
      indeterminate: false
  };
  Checkbox.contextTypes = {
      checkboxGroup: _propTypes2['default'].any
  };
  module.exports = exports['default'];
  });

  unwrapExports(Checkbox_1);

  var Group$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _toConsumableArray3 = _interopRequireDefault(toConsumableArray);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _classnames2 = _interopRequireDefault(classnames);



  var _shallowequal2 = _interopRequireDefault(shallowequal);



  var _Checkbox2 = _interopRequireDefault(Checkbox_1);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var CheckboxGroup = function (_React$Component) {
      (0, _inherits3['default'])(CheckboxGroup, _React$Component);

      function CheckboxGroup(props) {
          (0, _classCallCheck3['default'])(this, CheckboxGroup);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (CheckboxGroup.__proto__ || Object.getPrototypeOf(CheckboxGroup)).call(this, props));

          _this.toggleOption = function (option) {
              var optionIndex = _this.state.value.indexOf(option.value);
              var value = [].concat((0, _toConsumableArray3['default'])(_this.state.value));
              if (optionIndex === -1) {
                  value.push(option.value);
              } else {
                  value.splice(optionIndex, 1);
              }
              if (!('value' in _this.props)) {
                  _this.setState({ value: value });
              }
              var onChange = _this.props.onChange;
              if (onChange) {
                  onChange(value);
              }
          };
          _this.state = {
              value: props.value || props.defaultValue || []
          };
          return _this;
      }

      (0, _createClass3['default'])(CheckboxGroup, [{
          key: 'getChildContext',
          value: function getChildContext() {
              return {
                  checkboxGroup: {
                      toggleOption: this.toggleOption,
                      value: this.state.value,
                      disabled: this.props.disabled
                  }
              };
          }
      }, {
          key: 'componentWillReceiveProps',
          value: function componentWillReceiveProps(nextProps) {
              if ('value' in nextProps) {
                  this.setState({
                      value: nextProps.value || []
                  });
              }
          }
      }, {
          key: 'shouldComponentUpdate',
          value: function shouldComponentUpdate(nextProps, nextState) {
              return !(0, _shallowequal2['default'])(this.props, nextProps) || !(0, _shallowequal2['default'])(this.state, nextState);
          }
      }, {
          key: 'getOptions',
          value: function getOptions() {
              var options = this.props.options;
              // https://github.com/Microsoft/TypeScript/issues/7960

              return options.map(function (option) {
                  if (typeof option === 'string') {
                      return {
                          label: option,
                          value: option
                      };
                  }
                  return option;
              });
          }
      }, {
          key: 'render',
          value: function render() {
              var _this2 = this;

              var props = this.props,
                  state = this.state;
              var prefixCls = props.prefixCls,
                  className = props.className,
                  style = props.style,
                  options = props.options;

              var groupPrefixCls = prefixCls + '-group';
              var children = props.children;
              if (options && options.length > 0) {
                  children = this.getOptions().map(function (option) {
                      return React.createElement(
                          _Checkbox2['default'],
                          { prefixCls: prefixCls, key: option.value, disabled: 'disabled' in option ? option.disabled : props.disabled, value: option.value, checked: state.value.indexOf(option.value) !== -1, onChange: function onChange() {
                                  return _this2.toggleOption(option);
                              }, className: groupPrefixCls + '-item' },
                          option.label
                      );
                  });
              }
              var classString = (0, _classnames2['default'])(groupPrefixCls, className);
              return React.createElement(
                  'div',
                  { className: classString, style: style },
                  children
              );
          }
      }]);
      return CheckboxGroup;
  }(React.Component);

  exports['default'] = CheckboxGroup;

  CheckboxGroup.defaultProps = {
      options: [],
      prefixCls: 'ant-checkbox'
  };
  CheckboxGroup.propTypes = {
      defaultValue: _propTypes2['default'].array,
      value: _propTypes2['default'].array,
      options: _propTypes2['default'].array.isRequired,
      onChange: _propTypes2['default'].func
  };
  CheckboxGroup.childContextTypes = {
      checkboxGroup: _propTypes2['default'].any
  };
  module.exports = exports['default'];
  });

  unwrapExports(Group$1);

  var checkbox = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _Checkbox2 = _interopRequireDefault(Checkbox_1);



  var _Group2 = _interopRequireDefault(Group$1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  _Checkbox2['default'].Group = _Group2['default'];
  exports['default'] = _Checkbox2['default'];
  module.exports = exports['default'];
  });

  var Checkbox$2 = unwrapExports(checkbox);

  var radio = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _extends3 = _interopRequireDefault(_extends$1);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _rcCheckbox2 = _interopRequireDefault(_rcCheckbox);



  var _classnames2 = _interopRequireDefault(classnames);



  var _shallowequal2 = _interopRequireDefault(shallowequal);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var __rest = function (s, e) {
      var t = {};
      for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      }if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
      }return t;
  };

  var Radio = function (_React$Component) {
      (0, _inherits3['default'])(Radio, _React$Component);

      function Radio() {
          (0, _classCallCheck3['default'])(this, Radio);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (Radio.__proto__ || Object.getPrototypeOf(Radio)).apply(this, arguments));

          _this.saveCheckbox = function (node) {
              _this.rcCheckbox = node;
          };
          return _this;
      }

      (0, _createClass3['default'])(Radio, [{
          key: 'shouldComponentUpdate',
          value: function shouldComponentUpdate(nextProps, nextState, nextContext) {
              return !(0, _shallowequal2['default'])(this.props, nextProps) || !(0, _shallowequal2['default'])(this.state, nextState) || !(0, _shallowequal2['default'])(this.context.radioGroup, nextContext.radioGroup);
          }
      }, {
          key: 'focus',
          value: function focus() {
              this.rcCheckbox.focus();
          }
      }, {
          key: 'blur',
          value: function blur() {
              this.rcCheckbox.blur();
          }
      }, {
          key: 'render',
          value: function render() {
              var _classNames;

              var props = this.props,
                  context = this.context;

              var prefixCls = props.prefixCls,
                  className = props.className,
                  children = props.children,
                  style = props.style,
                  restProps = __rest(props, ["prefixCls", "className", "children", "style"]);

              var radioGroup = context.radioGroup;

              var radioProps = (0, _extends3['default'])({}, restProps);
              if (radioGroup) {
                  radioProps.name = radioGroup.name;
                  radioProps.onChange = radioGroup.onChange;
                  radioProps.checked = props.value === radioGroup.value;
                  radioProps.disabled = props.disabled || radioGroup.disabled;
              }
              var wrapperClassString = (0, _classnames2['default'])(className, (_classNames = {}, (0, _defineProperty3['default'])(_classNames, prefixCls + '-wrapper', true), (0, _defineProperty3['default'])(_classNames, prefixCls + '-wrapper-checked', radioProps.checked), (0, _defineProperty3['default'])(_classNames, prefixCls + '-wrapper-disabled', radioProps.disabled), _classNames));
              return React.createElement(
                  'label',
                  { className: wrapperClassString, style: style, onMouseEnter: props.onMouseEnter, onMouseLeave: props.onMouseLeave },
                  React.createElement(_rcCheckbox2['default'], (0, _extends3['default'])({}, radioProps, { prefixCls: prefixCls, ref: this.saveCheckbox })),
                  children !== undefined ? React.createElement(
                      'span',
                      null,
                      children
                  ) : null
              );
          }
      }]);
      return Radio;
  }(React.Component);

  exports['default'] = Radio;

  Radio.defaultProps = {
      prefixCls: 'ant-radio',
      type: 'radio'
  };
  Radio.contextTypes = {
      radioGroup: _propTypes2['default'].any
  };
  module.exports = exports['default'];
  });

  unwrapExports(radio);

  var group = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _classnames2 = _interopRequireDefault(classnames);



  var _shallowequal2 = _interopRequireDefault(shallowequal);



  var _radio2 = _interopRequireDefault(radio);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function getCheckedValue(children) {
      var value = null;
      var matched = false;
      React.Children.forEach(children, function (radio$$1) {
          if (radio$$1 && radio$$1.props && radio$$1.props.checked) {
              value = radio$$1.props.value;
              matched = true;
          }
      });
      return matched ? { value: value } : undefined;
  }

  var RadioGroup = function (_React$Component) {
      (0, _inherits3['default'])(RadioGroup, _React$Component);

      function RadioGroup(props) {
          (0, _classCallCheck3['default'])(this, RadioGroup);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (RadioGroup.__proto__ || Object.getPrototypeOf(RadioGroup)).call(this, props));

          _this.onRadioChange = function (ev) {
              var lastValue = _this.state.value;
              var value = ev.target.value;

              if (!('value' in _this.props)) {
                  _this.setState({
                      value: value
                  });
              }
              var onChange = _this.props.onChange;
              if (onChange && value !== lastValue) {
                  onChange(ev);
              }
          };
          var value = void 0;
          if ('value' in props) {
              value = props.value;
          } else if ('defaultValue' in props) {
              value = props.defaultValue;
          } else {
              var checkedValue = getCheckedValue(props.children);
              value = checkedValue && checkedValue.value;
          }
          _this.state = {
              value: value
          };
          return _this;
      }

      (0, _createClass3['default'])(RadioGroup, [{
          key: 'getChildContext',
          value: function getChildContext() {
              return {
                  radioGroup: {
                      onChange: this.onRadioChange,
                      value: this.state.value,
                      disabled: this.props.disabled,
                      name: this.props.name
                  }
              };
          }
      }, {
          key: 'componentWillReceiveProps',
          value: function componentWillReceiveProps(nextProps) {
              if ('value' in nextProps) {
                  this.setState({
                      value: nextProps.value
                  });
              } else {
                  var checkedValue = getCheckedValue(nextProps.children);
                  if (checkedValue) {
                      this.setState({
                          value: checkedValue.value
                      });
                  }
              }
          }
      }, {
          key: 'shouldComponentUpdate',
          value: function shouldComponentUpdate(nextProps, nextState) {
              return !(0, _shallowequal2['default'])(this.props, nextProps) || !(0, _shallowequal2['default'])(this.state, nextState);
          }
      }, {
          key: 'render',
          value: function render() {
              var _this2 = this;

              var props = this.props;
              var prefixCls = props.prefixCls,
                  _props$className = props.className,
                  className = _props$className === undefined ? '' : _props$className,
                  options = props.options;

              var groupPrefixCls = prefixCls + '-group';
              var classString = (0, _classnames2['default'])(groupPrefixCls, (0, _defineProperty3['default'])({}, groupPrefixCls + '-' + props.size, props.size), className);
              var children = props.children;
              // 如果存在 options, 优先使用
              if (options && options.length > 0) {
                  children = options.map(function (option, index) {
                      if (typeof option === 'string') {
                          // 此处类型自动推导为 string
                          return React.createElement(
                              _radio2['default'],
                              { key: index, prefixCls: prefixCls, disabled: _this2.props.disabled, value: option, onChange: _this2.onRadioChange, checked: _this2.state.value === option },
                              option
                          );
                      } else {
                          // 此处类型自动推导为 { label: string value: string }
                          return React.createElement(
                              _radio2['default'],
                              { key: index, prefixCls: prefixCls, disabled: option.disabled || _this2.props.disabled, value: option.value, onChange: _this2.onRadioChange, checked: _this2.state.value === option.value },
                              option.label
                          );
                      }
                  });
              }
              return React.createElement(
                  'div',
                  { className: classString, style: props.style, onMouseEnter: props.onMouseEnter, onMouseLeave: props.onMouseLeave, id: props.id },
                  children
              );
          }
      }]);
      return RadioGroup;
  }(React.Component);

  exports['default'] = RadioGroup;

  RadioGroup.defaultProps = {
      disabled: false,
      prefixCls: 'ant-radio'
  };
  RadioGroup.childContextTypes = {
      radioGroup: _propTypes2['default'].any
  };
  module.exports = exports['default'];
  });

  unwrapExports(group);

  var radioButton = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _radio2 = _interopRequireDefault(radio);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var RadioButton = function (_React$Component) {
      (0, _inherits3['default'])(RadioButton, _React$Component);

      function RadioButton() {
          (0, _classCallCheck3['default'])(this, RadioButton);
          return (0, _possibleConstructorReturn3['default'])(this, (RadioButton.__proto__ || Object.getPrototypeOf(RadioButton)).apply(this, arguments));
      }

      (0, _createClass3['default'])(RadioButton, [{
          key: 'render',
          value: function render() {
              var radioProps = (0, _extends3['default'])({}, this.props);
              if (this.context.radioGroup) {
                  radioProps.onChange = this.context.radioGroup.onChange;
                  radioProps.checked = this.props.value === this.context.radioGroup.value;
                  radioProps.disabled = this.props.disabled || this.context.radioGroup.disabled;
              }
              return React.createElement(_radio2['default'], radioProps);
          }
      }]);
      return RadioButton;
  }(React.Component);

  exports['default'] = RadioButton;

  RadioButton.defaultProps = {
      prefixCls: 'ant-radio-button'
  };
  RadioButton.contextTypes = {
      radioGroup: _propTypes2['default'].any
  };
  module.exports = exports['default'];
  });

  unwrapExports(radioButton);

  var radio$2 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Group = exports.Button = undefined;



  var _radio2 = _interopRequireDefault(radio);



  var _group2 = _interopRequireDefault(group);



  var _radioButton2 = _interopRequireDefault(radioButton);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  _radio2['default'].Button = _radioButton2['default'];
  _radio2['default'].Group = _group2['default'];
  exports.Button = _radioButton2['default'];
  exports.Group = _group2['default'];
  exports['default'] = _radio2['default'];
  });

  unwrapExports(radio$2);
  var radio_1 = radio$2.Group;
  var radio_2 = radio$2.Button;

  var FilterDropdownMenuWrapper = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var React = _interopRequireWildcard(React$1__default);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  exports['default'] = function (props) {
      return React.createElement(
          'div',
          { className: props.className, onClick: props.onClick },
          props.children
      );
  };

  module.exports = exports['default'];
  });

  unwrapExports(FilterDropdownMenuWrapper);

  var filterDropdown = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var ReactDOM$$1 = _interopRequireWildcard(ReactDOM__default);



  var _rcMenu2 = _interopRequireDefault(_rcMenu);



  var _domClosest2 = _interopRequireDefault(domClosest);



  var _classnames2 = _interopRequireDefault(classnames);



  var _shallowequal2 = _interopRequireDefault(shallowequal);



  var _dropdown2 = _interopRequireDefault(dropdown$2);



  var _icon2 = _interopRequireDefault(icon);



  var _checkbox2 = _interopRequireDefault(checkbox);



  var _radio2 = _interopRequireDefault(radio$2);



  var _FilterDropdownMenuWrapper2 = _interopRequireDefault(FilterDropdownMenuWrapper);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var FilterMenu = function (_React$Component) {
      (0, _inherits3['default'])(FilterMenu, _React$Component);

      function FilterMenu(props) {
          (0, _classCallCheck3['default'])(this, FilterMenu);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (FilterMenu.__proto__ || Object.getPrototypeOf(FilterMenu)).call(this, props));

          _this.setNeverShown = function (column) {
              var rootNode = ReactDOM$$1.findDOMNode(_this);
              var filterBelongToScrollBody = !!(0, _domClosest2['default'])(rootNode, '.ant-table-scroll');
              if (filterBelongToScrollBody) {
                  // When fixed column have filters, there will be two dropdown menus
                  // Filter dropdown menu inside scroll body should never be shown
                  // To fix https://github.com/ant-design/ant-design/issues/5010 and
                  // https://github.com/ant-design/ant-design/issues/7909
                  _this.neverShown = !!column.fixed;
              }
          };
          _this.setSelectedKeys = function (_ref) {
              var selectedKeys = _ref.selectedKeys;

              _this.setState({ selectedKeys: selectedKeys });
          };
          _this.handleClearFilters = function () {
              _this.setState({
                  selectedKeys: []
              }, _this.handleConfirm);
          };
          _this.handleConfirm = function () {
              _this.setVisible(false);
              _this.confirmFilter();
          };
          _this.onVisibleChange = function (visible) {
              _this.setVisible(visible);
              if (!visible) {
                  _this.confirmFilter();
              }
          };
          _this.handleMenuItemClick = function (info) {
              if (!info.keyPath || info.keyPath.length <= 1) {
                  return;
              }
              var keyPathOfSelectedItem = _this.state.keyPathOfSelectedItem;
              if (_this.state.selectedKeys.indexOf(info.key) >= 0) {
                  // deselect SubMenu child
                  delete keyPathOfSelectedItem[info.key];
              } else {
                  // select SubMenu child
                  keyPathOfSelectedItem[info.key] = info.keyPath;
              }
              _this.setState({ keyPathOfSelectedItem: keyPathOfSelectedItem });
          };
          _this.renderFilterIcon = function () {
              var _this$props = _this.props,
                  column = _this$props.column,
                  locale = _this$props.locale,
                  prefixCls = _this$props.prefixCls;

              var filterIcon = column.filterIcon;
              var dropdownSelectedClass = _this.props.selectedKeys.length > 0 ? prefixCls + '-selected' : '';
              return filterIcon ? React.cloneElement(filterIcon, {
                  title: locale.filterTitle,
                  className: (0, _classnames2['default'])(filterIcon.className, (0, _defineProperty3['default'])({}, prefixCls + '-icon', true))
              }) : React.createElement(_icon2['default'], { title: locale.filterTitle, type: 'filter', className: dropdownSelectedClass });
          };
          var visible = 'filterDropdownVisible' in props.column ? props.column.filterDropdownVisible : false;
          _this.state = {
              selectedKeys: props.selectedKeys,
              keyPathOfSelectedItem: {},
              visible: visible
          };
          return _this;
      }

      (0, _createClass3['default'])(FilterMenu, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              var column = this.props.column;

              this.setNeverShown(column);
          }
      }, {
          key: 'componentWillReceiveProps',
          value: function componentWillReceiveProps(nextProps) {
              var column = nextProps.column;

              this.setNeverShown(column);
              var newState = {};
              /**
               * if the state is visible the component should ignore updates on selectedKeys prop to avoid
               * that the user selection is lost
               * this happens frequently when a table is connected on some sort of realtime data
               * Fixes https://github.com/ant-design/ant-design/issues/10289 and
               * https://github.com/ant-design/ant-design/issues/10209
               */
              if ('selectedKeys' in nextProps && !(0, _shallowequal2['default'])(this.props.selectedKeys, nextProps.selectedKeys)) {
                  newState.selectedKeys = nextProps.selectedKeys;
              }
              if ('filterDropdownVisible' in column) {
                  newState.visible = column.filterDropdownVisible;
              }
              if (Object.keys(newState).length > 0) {
                  this.setState(newState);
              }
          }
      }, {
          key: 'setVisible',
          value: function setVisible(visible) {
              var column = this.props.column;

              if (!('filterDropdownVisible' in column)) {
                  this.setState({ visible: visible });
              }
              if (column.onFilterDropdownVisibleChange) {
                  column.onFilterDropdownVisibleChange(visible);
              }
          }
      }, {
          key: 'confirmFilter',
          value: function confirmFilter() {
              if (this.state.selectedKeys !== this.props.selectedKeys) {
                  this.props.confirmFilter(this.props.column, this.state.selectedKeys);
              }
          }
      }, {
          key: 'renderMenuItem',
          value: function renderMenuItem(item) {
              var column = this.props.column;

              var multiple = 'filterMultiple' in column ? column.filterMultiple : true;
              var input = multiple ? React.createElement(_checkbox2['default'], { checked: this.state.selectedKeys.indexOf(item.value.toString()) >= 0 }) : React.createElement(_radio2['default'], { checked: this.state.selectedKeys.indexOf(item.value.toString()) >= 0 });
              return React.createElement(
                  _rcMenu.Item,
                  { key: item.value },
                  input,
                  React.createElement(
                      'span',
                      null,
                      item.text
                  )
              );
          }
      }, {
          key: 'hasSubMenu',
          value: function hasSubMenu() {
              var _props$column$filters = this.props.column.filters,
                  filters = _props$column$filters === undefined ? [] : _props$column$filters;

              return filters.some(function (item) {
                  return !!(item.children && item.children.length > 0);
              });
          }
      }, {
          key: 'renderMenus',
          value: function renderMenus(items) {
              var _this2 = this;

              return items.map(function (item) {
                  if (item.children && item.children.length > 0) {
                      var keyPathOfSelectedItem = _this2.state.keyPathOfSelectedItem;

                      var containSelected = Object.keys(keyPathOfSelectedItem).some(function (key) {
                          return keyPathOfSelectedItem[key].indexOf(item.value) >= 0;
                      });
                      var subMenuCls = containSelected ? _this2.props.dropdownPrefixCls + '-submenu-contain-selected' : '';
                      return React.createElement(
                          _rcMenu.SubMenu,
                          { title: item.text, className: subMenuCls, key: item.value.toString() },
                          _this2.renderMenus(item.children)
                      );
                  }
                  return _this2.renderMenuItem(item);
              });
          }
      }, {
          key: 'render',
          value: function render() {
              var _props = this.props,
                  column = _props.column,
                  locale = _props.locale,
                  prefixCls = _props.prefixCls,
                  dropdownPrefixCls = _props.dropdownPrefixCls,
                  getPopupContainer = _props.getPopupContainer;
              // default multiple selection in filter dropdown

              var multiple = 'filterMultiple' in column ? column.filterMultiple : true;
              var dropdownMenuClass = (0, _classnames2['default'])((0, _defineProperty3['default'])({}, dropdownPrefixCls + '-menu-without-submenu', !this.hasSubMenu()));
              var menus = column.filterDropdown ? React.createElement(
                  _FilterDropdownMenuWrapper2['default'],
                  null,
                  column.filterDropdown
              ) : React.createElement(
                  _FilterDropdownMenuWrapper2['default'],
                  { className: prefixCls + '-dropdown' },
                  React.createElement(
                      _rcMenu2['default'],
                      { multiple: multiple, onClick: this.handleMenuItemClick, prefixCls: dropdownPrefixCls + '-menu', className: dropdownMenuClass, onSelect: this.setSelectedKeys, onDeselect: this.setSelectedKeys, selectedKeys: this.state.selectedKeys, getPopupContainer: function getPopupContainer(triggerNode) {
                              return triggerNode.parentNode;
                          } },
                      this.renderMenus(column.filters)
                  ),
                  React.createElement(
                      'div',
                      { className: prefixCls + '-dropdown-btns' },
                      React.createElement(
                          'a',
                          { className: prefixCls + '-dropdown-link confirm', onClick: this.handleConfirm },
                          locale.filterConfirm
                      ),
                      React.createElement(
                          'a',
                          { className: prefixCls + '-dropdown-link clear', onClick: this.handleClearFilters },
                          locale.filterReset
                      )
                  )
              );
              return React.createElement(
                  _dropdown2['default'],
                  { trigger: ['click'], overlay: menus, visible: this.neverShown ? false : this.state.visible, onVisibleChange: this.onVisibleChange, getPopupContainer: getPopupContainer, forceRender: true },
                  this.renderFilterIcon()
              );
          }
      }]);
      return FilterMenu;
  }(React.Component);

  exports['default'] = FilterMenu;

  FilterMenu.defaultProps = {
      handleFilter: function handleFilter() {},

      column: {}
  };
  module.exports = exports['default'];
  });

  unwrapExports(filterDropdown);

  var createStore_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);

  exports["default"] = createStore;

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function createStore(initialState) {
      var state = initialState;
      var listeners = [];
      function setState(partial) {
          state = (0, _extends3["default"])({}, state, partial);
          for (var i = 0; i < listeners.length; i++) {
              listeners[i]();
          }
      }
      function getState() {
          return state;
      }
      function subscribe(listener) {
          listeners.push(listener);
          return function unsubscribe() {
              var index = listeners.indexOf(listener);
              listeners.splice(index, 1);
          };
      }
      return {
          setState: setState,
          getState: getState,
          subscribe: subscribe
      };
  }
  module.exports = exports["default"];
  });

  unwrapExports(createStore_1);

  var SelectionBox_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var _checkbox2 = _interopRequireDefault(checkbox);



  var _radio2 = _interopRequireDefault(radio$2);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var __rest = function (s, e) {
      var t = {};
      for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      }if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
      }return t;
  };

  var SelectionBox = function (_React$Component) {
      (0, _inherits3['default'])(SelectionBox, _React$Component);

      function SelectionBox(props) {
          (0, _classCallCheck3['default'])(this, SelectionBox);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (SelectionBox.__proto__ || Object.getPrototypeOf(SelectionBox)).call(this, props));

          _this.state = {
              checked: _this.getCheckState(props)
          };
          return _this;
      }

      (0, _createClass3['default'])(SelectionBox, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              this.subscribe();
          }
      }, {
          key: 'componentWillUnmount',
          value: function componentWillUnmount() {
              if (this.unsubscribe) {
                  this.unsubscribe();
              }
          }
      }, {
          key: 'subscribe',
          value: function subscribe() {
              var _this2 = this;

              var store = this.props.store;

              this.unsubscribe = store.subscribe(function () {
                  var checked = _this2.getCheckState(_this2.props);
                  _this2.setState({ checked: checked });
              });
          }
      }, {
          key: 'getCheckState',
          value: function getCheckState(props) {
              var store = props.store,
                  defaultSelection = props.defaultSelection,
                  rowIndex = props.rowIndex;

              var checked = false;
              if (store.getState().selectionDirty) {
                  checked = store.getState().selectedRowKeys.indexOf(rowIndex) >= 0;
              } else {
                  checked = store.getState().selectedRowKeys.indexOf(rowIndex) >= 0 || defaultSelection.indexOf(rowIndex) >= 0;
              }
              return checked;
          }
      }, {
          key: 'render',
          value: function render() {
              var _a = this.props,
                  type = _a.type,
                  rowIndex = _a.rowIndex,
                  rest = __rest(_a, ["type", "rowIndex"]);var checked = this.state.checked;

              if (type === 'radio') {
                  return React.createElement(_radio2['default'], (0, _extends3['default'])({ checked: checked, value: rowIndex }, rest));
              } else {
                  return React.createElement(_checkbox2['default'], (0, _extends3['default'])({ checked: checked }, rest));
              }
          }
      }]);
      return SelectionBox;
  }(React.Component);

  exports['default'] = SelectionBox;
  module.exports = exports['default'];
  });

  unwrapExports(SelectionBox_1);

  var SelectionCheckboxAll_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var _checkbox2 = _interopRequireDefault(checkbox);



  var _dropdown2 = _interopRequireDefault(dropdown$2);



  var _menu2 = _interopRequireDefault(menu);



  var _icon2 = _interopRequireDefault(icon);



  var _classnames2 = _interopRequireDefault(classnames);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var SelectionCheckboxAll = function (_React$Component) {
      (0, _inherits3['default'])(SelectionCheckboxAll, _React$Component);

      function SelectionCheckboxAll(props) {
          (0, _classCallCheck3['default'])(this, SelectionCheckboxAll);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (SelectionCheckboxAll.__proto__ || Object.getPrototypeOf(SelectionCheckboxAll)).call(this, props));

          _this.handleSelectAllChagne = function (e) {
              var checked = e.target.checked;
              _this.props.onSelect(checked ? 'all' : 'removeAll', 0, null);
          };
          _this.defaultSelections = props.hideDefaultSelections ? [] : [{
              key: 'all',
              text: props.locale.selectAll,
              onSelect: function onSelect() {}
          }, {
              key: 'invert',
              text: props.locale.selectInvert,
              onSelect: function onSelect() {}
          }];
          _this.state = {
              checked: _this.getCheckState(props),
              indeterminate: _this.getIndeterminateState(props)
          };
          return _this;
      }

      (0, _createClass3['default'])(SelectionCheckboxAll, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              this.subscribe();
          }
      }, {
          key: 'componentWillReceiveProps',
          value: function componentWillReceiveProps(nextProps) {
              this.setCheckState(nextProps);
          }
      }, {
          key: 'componentWillUnmount',
          value: function componentWillUnmount() {
              if (this.unsubscribe) {
                  this.unsubscribe();
              }
          }
      }, {
          key: 'subscribe',
          value: function subscribe() {
              var _this2 = this;

              var store = this.props.store;

              this.unsubscribe = store.subscribe(function () {
                  _this2.setCheckState(_this2.props);
              });
          }
      }, {
          key: 'checkSelection',
          value: function checkSelection(data, type, byDefaultChecked) {
              var _props = this.props,
                  store = _props.store,
                  getCheckboxPropsByItem = _props.getCheckboxPropsByItem,
                  getRecordKey = _props.getRecordKey;
              // type should be 'every' | 'some'

              if (type === 'every' || type === 'some') {
                  return byDefaultChecked ? data[type](function (item, i) {
                      return getCheckboxPropsByItem(item, i).defaultChecked;
                  }) : data[type](function (item, i) {
                      return store.getState().selectedRowKeys.indexOf(getRecordKey(item, i)) >= 0;
                  });
              }
              return false;
          }
      }, {
          key: 'setCheckState',
          value: function setCheckState(props) {
              var checked = this.getCheckState(props);
              var indeterminate = this.getIndeterminateState(props);
              if (checked !== this.state.checked) {
                  this.setState({ checked: checked });
              }
              if (indeterminate !== this.state.indeterminate) {
                  this.setState({ indeterminate: indeterminate });
              }
          }
      }, {
          key: 'getCheckState',
          value: function getCheckState(props) {
              var store = props.store,
                  data = props.data;

              var checked = void 0;
              if (!data.length) {
                  checked = false;
              } else {
                  checked = store.getState().selectionDirty ? this.checkSelection(data, 'every', false) : this.checkSelection(data, 'every', false) || this.checkSelection(data, 'every', true);
              }
              return checked;
          }
      }, {
          key: 'getIndeterminateState',
          value: function getIndeterminateState(props) {
              var store = props.store,
                  data = props.data;

              var indeterminate = void 0;
              if (!data.length) {
                  indeterminate = false;
              } else {
                  indeterminate = store.getState().selectionDirty ? this.checkSelection(data, 'some', false) && !this.checkSelection(data, 'every', false) : this.checkSelection(data, 'some', false) && !this.checkSelection(data, 'every', false) || this.checkSelection(data, 'some', true) && !this.checkSelection(data, 'every', true);
              }
              return indeterminate;
          }
      }, {
          key: 'renderMenus',
          value: function renderMenus(selections) {
              var _this3 = this;

              return selections.map(function (selection, index) {
                  return React.createElement(
                      _menu2['default'].Item,
                      { key: selection.key || index },
                      React.createElement(
                          'div',
                          { onClick: function onClick() {
                                  _this3.props.onSelect(selection.key, index, selection.onSelect);
                              } },
                          selection.text
                      )
                  );
              });
          }
      }, {
          key: 'render',
          value: function render() {
              var _props2 = this.props,
                  disabled = _props2.disabled,
                  prefixCls = _props2.prefixCls,
                  selections = _props2.selections,
                  getPopupContainer = _props2.getPopupContainer;
              var _state = this.state,
                  checked = _state.checked,
                  indeterminate = _state.indeterminate;

              var selectionPrefixCls = prefixCls + '-selection';
              var customSelections = null;
              if (selections) {
                  var newSelections = Array.isArray(selections) ? this.defaultSelections.concat(selections) : this.defaultSelections;
                  var menu$$1 = React.createElement(
                      _menu2['default'],
                      { className: selectionPrefixCls + '-menu', selectedKeys: [] },
                      this.renderMenus(newSelections)
                  );
                  customSelections = newSelections.length > 0 ? React.createElement(
                      _dropdown2['default'],
                      { overlay: menu$$1, getPopupContainer: getPopupContainer },
                      React.createElement(
                          'div',
                          { className: selectionPrefixCls + '-down' },
                          React.createElement(_icon2['default'], { type: 'down' })
                      )
                  ) : null;
              }
              return React.createElement(
                  'div',
                  { className: selectionPrefixCls },
                  React.createElement(_checkbox2['default'], { className: (0, _classnames2['default'])((0, _defineProperty3['default'])({}, selectionPrefixCls + '-select-all-custom', customSelections)), checked: checked, indeterminate: indeterminate, disabled: disabled, onChange: this.handleSelectAllChagne }),
                  customSelections
              );
          }
      }]);
      return SelectionCheckboxAll;
  }(React.Component);

  exports['default'] = SelectionCheckboxAll;
  module.exports = exports['default'];
  });

  unwrapExports(SelectionCheckboxAll_1);

  var Column_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var Column = function (_React$Component) {
    (0, _inherits3['default'])(Column, _React$Component);

    function Column() {
      (0, _classCallCheck3['default'])(this, Column);
      return (0, _possibleConstructorReturn3['default'])(this, (Column.__proto__ || Object.getPrototypeOf(Column)).apply(this, arguments));
    }

    return Column;
  }(React.Component);

  exports['default'] = Column;
  module.exports = exports['default'];
  });

  unwrapExports(Column_1);

  var ColumnGroup_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var ColumnGroup = function (_React$Component) {
    (0, _inherits3['default'])(ColumnGroup, _React$Component);

    function ColumnGroup() {
      (0, _classCallCheck3['default'])(this, ColumnGroup);
      return (0, _possibleConstructorReturn3['default'])(this, (ColumnGroup.__proto__ || Object.getPrototypeOf(ColumnGroup)).apply(this, arguments));
    }

    return ColumnGroup;
  }(React.Component);

  exports['default'] = ColumnGroup;

  ColumnGroup.__ANT_TABLE_COLUMN_GROUP = true;
  module.exports = exports['default'];
  });

  unwrapExports(ColumnGroup_1);

  var createBodyRow = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);

  exports['default'] = createTableRow;



  var React = _interopRequireWildcard(React$1__default);



  var _classnames3 = _interopRequireDefault(classnames);



  var _omit2 = _interopRequireDefault(_omit);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function createTableRow() {
      var Component = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'tr';

      var BodyRow = function (_React$Component) {
          (0, _inherits3['default'])(BodyRow, _React$Component);

          function BodyRow(props) {
              (0, _classCallCheck3['default'])(this, BodyRow);

              var _this = (0, _possibleConstructorReturn3['default'])(this, (BodyRow.__proto__ || Object.getPrototypeOf(BodyRow)).call(this, props));

              _this.store = props.store;

              var _this$store$getState = _this.store.getState(),
                  selectedRowKeys = _this$store$getState.selectedRowKeys;

              _this.state = {
                  selected: selectedRowKeys.indexOf(props.rowKey) >= 0
              };
              return _this;
          }

          (0, _createClass3['default'])(BodyRow, [{
              key: 'componentDidMount',
              value: function componentDidMount() {
                  this.subscribe();
              }
          }, {
              key: 'componentWillUnmount',
              value: function componentWillUnmount() {
                  if (this.unsubscribe) {
                      this.unsubscribe();
                  }
              }
          }, {
              key: 'subscribe',
              value: function subscribe() {
                  var _this2 = this;

                  var _props = this.props,
                      store = _props.store,
                      rowKey = _props.rowKey;

                  this.unsubscribe = store.subscribe(function () {
                      var _store$getState = _this2.store.getState(),
                          selectedRowKeys = _store$getState.selectedRowKeys;

                      var selected = selectedRowKeys.indexOf(rowKey) >= 0;
                      if (selected !== _this2.state.selected) {
                          _this2.setState({ selected: selected });
                      }
                  });
              }
          }, {
              key: 'render',
              value: function render() {
                  var rowProps = (0, _omit2['default'])(this.props, ['prefixCls', 'rowKey', 'store']);
                  var className = (0, _classnames3['default'])(this.props.className, (0, _defineProperty3['default'])({}, this.props.prefixCls + '-row-selected', this.state.selected));
                  return React.createElement(
                      Component,
                      (0, _extends3['default'])({}, rowProps, { className: className }),
                      this.props.children
                  );
              }
          }]);
          return BodyRow;
      }(React.Component);

      return BodyRow;
  }
  module.exports = exports['default'];
  });

  unwrapExports(createBodyRow);

  var util$3 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _toConsumableArray3 = _interopRequireDefault(toConsumableArray);



  var _extends3 = _interopRequireDefault(_extends$1);

  exports.flatArray = flatArray;
  exports.treeMap = treeMap;
  exports.flatFilter = flatFilter;
  exports.normalizeColumns = normalizeColumns;



  var React = _interopRequireWildcard(React$1__default);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function flatArray() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var childrenName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'children';

      var result = [];
      var loop = function loop(array) {
          array.forEach(function (item) {
              if (item[childrenName]) {
                  var newItem = (0, _extends3['default'])({}, item);
                  delete newItem[childrenName];
                  result.push(newItem);
                  if (item[childrenName].length > 0) {
                      loop(item[childrenName]);
                  }
              } else {
                  result.push(item);
              }
          });
      };
      loop(data);
      return result;
  }
  function treeMap(tree, mapper) {
      var childrenName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'children';

      return tree.map(function (node, index) {
          var extra = {};
          if (node[childrenName]) {
              extra[childrenName] = treeMap(node[childrenName], mapper, childrenName);
          }
          return (0, _extends3['default'])({}, mapper(node, index), extra);
      });
  }
  function flatFilter(tree, callback) {
      return tree.reduce(function (acc, node) {
          if (callback(node)) {
              acc.push(node);
          }
          if (node.children) {
              var children = flatFilter(node.children, callback);
              acc.push.apply(acc, (0, _toConsumableArray3['default'])(children));
          }
          return acc;
      }, []);
  }
  function normalizeColumns(elements) {
      var columns = [];
      React.Children.forEach(elements, function (element) {
          if (!React.isValidElement(element)) {
              return;
          }
          var column = (0, _extends3['default'])({}, element.props);
          if (element.key) {
              column.key = element.key;
          }
          if (element.type && element.type.__ANT_TABLE_COLUMN_GROUP) {
              column.children = normalizeColumns(column.children);
          }
          columns.push(column);
      });
      return columns;
  }
  });

  unwrapExports(util$3);
  var util_1$1 = util$3.flatArray;
  var util_2$1 = util$3.treeMap;
  var util_3$1 = util$3.flatFilter;
  var util_4$1 = util$3.normalizeColumns;

  var _rcTable = getCjsExportFromNamespace(es$b);

  var Table_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _typeof3 = _interopRequireDefault(_typeof_1);



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _extends5 = _interopRequireDefault(_extends$1);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var ReactDOM$$1 = _interopRequireWildcard(ReactDOM__default);



  var _rcTable2 = _interopRequireDefault(_rcTable);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _classnames2 = _interopRequireDefault(classnames);



  var _pagination2 = _interopRequireDefault(pagination);



  var _icon2 = _interopRequireDefault(icon);



  var _spin2 = _interopRequireDefault(spin);



  var _LocaleReceiver2 = _interopRequireDefault(LocaleReceiver_1);



  var _default2 = _interopRequireDefault(_default);



  var _warning2 = _interopRequireDefault(warning$4);



  var _filterDropdown2 = _interopRequireDefault(filterDropdown);



  var _createStore2 = _interopRequireDefault(createStore_1);



  var _SelectionBox2 = _interopRequireDefault(SelectionBox_1);



  var _SelectionCheckboxAll2 = _interopRequireDefault(SelectionCheckboxAll_1);



  var _Column2 = _interopRequireDefault(Column_1);



  var _ColumnGroup2 = _interopRequireDefault(ColumnGroup_1);



  var _createBodyRow2 = _interopRequireDefault(createBodyRow);



  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var __rest = function (s, e) {
      var t = {};
      for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      }if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
      }return t;
  };

  function noop() {}
  function stopPropagation(e) {
      e.stopPropagation();
      if (e.nativeEvent.stopImmediatePropagation) {
          e.nativeEvent.stopImmediatePropagation();
      }
  }
  function getRowSelection(props) {
      return props.rowSelection || {};
  }
  var defaultPagination = {
      onChange: noop,
      onShowSizeChange: noop
  };
  /**
   * Avoid creating new object, so that parent component's shouldComponentUpdate
   * can works appropriately。
   */
  var emptyObject = {};

  var Table = function (_React$Component) {
      (0, _inherits3['default'])(Table, _React$Component);

      function Table(props) {
          (0, _classCallCheck3['default'])(this, Table);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (Table.__proto__ || Object.getPrototypeOf(Table)).call(this, props));

          _this.getCheckboxPropsByItem = function (item, index) {
              var rowSelection = getRowSelection(_this.props);
              if (!rowSelection.getCheckboxProps) {
                  return {};
              }
              var key = _this.getRecordKey(item, index);
              // Cache checkboxProps
              if (!_this.CheckboxPropsCache[key]) {
                  _this.CheckboxPropsCache[key] = rowSelection.getCheckboxProps(item);
              }
              return _this.CheckboxPropsCache[key];
          };
          _this.onRow = function (record, index) {
              var _this$props = _this.props,
                  onRow = _this$props.onRow,
                  prefixCls = _this$props.prefixCls;

              var custom = onRow ? onRow(record, index) : {};
              return (0, _extends5['default'])({}, custom, { prefixCls: prefixCls, store: _this.store, rowKey: _this.getRecordKey(record, index) });
          };
          _this.handleFilter = function (column, nextFilters) {
              var props = _this.props;
              var pagination$$1 = (0, _extends5['default'])({}, _this.state.pagination);
              var filters = (0, _extends5['default'])({}, _this.state.filters, (0, _defineProperty3['default'])({}, _this.getColumnKey(column), nextFilters));
              // Remove filters not in current columns
              var currentColumnKeys = [];
              (0, util$3.treeMap)(_this.columns, function (c) {
                  if (!c.children) {
                      currentColumnKeys.push(_this.getColumnKey(c));
                  }
              });
              Object.keys(filters).forEach(function (columnKey) {
                  if (currentColumnKeys.indexOf(columnKey) < 0) {
                      delete filters[columnKey];
                  }
              });
              if (props.pagination) {
                  // Reset current prop
                  pagination$$1.current = 1;
                  pagination$$1.onChange(pagination$$1.current);
              }
              var newState = {
                  pagination: pagination$$1,
                  filters: {}
              };
              var filtersToSetState = (0, _extends5['default'])({}, filters);
              // Remove filters which is controlled
              _this.getFilteredValueColumns().forEach(function (col) {
                  var columnKey = _this.getColumnKey(col);
                  if (columnKey) {
                      delete filtersToSetState[columnKey];
                  }
              });
              if (Object.keys(filtersToSetState).length > 0) {
                  newState.filters = filtersToSetState;
              }
              // Controlled current prop will not respond user interaction
              if ((0, _typeof3['default'])(props.pagination) === 'object' && 'current' in props.pagination) {
                  newState.pagination = (0, _extends5['default'])({}, pagination$$1, { current: _this.state.pagination.current });
              }
              _this.setState(newState, function () {
                  _this.store.setState({
                      selectionDirty: false
                  });
                  var onChange = _this.props.onChange;
                  if (onChange) {
                      onChange.apply(null, _this.prepareParamsArguments((0, _extends5['default'])({}, _this.state, { selectionDirty: false, filters: filters,
                          pagination: pagination$$1 })));
                  }
              });
          };
          _this.handleSelect = function (record, rowIndex, e) {
              var checked = e.target.checked;
              var nativeEvent = e.nativeEvent;
              var defaultSelection = _this.store.getState().selectionDirty ? [] : _this.getDefaultSelection();
              var selectedRowKeys = _this.store.getState().selectedRowKeys.concat(defaultSelection);
              var key = _this.getRecordKey(record, rowIndex);
              if (checked) {
                  selectedRowKeys.push(_this.getRecordKey(record, rowIndex));
              } else {
                  selectedRowKeys = selectedRowKeys.filter(function (i) {
                      return key !== i;
                  });
              }
              _this.store.setState({
                  selectionDirty: true
              });
              _this.setSelectedRowKeys(selectedRowKeys, {
                  selectWay: 'onSelect',
                  record: record,
                  checked: checked,
                  changeRowKeys: void 0,
                  nativeEvent: nativeEvent
              });
          };
          _this.handleRadioSelect = function (record, rowIndex, e) {
              var checked = e.target.checked;
              var nativeEvent = e.nativeEvent;
              var defaultSelection = _this.store.getState().selectionDirty ? [] : _this.getDefaultSelection();
              var selectedRowKeys = _this.store.getState().selectedRowKeys.concat(defaultSelection);
              var key = _this.getRecordKey(record, rowIndex);
              selectedRowKeys = [key];
              _this.store.setState({
                  selectionDirty: true
              });
              _this.setSelectedRowKeys(selectedRowKeys, {
                  selectWay: 'onSelect',
                  record: record,
                  checked: checked,
                  changeRowKeys: void 0,
                  nativeEvent: nativeEvent
              });
          };
          _this.handleSelectRow = function (selectionKey, index, onSelectFunc) {
              var data = _this.getFlatCurrentPageData();
              var defaultSelection = _this.store.getState().selectionDirty ? [] : _this.getDefaultSelection();
              var selectedRowKeys = _this.store.getState().selectedRowKeys.concat(defaultSelection);
              var changeableRowKeys = data.filter(function (item, i) {
                  return !_this.getCheckboxPropsByItem(item, i).disabled;
              }).map(function (item, i) {
                  return _this.getRecordKey(item, i);
              });
              var changeRowKeys = [];
              var selectWay = 'onSelectAll';
              var checked = void 0;
              // handle default selection
              switch (selectionKey) {
                  case 'all':
                      changeableRowKeys.forEach(function (key) {
                          if (selectedRowKeys.indexOf(key) < 0) {
                              selectedRowKeys.push(key);
                              changeRowKeys.push(key);
                          }
                      });
                      selectWay = 'onSelectAll';
                      checked = true;
                      break;
                  case 'removeAll':
                      changeableRowKeys.forEach(function (key) {
                          if (selectedRowKeys.indexOf(key) >= 0) {
                              selectedRowKeys.splice(selectedRowKeys.indexOf(key), 1);
                              changeRowKeys.push(key);
                          }
                      });
                      selectWay = 'onSelectAll';
                      checked = false;
                      break;
                  case 'invert':
                      changeableRowKeys.forEach(function (key) {
                          if (selectedRowKeys.indexOf(key) < 0) {
                              selectedRowKeys.push(key);
                          } else {
                              selectedRowKeys.splice(selectedRowKeys.indexOf(key), 1);
                          }
                          changeRowKeys.push(key);
                          selectWay = 'onSelectInvert';
                      });
                      break;
                  default:
                      break;
              }
              _this.store.setState({
                  selectionDirty: true
              });
              // when select custom selection, callback selections[n].onSelect
              var rowSelection = _this.props.rowSelection;

              var customSelectionStartIndex = 2;
              if (rowSelection && rowSelection.hideDefaultSelections) {
                  customSelectionStartIndex = 0;
              }
              if (index >= customSelectionStartIndex && typeof onSelectFunc === 'function') {
                  return onSelectFunc(changeableRowKeys);
              }
              _this.setSelectedRowKeys(selectedRowKeys, {
                  selectWay: selectWay,
                  checked: checked,
                  changeRowKeys: changeRowKeys
              });
          };
          _this.handlePageChange = function (current) {
              for (var _len = arguments.length, otherArguments = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  otherArguments[_key - 1] = arguments[_key];
              }

              var props = _this.props;
              var pagination$$1 = (0, _extends5['default'])({}, _this.state.pagination);
              if (current) {
                  pagination$$1.current = current;
              } else {
                  pagination$$1.current = pagination$$1.current || 1;
              }
              pagination$$1.onChange.apply(pagination$$1, [pagination$$1.current].concat(otherArguments));
              var newState = {
                  pagination: pagination$$1
              };
              // Controlled current prop will not respond user interaction
              if (props.pagination && (0, _typeof3['default'])(props.pagination) === 'object' && 'current' in props.pagination) {
                  newState.pagination = (0, _extends5['default'])({}, pagination$$1, { current: _this.state.pagination.current });
              }
              _this.setState(newState);
              _this.store.setState({
                  selectionDirty: false
              });
              var onChange = _this.props.onChange;
              if (onChange) {
                  onChange.apply(null, _this.prepareParamsArguments((0, _extends5['default'])({}, _this.state, { selectionDirty: false, pagination: pagination$$1 })));
              }
          };
          _this.renderSelectionBox = function (type) {
              return function (_, record, index) {
                  var rowIndex = _this.getRecordKey(record, index); // 从 1 开始
                  var props = _this.getCheckboxPropsByItem(record, index);
                  var handleChange = function handleChange(e) {
                      type === 'radio' ? _this.handleRadioSelect(record, rowIndex, e) : _this.handleSelect(record, rowIndex, e);
                  };
                  return React.createElement(
                      'span',
                      { onClick: stopPropagation },
                      React.createElement(_SelectionBox2['default'], (0, _extends5['default'])({ type: type, store: _this.store, rowIndex: rowIndex, onChange: handleChange, defaultSelection: _this.getDefaultSelection() }, props))
                  );
              };
          };
          _this.getRecordKey = function (record, index) {
              var rowKey = _this.props.rowKey;
              var recordKey = typeof rowKey === 'function' ? rowKey(record, index) : record[rowKey];
              (0, _warning2['default'])(recordKey !== undefined, 'Each record in dataSource of table should have a unique `key` prop, or set `rowKey` to an unique primary key,' + 'see https://u.ant.design/table-row-key');
              return recordKey === undefined ? index : recordKey;
          };
          _this.getPopupContainer = function () {
              return ReactDOM$$1.findDOMNode(_this);
          };
          _this.handleShowSizeChange = function (current, pageSize) {
              var pagination$$1 = _this.state.pagination;
              pagination$$1.onShowSizeChange(current, pageSize);
              var nextPagination = (0, _extends5['default'])({}, pagination$$1, { pageSize: pageSize,
                  current: current });
              _this.setState({ pagination: nextPagination });
              var onChange = _this.props.onChange;
              if (onChange) {
                  onChange.apply(null, _this.prepareParamsArguments((0, _extends5['default'])({}, _this.state, { pagination: nextPagination })));
              }
          };
          _this.renderTable = function (contextLocale, loading) {
              var _classNames;

              var locale = (0, _extends5['default'])({}, contextLocale, _this.props.locale);
              var _a = _this.props,
                  style = _a.style,
                  className = _a.className,
                  prefixCls = _a.prefixCls,
                  showHeader = _a.showHeader,
                  restProps = __rest(_a, ["style", "className", "prefixCls", "showHeader"]);
              var data = _this.getCurrentPageData();
              var expandIconAsCell = _this.props.expandedRowRender && _this.props.expandIconAsCell !== false;
              var classString = (0, _classnames2['default'])((_classNames = {}, (0, _defineProperty3['default'])(_classNames, prefixCls + '-' + _this.props.size, true), (0, _defineProperty3['default'])(_classNames, prefixCls + '-bordered', _this.props.bordered), (0, _defineProperty3['default'])(_classNames, prefixCls + '-empty', !data.length), (0, _defineProperty3['default'])(_classNames, prefixCls + '-without-column-header', !showHeader), _classNames));
              var columns = _this.renderRowSelection(locale);
              columns = _this.renderColumnsDropdown(columns, locale);
              columns = columns.map(function (column, i) {
                  var newColumn = (0, _extends5['default'])({}, column);
                  newColumn.key = _this.getColumnKey(newColumn, i);
                  return newColumn;
              });
              var expandIconColumnIndex = columns[0] && columns[0].key === 'selection-column' ? 1 : 0;
              if ('expandIconColumnIndex' in restProps) {
                  expandIconColumnIndex = restProps.expandIconColumnIndex;
              }
              return React.createElement(_rcTable2['default'], (0, _extends5['default'])({ key: 'table' }, restProps, { onRow: _this.onRow, components: _this.components, prefixCls: prefixCls, data: data, columns: columns, showHeader: showHeader, className: classString, expandIconColumnIndex: expandIconColumnIndex, expandIconAsCell: expandIconAsCell, emptyText: !loading.spinning && locale.emptyText }));
          };
          (0, _warning2['default'])(!('columnsPageRange' in props || 'columnsPageSize' in props), '`columnsPageRange` and `columnsPageSize` are removed, please use ' + 'fixed columns instead, see: https://u.ant.design/fixed-columns.');
          _this.columns = props.columns || (0, util$3.normalizeColumns)(props.children);
          _this.createComponents(props.components);
          _this.state = (0, _extends5['default'])({}, _this.getDefaultSortOrder(_this.columns), {
              // 减少状态
              filters: _this.getFiltersFromColumns(), pagination: _this.getDefaultPagination(props) });
          _this.CheckboxPropsCache = {};
          _this.store = (0, _createStore2['default'])({
              selectedRowKeys: getRowSelection(props).selectedRowKeys || [],
              selectionDirty: false
          });
          return _this;
      }

      (0, _createClass3['default'])(Table, [{
          key: 'getDefaultSelection',
          value: function getDefaultSelection() {
              var _this2 = this;

              var rowSelection = getRowSelection(this.props);
              if (!rowSelection.getCheckboxProps) {
                  return [];
              }
              return this.getFlatData().filter(function (item, rowIndex) {
                  return _this2.getCheckboxPropsByItem(item, rowIndex).defaultChecked;
              }).map(function (record, rowIndex) {
                  return _this2.getRecordKey(record, rowIndex);
              });
          }
      }, {
          key: 'getDefaultPagination',
          value: function getDefaultPagination(props) {
              var pagination$$1 = props.pagination || {};
              return this.hasPagination(props) ? (0, _extends5['default'])({}, defaultPagination, pagination$$1, { current: pagination$$1.defaultCurrent || pagination$$1.current || 1, pageSize: pagination$$1.defaultPageSize || pagination$$1.pageSize || 10 }) : {};
          }
      }, {
          key: 'componentWillReceiveProps',
          value: function componentWillReceiveProps(nextProps) {
              this.columns = nextProps.columns || (0, util$3.normalizeColumns)(nextProps.children);
              if ('pagination' in nextProps || 'pagination' in this.props) {
                  this.setState(function (previousState) {
                      var newPagination = (0, _extends5['default'])({}, defaultPagination, previousState.pagination, nextProps.pagination);
                      newPagination.current = newPagination.current || 1;
                      newPagination.pageSize = newPagination.pageSize || 10;
                      return { pagination: nextProps.pagination !== false ? newPagination : emptyObject };
                  });
              }
              if (nextProps.rowSelection && 'selectedRowKeys' in nextProps.rowSelection) {
                  this.store.setState({
                      selectedRowKeys: nextProps.rowSelection.selectedRowKeys || []
                  });
              }
              if ('dataSource' in nextProps && nextProps.dataSource !== this.props.dataSource) {
                  this.store.setState({
                      selectionDirty: false
                  });
              }
              // https://github.com/ant-design/ant-design/issues/10133
              this.CheckboxPropsCache = {};
              if (this.getSortOrderColumns(this.columns).length > 0) {
                  var sortState = this.getSortStateFromColumns(this.columns);
                  if (sortState.sortColumn !== this.state.sortColumn || sortState.sortOrder !== this.state.sortOrder) {
                      this.setState(sortState);
                  }
              }
              var filteredValueColumns = this.getFilteredValueColumns(this.columns);
              if (filteredValueColumns.length > 0) {
                  var filtersFromColumns = this.getFiltersFromColumns(this.columns);
                  var newFilters = (0, _extends5['default'])({}, this.state.filters);
                  Object.keys(filtersFromColumns).forEach(function (key) {
                      newFilters[key] = filtersFromColumns[key];
                  });
                  if (this.isFiltersChanged(newFilters)) {
                      this.setState({ filters: newFilters });
                  }
              }
              this.createComponents(nextProps.components, this.props.components);
          }
      }, {
          key: 'setSelectedRowKeys',
          value: function setSelectedRowKeys(selectedRowKeys, selectionInfo) {
              var _this3 = this;

              var selectWay = selectionInfo.selectWay,
                  record = selectionInfo.record,
                  checked = selectionInfo.checked,
                  changeRowKeys = selectionInfo.changeRowKeys,
                  nativeEvent = selectionInfo.nativeEvent;

              var rowSelection = getRowSelection(this.props);
              if (rowSelection && !('selectedRowKeys' in rowSelection)) {
                  this.store.setState({ selectedRowKeys: selectedRowKeys });
              }
              var data = this.getFlatData();
              if (!rowSelection.onChange && !rowSelection[selectWay]) {
                  return;
              }
              var selectedRows = data.filter(function (row, i) {
                  return selectedRowKeys.indexOf(_this3.getRecordKey(row, i)) >= 0;
              });
              if (rowSelection.onChange) {
                  rowSelection.onChange(selectedRowKeys, selectedRows);
              }
              if (selectWay === 'onSelect' && rowSelection.onSelect) {
                  rowSelection.onSelect(record, checked, selectedRows, nativeEvent);
              } else if (selectWay === 'onSelectAll' && rowSelection.onSelectAll) {
                  var changeRows = data.filter(function (row, i) {
                      return changeRowKeys.indexOf(_this3.getRecordKey(row, i)) >= 0;
                  });
                  rowSelection.onSelectAll(checked, selectedRows, changeRows);
              } else if (selectWay === 'onSelectInvert' && rowSelection.onSelectInvert) {
                  rowSelection.onSelectInvert(selectedRowKeys);
              }
          }
      }, {
          key: 'hasPagination',
          value: function hasPagination(props) {
              return (props || this.props).pagination !== false;
          }
      }, {
          key: 'isFiltersChanged',
          value: function isFiltersChanged(filters) {
              var _this4 = this;

              var filtersChanged = false;
              if (Object.keys(filters).length !== Object.keys(this.state.filters).length) {
                  filtersChanged = true;
              } else {
                  Object.keys(filters).forEach(function (columnKey) {
                      if (filters[columnKey] !== _this4.state.filters[columnKey]) {
                          filtersChanged = true;
                      }
                  });
              }
              return filtersChanged;
          }
      }, {
          key: 'getSortOrderColumns',
          value: function getSortOrderColumns(columns) {
              return (0, util$3.flatFilter)(columns || this.columns || [], function (column) {
                  return 'sortOrder' in column;
              });
          }
      }, {
          key: 'getFilteredValueColumns',
          value: function getFilteredValueColumns(columns) {
              return (0, util$3.flatFilter)(columns || this.columns || [], function (column) {
                  return typeof column.filteredValue !== 'undefined';
              });
          }
      }, {
          key: 'getFiltersFromColumns',
          value: function getFiltersFromColumns(columns) {
              var _this5 = this;

              var filters = {};
              this.getFilteredValueColumns(columns).forEach(function (col) {
                  var colKey = _this5.getColumnKey(col);
                  filters[colKey] = col.filteredValue;
              });
              return filters;
          }
      }, {
          key: 'getDefaultSortOrder',
          value: function getDefaultSortOrder(columns) {
              var definedSortState = this.getSortStateFromColumns(columns);
              var defaultSortedColumn = (0, util$3.flatFilter)(columns || [], function (column) {
                  return column.defaultSortOrder != null;
              })[0];
              if (defaultSortedColumn && !definedSortState.sortColumn) {
                  return {
                      sortColumn: defaultSortedColumn,
                      sortOrder: defaultSortedColumn.defaultSortOrder
                  };
              }
              return definedSortState;
          }
      }, {
          key: 'getSortStateFromColumns',
          value: function getSortStateFromColumns(columns) {
              // return first column which sortOrder is not falsy
              var sortedColumn = this.getSortOrderColumns(columns).filter(function (col) {
                  return col.sortOrder;
              })[0];
              if (sortedColumn) {
                  return {
                      sortColumn: sortedColumn,
                      sortOrder: sortedColumn.sortOrder
                  };
              }
              return {
                  sortColumn: null,
                  sortOrder: null
              };
          }
      }, {
          key: 'getSorterFn',
          value: function getSorterFn() {
              var _state = this.state,
                  sortOrder = _state.sortOrder,
                  sortColumn = _state.sortColumn;

              if (!sortOrder || !sortColumn || typeof sortColumn.sorter !== 'function') {
                  return;
              }
              return function (a, b) {
                  var result = sortColumn.sorter(a, b, sortOrder);
                  if (result !== 0) {
                      return sortOrder === 'descend' ? -result : result;
                  }
                  return 0;
              };
          }
      }, {
          key: 'toggleSortOrder',
          value: function toggleSortOrder(order, column) {
              var _state2 = this.state,
                  sortColumn = _state2.sortColumn,
                  sortOrder = _state2.sortOrder;
              // 只同时允许一列进行排序，否则会导致排序顺序的逻辑问题

              var isSortColumn = this.isSortColumn(column);
              if (!isSortColumn) {
                  // 当前列未排序
                  sortOrder = order;
                  sortColumn = column;
              } else {
                  // 当前列已排序
                  if (sortOrder === order) {
                      // 切换为未排序状态
                      sortOrder = undefined;
                      sortColumn = null;
                  } else {
                      // 切换为排序状态
                      sortOrder = order;
                  }
              }
              var newState = {
                  sortOrder: sortOrder,
                  sortColumn: sortColumn
              };
              // Controlled
              if (this.getSortOrderColumns().length === 0) {
                  this.setState(newState);
              }
              var onChange = this.props.onChange;
              if (onChange) {
                  onChange.apply(null, this.prepareParamsArguments((0, _extends5['default'])({}, this.state, newState)));
              }
          }
      }, {
          key: 'renderRowSelection',
          value: function renderRowSelection(locale) {
              var _this6 = this;

              var _props = this.props,
                  prefixCls = _props.prefixCls,
                  rowSelection = _props.rowSelection;

              var columns = this.columns.concat();
              if (rowSelection) {
                  var data = this.getFlatCurrentPageData().filter(function (item, index) {
                      if (rowSelection.getCheckboxProps) {
                          return !_this6.getCheckboxPropsByItem(item, index).disabled;
                      }
                      return true;
                  });
                  var selectionColumnClass = (0, _classnames2['default'])(prefixCls + '-selection-column', (0, _defineProperty3['default'])({}, prefixCls + '-selection-column-custom', rowSelection.selections));
                  var selectionColumn = {
                      key: 'selection-column',
                      render: this.renderSelectionBox(rowSelection.type),
                      className: selectionColumnClass,
                      fixed: rowSelection.fixed,
                      width: rowSelection.columnWidth
                  };
                  if (rowSelection.type !== 'radio') {
                      var checkboxAllDisabled = data.every(function (item, index) {
                          return _this6.getCheckboxPropsByItem(item, index).disabled;
                      });
                      selectionColumn.title = React.createElement(_SelectionCheckboxAll2['default'], { store: this.store, locale: locale, data: data, getCheckboxPropsByItem: this.getCheckboxPropsByItem, getRecordKey: this.getRecordKey, disabled: checkboxAllDisabled, prefixCls: prefixCls, onSelect: this.handleSelectRow, selections: rowSelection.selections, hideDefaultSelections: rowSelection.hideDefaultSelections, getPopupContainer: this.getPopupContainer });
                  }
                  if ('fixed' in rowSelection) {
                      selectionColumn.fixed = rowSelection.fixed;
                  } else if (columns.some(function (column) {
                      return column.fixed === 'left' || column.fixed === true;
                  })) {
                      selectionColumn.fixed = 'left';
                  }
                  if (columns[0] && columns[0].key === 'selection-column') {
                      columns[0] = selectionColumn;
                  } else {
                      columns.unshift(selectionColumn);
                  }
              }
              return columns;
          }
      }, {
          key: 'getColumnKey',
          value: function getColumnKey(column, index) {
              return column.key || column.dataIndex || index;
          }
      }, {
          key: 'getMaxCurrent',
          value: function getMaxCurrent(total) {
              var _state$pagination = this.state.pagination,
                  current = _state$pagination.current,
                  pageSize = _state$pagination.pageSize;

              if ((current - 1) * pageSize >= total) {
                  return Math.floor((total - 1) / pageSize) + 1;
              }
              return current;
          }
      }, {
          key: 'isSortColumn',
          value: function isSortColumn(column) {
              var sortColumn = this.state.sortColumn;

              if (!column || !sortColumn) {
                  return false;
              }
              return this.getColumnKey(sortColumn) === this.getColumnKey(column);
          }
      }, {
          key: 'renderColumnsDropdown',
          value: function renderColumnsDropdown(columns, locale) {
              var _this7 = this;

              var _props2 = this.props,
                  prefixCls = _props2.prefixCls,
                  dropdownPrefixCls = _props2.dropdownPrefixCls;
              var sortOrder = this.state.sortOrder;

              return (0, util$3.treeMap)(columns, function (originColumn, i) {
                  var column = (0, _extends5['default'])({}, originColumn);
                  var key = _this7.getColumnKey(column, i);
                  var filterDropdown$$1 = void 0;
                  var sortButton = void 0;
                  if (column.filters && column.filters.length > 0 || column.filterDropdown) {
                      var colFilters = _this7.state.filters[key] || [];
                      filterDropdown$$1 = React.createElement(_filterDropdown2['default'], { locale: locale, column: column, selectedKeys: colFilters, confirmFilter: _this7.handleFilter, prefixCls: prefixCls + '-filter', dropdownPrefixCls: dropdownPrefixCls || 'ant-dropdown', getPopupContainer: _this7.getPopupContainer });
                  }
                  if (column.sorter) {
                      var isSortColumn = _this7.isSortColumn(column);
                      if (isSortColumn) {
                          column.className = (0, _classnames2['default'])(column.className, (0, _defineProperty3['default'])({}, prefixCls + '-column-sort', sortOrder));
                      }
                      var isAscend = isSortColumn && sortOrder === 'ascend';
                      var isDescend = isSortColumn && sortOrder === 'descend';
                      sortButton = React.createElement(
                          'div',
                          { className: prefixCls + '-column-sorter' },
                          React.createElement(
                              'span',
                              { className: prefixCls + '-column-sorter-up ' + (isAscend ? 'on' : 'off'), title: '\u2191', onClick: function onClick() {
                                      return _this7.toggleSortOrder('ascend', column);
                                  } },
                              React.createElement(_icon2['default'], { type: 'caret-up' })
                          ),
                          React.createElement(
                              'span',
                              { className: prefixCls + '-column-sorter-down ' + (isDescend ? 'on' : 'off'), title: '\u2193', onClick: function onClick() {
                                      return _this7.toggleSortOrder('descend', column);
                                  } },
                              React.createElement(_icon2['default'], { type: 'caret-down' })
                          )
                      );
                  }
                  column.title = React.createElement(
                      'span',
                      { key: key },
                      column.title,
                      sortButton,
                      filterDropdown$$1
                  );
                  if (sortButton || filterDropdown$$1) {
                      column.className = (0, _classnames2['default'])(prefixCls + '-column-has-filters', column.className);
                  }
                  return column;
              });
          }
      }, {
          key: 'renderPagination',
          value: function renderPagination(paginationPosition) {
              // 强制不需要分页
              if (!this.hasPagination()) {
                  return null;
              }
              var size = 'default';
              var pagination$$1 = this.state.pagination;

              if (pagination$$1.size) {
                  size = pagination$$1.size;
              } else if (this.props.size === 'middle' || this.props.size === 'small') {
                  size = 'small';
              }
              var position = pagination$$1.position || 'bottom';
              var total = pagination$$1.total || this.getLocalData().length;
              return total > 0 && (position === paginationPosition || position === 'both') ? React.createElement(_pagination2['default'], (0, _extends5['default'])({ key: 'pagination-' + paginationPosition }, pagination$$1, { className: (0, _classnames2['default'])(pagination$$1.className, this.props.prefixCls + '-pagination'), onChange: this.handlePageChange, total: total, size: size, current: this.getMaxCurrent(total), onShowSizeChange: this.handleShowSizeChange })) : null;
          }
          // Get pagination, filters, sorter

      }, {
          key: 'prepareParamsArguments',
          value: function prepareParamsArguments(state) {
              var pagination$$1 = (0, _extends5['default'])({}, state.pagination);
              // remove useless handle function in Table.onChange
              delete pagination$$1.onChange;
              delete pagination$$1.onShowSizeChange;
              var filters = state.filters;
              var sorter = {};
              if (state.sortColumn && state.sortOrder) {
                  sorter.column = state.sortColumn;
                  sorter.order = state.sortOrder;
                  sorter.field = state.sortColumn.dataIndex;
                  sorter.columnKey = this.getColumnKey(state.sortColumn);
              }
              return [pagination$$1, filters, sorter];
          }
      }, {
          key: 'findColumn',
          value: function findColumn(myKey) {
              var _this8 = this;

              var column = void 0;
              (0, util$3.treeMap)(this.columns, function (c) {
                  if (_this8.getColumnKey(c) === myKey) {
                      column = c;
                  }
              });
              return column;
          }
      }, {
          key: 'getCurrentPageData',
          value: function getCurrentPageData() {
              var data = this.getLocalData();
              var current = void 0;
              var pageSize = void 0;
              var state = this.state;
              // 如果没有分页的话，默认全部展示
              if (!this.hasPagination()) {
                  pageSize = Number.MAX_VALUE;
                  current = 1;
              } else {
                  pageSize = state.pagination.pageSize;
                  current = this.getMaxCurrent(state.pagination.total || data.length);
              }
              // 分页
              // ---
              // 当数据量少于等于每页数量时，直接设置数据
              // 否则进行读取分页数据
              if (data.length > pageSize || pageSize === Number.MAX_VALUE) {
                  data = data.filter(function (_, i) {
                      return i >= (current - 1) * pageSize && i < current * pageSize;
                  });
              }
              return data;
          }
      }, {
          key: 'getFlatData',
          value: function getFlatData() {
              return (0, util$3.flatArray)(this.getLocalData());
          }
      }, {
          key: 'getFlatCurrentPageData',
          value: function getFlatCurrentPageData() {
              return (0, util$3.flatArray)(this.getCurrentPageData());
          }
      }, {
          key: 'recursiveSort',
          value: function recursiveSort(data, sorterFn) {
              var _this9 = this;

              var _props$childrenColumn = this.props.childrenColumnName,
                  childrenColumnName = _props$childrenColumn === undefined ? 'children' : _props$childrenColumn;

              return data.sort(sorterFn).map(function (item) {
                  return item[childrenColumnName] ? (0, _extends5['default'])({}, item, (0, _defineProperty3['default'])({}, childrenColumnName, _this9.recursiveSort(item[childrenColumnName], sorterFn))) : item;
              });
          }
      }, {
          key: 'getLocalData',
          value: function getLocalData() {
              var _this10 = this;

              var state = this.state;
              var dataSource = this.props.dataSource;

              var data = dataSource || [];
              // 优化本地排序
              data = data.slice(0);
              var sorterFn = this.getSorterFn();
              if (sorterFn) {
                  data = this.recursiveSort(data, sorterFn);
              }
              // 筛选
              if (state.filters) {
                  Object.keys(state.filters).forEach(function (columnKey) {
                      var col = _this10.findColumn(columnKey);
                      if (!col) {
                          return;
                      }
                      var values = state.filters[columnKey] || [];
                      if (values.length === 0) {
                          return;
                      }
                      var onFilter = col.onFilter;
                      data = onFilter ? data.filter(function (record) {
                          return values.some(function (v) {
                              return onFilter(v, record);
                          });
                      }) : data;
                  });
              }
              return data;
          }
      }, {
          key: 'createComponents',
          value: function createComponents() {
              var components = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              var prevComponents = arguments[1];

              var bodyRow = components && components.body && components.body.row;
              var preBodyRow = prevComponents && prevComponents.body && prevComponents.body.row;
              if (!this.components || bodyRow !== preBodyRow) {
                  this.components = (0, _extends5['default'])({}, components);
                  this.components.body = (0, _extends5['default'])({}, components.body, { row: (0, _createBodyRow2['default'])(bodyRow) });
              }
          }
      }, {
          key: 'render',
          value: function render() {
              var _this11 = this;

              var _props3 = this.props,
                  style = _props3.style,
                  className = _props3.className,
                  prefixCls = _props3.prefixCls;

              var data = this.getCurrentPageData();
              var loading = this.props.loading;
              if (typeof loading === 'boolean') {
                  loading = {
                      spinning: loading
                  };
              }
              var table = React.createElement(
                  _LocaleReceiver2['default'],
                  { componentName: 'Table', defaultLocale: _default2['default'].Table },
                  function (locale) {
                      return _this11.renderTable(locale, loading);
                  }
              );
              // if there is no pagination or no data,
              // the height of spin should decrease by half of pagination
              var paginationPatchClass = this.hasPagination() && data && data.length !== 0 ? prefixCls + '-with-pagination' : prefixCls + '-without-pagination';
              return React.createElement(
                  'div',
                  { className: (0, _classnames2['default'])(prefixCls + '-wrapper', className), style: style },
                  React.createElement(
                      _spin2['default'],
                      (0, _extends5['default'])({}, loading, { className: loading.spinning ? paginationPatchClass + ' ' + prefixCls + '-spin-holder' : '' }),
                      this.renderPagination('top'),
                      table,
                      this.renderPagination('bottom')
                  )
              );
          }
      }]);
      return Table;
  }(React.Component);

  exports['default'] = Table;

  Table.Column = _Column2['default'];
  Table.ColumnGroup = _ColumnGroup2['default'];
  Table.propTypes = {
      dataSource: _propTypes2['default'].array,
      columns: _propTypes2['default'].array,
      prefixCls: _propTypes2['default'].string,
      useFixedHeader: _propTypes2['default'].bool,
      rowSelection: _propTypes2['default'].object,
      className: _propTypes2['default'].string,
      size: _propTypes2['default'].string,
      loading: _propTypes2['default'].oneOfType([_propTypes2['default'].bool, _propTypes2['default'].object]),
      bordered: _propTypes2['default'].bool,
      onChange: _propTypes2['default'].func,
      locale: _propTypes2['default'].object,
      dropdownPrefixCls: _propTypes2['default'].string
  };
  Table.defaultProps = {
      dataSource: [],
      prefixCls: 'ant-table',
      useFixedHeader: false,
      className: '',
      size: 'large',
      loading: false,
      bordered: false,
      indentSize: 20,
      locale: {},
      rowKey: 'key',
      showHeader: true
  };
  module.exports = exports['default'];
  });

  unwrapExports(Table_1);

  var table = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _Table2 = _interopRequireDefault(Table_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  exports['default'] = _Table2['default'];
  module.exports = exports['default'];
  });

  var Table$2 = unwrapExports(table);

  var TableMenu =
  /*#__PURE__*/
  function (_Component) {
    _inherits(TableMenu, _Component);

    function TableMenu() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, TableMenu);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TableMenu)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", {
        visible: true,
        columns: [] //请求远程数据接口

      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "saveFormRef", function (form$$1) {
        return _this.form = form$$1;
      });

      return _this;
    }

    _createClass(TableMenu, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        var actions = this.props.actions;
      } // //处理表格提交后动作

    }, {
      key: "handleOk",
      value: function handleOk() {
        var columns = this.state.columns;
        var _this$props = this.props,
            onSelectChange = _this$props.onSelectChange,
            onClosePopup = _this$props.onClosePopup; //  console.log(columns)

        onSelectChange(columns); //  this.form.onSubmit()

        onClosePopup();
      }
    }, {
      key: "handleSubmit",
      value: function handleSubmit(values) {
        var onSelectChange = this.props.onSelectChange;
        this.setState({
          columns: values
        }); //  console.log(values)
        // return new API().fetchTableColumns(values).then(json => {
        //   onSelectChange(values.isShowArr)
        //   // console.log(json,values)
        // }).catch(ex => {
        //   return "error"
        // })
      }
    }, {
      key: "handleChange",
      value: function handleChange(values) {
        var onSelectChange = this.props.onSelectChange;
        this.setState({
          columns: values
        }); // console.log(value)
        // const { onSelectChange } =this.props
        // onSelectChange(value)
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props2 = this.props,
            form$$1 = _this$props2.form,
            initialValues = _this$props2.initialValues,
            handleSubmit = _this$props2.handleSubmit,
            children = _this$props2.children,
            defaultValue = _this$props2.defaultValue,
            columns = _this$props2.columns,
            onClosePopup = _this$props2.onClosePopup;
        var saveFormRef = this.saveFormRef;
        return React$1__default.createElement("div", {
          className: "",
          style: {
            width: 400,
            height: 200,
            padding: '10px',
            border: '1px solid #cfdae5',
            background: '#fff'
          }
        }, React$1__default.createElement(Form$1, {
          onSubmit: handleSubmit,
          ref: saveFormRef,
          layout: "inline"
        }, React$1__default.createElement(Checkbox$2.Group, {
          name: "isShowArr",
          style: {
            width: '100%'
          },
          defaultValue: defaultValue,
          onChange: this.handleChange.bind(this)
        }, React$1__default.createElement(Row, null, columns.filter(function (it) {
          return it.title != '操作';
        }).map(function (it, idx) {
          return React$1__default.createElement(Col, {
            span: 8,
            key: idx
          }, React$1__default.createElement(Checkbox$2, {
            value: it.key,
            disabled: it.isRead == 1 ? true : false
          }, it.title));
        }))), React$1__default.createElement("div", {
          style: {
            textAlign: 'right'
          }
        }, React$1__default.createElement(Button, {
          size: "small",
          onClick: onClosePopup
        }, "\u53D6\u6D88"), React$1__default.createElement(Button, {
          size: "small",
          type: "primary",
          onClick: this.handleOk.bind(this),
          style: {
            marginLeft: '10px'
          }
        }, "\u786E\u5B9A"))));
      }
    }]);

    return TableMenu;
  }(React$1.Component);

  var DataTable =
  /*#__PURE__*/
  function (_Component2) {
    _inherits(DataTable, _Component2);

    _createClass(DataTable, [{
      key: "showPopover",
      value: function showPopover() {
        this.setState({
          visible: true
        });
      }
    }]);

    function DataTable(props) {
      var _this2;

      _classCallCheck(this, DataTable);

      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(DataTable).call(this, props));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "state", {
        visible: false,
        newColumns: [],
        displayColumns: []
      });

      _this2.state.columns = props.columns;
      return _this2;
    }

    _createClass(DataTable, [{
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        var columns = nextProps.columns;
        this.setState({
          columns: columns
        });
      }
    }, {
      key: "onSelectChange",
      value: function onSelectChange(checkedValues) {
        //console.log(checkedValues)
        this.setState({
          columns: this.state.columns.map(function (col) {
            if (checkedValues.indexOf(col.key) >= 0) {
              col.visible = true;
            } else {
              col.visible = false;
            }

            return col;
          })
        });
      }
    }, {
      key: "onClosePopup",
      value: function onClosePopup() {
        this.setState({
          visible: false
        });
      }
    }, {
      key: "onPopupVisibleChange",
      value: function onPopupVisibleChange(boolean) {
        // console.log('show',arguments)
        this.setState({
          visible: boolean
        });
      }
    }, {
      key: "renderTableMenu",
      value: function renderTableMenu() {
        var columns = this.state.columns;
        var defaultValue = columns.filter(function (col) {
          return col.type != 'config' && (col.visible === true || col.visible === undefined);
        }).map(function (col) {
          return col.key;
        });
        return React$1__default.createElement(TableMenu, {
          defaultValue: defaultValue,
          columns: columns,
          onSelectChange: this.onSelectChange.bind(this),
          onClosePopup: this.onClosePopup.bind(this)
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props3 = this.props,
            pagination = _this$props3.pagination,
            showConfig = _this$props3.showConfig,
            page = _this$props3.page,
            otherProps = _objectWithoutProperties(_this$props3, ["pagination", "showConfig", "page"]);

        var _this$state = this.state,
            visible = _this$state.visible,
            columns = _this$state.columns;
        var newColumns;

        if (showConfig) {
          // if(true){
          newColumns = columns.filter(function (col) {
            return col.visible == true || col.visible == undefined; // return true
          }); // .concat([{
          //     title:" ",
          //     filterDropdown:(
          //       this.renderTableMenu()
          //     ),
          //     filterDropdownVisible:visible,
          //     onFilterDropdownVisibleChange:this.onPopupVisibleChange.bind(this),
          //     width:30,
          //     fixed:'right',
          //     type:'config'
          // }])
        } else {
          newColumns = columns;
        } //console.log(newColumns,columns)


        return React$1__default.createElement(Table$2, _extends({}, otherProps, {
          columns: newColumns,
          pagination: !pagination ? false : Object.assign({}, pagination, page)
        }));
      }
    }]);

    return DataTable;
  }(React$1.Component);

  _defineProperty(DataTable, "defaultProps", {
    page: {},
    prefixCls: 'ant-table',
    pagination: {
      showTotal: function showTotal(total) {
        return "\u5171 ".concat(total, " \u6761");
      },
      // showQuickJumper:true,
      size: "middle",
      showSizeChanger: true,
      pageSizeOptions: ['10', '20', '50', '100']
    },
    //  scroll:{ y: 500 },
    style: {
      width: "100%"
    },
    showConfig: false,
    columns: []
  });

  var css$4 = ".ant-panel-wrapper {\n  display: flex;\n  flex-direction: column;\n  flex: 1;\n  background-color: #fff;\n}\n.ant-panel-wrapper > .ant-spin-nested-loading {\n  display: flex;\n  flex-direction: column;\n  flex: 1;\n}\n.ant-panel-wrapper > .ant-spin-nested-loading > .ant-spin-container {\n  display: flex;\n  flex-direction: column;\n  flex: 1;\n}\n.ant-panel-wrapper .ant-panel {\n  display: flex;\n  flex-direction: column;\n  flex: 1;\n}\n.ant-panel-wrapper .ant-panel .ant-panel-head {\n  display: flex;\n  padding: 16px 24px;\n  color: rgba(0, 0, 0, 0.65);\n  background: #fff;\n  border-bottom: 1px solid #e8e8e8;\n  border-radius: 4px 4px 0 0;\n}\n.ant-panel-wrapper .ant-panel .ant-panel-head .ant-panel-head-title {\n  margin: 0;\n  color: rgba(0, 0, 0, 0.85);\n  font-weight: 500;\n  font-size: 16px;\n  line-height: 22px;\n}\n.ant-panel-wrapper .ant-panel .ant-panel-body {\n  display: flex;\n  flex: 1;\n  overflow: auto;\n  flex-direction: column;\n  padding: 10px 16px;\n}\n.ant-panel-wrapper .ant-panel .ant-panel-footer {\n  padding: 10px 16px;\n  text-align: center;\n  border-top: 1px solid #e8e8e8;\n  border-radius: 0 0 4px 4px;\n}\n.ant-panel-wrapper .ant-panel .ant-panel-footer button {\n  margin: 0 4px;\n}\n";
  styleInject(css$4);

  var Panel$1 =
  /*#__PURE__*/
  function (_Component) {
    _inherits(Panel, _Component);

    function Panel() {
      _classCallCheck(this, Panel);

      return _possibleConstructorReturn(this, _getPrototypeOf(Panel).apply(this, arguments));
    }

    _createClass(Panel, [{
      key: "renderHeader",
      value: function renderHeader() {
        var header;
        var _this$props = this.props,
            prefixCls = _this$props.prefixCls,
            title = _this$props.title,
            extra = _this$props.extra;

        if (title || extra) {
          header = React$1__default.createElement("div", {
            className: prefixCls + "-head"
          }, React$1__default.createElement("div", {
            className: prefixCls + "-head-wrapper"
          }, title && React$1__default.createElement("div", {
            className: prefixCls + "-head-title"
          }, title), extra && React$1__default.createElement("div", {
            className: prefixCls + "-extra"
          }, extra)));
        }

        return header;
      }
    }, {
      key: "renderBody",
      value: function renderBody() {
        var props = this.props;
        var prefixCls = this.props.prefixCls;
        return React$1__default.createElement("div", {
          className: prefixCls + '-body'
        }, props.children);
      }
    }, {
      key: "renderFooter",
      value: function renderFooter() {
        var footer;
        var props = this.props;
        var _this$props2 = this.props,
            prefixCls = _this$props2.prefixCls,
            onOk = _this$props2.onOk,
            onCancel = _this$props2.onCancel,
            okText = _this$props2.okText,
            cancelText = _this$props2.cancelText,
            confirmLoading = _this$props2.confirmLoading; // console.log(this.props)

        var defaultFooter = props.footer ? props.footer : function (props) {
          return [React$1__default.createElement(Button, {
            loading: confirmLoading,
            onClick: onOk,
            type: "primary"
          }, okText), React$1__default.createElement(Button, {
            onClick: onCancel
          }, cancelText)];
        };

        if (props.footer != false) {
          footer = React$1__default.createElement("div", {
            className: prefixCls + '-footer'
          }, defaultFooter());
        }

        return footer;
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props3 = this.props,
            prefixCls = _this$props3.prefixCls,
            loading = _this$props3.loading;
        return React$1__default.createElement("div", {
          className: "".concat(prefixCls, "-wrapper")
        }, React$1__default.createElement(Spin, {
          spinning: loading
        }, React$1__default.createElement("div", {
          className: "".concat(prefixCls)
        }, this.renderHeader(), this.renderBody(), this.renderFooter())));
      }
    }]);

    return Panel;
  }(React$1.Component);
  Panel$1.propTypes = {
    onOK: PropTypes.func,
    onCancel: PropTypes.func,
    title: PropTypes.string,
    okText: PropTypes.string,
    cancelText: PropTypes.string,
    footer: PropTypes.oneOfType([PropTypes.bool, PropTypes.element, PropTypes.func]),
    confirmLoading: PropTypes.bool,
    loading: PropTypes.bool
  };
  Panel$1.defaultProps = {
    prefixCls: "ant-panel",
    onOk: function onOk() {},
    loading: false,
    onCancel: function onCancel() {},
    title: "",
    okText: "确认",
    cancelText: "取消",
    // footer:function(){},
    confirmLoading: false
  };

  var ModalAndView =
  /*#__PURE__*/
  function (_Component) {
    _inherits(ModalAndView, _Component);

    function ModalAndView() {
      _classCallCheck(this, ModalAndView);

      return _possibleConstructorReturn(this, _getPrototypeOf(ModalAndView).apply(this, arguments));
    }

    _createClass(ModalAndView, [{
      key: "handleBackRoute",
      value: function handleBackRoute() {
        var _this$props = this.props,
            actions = _this$props.actions,
            history = _this$props.history,
            router = _this$props.router; //  actions.backRoute(router)
      }
    }, {
      key: "handleSaveRoute",
      value: function handleSaveRoute() {
        var formView = this.refs.formView;
        formView.onSubmit();
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props2 = this.props,
            route = _this$props2.route,
            children = _this$props2.children,
            otherProps = _objectWithoutProperties(_this$props2, ["route", "children"]);

        console.log(Modal$1);
        console.log(React$1__default.createElement("div", null));
        console.log(this.props);
        return React$1__default.createElement(Modal$1, _extends({
          title: "title",
          visible: true,
          maskClosable: false,
          onCancel: this.handleBackRoute.bind(this),
          onOk: this.handleSaveRoute.bind(this)
        }, otherProps), React$1__default.cloneElement(children.type, Object.assign({}, otherProps, {
          ref: "formView"
        })));
      }
    }]);

    return ModalAndView;
  }(React$1.Component); //export default withRouter(ModalAndView)

  var KeyCode$2 = {
    /**
     * LEFT
     */
    LEFT: 37, // also NUM_WEST
    /**
     * UP
     */
    UP: 38, // also NUM_NORTH
    /**
     * RIGHT
     */
    RIGHT: 39, // also NUM_EAST
    /**
     * DOWN
     */
    DOWN: 40 // also NUM_SOUTH
  };

  function toArray$3(children) {
    // allow [c,[a,b]]
    var c = [];
    React$1__default.Children.forEach(children, function (child) {
      if (child) {
        c.push(child);
      }
    });
    return c;
  }

  function getActiveIndex(children, activeKey) {
    var c = toArray$3(children);
    for (var i = 0; i < c.length; i++) {
      if (c[i].key === activeKey) {
        return i;
      }
    }
    return -1;
  }
  function getTransformPropValue(v) {
    return {
      transform: v,
      WebkitTransform: v,
      MozTransform: v
    };
  }

  function isVertical(tabBarPosition) {
    return tabBarPosition === 'left' || tabBarPosition === 'right';
  }

  function getTransformByIndex(index, tabBarPosition) {
    var translate = isVertical(tabBarPosition) ? 'translateY' : 'translateX';
    return translate + '(' + -index * 100 + '%) translateZ(0)';
  }

  function getMarginStyle(index, tabBarPosition) {
    var marginDirection = isVertical(tabBarPosition) ? 'marginTop' : 'marginLeft';
    return _defineProperty$1({}, marginDirection, -index * 100 + '%');
  }

  function getDataAttr(props) {
    return Object.keys(props).reduce(function (prev, key) {
      if (key.substr(0, 5) === 'aria-' || key.substr(0, 5) === 'data-' || key === 'role') {
        prev[key] = props[key];
      }
      return prev;
    }, {});
  }

  var TabPane = createReactClass({
    displayName: 'TabPane',
    propTypes: {
      className: PropTypes.string,
      active: PropTypes.bool,
      style: PropTypes.any,
      destroyInactiveTabPane: PropTypes.bool,
      forceRender: PropTypes.bool,
      placeholder: PropTypes.node
    },
    getDefaultProps: function getDefaultProps() {
      return { placeholder: null };
    },
    render: function render() {
      var _classnames;

      var _props = this.props,
          className = _props.className,
          destroyInactiveTabPane = _props.destroyInactiveTabPane,
          active = _props.active,
          forceRender = _props.forceRender,
          rootPrefixCls = _props.rootPrefixCls,
          style = _props.style,
          children = _props.children,
          placeholder = _props.placeholder,
          restProps = _objectWithoutProperties$1(_props, ['className', 'destroyInactiveTabPane', 'active', 'forceRender', 'rootPrefixCls', 'style', 'children', 'placeholder']);

      this._isActived = this._isActived || active;
      var prefixCls = rootPrefixCls + '-tabpane';
      var cls = classnames((_classnames = {}, _defineProperty$1(_classnames, prefixCls, 1), _defineProperty$1(_classnames, prefixCls + '-inactive', !active), _defineProperty$1(_classnames, prefixCls + '-active', active), _defineProperty$1(_classnames, className, className), _classnames));
      var isRender = destroyInactiveTabPane ? active : this._isActived;
      return React$1__default.createElement(
        'div',
        _extends$2({
          style: style,
          role: 'tabpanel',
          'aria-hidden': active ? 'false' : 'true',
          className: cls
        }, getDataAttr(restProps)),
        isRender || forceRender ? children : placeholder
      );
    }
  });

  function noop$d() {}

  function getDefaultActiveKey(props) {
    var activeKey = void 0;
    React$1__default.Children.forEach(props.children, function (child) {
      if (child && !activeKey && !child.props.disabled) {
        activeKey = child.key;
      }
    });
    return activeKey;
  }

  function activeKeyIsValid(props, key) {
    var keys = React$1__default.Children.map(props.children, function (child) {
      return child && child.key;
    });
    return keys.indexOf(key) >= 0;
  }

  var Tabs = function (_React$Component) {
    _inherits$1(Tabs, _React$Component);

    function Tabs(props) {
      _classCallCheck$1(this, Tabs);

      var _this = _possibleConstructorReturn$1(this, (Tabs.__proto__ || Object.getPrototypeOf(Tabs)).call(this, props));

      _initialiseProps$k.call(_this);

      var activeKey = void 0;
      if ('activeKey' in props) {
        activeKey = props.activeKey;
      } else if ('defaultActiveKey' in props) {
        activeKey = props.defaultActiveKey;
      } else {
        activeKey = getDefaultActiveKey(props);
      }

      _this.state = {
        activeKey: activeKey
      };
      return _this;
    }

    _createClass$1(Tabs, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        if ('activeKey' in nextProps) {
          this.setState({
            activeKey: nextProps.activeKey
          });
        } else if (!activeKeyIsValid(nextProps, this.state.activeKey)) {
          // https://github.com/ant-design/ant-design/issues/7093
          this.setState({
            activeKey: getDefaultActiveKey(nextProps)
          });
        }
      }
    }, {
      key: 'render',
      value: function render() {
        var _classnames;

        var props = this.props;

        var prefixCls = props.prefixCls,
            navWrapper = props.navWrapper,
            tabBarPosition = props.tabBarPosition,
            className = props.className,
            renderTabContent = props.renderTabContent,
            renderTabBar = props.renderTabBar,
            destroyInactiveTabPane = props.destroyInactiveTabPane,
            restProps = _objectWithoutProperties$1(props, ['prefixCls', 'navWrapper', 'tabBarPosition', 'className', 'renderTabContent', 'renderTabBar', 'destroyInactiveTabPane']);

        var cls = classnames((_classnames = {}, _defineProperty$1(_classnames, prefixCls, 1), _defineProperty$1(_classnames, prefixCls + '-' + tabBarPosition, 1), _defineProperty$1(_classnames, className, !!className), _classnames));

        this.tabBar = renderTabBar();
        var contents = [React$1__default.cloneElement(this.tabBar, {
          prefixCls: prefixCls,
          navWrapper: navWrapper,
          key: 'tabBar',
          onKeyDown: this.onNavKeyDown,
          tabBarPosition: tabBarPosition,
          onTabClick: this.onTabClick,
          panels: props.children,
          activeKey: this.state.activeKey
        }), React$1__default.cloneElement(renderTabContent(), {
          prefixCls: prefixCls,
          tabBarPosition: tabBarPosition,
          activeKey: this.state.activeKey,
          destroyInactiveTabPane: destroyInactiveTabPane,
          children: props.children,
          onChange: this.setActiveKey,
          key: 'tabContent'
        })];
        if (tabBarPosition === 'bottom') {
          contents.reverse();
        }
        return React$1__default.createElement(
          'div',
          _extends$2({
            className: cls,
            style: props.style
          }, getDataAttr(restProps)),
          contents
        );
      }
    }]);

    return Tabs;
  }(React$1__default.Component);

  var _initialiseProps$k = function _initialiseProps() {
    var _this2 = this;

    this.onTabClick = function (activeKey, e) {
      if (_this2.tabBar.props.onTabClick) {
        _this2.tabBar.props.onTabClick(activeKey, e);
      }
      _this2.setActiveKey(activeKey);
    };

    this.onNavKeyDown = function (e) {
      var eventKeyCode = e.keyCode;
      if (eventKeyCode === KeyCode$2.RIGHT || eventKeyCode === KeyCode$2.DOWN) {
        e.preventDefault();
        var nextKey = _this2.getNextActiveKey(true);
        _this2.onTabClick(nextKey);
      } else if (eventKeyCode === KeyCode$2.LEFT || eventKeyCode === KeyCode$2.UP) {
        e.preventDefault();
        var previousKey = _this2.getNextActiveKey(false);
        _this2.onTabClick(previousKey);
      }
    };

    this.setActiveKey = function (activeKey) {
      if (_this2.state.activeKey !== activeKey) {
        if (!('activeKey' in _this2.props)) {
          _this2.setState({
            activeKey: activeKey
          });
        }
        _this2.props.onChange(activeKey);
      }
    };

    this.getNextActiveKey = function (next) {
      var activeKey = _this2.state.activeKey;
      var children = [];
      React$1__default.Children.forEach(_this2.props.children, function (c) {
        if (c && !c.props.disabled) {
          if (next) {
            children.push(c);
          } else {
            children.unshift(c);
          }
        }
      });
      var length = children.length;
      var ret = length && children[0].key;
      children.forEach(function (child, i) {
        if (child.key === activeKey) {
          if (i === length - 1) {
            ret = children[0].key;
          } else {
            ret = children[i + 1].key;
          }
        }
      });
      return ret;
    };
  };


  Tabs.propTypes = {
    destroyInactiveTabPane: PropTypes.bool,
    renderTabBar: PropTypes.func.isRequired,
    renderTabContent: PropTypes.func.isRequired,
    navWrapper: PropTypes.func,
    onChange: PropTypes.func,
    children: PropTypes.any,
    prefixCls: PropTypes.string,
    className: PropTypes.string,
    tabBarPosition: PropTypes.string,
    style: PropTypes.object,
    activeKey: PropTypes.string,
    defaultActiveKey: PropTypes.string
  };

  Tabs.defaultProps = {
    prefixCls: 'rc-tabs',
    destroyInactiveTabPane: false,
    onChange: noop$d,
    navWrapper: function navWrapper(arg) {
      return arg;
    },
    tabBarPosition: 'top',
    style: {}
  };

  Tabs.TabPane = TabPane;

  var TabContent = createReactClass({
    displayName: 'TabContent',
    propTypes: {
      animated: PropTypes.bool,
      animatedWithMargin: PropTypes.bool,
      prefixCls: PropTypes.string,
      children: PropTypes.any,
      activeKey: PropTypes.string,
      style: PropTypes.any,
      tabBarPosition: PropTypes.string
    },
    getDefaultProps: function getDefaultProps() {
      return {
        animated: true
      };
    },
    getTabPanes: function getTabPanes() {
      var props = this.props;
      var activeKey = props.activeKey;
      var children = props.children;
      var newChildren = [];

      React$1__default.Children.forEach(children, function (child) {
        if (!child) {
          return;
        }
        var key = child.key;
        var active = activeKey === key;
        newChildren.push(React$1__default.cloneElement(child, {
          active: active,
          destroyInactiveTabPane: props.destroyInactiveTabPane,
          rootPrefixCls: props.prefixCls
        }));
      });

      return newChildren;
    },
    render: function render() {
      var _classnames;

      var props = this.props;
      var prefixCls = props.prefixCls,
          children = props.children,
          activeKey = props.activeKey,
          tabBarPosition = props.tabBarPosition,
          animated = props.animated,
          animatedWithMargin = props.animatedWithMargin;
      var style = props.style;

      var classes = classnames((_classnames = {}, _defineProperty$1(_classnames, prefixCls + '-content', true), _defineProperty$1(_classnames, animated ? prefixCls + '-content-animated' : prefixCls + '-content-no-animated', true), _classnames));
      if (animated) {
        var activeIndex = getActiveIndex(children, activeKey);
        if (activeIndex !== -1) {
          var animatedStyle = animatedWithMargin ? getMarginStyle(activeIndex, tabBarPosition) : getTransformPropValue(getTransformByIndex(activeIndex, tabBarPosition));
          style = _extends$2({}, style, animatedStyle);
        } else {
          style = _extends$2({}, style, {
            display: 'none'
          });
        }
      }
      return React$1__default.createElement(
        'div',
        {
          className: classes,
          style: style
        },
        this.getTabPanes()
      );
    }
  });



  var es$e = /*#__PURE__*/Object.freeze({
    default: Tabs,
    TabPane: TabPane,
    TabContent: TabContent
  });

  var utils$3 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);

  exports.toArray = toArray;
  exports.getActiveIndex = getActiveIndex;
  exports.getActiveKey = getActiveKey;
  exports.setTransform = setTransform;
  exports.isTransformSupported = isTransformSupported;
  exports.setTransition = setTransition;
  exports.getTransformPropValue = getTransformPropValue;
  exports.isVertical = isVertical;
  exports.getTransformByIndex = getTransformByIndex;
  exports.getMarginStyle = getMarginStyle;
  exports.getStyle = getStyle;
  exports.setPxStyle = setPxStyle;
  exports.getDataAttr = getDataAttr;



  var _react2 = _interopRequireDefault(React$1__default);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function toArray(children) {
    // allow [c,[a,b]]
    var c = [];
    _react2['default'].Children.forEach(children, function (child) {
      if (child) {
        c.push(child);
      }
    });
    return c;
  }

  function getActiveIndex(children, activeKey) {
    var c = toArray(children);
    for (var i = 0; i < c.length; i++) {
      if (c[i].key === activeKey) {
        return i;
      }
    }
    return -1;
  }

  function getActiveKey(children, index) {
    var c = toArray(children);
    return c[index].key;
  }

  function setTransform(style, v) {
    style.transform = v;
    style.webkitTransform = v;
    style.mozTransform = v;
  }

  function isTransformSupported(style) {
    return 'transform' in style || 'webkitTransform' in style || 'MozTransform' in style;
  }

  function setTransition(style, v) {
    style.transition = v;
    style.webkitTransition = v;
    style.MozTransition = v;
  }
  function getTransformPropValue(v) {
    return {
      transform: v,
      WebkitTransform: v,
      MozTransform: v
    };
  }

  function isVertical(tabBarPosition) {
    return tabBarPosition === 'left' || tabBarPosition === 'right';
  }

  function getTransformByIndex(index, tabBarPosition) {
    var translate = isVertical(tabBarPosition) ? 'translateY' : 'translateX';
    return translate + '(' + -index * 100 + '%) translateZ(0)';
  }

  function getMarginStyle(index, tabBarPosition) {
    var marginDirection = isVertical(tabBarPosition) ? 'marginTop' : 'marginLeft';
    return (0, _defineProperty3['default'])({}, marginDirection, -index * 100 + '%');
  }

  function getStyle(el, property) {
    return +getComputedStyle(el).getPropertyValue(property).replace('px', '');
  }

  function setPxStyle(el, value, vertical) {
    value = vertical ? '0px, ' + value + 'px, 0px' : value + 'px, 0px, 0px';
    setTransform(el.style, 'translate3d(' + value + ')');
  }

  function getDataAttr(props) {
    return Object.keys(props).reduce(function (prev, key) {
      if (key.substr(0, 5) === 'aria-' || key.substr(0, 5) === 'data-' || key === 'role') {
        prev[key] = props[key];
      }
      return prev;
    }, {});
  }
  });

  unwrapExports(utils$3);
  var utils_1$1 = utils$3.toArray;
  var utils_2$1 = utils$3.getActiveIndex;
  var utils_3$1 = utils$3.getActiveKey;
  var utils_4$1 = utils$3.setTransform;
  var utils_5$1 = utils$3.isTransformSupported;
  var utils_6$1 = utils$3.setTransition;
  var utils_7$1 = utils$3.getTransformPropValue;
  var utils_8$1 = utils$3.isVertical;
  var utils_9$1 = utils$3.getTransformByIndex;
  var utils_10$1 = utils$3.getMarginStyle;
  var utils_11$1 = utils$3.getStyle;
  var utils_12$1 = utils$3.setPxStyle;
  var utils_13$1 = utils$3.getDataAttr;

  var InkTabBarMixin = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);

  exports.getScroll = getScroll;





  var _react2 = _interopRequireDefault(React$1__default);



  var _classnames3 = _interopRequireDefault(classnames);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function getScroll(w, top) {
    var ret = w['page' + (top ? 'Y' : 'X') + 'Offset'];
    var method = 'scroll' + (top ? 'Top' : 'Left');
    if (typeof ret !== 'number') {
      var d = w.document;
      // ie6,7,8 standard mode
      ret = d.documentElement[method];
      if (typeof ret !== 'number') {
        // quirks mode
        ret = d.body[method];
      }
    }
    return ret;
  }

  function offset(elem) {
    var box = void 0;
    var x = void 0;
    var y = void 0;
    var doc = elem.ownerDocument;
    var body = doc.body;
    var docElem = doc && doc.documentElement;
    box = elem.getBoundingClientRect();
    x = box.left;
    y = box.top;
    x -= docElem.clientLeft || body.clientLeft || 0;
    y -= docElem.clientTop || body.clientTop || 0;
    var w = doc.defaultView || doc.parentWindow;
    x += getScroll(w);
    y += getScroll(w, true);
    return {
      left: x, top: y
    };
  }

  function _componentDidUpdate(component, init) {
    var styles = component.props.styles;

    var rootNode = component.root;
    var wrapNode = component.nav || rootNode;
    var containerOffset = offset(wrapNode);
    var inkBarNode = component.inkBar;
    var activeTab = component.activeTab;
    var inkBarNodeStyle = inkBarNode.style;
    var tabBarPosition = component.props.tabBarPosition;
    if (init) {
      // prevent mount animation
      inkBarNodeStyle.display = 'none';
    }
    if (activeTab) {
      var tabNode = activeTab;
      var tabOffset = offset(tabNode);
      var transformSupported = (0, utils$3.isTransformSupported)(inkBarNodeStyle);
      if (tabBarPosition === 'top' || tabBarPosition === 'bottom') {
        var left = tabOffset.left - containerOffset.left;
        var width = tabNode.offsetWidth;

        // If tabNode'width width equal to wrapNode'width when tabBarPosition is top or bottom
        // It means no css working, then ink bar should not have width until css is loaded
        // Fix https://github.com/ant-design/ant-design/issues/7564
        if (width === rootNode.offsetWidth) {
          width = 0;
        } else if (styles.inkBar && styles.inkBar.width !== undefined) {
          width = parseFloat(styles.inkBar.width, 10);
          if (width) {
            left = left + (tabNode.offsetWidth - width) / 2;
          }
        }
        // use 3d gpu to optimize render
        if (transformSupported) {
          (0, utils$3.setTransform)(inkBarNodeStyle, 'translate3d(' + left + 'px,0,0)');
          inkBarNodeStyle.width = width + 'px';
          inkBarNodeStyle.height = '';
        } else {
          inkBarNodeStyle.left = left + 'px';
          inkBarNodeStyle.top = '';
          inkBarNodeStyle.bottom = '';
          inkBarNodeStyle.right = wrapNode.offsetWidth - left - width + 'px';
        }
      } else {
        var top = tabOffset.top - containerOffset.top;
        var height = tabNode.offsetHeight;
        if (styles.inkBar && styles.inkBar.height !== undefined) {
          height = parseFloat(styles.inkBar.height, 10);
          if (height) {
            top = top + (tabNode.offsetHeight - height) / 2;
          }
        }
        if (transformSupported) {
          (0, utils$3.setTransform)(inkBarNodeStyle, 'translate3d(0,' + top + 'px,0)');
          inkBarNodeStyle.height = height + 'px';
          inkBarNodeStyle.width = '';
        } else {
          inkBarNodeStyle.left = '';
          inkBarNodeStyle.right = '';
          inkBarNodeStyle.top = top + 'px';
          inkBarNodeStyle.bottom = wrapNode.offsetHeight - top - height + 'px';
        }
      }
    }
    inkBarNodeStyle.display = activeTab ? 'block' : 'none';
  }

  exports['default'] = {
    getDefaultProps: function getDefaultProps() {
      return {
        inkBarAnimated: true
      };
    },
    componentDidUpdate: function componentDidUpdate() {
      _componentDidUpdate(this);
    },
    componentDidMount: function componentDidMount() {

      {
        _componentDidUpdate(this, true);
      }
    },
    componentWillUnmount: function componentWillUnmount() {
      clearTimeout(this.timeout);
    },
    getInkBarNode: function getInkBarNode() {
      var _classnames;

      var _props = this.props,
          prefixCls = _props.prefixCls,
          styles = _props.styles,
          inkBarAnimated = _props.inkBarAnimated;

      var className = prefixCls + '-ink-bar';
      var classes = (0, _classnames3['default'])((_classnames = {}, (0, _defineProperty3['default'])(_classnames, className, true), (0, _defineProperty3['default'])(_classnames, inkBarAnimated ? className + '-animated' : className + '-no-animated', true), _classnames));
      return _react2['default'].createElement('div', {
        style: styles.inkBar,
        className: classes,
        key: 'inkBar',
        ref: this.saveRef('inkBar')
      });
    }
  };
  });

  unwrapExports(InkTabBarMixin);
  var InkTabBarMixin_1 = InkTabBarMixin.getScroll;

  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */
  var now = function() {
    return _root.Date.now();
  };

  var now_1 = now;

  /** Used as references for various `Number` constants. */
  var NAN = 0 / 0;

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Built-in method references without a dependency on `root`. */
  var freeParseInt = parseInt;

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol_1(value)) {
      return NAN;
    }
    if (isObject_1(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject_1(other) ? (other + '') : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return (isBinary || reIsOctal.test(value))
      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
      : (reIsBadHex.test(value) ? NAN : +value);
  }

  var toNumber_1 = toNumber;

  /** Error message constants. */
  var FUNC_ERROR_TEXT$1 = 'Expected a function';

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax$1 = Math.max,
      nativeMin = Math.min;

  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */
  function debounce$1(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT$1);
    }
    wait = toNumber_1(wait) || 0;
    if (isObject_1(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax$1(toNumber_1(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;

      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time;
      // Start the timer for the trailing edge.
      timerId = setTimeout(timerExpired, wait);
      // Invoke the leading edge.
      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          timeWaiting = wait - timeSinceLastCall;

      return maxing
        ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
        : timeWaiting;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime;

      // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.
      return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
        (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
    }

    function timerExpired() {
      var time = now_1();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      // Restart the timer.
      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined;

      // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now_1());
    }

    function debounced() {
      var time = now_1(),
          isInvoking = shouldInvoke(time);

      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          // Handle invocations in a tight loop.
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }

  var debounce_1 = debounce$1;

  var ScrollableTabBarMixin = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _classnames6 = _interopRequireDefault(classnames);





  var _react2 = _interopRequireDefault(React$1__default);



  var _addEventListener2 = _interopRequireDefault(addEventListener$1);



  var _debounce2 = _interopRequireDefault(debounce_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  exports['default'] = {
    getDefaultProps: function getDefaultProps() {
      return {
        scrollAnimated: true,
        onPrevClick: function onPrevClick() {},
        onNextClick: function onNextClick() {}
      };
    },
    getInitialState: function getInitialState() {
      this.offset = 0;
      return {
        next: false,
        prev: false
      };
    },
    componentDidMount: function componentDidMount() {
      var _this = this;

      this.componentDidUpdate();
      this.debouncedResize = (0, _debounce2['default'])(function () {
        _this.setNextPrev();
        _this.scrollToActiveTab();
      }, 200);
      this.resizeEvent = (0, _addEventListener2['default'])(window, 'resize', this.debouncedResize);
    },
    componentDidUpdate: function componentDidUpdate(prevProps) {
      var props = this.props;
      if (prevProps && prevProps.tabBarPosition !== props.tabBarPosition) {
        this.setOffset(0);
        return;
      }
      var nextPrev = this.setNextPrev();
      // wait next, prev show hide
      /* eslint react/no-did-update-set-state:0 */
      if (this.isNextPrevShown(this.state) !== this.isNextPrevShown(nextPrev)) {
        this.setState({}, this.scrollToActiveTab);
      } else if (!prevProps || props.activeKey !== prevProps.activeKey) {
        // can not use props.activeKey
        this.scrollToActiveTab();
      }
    },
    componentWillUnmount: function componentWillUnmount() {
      if (this.resizeEvent) {
        this.resizeEvent.remove();
      }
      if (this.debouncedResize && this.debouncedResize.cancel) {
        this.debouncedResize.cancel();
      }
    },
    setNextPrev: function setNextPrev() {
      var navNode = this.nav;
      var navNodeWH = this.getScrollWH(navNode);
      var containerWH = this.getOffsetWH(this.container);
      var navWrapNodeWH = this.getOffsetWH(this.navWrap);
      var offset = this.offset;

      var minOffset = containerWH - navNodeWH;
      var _state = this.state,
          next = _state.next,
          prev = _state.prev;

      if (minOffset >= 0) {
        next = false;
        this.setOffset(0, false);
        offset = 0;
      } else if (minOffset < offset) {
        next = true;
      } else {
        next = false;
        // Fix https://github.com/ant-design/ant-design/issues/8861
        // Test with container offset which is stable
        // and set the offset of the nav wrap node
        var realOffset = navWrapNodeWH - navNodeWH;
        this.setOffset(realOffset, false);
        offset = realOffset;
      }

      if (offset < 0) {
        prev = true;
      } else {
        prev = false;
      }

      this.setNext(next);
      this.setPrev(prev);
      return {
        next: next,
        prev: prev
      };
    },
    getOffsetWH: function getOffsetWH(node) {
      var tabBarPosition = this.props.tabBarPosition;
      var prop = 'offsetWidth';
      if (tabBarPosition === 'left' || tabBarPosition === 'right') {
        prop = 'offsetHeight';
      }
      return node[prop];
    },
    getScrollWH: function getScrollWH(node) {
      var tabBarPosition = this.props.tabBarPosition;
      var prop = 'scrollWidth';
      if (tabBarPosition === 'left' || tabBarPosition === 'right') {
        prop = 'scrollHeight';
      }
      return node[prop];
    },
    getOffsetLT: function getOffsetLT(node) {
      var tabBarPosition = this.props.tabBarPosition;
      var prop = 'left';
      if (tabBarPosition === 'left' || tabBarPosition === 'right') {
        prop = 'top';
      }
      return node.getBoundingClientRect()[prop];
    },
    setOffset: function setOffset(offset) {
      var checkNextPrev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var target = Math.min(0, offset);
      if (this.offset !== target) {
        this.offset = target;
        var navOffset = {};
        var tabBarPosition = this.props.tabBarPosition;
        var navStyle = this.nav.style;
        var transformSupported = (0, utils$3.isTransformSupported)(navStyle);
        if (tabBarPosition === 'left' || tabBarPosition === 'right') {
          if (transformSupported) {
            navOffset = {
              value: 'translate3d(0,' + target + 'px,0)'
            };
          } else {
            navOffset = {
              name: 'top',
              value: target + 'px'
            };
          }
        } else {
          if (transformSupported) {
            navOffset = {
              value: 'translate3d(' + target + 'px,0,0)'
            };
          } else {
            navOffset = {
              name: 'left',
              value: target + 'px'
            };
          }
        }
        if (transformSupported) {
          (0, utils$3.setTransform)(navStyle, navOffset.value);
        } else {
          navStyle[navOffset.name] = navOffset.value;
        }
        if (checkNextPrev) {
          this.setNextPrev();
        }
      }
    },
    setPrev: function setPrev(v) {
      if (this.state.prev !== v) {
        this.setState({
          prev: v
        });
      }
    },
    setNext: function setNext(v) {
      if (this.state.next !== v) {
        this.setState({
          next: v
        });
      }
    },
    isNextPrevShown: function isNextPrevShown(state) {
      if (state) {
        return state.next || state.prev;
      }
      return this.state.next || this.state.prev;
    },
    prevTransitionEnd: function prevTransitionEnd(e) {
      if (e.propertyName !== 'opacity') {
        return;
      }
      var container = this.container;

      this.scrollToActiveTab({
        target: container,
        currentTarget: container
      });
    },
    scrollToActiveTab: function scrollToActiveTab(e) {
      var activeTab = this.activeTab,
          navWrap = this.navWrap;

      if (e && e.target !== e.currentTarget || !activeTab) {
        return;
      }

      // when not scrollable or enter scrollable first time, don't emit scrolling
      var needToSroll = this.isNextPrevShown() && this.lastNextPrevShown;
      this.lastNextPrevShown = this.isNextPrevShown();
      if (!needToSroll) {
        return;
      }

      var activeTabWH = this.getScrollWH(activeTab);
      var navWrapNodeWH = this.getOffsetWH(navWrap);
      var offset = this.offset;

      var wrapOffset = this.getOffsetLT(navWrap);
      var activeTabOffset = this.getOffsetLT(activeTab);
      if (wrapOffset > activeTabOffset) {
        offset += wrapOffset - activeTabOffset;
        this.setOffset(offset);
      } else if (wrapOffset + navWrapNodeWH < activeTabOffset + activeTabWH) {
        offset -= activeTabOffset + activeTabWH - (wrapOffset + navWrapNodeWH);
        this.setOffset(offset);
      }
    },
    prev: function prev(e) {
      this.props.onPrevClick(e);
      var navWrapNode = this.navWrap;
      var navWrapNodeWH = this.getOffsetWH(navWrapNode);
      var offset = this.offset;

      this.setOffset(offset + navWrapNodeWH);
    },
    next: function next(e) {
      this.props.onNextClick(e);
      var navWrapNode = this.navWrap;
      var navWrapNodeWH = this.getOffsetWH(navWrapNode);
      var offset = this.offset;

      this.setOffset(offset - navWrapNodeWH);
    },
    getScrollBarNode: function getScrollBarNode(content) {
      var _classnames, _classnames2, _classnames3, _classnames4;

      var _state2 = this.state,
          next = _state2.next,
          prev = _state2.prev;
      var _props = this.props,
          prefixCls = _props.prefixCls,
          scrollAnimated = _props.scrollAnimated,
          navWrapper = _props.navWrapper;

      var showNextPrev = prev || next;

      var prevButton = _react2['default'].createElement(
        'span',
        {
          onClick: prev ? this.prev : null,
          unselectable: 'unselectable',
          className: (0, _classnames6['default'])((_classnames = {}, (0, _defineProperty3['default'])(_classnames, prefixCls + '-tab-prev', 1), (0, _defineProperty3['default'])(_classnames, prefixCls + '-tab-btn-disabled', !prev), (0, _defineProperty3['default'])(_classnames, prefixCls + '-tab-arrow-show', showNextPrev), _classnames)),
          onTransitionEnd: this.prevTransitionEnd
        },
        _react2['default'].createElement('span', { className: prefixCls + '-tab-prev-icon' })
      );

      var nextButton = _react2['default'].createElement(
        'span',
        {
          onClick: next ? this.next : null,
          unselectable: 'unselectable',
          className: (0, _classnames6['default'])((_classnames2 = {}, (0, _defineProperty3['default'])(_classnames2, prefixCls + '-tab-next', 1), (0, _defineProperty3['default'])(_classnames2, prefixCls + '-tab-btn-disabled', !next), (0, _defineProperty3['default'])(_classnames2, prefixCls + '-tab-arrow-show', showNextPrev), _classnames2))
        },
        _react2['default'].createElement('span', { className: prefixCls + '-tab-next-icon' })
      );

      var navClassName = prefixCls + '-nav';
      var navClasses = (0, _classnames6['default'])((_classnames3 = {}, (0, _defineProperty3['default'])(_classnames3, navClassName, true), (0, _defineProperty3['default'])(_classnames3, scrollAnimated ? navClassName + '-animated' : navClassName + '-no-animated', true), _classnames3));

      return _react2['default'].createElement(
        'div',
        {
          className: (0, _classnames6['default'])((_classnames4 = {}, (0, _defineProperty3['default'])(_classnames4, prefixCls + '-nav-container', 1), (0, _defineProperty3['default'])(_classnames4, prefixCls + '-nav-container-scrolling', showNextPrev), _classnames4)),
          key: 'container',
          ref: this.saveRef('container')
        },
        prevButton,
        nextButton,
        _react2['default'].createElement(
          'div',
          { className: prefixCls + '-nav-wrap', ref: this.saveRef('navWrap') },
          _react2['default'].createElement(
            'div',
            { className: prefixCls + '-nav-scroll' },
            _react2['default'].createElement(
              'div',
              { className: navClasses, ref: this.saveRef('nav') },
              navWrapper(content)
            )
          )
        )
      );
    }
  };
  module.exports = exports['default'];
  });

  unwrapExports(ScrollableTabBarMixin);

  var TabBarMixin = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _objectWithoutProperties3 = _interopRequireDefault(objectWithoutProperties);



  var _extends3 = _interopRequireDefault(_extends$1);



  var _react2 = _interopRequireDefault(React$1__default);



  var _classnames3 = _interopRequireDefault(classnames);



  var _warning2 = _interopRequireDefault(warning_1$1);



  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  exports['default'] = {
    getDefaultProps: function getDefaultProps() {
      return {
        styles: {}
      };
    },
    onTabClick: function onTabClick(key, e) {
      this.props.onTabClick(key, e);
    },
    getTabs: function getTabs() {
      var _this = this;

      var _props = this.props,
          children = _props.panels,
          activeKey = _props.activeKey,
          prefixCls = _props.prefixCls,
          tabBarGutter = _props.tabBarGutter;

      var rst = [];

      _react2['default'].Children.forEach(children, function (child, index) {
        if (!child) {
          return;
        }
        var key = child.key;
        var cls = activeKey === key ? prefixCls + '-tab-active' : '';
        cls += ' ' + prefixCls + '-tab';
        var events = {};
        if (child.props.disabled) {
          cls += ' ' + prefixCls + '-tab-disabled';
        } else {
          events = {
            onClick: function onClick(e) {
              return _this.onTabClick.call(_this, key, e);
            }
          };
        }
        var ref = {};
        if (activeKey === key) {
          ref.ref = _this.saveRef('activeTab');
        }
        (0, _warning2['default'])('tab' in child.props, 'There must be `tab` property on children of Tabs.');
        rst.push(_react2['default'].createElement(
          'div',
          (0, _extends3['default'])({
            role: 'tab',
            'aria-disabled': child.props.disabled ? 'true' : 'false',
            'aria-selected': activeKey === key ? 'true' : 'false'
          }, events, {
            className: cls,
            key: key,
            style: { marginRight: tabBarGutter && index === children.length - 1 ? 0 : tabBarGutter }
          }, ref),
          child.props.tab
        ));
      });

      return rst;
    },
    getRootNode: function getRootNode(contents) {
      var _props2 = this.props,
          prefixCls = _props2.prefixCls,
          onKeyDown = _props2.onKeyDown,
          className = _props2.className,
          extraContent = _props2.extraContent,
          style = _props2.style,
          tabBarPosition = _props2.tabBarPosition,
          restProps = (0, _objectWithoutProperties3['default'])(_props2, ['prefixCls', 'onKeyDown', 'className', 'extraContent', 'style', 'tabBarPosition']);

      var cls = (0, _classnames3['default'])(prefixCls + '-bar', (0, _defineProperty3['default'])({}, className, !!className));
      var topOrBottom = tabBarPosition === 'top' || tabBarPosition === 'bottom';
      var tabBarExtraContentStyle = topOrBottom ? { float: 'right' } : {};
      var extraContentStyle = extraContent && extraContent.props ? extraContent.props.style : {};
      var children = contents;
      if (extraContent) {
        children = [(0, React$1__default.cloneElement)(extraContent, {
          key: 'extra',
          style: (0, _extends3['default'])({}, tabBarExtraContentStyle, extraContentStyle)
        }), (0, React$1__default.cloneElement)(contents, { key: 'content' })];
        children = topOrBottom ? children : children.reverse();
      }
      return _react2['default'].createElement(
        'div',
        (0, _extends3['default'])({
          role: 'tablist',
          className: cls,
          tabIndex: '0',
          ref: this.saveRef('root'),
          onKeyDown: onKeyDown,
          style: style
        }, (0, utils$3.getDataAttr)(restProps)),
        children
      );
    }
  };
  module.exports = exports['default'];
  });

  unwrapExports(TabBarMixin);

  var RefMixin = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = {
    saveRef: function saveRef(name) {
      var _this = this;

      return function (node) {
        _this[name] = node;
      };
    }
  };
  module.exports = exports['default'];
  });

  unwrapExports(RefMixin);

  var ScrollableInkTabBar_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _createReactClass2 = _interopRequireDefault(createReactClass);



  var _InkTabBarMixin2 = _interopRequireDefault(InkTabBarMixin);



  var _ScrollableTabBarMixin2 = _interopRequireDefault(ScrollableTabBarMixin);



  var _TabBarMixin2 = _interopRequireDefault(TabBarMixin);



  var _RefMixin2 = _interopRequireDefault(RefMixin);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var ScrollableInkTabBar = (0, _createReactClass2['default'])({
    displayName: 'ScrollableInkTabBar',
    mixins: [_RefMixin2['default'], _TabBarMixin2['default'], _InkTabBarMixin2['default'], _ScrollableTabBarMixin2['default']],
    render: function render() {
      var inkBarNode = this.getInkBarNode();
      var tabs = this.getTabs();
      var scrollbarNode = this.getScrollBarNode([inkBarNode, tabs]);
      return this.getRootNode(scrollbarNode);
    }
  });

  exports['default'] = ScrollableInkTabBar;
  module.exports = exports['default'];
  });

  unwrapExports(ScrollableInkTabBar_1);

  var TabContent_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _react2 = _interopRequireDefault(React$1__default);



  var _createReactClass2 = _interopRequireDefault(createReactClass);



  var _propTypes2 = _interopRequireDefault(PropTypes);



  var _classnames3 = _interopRequireDefault(classnames);



  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var TabContent = (0, _createReactClass2['default'])({
    displayName: 'TabContent',
    propTypes: {
      animated: _propTypes2['default'].bool,
      animatedWithMargin: _propTypes2['default'].bool,
      prefixCls: _propTypes2['default'].string,
      children: _propTypes2['default'].any,
      activeKey: _propTypes2['default'].string,
      style: _propTypes2['default'].any,
      tabBarPosition: _propTypes2['default'].string
    },
    getDefaultProps: function getDefaultProps() {
      return {
        animated: true
      };
    },
    getTabPanes: function getTabPanes() {
      var props = this.props;
      var activeKey = props.activeKey;
      var children = props.children;
      var newChildren = [];

      _react2['default'].Children.forEach(children, function (child) {
        if (!child) {
          return;
        }
        var key = child.key;
        var active = activeKey === key;
        newChildren.push(_react2['default'].cloneElement(child, {
          active: active,
          destroyInactiveTabPane: props.destroyInactiveTabPane,
          rootPrefixCls: props.prefixCls
        }));
      });

      return newChildren;
    },
    render: function render() {
      var _classnames;

      var props = this.props;
      var prefixCls = props.prefixCls,
          children = props.children,
          activeKey = props.activeKey,
          tabBarPosition = props.tabBarPosition,
          animated = props.animated,
          animatedWithMargin = props.animatedWithMargin;
      var style = props.style;

      var classes = (0, _classnames3['default'])((_classnames = {}, (0, _defineProperty3['default'])(_classnames, prefixCls + '-content', true), (0, _defineProperty3['default'])(_classnames, animated ? prefixCls + '-content-animated' : prefixCls + '-content-no-animated', true), _classnames));
      if (animated) {
        var activeIndex = (0, utils$3.getActiveIndex)(children, activeKey);
        if (activeIndex !== -1) {
          var animatedStyle = animatedWithMargin ? (0, utils$3.getMarginStyle)(activeIndex, tabBarPosition) : (0, utils$3.getTransformPropValue)((0, utils$3.getTransformByIndex)(activeIndex, tabBarPosition));
          style = (0, _extends3['default'])({}, style, animatedStyle);
        } else {
          style = (0, _extends3['default'])({}, style, {
            display: 'none'
          });
        }
      }
      return _react2['default'].createElement(
        'div',
        {
          className: classes,
          style: style
        },
        this.getTabPanes()
      );
    }
  });

  exports['default'] = TabContent;
  module.exports = exports['default'];
  });

  unwrapExports(TabContent_1);

  var isFlexSupported_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports['default'] = isFlexSupported;
  function isFlexSupported() {
      if (typeof window !== 'undefined' && window.document && window.document.documentElement) {
          var documentElement = window.document.documentElement;

          return 'flex' in documentElement.style || 'webkitFlex' in documentElement.style || 'Flex' in documentElement.style || 'msFlex' in documentElement.style;
      }
      return false;
  }
  module.exports = exports['default'];
  });

  unwrapExports(isFlexSupported_1);

  var _rcTabs = getCjsExportFromNamespace(es$e);

  var tabs = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);



  var _typeof3 = _interopRequireDefault(_typeof_1);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var ReactDOM$$1 = _interopRequireWildcard(ReactDOM__default);



  var _rcTabs2 = _interopRequireDefault(_rcTabs);



  var _ScrollableInkTabBar2 = _interopRequireDefault(ScrollableInkTabBar_1);



  var _TabContent2 = _interopRequireDefault(TabContent_1);



  var _classnames2 = _interopRequireDefault(classnames);



  var _icon2 = _interopRequireDefault(icon);



  var _warning2 = _interopRequireDefault(warning$4);



  var _isFlexSupported2 = _interopRequireDefault(isFlexSupported_1);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var Tabs = function (_React$Component) {
      (0, _inherits3['default'])(Tabs, _React$Component);

      function Tabs() {
          (0, _classCallCheck3['default'])(this, Tabs);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (Tabs.__proto__ || Object.getPrototypeOf(Tabs)).apply(this, arguments));

          _this.createNewTab = function (targetKey) {
              var onEdit = _this.props.onEdit;
              if (onEdit) {
                  onEdit(targetKey, 'add');
              }
          };
          _this.removeTab = function (targetKey, e) {
              e.stopPropagation();
              if (!targetKey) {
                  return;
              }
              var onEdit = _this.props.onEdit;
              if (onEdit) {
                  onEdit(targetKey, 'remove');
              }
          };
          _this.handleChange = function (activeKey) {
              var onChange = _this.props.onChange;
              if (onChange) {
                  onChange(activeKey);
              }
          };
          return _this;
      }

      (0, _createClass3['default'])(Tabs, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              var NO_FLEX = ' no-flex';
              var tabNode = ReactDOM$$1.findDOMNode(this);
              if (tabNode && !(0, _isFlexSupported2['default'])() && tabNode.className.indexOf(NO_FLEX) === -1) {
                  tabNode.className += NO_FLEX;
              }
          }
      }, {
          key: 'render',
          value: function render() {
              var _classNames,
                  _this2 = this;

              var _props = this.props,
                  prefixCls = _props.prefixCls,
                  _props$className = _props.className,
                  className = _props$className === undefined ? '' : _props$className,
                  size = _props.size,
                  _props$type = _props.type,
                  type = _props$type === undefined ? 'line' : _props$type,
                  tabPosition = _props.tabPosition,
                  children = _props.children,
                  tabBarExtraContent = _props.tabBarExtraContent,
                  tabBarStyle = _props.tabBarStyle,
                  hideAdd = _props.hideAdd,
                  onTabClick = _props.onTabClick,
                  onPrevClick = _props.onPrevClick,
                  onNextClick = _props.onNextClick,
                  _props$animated = _props.animated,
                  animated = _props$animated === undefined ? true : _props$animated,
                  tabBarGutter = _props.tabBarGutter;

              var _ref = (typeof animated === 'undefined' ? 'undefined' : (0, _typeof3['default'])(animated)) === 'object' ? {
                  inkBarAnimated: animated.inkBar, tabPaneAnimated: animated.tabPane
              } : {
                  inkBarAnimated: animated, tabPaneAnimated: animated
              },
                  inkBarAnimated = _ref.inkBarAnimated,
                  tabPaneAnimated = _ref.tabPaneAnimated;
              // card tabs should not have animation


              if (type !== 'line') {
                  tabPaneAnimated = 'animated' in this.props ? tabPaneAnimated : false;
              }
              (0, _warning2['default'])(!(type.indexOf('card') >= 0 && (size === 'small' || size === 'large')), 'Tabs[type=card|editable-card] doesn\'t have small or large size, it\'s by designed.');
              var cls = (0, _classnames2['default'])(className, (_classNames = {}, (0, _defineProperty3['default'])(_classNames, prefixCls + '-vertical', tabPosition === 'left' || tabPosition === 'right'), (0, _defineProperty3['default'])(_classNames, prefixCls + '-' + size, !!size), (0, _defineProperty3['default'])(_classNames, prefixCls + '-card', type.indexOf('card') >= 0), (0, _defineProperty3['default'])(_classNames, prefixCls + '-' + type, true), (0, _defineProperty3['default'])(_classNames, prefixCls + '-no-animation', !tabPaneAnimated), _classNames));
              // only card type tabs can be added and closed
              var childrenWithClose = [];
              if (type === 'editable-card') {
                  childrenWithClose = [];
                  React.Children.forEach(children, function (child, index) {
                      var closable = child.props.closable;
                      closable = typeof closable === 'undefined' ? true : closable;
                      var closeIcon = closable ? React.createElement(_icon2['default'], { type: 'close', onClick: function onClick(e) {
                              return _this2.removeTab(child.key, e);
                          } }) : null;
                      childrenWithClose.push(React.cloneElement(child, {
                          tab: React.createElement(
                              'div',
                              { className: closable ? undefined : prefixCls + '-tab-unclosable' },
                              child.props.tab,
                              closeIcon
                          ),
                          key: child.key || index
                      }));
                  });
                  // Add new tab handler
                  if (!hideAdd) {
                      tabBarExtraContent = React.createElement(
                          'span',
                          null,
                          React.createElement(_icon2['default'], { type: 'plus', className: prefixCls + '-new-tab', onClick: this.createNewTab }),
                          tabBarExtraContent
                      );
                  }
              }
              tabBarExtraContent = tabBarExtraContent ? React.createElement(
                  'div',
                  { className: prefixCls + '-extra-content' },
                  tabBarExtraContent
              ) : null;
              var renderTabBar = function renderTabBar() {
                  return React.createElement(_ScrollableInkTabBar2['default'], { inkBarAnimated: inkBarAnimated, extraContent: tabBarExtraContent, onTabClick: onTabClick, onPrevClick: onPrevClick, onNextClick: onNextClick, style: tabBarStyle, tabBarGutter: tabBarGutter });
              };
              return React.createElement(
                  _rcTabs2['default'],
                  (0, _extends3['default'])({}, this.props, { className: cls, tabBarPosition: tabPosition, renderTabBar: renderTabBar, renderTabContent: function renderTabContent() {
                          return React.createElement(_TabContent2['default'], { animated: tabPaneAnimated, animatedWithMargin: true });
                      }, onChange: this.handleChange }),
                  childrenWithClose.length > 0 ? childrenWithClose : children
              );
          }
      }]);
      return Tabs;
  }(React.Component);

  exports['default'] = Tabs;

  Tabs.TabPane = _rcTabs.TabPane;
  Tabs.defaultProps = {
      prefixCls: 'ant-tabs',
      hideAdd: false
  };
  module.exports = exports['default'];
  });

  var Tabs$1 = unwrapExports(tabs);

  var TabPane$1 = Tabs$1.TabPane;

  var TabsPanel =
  /*#__PURE__*/
  function (_PureComponent) {
    _inherits(TabsPanel, _PureComponent);

    function TabsPanel() {
      _classCallCheck(this, TabsPanel);

      return _possibleConstructorReturn(this, _getPrototypeOf(TabsPanel).apply(this, arguments));
    }

    _createClass(TabsPanel, [{
      key: "stringifyURL",
      value: function stringifyURL(str, options) {
        if (!str) {
          return str;
        }

        return str.replace(/:(\w+)/gi, function (match, p1) {
          var replacement = options[p1];

          if (!replacement) {
            throw new Error('Could not find url parameter ' + p1 + ' in passed options object');
          }

          return replacement;
        });
        return str;
      }
    }, {
      key: "onChange",
      value: function onChange(activeKey) {
        var _this$props = this.props,
            history = _this$props.history,
            _this$props$match = _this$props.match,
            path = _this$props$match.path,
            params = _this$props$match.params;
        history.push(this.stringifyURL(path, Object.assign({}, params, {
          type: activeKey
        })));
      }
    }, {
      key: "renderModule",
      value: function renderModule(child) {
        var _this$props2 = this.props,
            children = _this$props2.children,
            otherProps = _objectWithoutProperties(_this$props2, ["children"]);

        var childProps = child.props; // console.log(childProps.children)

        return React$1__default.createElement(TabPane$1, {
          tab: childProps.title,
          key: childProps.path
        }, typeof childProps.children === "function" ? React$1__default.createElement(childProps.children, otherProps) : React$1__default.cloneElement(childProps.children, otherProps));
      }
    }, {
      key: "renderPanes",
      value: function renderPanes() {
        var _this = this;

        var children = this.props.children;
        return [].concat(children).map(function (child) {
          return _this.renderModule(child);
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props3 = this.props,
            params = _this$props3.match.params,
            defaultPath = _this$props3.defaultPath;
        return React$1__default.createElement(Panel$1, null, React$1__default.createElement(Tabs$1, {
          activeKey: params.type || defaultPath,
          animated: false,
          onChange: this.onChange.bind(this)
        }, this.renderPanes()));
      }
    }]);

    return TabsPanel;
  }(React$1.PureComponent);

  var PropertyTable =
  /*#__PURE__*/
  function (_Component) {
    _inherits(PropertyTable, _Component);

    function PropertyTable() {
      _classCallCheck(this, PropertyTable);

      return _possibleConstructorReturn(this, _getPrototypeOf(PropertyTable).apply(this, arguments));
    }

    _createClass(PropertyTable, [{
      key: "renderItem",
      value: function renderItem(ds, idx) {
        return React$1__default.createElement("div", {
          key: idx
        }, React$1__default.createElement("th", null, ds.label), React$1__default.createElement("td", null, ds.value));
      }
    }, {
      key: "renderTableRows",
      value: function renderTableRows() {
        var dataSource = this.props.dataSource;
        return React$1__default.createElement("tr", null, dataSource.map(this.renderItem));
      }
    }, {
      key: "render",
      value: function render() {
        return React$1__default.createElement("table", null, React$1__default.createElement("tbody", null, this.renderTableRows()));
      }
    }]);

    return PropertyTable;
  }(React$1.Component);
  PropertyTable.propsType = {
    dataSource: PropTypes.array.isRequired,
    renderItem: PropTypes.func
  };

  var popconfirm = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _classCallCheck3 = _interopRequireDefault(classCallCheck);



  var _createClass3 = _interopRequireDefault(createClass);



  var _possibleConstructorReturn3 = _interopRequireDefault(possibleConstructorReturn);



  var _inherits3 = _interopRequireDefault(inherits);



  var React = _interopRequireWildcard(React$1__default);



  var _tooltip2 = _interopRequireDefault(tooltip);



  var _icon2 = _interopRequireDefault(icon);



  var _button2 = _interopRequireDefault(button$2);



  var _LocaleReceiver2 = _interopRequireDefault(LocaleReceiver_1);



  var _default2 = _interopRequireDefault(_default);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var __rest = function (s, e) {
      var t = {};
      for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      }if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
      }return t;
  };

  var Popconfirm = function (_React$Component) {
      (0, _inherits3['default'])(Popconfirm, _React$Component);

      function Popconfirm(props) {
          (0, _classCallCheck3['default'])(this, Popconfirm);

          var _this = (0, _possibleConstructorReturn3['default'])(this, (Popconfirm.__proto__ || Object.getPrototypeOf(Popconfirm)).call(this, props));

          _this.onConfirm = function (e) {
              _this.setVisible(false);
              var onConfirm = _this.props.onConfirm;

              if (onConfirm) {
                  onConfirm.call(_this, e);
              }
          };
          _this.onCancel = function (e) {
              _this.setVisible(false);
              var onCancel = _this.props.onCancel;

              if (onCancel) {
                  onCancel.call(_this, e);
              }
          };
          _this.onVisibleChange = function (visible) {
              _this.setVisible(visible);
          };
          _this.saveTooltip = function (node) {
              _this.tooltip = node;
          };
          _this.renderOverlay = function (popconfirmLocale) {
              var _this$props = _this.props,
                  prefixCls = _this$props.prefixCls,
                  title = _this$props.title,
                  cancelText = _this$props.cancelText,
                  okText = _this$props.okText,
                  okType = _this$props.okType;

              return React.createElement(
                  'div',
                  null,
                  React.createElement(
                      'div',
                      { className: prefixCls + '-inner-content' },
                      React.createElement(
                          'div',
                          { className: prefixCls + '-message' },
                          React.createElement(_icon2['default'], { type: 'exclamation-circle' }),
                          React.createElement(
                              'div',
                              { className: prefixCls + '-message-title' },
                              title
                          )
                      ),
                      React.createElement(
                          'div',
                          { className: prefixCls + '-buttons' },
                          React.createElement(
                              _button2['default'],
                              { onClick: _this.onCancel, size: 'small' },
                              cancelText || popconfirmLocale.cancelText
                          ),
                          React.createElement(
                              _button2['default'],
                              { onClick: _this.onConfirm, type: okType, size: 'small' },
                              okText || popconfirmLocale.okText
                          )
                      )
                  )
              );
          };
          _this.state = {
              visible: props.visible
          };
          return _this;
      }

      (0, _createClass3['default'])(Popconfirm, [{
          key: 'componentWillReceiveProps',
          value: function componentWillReceiveProps(nextProps) {
              if ('visible' in nextProps) {
                  this.setState({ visible: nextProps.visible });
              }
          }
      }, {
          key: 'getPopupDomNode',
          value: function getPopupDomNode() {
              return this.tooltip.getPopupDomNode();
          }
      }, {
          key: 'setVisible',
          value: function setVisible(visible) {
              var props = this.props;
              if (!('visible' in props)) {
                  this.setState({ visible: visible });
              }
              var onVisibleChange = props.onVisibleChange;

              if (onVisibleChange) {
                  onVisibleChange(visible);
              }
          }
      }, {
          key: 'render',
          value: function render() {
              var _a = this.props,
                  prefixCls = _a.prefixCls,
                  placement = _a.placement,
                  restProps = __rest(_a, ["prefixCls", "placement"]);
              var overlay = React.createElement(
                  _LocaleReceiver2['default'],
                  { componentName: 'Popconfirm', defaultLocale: _default2['default'].Popconfirm },
                  this.renderOverlay
              );
              return React.createElement(_tooltip2['default'], (0, _extends3['default'])({}, restProps, { prefixCls: prefixCls, placement: placement, onVisibleChange: this.onVisibleChange, visible: this.state.visible, overlay: overlay, ref: this.saveTooltip }));
          }
      }]);
      return Popconfirm;
  }(React.Component);

  exports['default'] = Popconfirm;

  Popconfirm.defaultProps = {
      prefixCls: 'ant-popover',
      transitionName: 'zoom-big',
      placement: 'top',
      trigger: 'click',
      okType: 'primary'
  };
  module.exports = exports['default'];
  });

  var Popconfirm = unwrapExports(popconfirm);

  var Notice = function (_Component) {
    _inherits$1(Notice, _Component);

    function Notice() {
      var _ref;

      var _temp, _this, _ret;

      _classCallCheck$1(this, Notice);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn$1(this, (_ref = Notice.__proto__ || Object.getPrototypeOf(Notice)).call.apply(_ref, [this].concat(args))), _this), _this.close = function () {
        _this.clearCloseTimer();
        _this.props.onClose();
      }, _this.startCloseTimer = function () {
        if (_this.props.duration) {
          _this.closeTimer = setTimeout(function () {
            _this.close();
          }, _this.props.duration * 1000);
        }
      }, _this.clearCloseTimer = function () {
        if (_this.closeTimer) {
          clearTimeout(_this.closeTimer);
          _this.closeTimer = null;
        }
      }, _temp), _possibleConstructorReturn$1(_this, _ret);
    }

    _createClass$1(Notice, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        this.startCloseTimer();
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate(prevProps) {
        if (this.props.duration !== prevProps.duration || this.props.update) {
          this.restartCloseTimer();
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        this.clearCloseTimer();
      }
    }, {
      key: 'restartCloseTimer',
      value: function restartCloseTimer() {
        this.clearCloseTimer();
        this.startCloseTimer();
      }
    }, {
      key: 'render',
      value: function render() {
        var _className;

        var props = this.props;
        var componentClass = props.prefixCls + '-notice';
        var className = (_className = {}, _defineProperty$1(_className, '' + componentClass, 1), _defineProperty$1(_className, componentClass + '-closable', props.closable), _defineProperty$1(_className, props.className, !!props.className), _className);
        return React$1__default.createElement(
          'div',
          { className: classnames(className), style: props.style, onMouseEnter: this.clearCloseTimer,
            onMouseLeave: this.startCloseTimer
          },
          React$1__default.createElement(
            'div',
            { className: componentClass + '-content' },
            props.children
          ),
          props.closable ? React$1__default.createElement(
            'a',
            { tabIndex: '0', onClick: this.close, className: componentClass + '-close' },
            React$1__default.createElement('span', { className: componentClass + '-close-x' })
          ) : null
        );
      }
    }]);

    return Notice;
  }(React$1.Component);

  Notice.propTypes = {
    duration: PropTypes.number,
    onClose: PropTypes.func,
    children: PropTypes.any,
    update: PropTypes.bool
  };
  Notice.defaultProps = {
    onEnd: function onEnd() {},
    onClose: function onClose() {},

    duration: 1.5,
    style: {
      right: '50%'
    }
  };

  var seed = 0;
  var now$1 = Date.now();

  function getUuid() {
    return 'rcNotification_' + now$1 + '_' + seed++;
  }

  var Notification = function (_Component) {
    _inherits$1(Notification, _Component);

    function Notification() {
      var _ref;

      var _temp, _this, _ret;

      _classCallCheck$1(this, Notification);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn$1(this, (_ref = Notification.__proto__ || Object.getPrototypeOf(Notification)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        notices: []
      }, _this.add = function (notice) {
        var key = notice.key = notice.key || getUuid();
        var maxCount = _this.props.maxCount;

        _this.setState(function (previousState) {
          var notices = previousState.notices;
          var noticeIndex = notices.map(function (v) {
            return v.key;
          }).indexOf(key);
          var updatedNotices = notices.concat();
          if (noticeIndex !== -1) {
            updatedNotices.splice(noticeIndex, 1, notice);
          } else {
            if (maxCount && notices.length >= maxCount) {
                                                  notice.updateKey = updatedNotices[0].updateKey || updatedNotices[0].key;
              updatedNotices.shift();
            }
            updatedNotices.push(notice);
          }
          return {
            notices: updatedNotices
          };
        });
      }, _this.remove = function (key) {
        _this.setState(function (previousState) {
          return {
            notices: previousState.notices.filter(function (notice) {
              return notice.key !== key;
            })
          };
        });
      }, _temp), _possibleConstructorReturn$1(_this, _ret);
    }

    _createClass$1(Notification, [{
      key: 'getTransitionName',
      value: function getTransitionName() {
        var props = this.props;
        var transitionName = props.transitionName;
        if (!transitionName && props.animation) {
          transitionName = props.prefixCls + '-' + props.animation;
        }
        return transitionName;
      }
    }, {
      key: 'render',
      value: function render() {
        var _this2 = this,
            _className;

        var props = this.props;
        var notices = this.state.notices;

        var noticeNodes = notices.map(function (notice, index) {
          var update = Boolean(index === notices.length - 1 && notice.updateKey);
          var key = notice.updateKey ? notice.updateKey : notice.key;
          var onClose = createChainedFunction(_this2.remove.bind(_this2, notice.key), notice.onClose);
          return React$1__default.createElement(
            Notice,
            _extends$2({
              prefixCls: props.prefixCls
            }, notice, {
              key: key,
              update: update,
              onClose: onClose
            }),
            notice.content
          );
        });
        var className = (_className = {}, _defineProperty$1(_className, props.prefixCls, 1), _defineProperty$1(_className, props.className, !!props.className), _className);
        return React$1__default.createElement(
          'div',
          { className: classnames(className), style: props.style },
          React$1__default.createElement(
            Animate,
            { transitionName: this.getTransitionName() },
            noticeNodes
          )
        );
      }
    }]);

    return Notification;
  }(React$1.Component);

  Notification.propTypes = {
    prefixCls: PropTypes.string,
    transitionName: PropTypes.string,
    animation: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
    style: PropTypes.object,
    maxCount: PropTypes.number
  };
  Notification.defaultProps = {
    prefixCls: 'rc-notification',
    animation: 'fade',
    style: {
      top: 65,
      left: '50%'
    }
  };


  Notification.newInstance = function newNotificationInstance(properties, callback) {
    var _ref2 = properties || {},
        getContainer = _ref2.getContainer,
        props = _objectWithoutProperties$1(_ref2, ['getContainer']);

    var div = document.createElement('div');
    if (getContainer) {
      var root = getContainer();
      root.appendChild(div);
    } else {
      document.body.appendChild(div);
    }
    var called = false;
    function ref(notification) {
      if (called) {
        return;
      }
      called = true;
      callback({
        notice: function notice(noticeProps) {
          notification.add(noticeProps);
        },
        removeNotice: function removeNotice(key) {
          notification.remove(key);
        },

        component: notification,
        destroy: function destroy() {
          ReactDOM__default.unmountComponentAtNode(div);
          div.parentNode.removeChild(div);
        }
      });
    }
    ReactDOM__default.render(React$1__default.createElement(Notification, _extends$2({}, props, { ref: ref })), div);
  };



  var es$f = /*#__PURE__*/Object.freeze({
    default: Notification
  });

  var _rcNotification = getCjsExportFromNamespace(es$f);

  var message = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var React = _interopRequireWildcard(React$1__default);



  var _rcNotification2 = _interopRequireDefault(_rcNotification);



  var _icon2 = _interopRequireDefault(icon);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  var defaultDuration = 3;
  var defaultTop = void 0;
  var messageInstance = void 0;
  var key = 1;
  var prefixCls = 'ant-message';
  var transitionName = 'move-up';
  var getContainer = void 0;
  var maxCount = void 0;
  function getMessageInstance(callback) {
      if (messageInstance) {
          callback(messageInstance);
          return;
      }
      _rcNotification2['default'].newInstance({
          prefixCls: prefixCls,
          transitionName: transitionName,
          style: { top: defaultTop },
          getContainer: getContainer,
          maxCount: maxCount
      }, function (instance) {
          if (messageInstance) {
              callback(messageInstance);
              return;
          }
          messageInstance = instance;
          callback(instance);
      });
  }
  function notice(content) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultDuration;
      var type = arguments[2];
      var onClose = arguments[3];

      var iconType = {
          info: 'info-circle',
          success: 'check-circle',
          error: 'cross-circle',
          warning: 'exclamation-circle',
          loading: 'loading'
      }[type];
      if (typeof duration === 'function') {
          onClose = duration;
          duration = defaultDuration;
      }
      var target = key++;
      getMessageInstance(function (instance) {
          instance.notice({
              key: target,
              duration: duration,
              style: {},
              content: React.createElement(
                  'div',
                  { className: prefixCls + '-custom-content ' + prefixCls + '-' + type },
                  React.createElement(_icon2['default'], { type: iconType }),
                  React.createElement(
                      'span',
                      null,
                      content
                  )
              ),
              onClose: onClose
          });
      });
      return function () {
          if (messageInstance) {
              messageInstance.removeNotice(target);
          }
      };
  }
  exports['default'] = {
      info: function info(content, duration, onClose) {
          return notice(content, duration, 'info', onClose);
      },
      success: function success(content, duration, onClose) {
          return notice(content, duration, 'success', onClose);
      },
      error: function error(content, duration, onClose) {
          return notice(content, duration, 'error', onClose);
      },

      // Departed usage, please use warning()
      warn: function warn(content, duration, onClose) {
          return notice(content, duration, 'warning', onClose);
      },
      warning: function warning(content, duration, onClose) {
          return notice(content, duration, 'warning', onClose);
      },
      loading: function loading(content, duration, onClose) {
          return notice(content, duration, 'loading', onClose);
      },
      config: function config(options) {
          if (options.top !== undefined) {
              defaultTop = options.top;
              messageInstance = null; // delete messageInstance for new defaultTop
          }
          if (options.duration !== undefined) {
              defaultDuration = options.duration;
          }
          if (options.prefixCls !== undefined) {
              prefixCls = options.prefixCls;
          }
          if (options.getContainer !== undefined) {
              getContainer = options.getContainer;
          }
          if (options.transitionName !== undefined) {
              transitionName = options.transitionName;
              messageInstance = null; // delete messageInstance for new transitionName
          }
          if (options.maxCount !== undefined) {
              maxCount = options.maxCount;
              messageInstance = null;
          }
      },
      destroy: function destroy() {
          if (messageInstance) {
              messageInstance.destroy();
              messageInstance = null;
          }
      }
  };
  module.exports = exports['default'];
  });

  var message$1 = unwrapExports(message);

  var FormItem$2 = Form$1.Item;
  var EditableContext = React$1__default.createContext();

  var EditableRow = function EditableRow(_ref) {
    var form$$1 = _ref.form,
        index = _ref.index,
        props = _objectWithoutProperties(_ref, ["form", "index"]);

    return React$1__default.createElement(EditableContext.Provider, {
      value: form$$1
    }, React$1__default.createElement("tr", props));
  };

  var EditableFormRow = Form$1.create()(EditableRow);

  var EditableCell =
  /*#__PURE__*/
  function (_React$Component) {
    _inherits(EditableCell, _React$Component);

    function EditableCell() {
      _classCallCheck(this, EditableCell);

      return _possibleConstructorReturn(this, _getPrototypeOf(EditableCell).apply(this, arguments));
    }

    _createClass(EditableCell, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            editing = _this$props.editing,
            dataIndex = _this$props.dataIndex,
            title = _this$props.title,
            record = _this$props.record,
            index = _this$props.index,
            editDom = _this$props.editDom,
            editConfig = _this$props.editConfig,
            restProps = _objectWithoutProperties(_this$props, ["editing", "dataIndex", "title", "record", "index", "editDom", "editConfig"]);

        return React$1__default.createElement(EditableContext.Consumer, null, function (form$$1) {
          var getFieldDecorator = form$$1.getFieldDecorator;
          return React$1__default.createElement("td", restProps, editing ? React$1__default.createElement(FormItem$2, {
            style: {
              margin: 0
            }
          }, getFieldDecorator(dataIndex, _objectSpread({}, editConfig, {
            initialValue: record[dataIndex] === '' ? editConfig.initialValue : record[dataIndex]
          }))(editDom())) : restProps.children);
        });
      }
    }]);

    return EditableCell;
  }(React$1__default.Component);

  var EditTable =
  /*#__PURE__*/
  function (_React$Component2) {
    _inherits(EditTable, _React$Component2);

    function EditTable(props) {
      var _this;

      _classCallCheck(this, EditTable);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(EditTable).call(this, props));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "isEditing", function (record) {
        return record.key === _this.state.editingKey;
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "cancel", function (form$$1, key) {
        var obj = _this.state.data.filter(function (d) {
          return d.key === key;
        })[0];

        var Bdelete = false;

        for (var b in obj) {
          if (obj[b] === '') {
            Bdelete = true;
            break;
          }
        }

        if (Bdelete) {
          _this.delete(key);
        }

        _this.setState({
          editingKey: ''
        });
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "addNew", function () {
        if (_this.state.editingKey !== '') {
          message$1.error('请先保存编辑项再进行添加操作！');
          return false;
        }

        var key = new Date().valueOf() + '' + Math.floor(Math.random() * 10 + 1);
        var obj = {
          key: key
        };

        var keyList = _toConsumableArray(_this.state.keyList);

        if (keyList.length > 1) {
          keyList.length = keyList.length - 1;
        }

        keyList.forEach(function (d) {
          obj[d] = '';
        });

        var data = _toConsumableArray(_this.state.data);

        data.push(obj);

        _this.setState({
          data: data,
          editingKey: key
        });
      });

      _this.state = {
        data: [],
        editingKey: '',
        keyList: [],
        columns: [{
          title: '操作',
          dataIndex: '操作',
          render: function render(text, record) {
            var editable = _this.isEditing(record);

            return React$1__default.createElement("div", null, editable ? React$1__default.createElement("span", null, React$1__default.createElement(EditableContext.Consumer, null, function (form$$1) {
              return React$1__default.createElement("a", {
                onClick: function onClick() {
                  return _this.save(form$$1, record.key);
                },
                style: {
                  marginRight: 8
                }
              }, "\u4FDD\u5B58");
            }), React$1__default.createElement(EditableContext.Consumer, null, function (form$$1) {
              return React$1__default.createElement(Popconfirm, {
                title: "\u786E\u8BA4\u53D6\u6D88?",
                onConfirm: function onConfirm() {
                  return _this.cancel(form$$1, record.key);
                }
              }, React$1__default.createElement("a", null, "\u53D6\u6D88"));
            })) : React$1__default.createElement("span", null, React$1__default.createElement("a", {
              style: {
                marginRight: 8
              },
              onClick: function onClick() {
                return _this.edit(record.key);
              }
            }, "\u7F16\u8F91"), React$1__default.createElement(Popconfirm, {
              title: "\u786E\u8BA4\u5220\u9664?",
              onConfirm: function onConfirm() {
                return _this.delete(record.key);
              }
            }, React$1__default.createElement("a", null, "\u5220\u9664"))));
          }
        }]
      };
      return _this;
    }

    _createClass(EditTable, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this2 = this;

        if (this.props.columns && this.props.columns.length > 0) {
          this.setState({
            data: this.props.data === undefined ? [] : this.props.data,
            columns: _toConsumableArray(this.props.columns).concat(_toConsumableArray(this.state.columns))
          }, function () {
            var keyList = _this2.state.columns.map(function (c) {
              return c.dataIndex;
            });

            _this2.setState({
              keyList: keyList
            });
          });
        }
      }
    }, {
      key: "edit",
      value: function edit(key) {
        if (this.state.editingKey !== '') {
          message$1.error('请先保存编辑项再进行其他编辑操作！');
          return false;
        }

        this.setState({
          editingKey: key
        });
      }
    }, {
      key: "delete",
      value: function _delete(key) {
        var _this3 = this;

        var newData = _toConsumableArray(this.state.data);

        this.setState({
          data: newData.filter(function (c) {
            return c.key !== key;
          }),
          editingKey: ''
        }, function () {
          _this3.props.onChange(_this3.state.data);
        });
      }
    }, {
      key: "save",
      value: function save(form$$1, key) {
        var _this4 = this;

        form$$1.validateFields(function (error, row) {
          if (error) {
            return;
          }

          var newData = _toConsumableArray(_this4.state.data);

          var index = newData.findIndex(function (item) {
            return key === item.key;
          });

          if (index > -1) {
            var item = newData[index];
            newData.splice(index, 1, _objectSpread({}, item, row));

            _this4.setState({
              data: newData,
              editingKey: ''
            }, function () {
              _this4.props.onChange(newData);
            });
          } else {
            newData.push(row);

            _this4.setState({
              data: newData,
              editingKey: ''
            }, function () {
              _this4.props.onChange(newData);
            });
          }
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this5 = this;

        var components = {
          body: {
            row: EditableFormRow,
            cell: EditableCell
          }
        };
        var columns = this.state.columns.map(function (col) {
          if (!col.editComponent) {
            return col;
          }

          return _objectSpread({}, col, {
            onCell: function onCell(record) {
              return {
                record: record,
                editConfig: col.editConfig,
                editDom: col.editComponent,
                dataIndex: col.dataIndex,
                title: col.title,
                editing: _this5.isEditing(record)
              };
            }
          });
        });
        return React$1__default.createElement(Table$2, {
          components: components,
          bordered: true,
          dataSource: this.state.data,
          columns: columns,
          rowClassName: "editable-row",
          footer: function footer() {
            return React$1__default.createElement(Button, {
              icon: "plus",
              onClick: _this5.addNew,
              style: {
                width: '100%'
              }
            }, "\u65B0\u589E");
          }
        });
      }
    }]);

    return EditTable;
  }(React$1__default.Component);

  EditTable.propTypes = {
    columns: PropTypes.array.isRequired
  };

  var divider = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });



  var _extends3 = _interopRequireDefault(_extends$1);



  var _defineProperty3 = _interopRequireDefault(defineProperty$3);

  exports['default'] = Divider;



  var React = _interopRequireWildcard(React$1__default);



  var _classnames2 = _interopRequireDefault(classnames);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var __rest = function (s, e) {
      var t = {};
      for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      }if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
      }return t;
  };
  function Divider(_a) {
      var _classNames;

      var _a$prefixCls = _a.prefixCls,
          prefixCls = _a$prefixCls === undefined ? 'ant' : _a$prefixCls,
          _a$type = _a.type,
          type = _a$type === undefined ? 'horizontal' : _a$type,
          _a$orientation = _a.orientation,
          orientation = _a$orientation === undefined ? '' : _a$orientation,
          className = _a.className,
          children = _a.children,
          dashed = _a.dashed,
          restProps = __rest(_a, ["prefixCls", "type", "orientation", "className", "children", "dashed"]);

      var orientationPrefix = orientation.length > 0 ? '-' + orientation : orientation;
      var classString = (0, _classnames2['default'])(className, prefixCls + '-divider', prefixCls + '-divider-' + type, (_classNames = {}, (0, _defineProperty3['default'])(_classNames, prefixCls + '-divider-with-text' + orientationPrefix, children), (0, _defineProperty3['default'])(_classNames, prefixCls + '-divider-dashed', !!dashed), _classNames));
      return React.createElement(
          'div',
          (0, _extends3['default'])({ className: classString }, restProps),
          children && React.createElement(
              'span',
              { className: prefixCls + '-divider-inner-text' },
              children
          )
      );
  }
  module.exports = exports['default'];
  });

  var Divider$2 = unwrapExports(divider);

  var up = {
    transform: 'rotate(180deg)',
    fontSize: 12,
    marginLeft: 5,
    verticalAlign: -1
  };
  var down = {
    fontSize: 12,
    marginLeft: 5,
    verticalAlign: -1
  };

  var UpDown = function UpDown(_ref) {
    var _ref$state = _ref.state,
        state = _ref$state === void 0 ? 'up' : _ref$state;
    return React$1__default.createElement(Icon, {
      type: 'down',
      className: down,
      style: state === 'down' ? down : up
    });
  };

  var FieldSet =
  /*#__PURE__*/
  function (_React$Component) {
    _inherits(FieldSet, _React$Component);

    function FieldSet() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, FieldSet);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(FieldSet)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", {
        hidden: _this.props.display === undefined ? false : _this.props.display === 'hide'
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "showHideFun", function () {
        _this.setState({
          hidden: !_this.state.hidden
        }, function () {
          if (_this.props.onChange) {
            _this.props.onChange(_this.state.hidden ? 'hide' : 'show');
          }
        });
      });

      return _this;
    }

    _createClass(FieldSet, [{
      key: "render",
      value: function render() {
        return React$1__default.createElement("div", null, React$1__default.createElement(Divider$2, {
          orientation: "left"
        }, this.props.display === undefined ? this.props.title : React$1__default.createElement("a", {
          onClick: this.showHideFun
        }, this.props.title, React$1__default.createElement(UpDown, {
          state: this.state.hidden ? 'up' : 'down'
        }))), !this.state.hidden && this.props.children);
      }
    }]);

    return FieldSet;
  }(React$1__default.Component);
  FieldSet.defaultProps = {
    title: '标题'
  };

  var downList = [{
    label: '应用程序名',
    value: ['IMP', 'EXP', 'DBLINK', 'JOB', 'PLSQLDEV', 'SQL DEVELOPER', 'TOAD', 'SQLPLUS']
  }, {
    label: '执行结果',
    value: ['成功', '失败']
  }, {
    label: '时间域',
    value: ['周末', '工作日非工作时间', '工作日']
  }, {
    label: '审计级别',
    value: ['高', '中', '低']
  }, {
    label: '数据库类型',
    value: ['Oracle', 'MySQL', 'SQL Server', 'DB2', 'Sybase', 'PostgreSQL', 'Hive', 'DaMeng', 'KingBase', 'Informix', 'Mariadb', 'GBase', 'GBase 8s 8.3']
  }];

  var TextArea$1 = Input$1.TextArea;
  var FormItem$3 = Form$1.Item;

  var ConditionForm =
  /*#__PURE__*/
  function (_PureComponent) {
    _inherits(ConditionForm, _PureComponent);

    function ConditionForm(props) {
      var _this;

      _classCallCheck(this, ConditionForm);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ConditionForm).call(this, props));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", {
        conditionSelect: [],
        selection: [],
        isfirstSVList: false,
        isMulti: false,
        isShowSec: false,
        isShowfirstSV: true
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "factorHandleChange", function (value) {
        var setFieldsValue = _this.props.form.setFieldsValue;
        var conditionSelect$$1 = _this.state.conditionSelect;

        _this.setState({
          isfirstSVList: false,
          isShowSec: false
        });

        setFieldsValue({
          'condition-selection': undefined,
          'value-selection': undefined
        }); //通过value反查对应的factorOperate

        function getOperateByFac(value) {
          for (var i = 0; i < conditionSelect$$1.length; i++) {
            if (conditionSelect$$1[i].value == value) return conditionSelect$$1[i].factorOperate;
          }

          return '';
        }

        for (var i = 0; i < downList.length; i++) {
          if (value == downList[i].label) {
            _this.setState({
              isfirstSVList: true,
              firstSVList: downList[i].value.map(function (v, index) {
                return React.createElement(Select$1.Option, {
                  key: index,
                  value: v
                }, v);
              })
            });

            break;
          }
        }

        setFieldsValue({
          'factorLabel': "$".concat(value)
        });

        _this.setState({
          selection: getOperateByFac(value).split(',')
        });
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "selectionHandleChange", function (value) {
        var _this$props$form = _this.props.form,
            setFieldsValue = _this$props$form.setFieldsValue,
            getFieldValue = _this$props$form.getFieldValue;
        setFieldsValue({
          'condition-selection': "".concat(value)
        });
        var cs = getFieldValue('condition-selection');

        if (cs == 'between') {
          _this.setState({
            isShowSec: true
          });
        } else {
          _this.setState({
            isShowSec: false
          });
        }

        if (cs == 'is not null' || cs == 'is null') {
          _this.setState({
            isShowfirstSV: false
          });

          setFieldsValue({
            'value-selection': undefined
          });
        } else {
          _this.setState({
            isShowfirstSV: true
          });
        } //三级下拉框多选


        var cf = getFieldValue('condition-factor');
        var cfMultArr = ['应用程序名', '执行结果', '时间域', '审计级别', '数据库类型']; //, '服务端IP',  '物理地址', '主机名'

        if (cfMultArr.includes(cf) && (cs === 'in' || cs === 'not in')) {
          _this.setState({
            isMulti: true
          }, setFieldsValue({
            'value-selection': undefined
          }));
        } else {
          _this.setState({
            isMulti: false
          }, setFieldsValue({
            'value-selection': undefined
          }));
        }
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "addSql", function () {
        var _this$props$form2 = _this.props.form,
            getFieldValue = _this$props$form2.getFieldValue,
            setFieldsValue = _this$props$form2.setFieldsValue;
        var isShowfirstSV = _this.state.isShowfirstSV;
        var cs = getFieldValue('condition-selection');
        var vs = getFieldValue('value-selection');
        var ao = getFieldValue('and-or');
        var sqlTextarea = getFieldValue('sql-textarea');
        var vs2 = getFieldValue('value-selection2'); //如果in 或not in要加括号 , 如果是空就空

        var inSql = ''; //in 的情况要对每个逗号给出单引号

        var isBrack = '';

        if (!isShowfirstSV) ; else {
          if (vs == '' || vs == undefined) {
            Modal$1.error({
              title: '系统提示',
              okText: '确定',
              content: "\u8BF7\u5C06\u6761\u4EF6\u586B\u5199\u5B8C\u6574\uFF01"
            });
            return;
          }

          if (!(vs instanceof Array) && vs != '' && vs != undefined) //下拉框选择就是数组, 否则就是输入框逗号隔开
            vs = vs.split(',');
          if (vs instanceof Array && vs.toString().includes(',')) //输入框本来用enter隔开, 现在需要用逗号隔开
            vs = vs.toString().split(',');
          console.log('vs', vs, cs, ao, "".concat(getFieldValue('factorLabel')), _this.validTime(vs[0]));
          inSql = vs.length > 1 ? vs.reduce(function (ac, cv, ci) {
            if (ci == 1) return "'".concat(ac, "','").concat(cv, "'");
            return "".concat(ac, ",'").concat(cv, "'");
          }) : "'".concat(vs, "'");
          isBrack = cs == 'in' || cs == 'not in' ? "(".concat(inSql, ")") : vs == "" ? "" : "'".concat(vs, "'");
        }

        var vs2Sql = vs2 ? " and '".concat(vs2, "'") : "";

        if (getFieldValue('factorLabel') == '$登录时间' || getFieldValue('factorLabel') == '$退出时间') {
          if (!_this.validTime(vs[0]) || !_this.validTime(vs2) && cs == 'between') {
            Modal$1.error({
              title: '系统提示',
              okText: '确定',
              content: "\u65F6\u95F4\u683C\u5F0F\u4E0D\u6B63\u786E"
            });
            return;
          }
        }

        if (getFieldValue('factorLabel') == '$返回/影响行数') {
          if (!_this.validAllNaturalNum(vs[0]) || vs[0] > 2147483648 || vs[0] < -2147483648) {
            Modal$1.error({
              title: '系统提示',
              okText: '确定',
              content: "\u8F93\u5165\u7684\u8FD4\u56DE\uFF0F\u5F71\u54CD\u884C\u6570\u8D85\u51FA\u53D6\u503C\u8303\u56F4\u3002"
            });
            return;
          }

          if ((!_this.validAllNaturalNum(vs2) || vs2 > 2147483648 || vs2 < -2147483648) && cs == 'between') {
            Modal$1.error({
              title: '系统提示',
              okText: '确定',
              content: "\u8F93\u5165\u7684\u8FD4\u56DE\uFF0F\u5F71\u54CD\u884C\u6570\u8D85\u51FA\u53D6\u503C\u8303\u56F4\u3002"
            });
            return;
          }
        }

        var sql = "\"".concat(getFieldValue('factorLabel'), "\" ").concat(cs, " ").concat(isBrack).concat(vs2Sql);

        if (sql.includes('undefined')) {
          Modal$1.error({
            title: '系统提示',
            okText: '确定',
            content: "\u8BF7\u5C06\u6761\u4EF6\u586B\u5199\u5B8C\u6574\uFF01"
          });
          return;
        }

        var nextV = !sqlTextarea ? sql : sqlTextarea + " ".concat(ao, " ").concat(sql);
        nextV = _this.convertValue(nextV);
        setFieldsValue({
          //and 或or 追加sqltest
          'sql-textarea': nextV
        });

        _this.props.callbackParentSql(nextV);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "convertValue", function (v) {
        v = v.replace('成功', '0');
        v = v.replace('失败', '1');
        v = v.replace('高', '3');
        v = v.replace('中', '2');
        v = v.replace('低', '1');
        return v;
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onTextChange", function (v) {
        _this.setState({
          sql: v
        });

        _this.props.callbackParentSql(v);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "validTime", function (str) {
        var regDate = /^[0-9]{4}-[0-1]?[0-9]{1}-[0-3]?[0-9]{1} ([0-2][0-9]):([0-5][0-9]):([0-5][0-9])$/;
        return regDate.test(str);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "validAllNaturalNum", function (str) {
        var re = /^-?[0-9]*$/; //判断字符串是否为正整数

        if (!re.test(str)) {
          return false;
        } else {
          return true;
        }
      });

      return _this;
    }

    _createClass(ConditionForm, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var conditionSelect$$1 = this.props.conditionSelect;
        this.setState({
          conditionSelect: conditionSelect$$1
        });
        console.log('conditionSelect', conditionSelect$$1);
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        //console.log('nextProps', nextProps)
        this.setState({
          conditionSelect: nextProps.conditionSelect
        });
      } //条件因子 下拉框点击事件

    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var getFieldDecorator = this.props.form.getFieldDecorator;
        var _this$state = this.state,
            conditionSelect$$1 = _this$state.conditionSelect,
            selection = _this$state.selection,
            isfirstSVList = _this$state.isfirstSVList,
            firstSVList = _this$state.firstSVList,
            isMulti = _this$state.isMulti,
            isShowSec = _this$state.isShowSec,
            isShowfirstSV = _this$state.isShowfirstSV; //console.log('conditionSelect', conditionSelect)
        var conditionRender = conditionSelect$$1.map(function (v, i) {
          return React.createElement(Select$1.Option, {
            key: i,
            value: v.value
          }, v.label);
        });
        var selectionRender = selection.map(function (v, i) {
          return React.createElement(Select$1.Option, {
            key: i,
            value: v
          }, v);
        });
        var formItemLayout = {
          labelCol: {
            xs: {
              span: 24
            },
            sm: {
              span: 8
            }
          },
          wrapperCol: {
            xs: {
              span: 24
            },
            sm: {
              span: 12
            }
          }
        };
        return React.createElement("div", null, React.createElement(Row, {
          gutter: 12
        }, React.createElement(Col, {
          md: 6
        }, React.createElement(FormItem$3, _extends({}, formItemLayout, {
          label: "\u6761\u4EF6\u56E0\u5B50"
        }), getFieldDecorator('condition-factor')(React.createElement(Select$1, {
          placeholder: "\u8BF7\u9009\u62E9",
          onChange: this.factorHandleChange
        }, conditionRender)))), React.createElement(Col, {
          md: 3
        }, getFieldDecorator('factorLabel')(React.createElement(Input$1, {
          placeholder: "",
          disabled: true
        }))), React.createElement(Col, {
          md: 3
        }, React.createElement(FormItem$3, _extends({}, formItemLayout, {
          label: ""
        }), getFieldDecorator('condition-selection')(React.createElement(Select$1, {
          placeholder: "\u8BF7\u9009\u62E9",
          onChange: this.selectionHandleChange
        }, selectionRender)))), isShowfirstSV ? React.createElement(Col, {
          md: 3
        }, getFieldDecorator('value-selection')(isfirstSVList ? React.createElement(Select$1, {
          mode: isMulti ? "tags" : "combobox",
          key: isMulti ? "tags" : "combobox",
          placeholder: "\u8BF7\u9009\u62E9",
          style: {
            width: '100%',
            marginRight: 5
          }
        }, firstSVList) : React.createElement(Input$1, {
          placeholder: "\u8BF7\u8F93\u5165"
        }))) : '', isShowSec ? React.createElement(Col, {
          md: 4
        }, React.createElement(FormItem$3, _extends({}, formItemLayout, {
          label: "AND",
          colon: false
        }), getFieldDecorator('value-selection2')(React.createElement(Input$1, {
          placeholder: "\u8BF7\u8F93\u5165"
        })))) : '', React.createElement(Col, {
          md: 5
        }, getFieldDecorator('and-or', {
          initialValue: 'AND'
        })(React.createElement(Select$1, {
          style: {
            width: 80,
            marginRight: 10
          }
        }, React.createElement(Select$1.Option, {
          key: "and",
          value: "AND"
        }, "AND"), React.createElement(Select$1.Option, {
          key: "or",
          value: "OR"
        }, "OR"))), React.createElement(Button, {
          type: "primary",
          onClick: this.addSql
        }, "\u6DFB\u52A0"))), React.createElement(Row, null, React.createElement(Col, {
          md: 18
        }, getFieldDecorator('sql-textarea', {
          onChange: function onChange(e) {
            return _this2.onTextChange(e.target.value);
          }
        })(React.createElement(TextArea$1, {
          rows: 4
        })))));
      }
    }]);

    return ConditionForm;
  }(React$1.PureComponent);

  ConditionForm.propTypes = {
    conditionSelect: PropTypes.array.isRequired,
    //传入的下拉列表框数组值
    callbackParentSql: PropTypes.func.isRequired //把textarea输入框的值回传出去的回调方法

  };
  ConditionForm.defaultProps = {
    conditionSelect: [],
    callbackParentSql: function callbackParentSql() {}
  };

  exports.AdvancedSearch = AdvancedSearchForm;
  exports.BaseForm = SubmitForm;
  exports.FormItem = FormItem$1;
  exports.ButtonGroups = ButtonGroups;
  exports.WrapperDatePicker = WrapperDatePicker;
  exports.DataTable = DataTable;
  exports.Permission = Permission;
  exports.Panel = Panel$1;
  exports.ModalAndView = ModalAndView;
  exports.TreeView = TreeView;
  exports.TabsPanel = TabsPanel;
  exports.PropertyTable = PropertyTable;
  exports.EditTable = EditTable;
  exports.DetailTable = DetailTable;
  exports.FieldSet = FieldSet;
  exports.ConditionForm = ConditionForm;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
